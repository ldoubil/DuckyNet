Project Path: DuckyNet

Source Tree:

```txt
DuckyNet
â”œâ”€â”€ Client
â”‚   â”œâ”€â”€ Core
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncManager.cs
â”‚   â”‚   â”œâ”€â”€ AvatarManager.cs
â”‚   â”‚   â”œâ”€â”€ CharacterCustomizationManager.cs
â”‚   â”‚   â”œâ”€â”€ DebugModule
â”‚   â”‚   â”‚   â”œâ”€â”€ AnimationDebugger.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ AnimatorFixer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ DebugModuleManager.cs
â”‚   â”‚   â”‚   â””â”€â”€ Modules
â”‚   â”‚   â”‚       â”œâ”€â”€ AnimatorStateModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ AnimatorSyncTestModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ AppearanceTestModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ CharacterAppearanceDebugModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ CharacterPresetScannerModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ EquipmentSyncDebugModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ NetworkDebugModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ NpcManagerModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ PlayerModelDebugModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ RemotePlayerDebugModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ RemotePlayerSpawnerModule.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ ShadowNpcTestModule.cs
â”‚   â”‚   â”‚       â””â”€â”€ WeaponInfoModule.cs
â”‚   â”‚   â”œâ”€â”€ EventBus
â”‚   â”‚   â”‚   â”œâ”€â”€ EventBus.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ EventSubscriberHelper.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ Events
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AllEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterLifecycleEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ChatEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DamageEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ EquipmentEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ NetworkEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RoomEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SceneEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SyncEvents.cs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ WeaponEvents.cs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ WeaponSyncEvents.cs
â”‚   â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ GameContext.cs
â”‚   â”‚   â”œâ”€â”€ Helpers
â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceConverter.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceHelper.cs
â”‚   â”‚   â”‚   â””â”€â”€ SceneInfoProvider.cs
â”‚   â”‚   â”œâ”€â”€ InputManager.cs
â”‚   â”‚   â”œâ”€â”€ NetworkLifecycleManager.cs
â”‚   â”‚   â”œâ”€â”€ NpcManager.cs
â”‚   â”‚   â”œâ”€â”€ NpcVisibilityManager.cs
â”‚   â”‚   â”œâ”€â”€ Players
â”‚   â”‚   â”‚   â”œâ”€â”€ BasePlayer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ LocalPlayer.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerManager.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ RemoteAnimatorSyncManager.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ RemotePlayer.cs
â”‚   â”‚   â”‚   â””â”€â”€ SmoothSyncManager.cs
â”‚   â”‚   â”œâ”€â”€ RoomManager.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientManager.cs
â”‚   â”‚   â”œâ”€â”€ ShadowNpcFactory.cs
â”‚   â”‚   â”œâ”€â”€ ShadowNpcPool.cs
â”‚   â”‚   â”œâ”€â”€ UIManager.cs
â”‚   â”‚   â””â”€â”€ Utils
â”‚   â”‚       â”œâ”€â”€ AnimationBatchWriter.cs
â”‚   â”‚       â”œâ”€â”€ AnimationFrameBuffer.cs
â”‚   â”‚       â”œâ”€â”€ AppearanceConverter.cs
â”‚   â”‚       â”œâ”€â”€ CharacterCreationUtils.cs
â”‚   â”‚       â”œâ”€â”€ EquipmentTools.cs
â”‚   â”‚       â”œâ”€â”€ KalmanMotionPredictor.cs
â”‚   â”‚       â”œâ”€â”€ UniTaskHelper.cs
â”‚   â”‚       â”œâ”€â”€ WeaponEffectsCore.cs
â”‚   â”‚       â””â”€â”€ WeaponEffectsPlayer.cs
â”‚   â”œâ”€â”€ DuckyNetClient.csproj
â”‚   â”œâ”€â”€ ModBehaviour.cs
â”‚   â”œâ”€â”€ Patches
â”‚   â”‚   â”œâ”€â”€ CharacterLifecyclePatch.cs
â”‚   â”‚   â”œâ”€â”€ DamageModificationPatch.cs
â”‚   â”‚   â”œâ”€â”€ DropOperationBroadcaster.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentSlotPatch.cs
â”‚   â”‚   â”œâ”€â”€ HealthEventBridge.cs
â”‚   â”‚   â”œâ”€â”€ InputBlockingPatch.cs
â”‚   â”‚   â”œâ”€â”€ LocalPlayerShootBridge.cs
â”‚   â”‚   â”œâ”€â”€ MovementPatch.cs
â”‚   â”‚   â”œâ”€â”€ PickupActionForwarder.cs
â”‚   â”‚   â”œâ”€â”€ SceneEventBridge.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSlotPatch.cs
â”‚   â”‚   â””â”€â”€ WeaponSwitchPatch.cs
â”‚   â”œâ”€â”€ RPC
â”‚   â”‚   â””â”€â”€ RpcClient.cs
â”‚   â”œâ”€â”€ Services
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ ItemNetworkCoordinator.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ SerializationPool.cs
â”‚   â”‚   â”œâ”€â”€ WeaponFireEffectsPlayer.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceImpl.cs
â”‚   â”‚   â””â”€â”€ WeaponSyncHelper.cs
â”‚   â”œâ”€â”€ UI
â”‚   â”‚   â”œâ”€â”€ ChatWindow.cs
â”‚   â”‚   â”œâ”€â”€ DebugWindow.cs
â”‚   â”‚   â”œâ”€â”€ LobbyPage.cs
â”‚   â”‚   â”œâ”€â”€ MainMenuWindow.cs
â”‚   â”‚   â”œâ”€â”€ PlayerListWindow.cs
â”‚   â”‚   â””â”€â”€ RoomPage.cs
â”‚   â””â”€â”€ res
â”‚       â”œâ”€â”€ 0Harmony.dll
â”‚       â”œâ”€â”€ DuckyNet.Client.dll
â”‚       â”œâ”€â”€ DuckyNet.Shared.dll
â”‚       â”œâ”€â”€ LiteNetLib.dll
â”‚       â”œâ”€â”€ NetSerializer.dll
â”‚       â”œâ”€â”€ info.ini
â”‚       â””â”€â”€ preview.png
â”œâ”€â”€ Console
â”‚   â”œâ”€â”€ Commands
â”‚   â”‚   â””â”€â”€ BuiltIn
â”‚   â”œâ”€â”€ ConsoleModule.cs
â”‚   â”œâ”€â”€ DuckyNetConsole.csproj
â”‚   â”œâ”€â”€ ModBehaviour.cs
â”‚   â”œâ”€â”€ Performance
â”‚   â”œâ”€â”€ TUI
â”‚   â”‚   â””â”€â”€ Controls
â”‚   â”‚       â””â”€â”€ LogViewer.cs
â”‚   â””â”€â”€ res
â”‚       â”œâ”€â”€ DuckyNet.Console.dll
â”‚       â”œâ”€â”€ DuckyNet.Shared.dll
â”‚       â”œâ”€â”€ info.ini
â”‚       â””â”€â”€ preview.png
â”œâ”€â”€ DuckyNet.sln
â”œâ”€â”€ ExamplePlugin
â”‚   â”œâ”€â”€ ExamplePlugin.csproj
â”‚   â””â”€â”€ WelcomePlugin.cs
â”œâ”€â”€ LICENSE
â”œâ”€â”€ Milk
â”‚   â”œâ”€â”€ DecalFadeEffect.cs
â”‚   â”œâ”€â”€ LineDrippingEffect.cs
â”‚   â”œâ”€â”€ Milk.csproj
â”‚   â”œâ”€â”€ MilkParticleLauncher.cs
â”‚   â”œâ”€â”€ MilkStickyEffectHandler.cs
â”‚   â”œâ”€â”€ ModBehaviour.cs
â”‚   â”œâ”€â”€ ParticleConfig.cs
â”‚   â”œâ”€â”€ SplatDecalCreator.cs
â”‚   â”œâ”€â”€ StickyLineCreator.cs
â”‚   â””â”€â”€ res
â”‚       â”œâ”€â”€ 0Harmony.dll
â”‚       â”œâ”€â”€ Milk.dll
â”‚       â””â”€â”€ info.ini
â”œâ”€â”€ Server
â”‚   â”œâ”€â”€ Core
â”‚   â”‚   â”œâ”€â”€ ServerContext.cs
â”‚   â”‚   â”œâ”€â”€ ServerInitializer.cs
â”‚   â”‚   â””â”€â”€ ServiceCollectionExtensions.cs
â”‚   â”œâ”€â”€ DuckyNetServer.csproj
â”‚   â”œâ”€â”€ Events
â”‚   â”‚   â”œâ”€â”€ EventBus.cs
â”‚   â”‚   â”œâ”€â”€ Handlers
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerCleanupHandler.cs
â”‚   â”‚   â”‚   â””â”€â”€ Room
â”‚   â”‚   â”œâ”€â”€ IEventBus.cs
â”‚   â”‚   â”œâ”€â”€ ServerEventPublisher.cs
â”‚   â”‚   â””â”€â”€ ServerEvents.cs
â”‚   â”œâ”€â”€ Managers
â”‚   â”‚   â”œâ”€â”€ BroadcastManager.cs
â”‚   â”‚   â”œâ”€â”€ NpcVisibilityTracker.cs
â”‚   â”‚   â”œâ”€â”€ PlayerManager.cs
â”‚   â”‚   â”œâ”€â”€ PlayerNpcManager.cs
â”‚   â”‚   â”œâ”€â”€ README_STEAMID_INDEXING.md
â”‚   â”‚   â”œâ”€â”€ RoomManager.cs
â”‚   â”‚   â””â”€â”€ SceneManager.cs
â”‚   â”œâ”€â”€ Modules
â”‚   â”œâ”€â”€ Plugin
â”‚   â”‚   â”œâ”€â”€ IPlugin.cs
â”‚   â”‚   â”œâ”€â”€ IPluginContext.cs
â”‚   â”‚   â”œâ”€â”€ IPluginLogger.cs
â”‚   â”‚   â”œâ”€â”€ PluginContext.cs
â”‚   â”‚   â”œâ”€â”€ PluginManager.cs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ Program.cs
â”‚   â”œâ”€â”€ RPC
â”‚   â”‚   â”œâ”€â”€ Middleware
â”‚   â”‚   â”‚   â””â”€â”€ BuiltInMiddlewares
â”‚   â”‚   â”œâ”€â”€ RpcServer.cs
â”‚   â”‚   â””â”€â”€ RpcServerExtensions.cs
â”‚   â”œâ”€â”€ Services
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ CharacterServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentServerServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ PlayerServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ PlayerUnitySyncServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ RoomServiceImpl.cs
â”‚   â”‚   â”œâ”€â”€ SceneServiceImpl.cs
â”‚   â”‚   â””â”€â”€ WeaponSyncServerServiceImpl.cs
â”‚   â”œâ”€â”€ TUI
â”‚   â”‚   â”œâ”€â”€ Extensions
â”‚   â”‚   â”œâ”€â”€ ITuiModule.cs
â”‚   â”‚   â””â”€â”€ Modules
â”‚   â”‚       â”œâ”€â”€ LogViewerModule.cs
â”‚   â”‚       â”œâ”€â”€ NpcManagementModule.cs
â”‚   â”‚       â””â”€â”€ PerformanceModule.cs
â”‚   â”œâ”€â”€ Web
â”‚   â”‚   â”œâ”€â”€ Controllers
â”‚   â”‚   â”‚   â”œâ”€â”€ DashboardController.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ MonitorController.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ NpcsController.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayersController.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ RoomsController.cs
â”‚   â”‚   â”‚   â””â”€â”€ ScenesController.cs
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ Services
â”‚   â”‚   â”œâ”€â”€ WebServerStartup.cs
â”‚   â”‚   â””â”€â”€ wwwroot
â”‚   â”‚       â”œâ”€â”€ css
â”‚   â”‚       â”‚   â””â”€â”€ steam-style.css
â”‚   â”‚       â”œâ”€â”€ index.html
â”‚   â”‚       â””â”€â”€ js
â”‚   â”‚           â””â”€â”€ app.js
â”‚   â”œâ”€â”€ å¯åŠ¨æœåŠ¡å™¨.bat
â”‚   â”œâ”€â”€ å¯åŠ¨æœåŠ¡å™¨.ps1
â”‚   â””â”€â”€ å¯åŠ¨è¯´æ˜.md
â”œâ”€â”€ Shared
â”‚   â”œâ”€â”€ Data
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncData.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceData.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentData.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncData.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncData.cs
â”‚   â”‚   â”œâ”€â”€ NpcData.cs
â”‚   â”‚   â”œâ”€â”€ ScenelData.cs
â”‚   â”‚   â”œâ”€â”€ UnitySyncData.cs
â”‚   â”‚   â”œâ”€â”€ WeaponFireData.cs
â”‚   â”‚   â””â”€â”€ WeaponSyncData.cs
â”‚   â”œâ”€â”€ DuckyNetShared.csproj
â”‚   â”œâ”€â”€ Events
â”‚   â”œâ”€â”€ Generated
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ AnimatorSyncServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterAppearanceServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ CharacterClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ CharacterServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ EquipmentServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ HealthSyncServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ ItemSyncServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ NpcSyncServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ PlayerClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ PlayerUnitySyncServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ PlayerUnitySyncServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ RoomClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ RoomServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ RoomServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ RpcTypeRegistry.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ SceneClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ SceneServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ SceneServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceClientCallProxy.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceClientProxy.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceClientsBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceServerDispatcher.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncClientServiceWhereBroadcastProxy.cs
â”‚   â”‚   â”œâ”€â”€ WeaponSyncServiceClientProxy.cs
â”‚   â”‚   â””â”€â”€ WeaponSyncServiceServerDispatcher.cs
â”‚   â”œâ”€â”€ RPC
â”‚   â”‚   â”œâ”€â”€ ClientLoginState.cs
â”‚   â”‚   â”œâ”€â”€ ConnectionState.cs
â”‚   â”‚   â”œâ”€â”€ IClientContext.cs
â”‚   â”‚   â”œâ”€â”€ IClientContextExtensions.cs
â”‚   â”‚   â”œâ”€â”€ RpcAttributes.cs
â”‚   â”‚   â”œâ”€â”€ RpcConfig.cs
â”‚   â”‚   â”œâ”€â”€ RpcInvoker.cs
â”‚   â”‚   â”œâ”€â”€ RpcLogger.cs
â”‚   â”‚   â”œâ”€â”€ RpcMessage.cs
â”‚   â”‚   â”œâ”€â”€ RpcPerformanceStats.cs
â”‚   â”‚   â”œâ”€â”€ RpcSerializer.cs
â”‚   â”‚   â””â”€â”€ RpcTimeoutManager.cs
â”‚   â””â”€â”€ Services
â”‚       â”œâ”€â”€ IAnimatorSyncService.cs
â”‚       â”œâ”€â”€ ICharacterAppearanceService.cs
â”‚       â”œâ”€â”€ ICharacterService.cs
â”‚       â”œâ”€â”€ IEquipmentService.cs
â”‚       â”œâ”€â”€ IHealthSyncService.cs
â”‚       â”œâ”€â”€ IItemSyncService.cs
â”‚       â”œâ”€â”€ INpcSyncService.cs
â”‚       â”œâ”€â”€ IPlayerService.cs
â”‚       â”œâ”€â”€ IPlayerUnitySyncService.cs
â”‚       â”œâ”€â”€ IRoomService.cs
â”‚       â”œâ”€â”€ ISceneService.cs
â”‚       â””â”€â”€ IWeaponSyncService.cs
â”œâ”€â”€ Tools
â”‚   â””â”€â”€ RpcCodeGen
â”‚       â”œâ”€â”€ Program.cs
â”‚       â””â”€â”€ RpcCodeGen.csproj
â”œâ”€â”€ WebAdmin
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ App.vue
â”‚   â”‚   â”œâ”€â”€ assets
â”‚   â”‚   â”‚   â””â”€â”€ steam-style.css
â”‚   â”‚   â”œâ”€â”€ components
â”‚   â”‚   â”‚   â””â”€â”€ SceneMap.vue
â”‚   â”‚   â”œâ”€â”€ main.js
â”‚   â”‚   â””â”€â”€ services
â”‚   â”‚       â””â”€â”€ api.js
â”‚   â”œâ”€â”€ vite.config.js
â”‚   â”œâ”€â”€ å¯åŠ¨å‰ç«¯.bat
â”‚   â””â”€â”€ å¿«é€Ÿå¼€å§‹.md
â”œâ”€â”€ build.bat
â”œâ”€â”€ build_linux_release.ps1
â”œâ”€â”€ build_macos_release.ps1
â”œâ”€â”€ build_release.bat
â”œâ”€â”€ dist
â”‚   â”œâ”€â”€ linux
â”‚   â”‚   â”œâ”€â”€ Client
â”‚   â”‚   â”‚   â”œâ”€â”€ 0Harmony.dll
â”‚   â”‚   â”‚   â”œâ”€â”€ DuckyNet.Client.dll
â”‚   â”‚   â”‚   â”œâ”€â”€ DuckyNet.Shared.dll
â”‚   â”‚   â”‚   â”œâ”€â”€ LiteNetLib.dll
â”‚   â”‚   â”‚   â”œâ”€â”€ NetSerializer.dll
â”‚   â”‚   â”‚   â”œâ”€â”€ info.ini
â”‚   â”‚   â”‚   â””â”€â”€ preview.png
â”‚   â”‚   â”œâ”€â”€ README.txt
â”‚   â”‚   â””â”€â”€ Server
â”‚   â”‚       â”œâ”€â”€ DuckyNet.Server
â”‚   â”‚       â””â”€â”€ start_server.sh
â”‚   â””â”€â”€ macos-x64
â”‚       â”œâ”€â”€ Client
â”‚       â”‚   â”œâ”€â”€ 0Harmony.dll
â”‚       â”‚   â”œâ”€â”€ DuckyNet.Client.dll
â”‚       â”‚   â”œâ”€â”€ DuckyNet.Shared.dll
â”‚       â”‚   â”œâ”€â”€ LiteNetLib.dll
â”‚       â”‚   â”œâ”€â”€ NetSerializer.dll
â”‚       â”‚   â”œâ”€â”€ info.ini
â”‚       â”‚   â””â”€â”€ preview.png
â”‚       â”œâ”€â”€ README.txt
â”‚       â””â”€â”€ Server
â”‚           â”œâ”€â”€ MacDuckyNet.Server
â”‚           â””â”€â”€ start_server.sh
â”œâ”€â”€ start_server.bat
â””â”€â”€ å¯åŠ¨å®Œæ•´ç³»ç»Ÿ.bat

```

`Client\Core\AnimatorSyncManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// åŠ¨ç”»åŒæ­¥ç®¡ç†å™¨
    /// è´Ÿè´£é‡‡é›†æœ¬åœ°ç©å®¶åŠ¨ç”»çŠ¶æ€å¹¶ä¸Šä¼ åˆ°æœåŠ¡å™¨
    /// </summary>
    public class AnimatorSyncManager : IDisposable
    {
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        private Animator? _localPlayerAnimator;
        
        // åŒæ­¥é…ç½®
        private float _syncCheckInterval = 0.05f; // æ¯ 50ms æ£€æŸ¥ä¸€æ¬¡ï¼ˆ20Hzï¼‰
        private float _lastCheckTime = 0f;
        private float _forceSyncInterval = 1.0f; // å¼ºåˆ¶åŒæ­¥é—´éš”ï¼ˆ1ç§’ï¼‰
        private float _lastForceSyncTime = 0f;
        
        // ç¼“å­˜ä¸Šæ¬¡å‘é€çš„æ•°æ®
        private AnimatorSyncData? _lastSentData = null;
        
        // å˜åŒ–æ£€æµ‹é˜ˆå€¼
        private const float FLOAT_CHANGE_THRESHOLD = 0.02f;  // Float å‚æ•°å˜åŒ–é˜ˆå€¼ï¼ˆ2%ï¼‰
        private const float STATE_TIME_THRESHOLD = 0.15f;     // åŠ¨ç”»çŠ¶æ€æ—¶é—´é˜ˆå€¼ï¼ˆ15%ï¼‰
        
        // å‚æ•°æ˜ å°„é…ç½®ï¼ˆä½¿ç”¨æ¸¸æˆå®é™…çš„å‚æ•°åï¼‰
        private readonly string[] _floatParamNames = new string[]
        {
            "MoveSpeed",       // 0: ç§»åŠ¨é€Ÿåº¦
            "MoveDirX",        // 1: ç§»åŠ¨æ–¹å‘ X
            "MoveDirY",        // 2: ç§»åŠ¨æ–¹å‘ Y
            "",                // 3: é¢„ç•™ç»™ HandState (Integer)
            "",                // 4: é¢„ç•™
            "",                // 5: é¢„ç•™
            "",                // 6: é¢„ç•™
            ""                 // 7: é¢„ç•™
        };
        
        private readonly string[] _boolParamNames = new string[]
        {
            "Dashing",         // 0: ç¿»æ»š/å†²åˆº
            "RightHandOut",    // 1: å³æ‰‹æ˜¯å¦ä¼¸å‡º
            "Attack",          // 2: æ”»å‡»çŠ¶æ€ (MagicBlend)
            "GunReady",        // 3: æªæ¢°å‡†å¤‡ (MagicBlend)
            "",                // 4-31: é¢„ç•™
        };
        
        // å‚æ•°å“ˆå¸Œç¼“å­˜
        private Dictionary<int, int> _floatParamHashes = new Dictionary<int, int>();
        private Dictionary<int, int> _boolParamHashes = new Dictionary<int, int>();
        
        public AnimatorSyncManager()
        {
            _eventSubscriber.EnsureInitializedAndSubscribe();
            
            // é¢„è®¡ç®—å‚æ•°å“ˆå¸Œ
            for (int i = 0; i < _floatParamNames.Length; i++)
            {
                if (string.IsNullOrEmpty(_floatParamNames[i])) continue;
                _floatParamHashes[i] = Animator.StringToHash(_floatParamNames[i]);
            }
            for (int i = 0; i < _boolParamNames.Length; i++)
            {
                if (string.IsNullOrEmpty(_boolParamNames[i])) continue;
                _boolParamHashes[i] = Animator.StringToHash(_boolParamNames[i]);
            }
        }
        
        /// <summary>
        /// åˆå§‹åŒ–ï¼ˆæŸ¥æ‰¾æœ¬åœ°ç©å®¶ Animatorï¼‰
        /// </summary>
        public void Initialize()
        {
            try
            {
                if (!GameContext.IsInitialized) return;
                
                var localPlayer = GameContext.Instance.PlayerManager?.LocalPlayer;
                if (localPlayer?.CharacterObject != null)
                {
                    _localPlayerAnimator = localPlayer.CharacterObject.GetComponentInChildren<Animator>();
                    
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncManager] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }
        
        /// <summary>
        /// æ›´æ–°ï¼ˆå®šæœŸæ£€æŸ¥å¹¶åŒæ­¥ï¼‰
        /// </summary>
        public void Update()
        {
            if (_localPlayerAnimator == null)
            {
                // å°è¯•é‡æ–°æŸ¥æ‰¾ï¼ˆæ¯ç§’ä¸€æ¬¡ï¼‰
                if (Time.time - _lastCheckTime > 1f)
                {
                    Initialize();
                    _lastCheckTime = Time.time;
                }
                return;
            }
            
            // å®šæœŸæ£€æŸ¥åŠ¨ç”»å˜åŒ–
            if (Time.time - _lastCheckTime >= _syncCheckInterval)
            {
                CheckAndSyncAnimatorState();
                _lastCheckTime = Time.time;
            }
        }
        
        /// <summary>
        /// æ£€æŸ¥åŠ¨ç”»çŠ¶æ€å¹¶å†³å®šæ˜¯å¦åŒæ­¥
        /// ç­–ç•¥ï¼š
        /// 1. æ˜¾è‘—å˜åŒ–æ—¶ç«‹å³å‘é€ï¼ˆFloat/Bool å‚æ•°æ”¹å˜ï¼‰
        /// 2. åŠ¨ç”»çŠ¶æ€åˆ‡æ¢æ—¶ç«‹å³å‘é€
        /// 3. æ— å˜åŒ–æ—¶ï¼Œæ¯ 1 ç§’å¼ºåˆ¶å‘é€ä¸€æ¬¡ï¼ˆä¿æŒè¿æ¥æ´»è·ƒï¼‰
        /// </summary>
        private void CheckAndSyncAnimatorState()
        {
            if (_localPlayerAnimator == null || !GameContext.IsInitialized) return;
            
            try
            {
                var currentData = CaptureAnimatorState();
                
                // ç­–ç•¥1: é¦–æ¬¡å‘é€
                if (_lastSentData == null)
                {
                    SendAnimatorState(currentData);
                    return;
                }
                
                // ç­–ç•¥2: æ£€æµ‹æ˜¾è‘—å˜åŒ–
                if (HasSignificantChange(currentData, _lastSentData))
                {
                    SendAnimatorState(currentData);
                    return;
                }
                
                // ç­–ç•¥3: å¼ºåˆ¶åŒæ­¥ï¼ˆé˜²æ­¢é•¿æ—¶é—´æ— æ›´æ–°ï¼‰
                if (Time.time - _lastForceSyncTime >= _forceSyncInterval)
                {
                    SendAnimatorState(currentData);
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncManager] æ£€æŸ¥åŠ¨ç”»çŠ¶æ€å¤±è´¥: {ex.Message}");
            }
        }
        
        /// <summary>
        /// é‡‡é›†å½“å‰åŠ¨ç”»çŠ¶æ€
        /// </summary>
        private AnimatorSyncData CaptureAnimatorState()
        {
            var syncData = new AnimatorSyncData();
            
            // è·å–å½“å‰çŠ¶æ€å“ˆå¸Œï¼ˆä¸»å±‚ï¼‰
            var currentState = _localPlayerAnimator!.GetCurrentAnimatorStateInfo(0);
            syncData.StateHash = currentState.fullPathHash;
            syncData.SetNormalizedTime(currentState.normalizedTime);
            
            // é‡‡é›† Float å‚æ•°
            for (int i = 0; i < Math.Min(_floatParamNames.Length, 8); i++)
            {
                if (_floatParamHashes.TryGetValue(i, out int hash))
                {
                    try
                    {
                        float value = _localPlayerAnimator.GetFloat(hash);
                        syncData.SetFloatParam(i, value);
                    }
                    catch
                    {
                        // å‚æ•°ä¸å­˜åœ¨ï¼Œè·³è¿‡
                    }
                }
            }
            
            // é‡‡é›† Integer å‚æ•° - HandState
            try
            {
                int handStateHash = Animator.StringToHash("HandState");
                int handStateValue = _localPlayerAnimator.GetInteger(handStateHash);
                syncData.SetFloatParam(3, handStateValue);
            }
            catch
            {
                // å‚æ•°ä¸å­˜åœ¨ï¼Œè·³è¿‡
            }
            
            // é‡‡é›† Bool å‚æ•°
            for (int i = 0; i < Math.Min(_boolParamNames.Length, 32); i++)
            {
                if (_boolParamHashes.TryGetValue(i, out int hash))
                {
                    try
                    {
                        bool value = _localPlayerAnimator.GetBool(hash);
                        syncData.SetBoolParam(i, value);
                    }
                    catch
                    {
                        // å‚æ•°ä¸å­˜åœ¨ï¼Œè·³è¿‡
                    }
                }
            }
            
            return syncData;
        }
        
        /// <summary>
        /// å‘é€åŠ¨ç”»çŠ¶æ€åˆ°æœåŠ¡å™¨
        /// </summary>
        private void SendAnimatorState(AnimatorSyncData syncData)
        {
            if (GameContext.Instance.RpcClient == null) return;
            
            try
            {
                GameContext.Instance.RpcClient.InvokeServer<Shared.Services.IAnimatorSyncService>(
                    nameof(Shared.Services.IAnimatorSyncService.UpdateAnimatorState),
                    syncData
                );
                
                // æ›´æ–°ç¼“å­˜
                _lastSentData = syncData;
                _lastForceSyncTime = Time.time;
                
              
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncManager] å‘é€åŠ¨ç”»çŠ¶æ€å¤±è´¥: {ex.Message}");
            }
        }
        
        /// <summary>
        /// æ£€æµ‹æ˜¯å¦æœ‰æ˜¾è‘—å˜åŒ–
        /// ç®—æ³•ï¼šåŸºäºé˜ˆå€¼çš„å¢é‡æ£€æµ‹
        /// </summary>
        private bool HasSignificantChange(AnimatorSyncData current, AnimatorSyncData last)
        {
            // 1. åŠ¨ç”»çŠ¶æ€åˆ‡æ¢ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
            if (current.StateHash != last.StateHash)
            {
                return true;
            }
            
            // 2. Bool å‚æ•°å˜åŒ–ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
            if (current.BoolParams != last.BoolParams)
            {
                return true;
            }
            
            // 3. Float å‚æ•°æ˜¾è‘—å˜åŒ–ï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰
            for (int i = 0; i < 8; i++)
            {
                float currentVal = current.GetFloatParam(i);
                float lastVal = last.GetFloatParam(i);
                float delta = Mathf.Abs(currentVal - lastVal);
                
                // å¯¹äºç§»åŠ¨å‚æ•° (0-2)ï¼Œä½¿ç”¨æ›´æ•æ„Ÿçš„é˜ˆå€¼
                float threshold = (i <= 2) ? FLOAT_CHANGE_THRESHOLD : FLOAT_CHANGE_THRESHOLD * 2;
                
                if (delta > threshold)
                {
                    return true;
                }
            }
            
            // 4. åŠ¨ç”»æ—¶é—´è·³è·ƒï¼ˆä½ä¼˜å…ˆçº§ï¼‰
            float currentTime = current.GetNormalizedTime();
            float lastTime = last.GetNormalizedTime();
            float timeDelta = Mathf.Abs(currentTime - lastTime);
            
            // å¦‚æœæ—¶é—´å€’é€€ï¼ˆå¾ªç¯ï¼‰æˆ–è·³è·ƒè¿‡å¤§
            if (timeDelta > STATE_TIME_THRESHOLD && timeDelta < 0.9f)
            {
                return true;
            }
            
            return false; // æ— æ˜¾è‘—å˜åŒ–
        }
        
        public void Dispose()
        {
            _eventSubscriber.Dispose();
            _localPlayerAnimator = null;
        }
    }
}

```

`Client\Core\AvatarManager.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using Steamworks;
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// å¤´åƒç®¡ç†å™¨
    /// ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç©å®¶çš„ Steam å¤´åƒåŠ è½½å’Œç¼“å­˜
    /// </summary>
    public class AvatarManager : IDisposable
    {
        private readonly Dictionary<string, Texture2D> _avatarCache;
        private readonly Dictionary<string, bool> _downloadingAvatars; // æ­£åœ¨ä¸‹è½½çš„å¤´åƒ

        public AvatarManager()
        {
            _avatarCache = new Dictionary<string, Texture2D>();
            _downloadingAvatars = new Dictionary<string, bool>();
        }

        /// <summary>
        /// è·å–ç©å®¶å¤´åƒï¼ˆä»ç¼“å­˜ã€URL æˆ– Steam APIï¼‰
        /// </summary>
        public Texture2D? GetAvatar(string steamId)
        {
            // æ£€æŸ¥ç¼“å­˜
            if (_avatarCache.TryGetValue(steamId, out var cachedAvatar))
            {
                return cachedAvatar;
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
            if (GameContext.IsInitialized)
            {
                var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                if (localPlayer.Info.SteamId == steamId && localPlayer.AvatarTexture != null)
                {
                    // ç¼“å­˜æœ¬åœ°ç©å®¶å¤´åƒ
                    _avatarCache[steamId] = localPlayer.AvatarTexture;
                    return localPlayer.AvatarTexture;
                }
            }

            // ğŸ”¥ ä¼˜å…ˆä» AvatarUrl ä¸‹è½½ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (GameContext.IsInitialized)
            {
                PlayerInfo? playerInfo = GetPlayerInfo(steamId);
                if (playerInfo != null && !string.IsNullOrEmpty(playerInfo.AvatarUrl))
                {
                    // å¼‚æ­¥ä¸‹è½½å¤´åƒï¼ˆä¸é˜»å¡ï¼‰
                    if (!_downloadingAvatars.ContainsKey(steamId))
                    {
                        _downloadingAvatars[steamId] = true;
                        // ä½¿ç”¨ ModBehaviour å¯åŠ¨åç¨‹
                        if (ModBehaviour.Instance != null)
                        {
                            ModBehaviour.Instance.StartCoroutine(DownloadAvatarFromUrl(steamId, playerInfo.AvatarUrl));
                        }
                    }
                    return null; // é¦–æ¬¡è¿”å› nullï¼Œä¸‹è½½å®Œæˆåä¼šç¼“å­˜
                }
            }

            // å›é€€ï¼šå°è¯•ä» Steam API åŠ è½½ï¼ˆåªèƒ½åŠ è½½å¥½å‹ï¼‰
            var avatar = LoadAvatarFromSteam(steamId);
            if (avatar != null)
            {
                _avatarCache[steamId] = avatar;
            }

            return avatar;
        }

        /// <summary>
        /// è·å–ç©å®¶ä¿¡æ¯ï¼ˆä»æˆ¿é—´åˆ—è¡¨ï¼‰
        /// </summary>
        private PlayerInfo? GetPlayerInfo(string steamId)
        {
            if (!GameContext.IsInitialized) 
                return null;

            var roomManager = GameContext.Instance.RoomManager;
            if (roomManager == null) 
                return null;

            var players = roomManager.GetRoomPlayers();
            if (players == null)
                return null;

            foreach (var player in players)
            {
                if (player != null && player.SteamId == steamId)
                {
                    return player;
                }
            }

            return null;
        }

        /// <summary>
        /// ä» URL ä¸‹è½½å¤´åƒ
        /// </summary>
        private IEnumerator DownloadAvatarFromUrl(string steamId, string avatarUrl)
        {
            UnityEngine.Debug.Log($"[AvatarManager] å¼€å§‹ä¸‹è½½å¤´åƒ: {steamId} from {avatarUrl}");

            using (UnityWebRequest www = UnityWebRequestTexture.GetTexture(avatarUrl))
            {
                yield return www.SendWebRequest();

                // ä¸‹è½½å®Œæˆï¼Œç§»é™¤ä¸‹è½½æ ‡è®°
                _downloadingAvatars.Remove(steamId);

                if (www.result != UnityWebRequest.Result.Success)
                {
                    UnityEngine.Debug.LogWarning($"[AvatarManager] ä¸‹è½½å¤´åƒå¤±è´¥ {steamId}: {www.error}");
                    
                    // å›é€€ï¼šå°è¯•ä½¿ç”¨ Steam API
                    var fallbackAvatar = LoadAvatarFromSteam(steamId);
                    if (fallbackAvatar != null)
                    {
                        _avatarCache[steamId] = fallbackAvatar;
                    }
                }
                else
                {
                    // ä¸‹è½½æˆåŠŸ
                    Texture2D avatarTexture = DownloadHandlerTexture.GetContent(www);
                    _avatarCache[steamId] = avatarTexture;
                    UnityEngine.Debug.Log($"[AvatarManager] âœ… å¤´åƒä¸‹è½½æˆåŠŸ: {steamId}");
                }
            }
        }

        /// <summary>
        /// ä» Steam API åŠ è½½å¤´åƒ
        /// </summary>
        private Texture2D? LoadAvatarFromSteam(string steamId)
        {
            try
            {
                if (!SteamManager.Initialized)
                {
                    return null;
                }

                if (!ulong.TryParse(steamId, out ulong steamIdValue))
                {
                    return null;
                }

                CSteamID cSteamId = new CSteamID(steamIdValue);
                int avatarHandle = SteamFriends.GetMediumFriendAvatar(cSteamId);
                
                if (avatarHandle <= 0)
                {
                    return null;
                }

                // è·å–å¤´åƒå°ºå¯¸
                bool success = SteamUtils.GetImageSize(avatarHandle, out uint width, out uint height);
                if (!success || width == 0 || height == 0)
                {
                    return null;
                }

                // è·å– RGBA æ•°æ®
                byte[] imageData = new byte[width * height * 4];
                success = SteamUtils.GetImageRGBA(avatarHandle, imageData, (int)(width * height * 4));
                
                if (!success)
                {
                    return null;
                }

                // åˆ›å»ºçº¹ç†
                Texture2D avatarTexture = new Texture2D((int)width, (int)height, TextureFormat.RGBA32, false);
                avatarTexture.LoadRawTextureData(imageData);
                avatarTexture.Apply();
                
                // å‚ç›´ç¿»è½¬ï¼ˆSteam å›¾åƒæ˜¯ä¸Šä¸‹é¢ å€’çš„ï¼‰
                FlipTextureVertically(avatarTexture);

                UnityEngine.Debug.Log($"[AvatarManager] å·²åŠ è½½ Steam å¤´åƒ: {steamId} ({width}x{height})");
                return avatarTexture;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogWarning($"[AvatarManager] åŠ è½½å¤´åƒå¤±è´¥ {steamId}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// å‚ç›´ç¿»è½¬çº¹ç†
        /// </summary>
        private void FlipTextureVertically(Texture2D texture)
        {
            Color[] pixels = texture.GetPixels();
            Color[] flipped = new Color[pixels.Length];
            
            int width = texture.width;
            int height = texture.height;
            
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    flipped[x + y * width] = pixels[x + (height - y - 1) * width];
                }
            }
            
            texture.SetPixels(flipped);
            texture.Apply();
        }

        /// <summary>
        /// é¢„åŠ è½½æŒ‡å®šç©å®¶çš„å¤´åƒ
        /// </summary>
        public void PreloadAvatar(string steamId)
        {
            if (!_avatarCache.ContainsKey(steamId))
            {
                GetAvatar(steamId);
            }
        }

        /// <summary>
        /// æ¸…é™¤æŒ‡å®šç©å®¶çš„å¤´åƒç¼“å­˜
        /// </summary>
        public void ClearAvatar(string steamId)
        {
            if (_avatarCache.TryGetValue(steamId, out var avatar))
            {
                // ä¸è¦é”€æ¯æœ¬åœ°ç©å®¶çš„å¤´åƒï¼ˆç”± LocalPlayer ç®¡ç†ï¼‰
                if (GameContext.IsInitialized && 
                    steamId != GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId)
                {
                    UnityEngine.Object.Destroy(avatar);
                }
                _avatarCache.Remove(steamId);
            }
        }

        /// <summary>
        /// æ¸…é™¤æ‰€æœ‰ç¼“å­˜
        /// </summary>
        public void ClearAll()
        {
            foreach (var kvp in _avatarCache)
            {
                // ä¸è¦é”€æ¯æœ¬åœ°ç©å®¶çš„å¤´åƒ
                if (GameContext.IsInitialized && 
                    kvp.Key != GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId)
                {
                    UnityEngine.Object.Destroy(kvp.Value);
                }
            }
            _avatarCache.Clear();
            UnityEngine.Debug.Log("[AvatarManager] å¤´åƒç¼“å­˜å·²æ¸…é™¤");
        }

        /// <summary>
        /// æ¸…ç†èµ„æº
        /// </summary>
        public void Dispose()
        {
            ClearAll();
        }
    }
}


```

`Client\Core\CharacterCustomizationManager.cs`:

```cs
using System;
using UnityEngine;
using HarmonyLib;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// è§’è‰²è‡ªå®šä¹‰ç®¡ç†å™¨ - ç®¡ç†è§’è‰²å¤–è§‚å®šåˆ¶ï¼ˆæè„¸ã€éƒ¨ä½ã€é¢œè‰²ç­‰ï¼‰
    /// </summary>
    public class CharacterCustomizationManager : IDisposable
    {
        private Type? _customFaceSettingDataType;
        private Type? _customFaceHeadSettingType;
        private Type? _customFacePartInfoType;
        private Type? _customFacePartTypesType;
        private bool _initialized = false;

        public CharacterCustomizationManager()
        {
            InitializeTypes();
        }

        private void InitializeTypes()
        {
            try
            {
                _customFaceSettingDataType = AccessTools.TypeByName("CustomFaceSettingData");
                _customFaceHeadSettingType = AccessTools.TypeByName("CustomFaceHeadSetting");
                _customFacePartInfoType = AccessTools.TypeByName("CustomFacePartInfo");
                _customFacePartTypesType = AccessTools.TypeByName("CustomFacePartTypes");

                _initialized = _customFaceSettingDataType != null 
                    && _customFaceHeadSettingType != null 
                    && _customFacePartInfoType != null;

                if (_initialized)
                {
                    UnityEngine.Debug.Log("[CharacterCustomizationManager] ç±»å‹åˆå§‹åŒ–æˆåŠŸ");
                }
                else
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] ç±»å‹åˆå§‹åŒ–å¤±è´¥");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åˆ›å»ºé»˜è®¤è‡ªå®šä¹‰æ•°æ®ï¼ˆä»æ¸¸æˆé»˜è®¤é¢„è®¾è·å–ï¼‰
        /// </summary>
        public object CreateDefaultCustomization()
        {
            if (!_initialized || _customFaceSettingDataType == null)
            {
                UnityEngine.Debug.LogError("[CharacterCustomizationManager] æœªåˆå§‹åŒ–");
                return null!;
            }

            try
            {
                // å°è¯•ä»æ¸¸æˆçš„é»˜è®¤é¢„è®¾è·å–
                var gameplayDataSettingsType = AccessTools.TypeByName("Duckov.Utilities.GameplayDataSettings");
                if (gameplayDataSettingsType != null)
                {
                    var customFaceDataProp = AccessTools.Property(gameplayDataSettingsType, "CustomFaceData");
                    object? customFaceData = customFaceDataProp?.GetValue(null);
                    
                    if (customFaceData != null)
                    {
                        var defaultPresetProp = AccessTools.Property(customFaceData.GetType(), "DefaultPreset");
                        object? defaultPreset = defaultPresetProp?.GetValue(customFaceData);
                        
                        if (defaultPreset != null)
                        {
                            var settingsField = AccessTools.Field(defaultPreset.GetType(), "settings");
                            object? settings = settingsField?.GetValue(defaultPreset);
                            
                            if (settings != null)
                            {
                                return settings;
                            }
                        }
                    }
                }

                // å¦‚æœæ— æ³•è·å–é»˜è®¤é¢„è®¾ï¼Œåˆ›å»ºåŸºç¡€é»˜è®¤æ•°æ®
                object customData = Activator.CreateInstance(_customFaceSettingDataType);

                // è®¾ç½®é»˜è®¤å¤´éƒ¨è®¾ç½®
                object headSetting = CreateDefaultHeadSetting();
                var headSettingField = AccessTools.Field(_customFaceSettingDataType, "headSetting");
                headSettingField?.SetValue(customData, headSetting);

                return customData;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] åˆ›å»ºå¤±è´¥: {ex.Message}");
                return null!;
            }
        }

        /// <summary>
        /// åˆ›å»ºè‡ªå®šä¹‰æ•°æ®
        /// </summary>
        public object CreateCustomization(CharacterCustomization config)
        {
            if (!_initialized || _customFaceSettingDataType == null)
            {
                UnityEngine.Debug.LogError("[CharacterCustomizationManager] æœªåˆå§‹åŒ–");
                return null!;
            }

            try
            {
                object customData = Activator.CreateInstance(_customFaceSettingDataType);

                // è®¾ç½®å¤´éƒ¨
                object headSetting = CreateHeadSetting(
                    config.MainColor,
                    config.HeadScaleOffset,
                    config.ForeheadHeight,
                    config.ForeheadRound
                );
                var headSettingField = AccessTools.Field(_customFaceSettingDataType, "headSetting");
                headSettingField?.SetValue(customData, headSetting);

                // è®¾ç½®å„ä¸ªéƒ¨ä½
                SetPart(customData, "hairID", "hairInfo", config.HairID, config.HairInfo);
                SetPart(customData, "eyeID", "eyeInfo", config.EyeID, config.EyeInfo);
                SetPart(customData, "eyebrowID", "eyebrowInfo", config.EyebrowID, config.EyebrowInfo);
                SetPart(customData, "mouthID", "mouthInfo", config.MouthID, config.MouthInfo);
                SetPart(customData, "tailID", "tailInfo", config.TailID, config.TailInfo);
                SetPart(customData, "footID", "footInfo", config.FootID, config.FootInfo);
                SetPart(customData, "wingID", "wingInfo", config.WingID, config.WingInfo);

                return customData;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] åˆ›å»ºå¤±è´¥: {ex.Message}");
                return null!;
            }
        }

        /// <summary>
        /// åº”ç”¨è‡ªå®šä¹‰åˆ°è§’è‰²æ¨¡å‹
        /// </summary>
        public void ApplyToCharacter(object character, object customData)
        {
            try
            {
                var component = character as Component;
                if (component == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] è§’è‰²ä¸æ˜¯Componentç±»å‹");
                    return;
                }

                // è·å– CharacterModelï¼ˆæ³¨æ„ï¼šæ˜¯å­—æ®µä¸æ˜¯å±æ€§ï¼‰
                var characterModelField = AccessTools.Field(character.GetType(), "characterModel");
                object? characterModel = characterModelField?.GetValue(character);

                if (characterModel == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] CharacterModel å­—æ®µä¸ºç©ºï¼Œè§’è‰²å¯èƒ½æœªå®Œå…¨åˆå§‹åŒ–");
                    return;
                }

                // è°ƒç”¨ SetFaceFromData
                var setFaceMethod = AccessTools.Method(characterModel.GetType(), "SetFaceFromData", new[] { _customFaceSettingDataType });
                if (setFaceMethod != null)
                {
                    setFaceMethod.Invoke(characterModel, new[] { customData });
                }
                else
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] SetFaceFromData æ–¹æ³•æœªæ‰¾åˆ°");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] åº”ç”¨å¤±è´¥: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
            }
        }

        /// <summary>
        /// ä»JSONåŠ è½½è‡ªå®šä¹‰æ•°æ®
        /// </summary>
        public object? LoadFromJson(string json)
        {
            try
            {
                var jsonToDataMethod = AccessTools.Method(_customFaceSettingDataType, "JsonToData");
                if (jsonToDataMethod != null)
                {
                    object[] parameters = new object[] { json, null! };
                    bool success = (bool)jsonToDataMethod.Invoke(null, parameters);
                    if (success)
                    {
                        return parameters[1];
                    }
                }
                return null;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] JSON è§£æå¤±è´¥: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// è½¬æ¢ä¸ºJSON
        /// </summary>
        public string? ToJson(object customData)
        {
            try
            {
                var toJsonMethod = AccessTools.Method(customData.GetType(), "DataToJson");
                if (toJsonMethod != null)
                {
                    return (string)toJsonMethod.Invoke(customData, null);
                }
                
                UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] DataToJson æ–¹æ³•æœªæ‰¾åˆ°");
                return null;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] JSON åºåˆ—åŒ–å¤±è´¥: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// ä»è§’è‰²å¯¹è±¡è·å–è‡ªå®šä¹‰æ•°æ®
        /// </summary>
        public object? GetCustomizationFromCharacter(object character)
        {
            if (!_initialized || _customFaceSettingDataType == null)
            {
                UnityEngine.Debug.LogError("[CharacterCustomizationManager] æœªåˆå§‹åŒ–");
                return null;
            }

            try
            {
                var component = character as Component;
                if (component == null)
                {
                    // å°è¯•ä½œä¸ºGameObjectå¤„ç†
                    var gameObject = character as GameObject;
                    if (gameObject != null)
                    {
                        // æŸ¥æ‰¾ CharacterMainControl ç»„ä»¶ï¼ˆè¿™æ˜¯æ¸¸æˆä¸­ä¸»è¦çš„è§’è‰²æ§åˆ¶ç±»ï¼‰
                        var characterMainControlType = AccessTools.TypeByName("CharacterMainControl");
                        if (characterMainControlType != null)
                        {
                            component = gameObject.GetComponent(characterMainControlType) as Component;
                            
                            if (component == null)
                            {
                                UnityEngine.Debug.LogWarning($"[CharacterCustomizationManager] GameObject ä¸Šæ²¡æœ‰ CharacterMainControl ç»„ä»¶");
                            }
                        }
                        else
                        {
                            UnityEngine.Debug.LogError("[CharacterCustomizationManager] æ‰¾ä¸åˆ° CharacterMainControl ç±»å‹");
                        }
                    }

                    if (component == null)
                    {
                        UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] æ— æ•ˆçš„è§’è‰²å¯¹è±¡ç±»å‹");
                        return null;
                    }
                }

                // è·å– CharacterModel å­—æ®µ
                var characterModelField = AccessTools.Field(component.GetType(), "characterModel");
                object? characterModel = characterModelField?.GetValue(component);

                if (characterModel == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] CharacterModel å­—æ®µä¸ºç©ºï¼Œè§’è‰²å¯èƒ½è¿˜æœªå®Œå…¨åˆå§‹åŒ–");
                    return null;
                }

                // è·å– CustomFaceInstance (customFace å­—æ®µ)
                var customFaceField = AccessTools.Field(characterModel.GetType(), "customFace");
                object? customFace = customFaceField?.GetValue(characterModel);

                if (customFace == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] customFace å­—æ®µä¸ºç©º");
                    return null;
                }

                // è°ƒç”¨ ConvertToSaveData() æ–¹æ³•è·å–å¤–è§‚æ•°æ®
                var convertToSaveDataMethod = AccessTools.Method(customFace.GetType(), "ConvertToSaveData");
                if (convertToSaveDataMethod != null)
                {
                    object? faceData = convertToSaveDataMethod.Invoke(customFace, null);
                    if (faceData != null)
                    {
                        return faceData;
                    }
                    else
                    {
                        UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] ConvertToSaveData() è¿”å› null");
                    }
                }
                else
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] ConvertToSaveData æ–¹æ³•æœªæ‰¾åˆ°");
                }

                return null;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] è·å–å¤–è§‚æ•°æ®å¤±è´¥: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
                return null;
            }
        }

        /// <summary>
        /// å°è¯•è·å–æœ¬åœ°ç©å®¶è§’è‰²å¯¹è±¡
        /// </summary>
        public GameObject? GetLocalPlayerCharacter()
        {
            try
            {
                // é€šè¿‡ LevelManager.Instance.MainCharacter è·å–æœ¬åœ°ç©å®¶è§’è‰²
                var levelManagerType = AccessTools.TypeByName("LevelManager");
                if (levelManagerType == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] æ‰¾ä¸åˆ° LevelManager ç±»å‹");
                    return null;
                }

                var instanceProp = AccessTools.Property(levelManagerType, "Instance");
                object? levelManager = instanceProp?.GetValue(null);

                if (levelManager == null)
                {
                    // LevelManager.Instance ä¸º null åœ¨è§’è‰²åˆ›å»ºå‰æ˜¯æ­£å¸¸çš„ï¼Œä¸éœ€è¦è­¦å‘Šæ—¥å¿—
                    // ï¼ˆä¾‹å¦‚ï¼šåœ¨å¤§å…ã€ä¸»èœå•ã€å…³å¡åŠ è½½ä¸­ç­‰æƒ…å†µï¼‰
                    return null;
                }

                // âœ… æ­£ç¡®çš„å±æ€§åæ˜¯ MainCharacterï¼Œè€Œä¸æ˜¯ LocalCharacter
                var mainCharacterProp = AccessTools.Property(levelManagerType, "MainCharacter");
                if (mainCharacterProp == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] æ‰¾ä¸åˆ° MainCharacter å±æ€§");
                    return null;
                }

                object? mainCharacter = mainCharacterProp.GetValue(levelManager);

                if (mainCharacter == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCustomizationManager] MainCharacter ä¸º nullï¼ˆè§’è‰²å¯èƒ½è¿˜æœªåŠ è½½ï¼‰");
                    return null;
                }

                // MainCharacter æ˜¯ Character ç»„ä»¶
                var component = mainCharacter as Component;
                if (component != null)
                {
                    return component.gameObject;
                }

                // å¦‚æœä¸æ˜¯ Componentï¼Œå°è¯•ä½œä¸º GameObject
                var gameObject = mainCharacter as GameObject;
                if (gameObject != null)
                {
                    return gameObject;
                }

                UnityEngine.Debug.LogWarning($"[CharacterCustomizationManager] MainCharacter ç±»å‹ä¸æ˜¯ Component æˆ– GameObject: {mainCharacter.GetType().Name}");
                return null;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCustomizationManager] è·å–æœ¬åœ°ç©å®¶è§’è‰²å¤±è´¥: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
                return null;
            }
        }

        /// <summary>
        /// åˆ›å»ºå¤´éƒ¨è®¾ç½®
        /// </summary>
        private object CreateHeadSetting(Color mainColor, float headScaleOffset, float foreheadHeight, float foreheadRound)
        {
            object headSetting = Activator.CreateInstance(_customFaceHeadSettingType);
            
            var mainColorField = AccessTools.Field(_customFaceHeadSettingType, "mainColor");
            var headScaleOffsetField = AccessTools.Field(_customFaceHeadSettingType, "headScaleOffset");
            var foreheadHeightField = AccessTools.Field(_customFaceHeadSettingType, "foreheadHeight");
            var foreheadRoundField = AccessTools.Field(_customFaceHeadSettingType, "foreheadRound");

            mainColorField?.SetValue(headSetting, mainColor);
            headScaleOffsetField?.SetValue(headSetting, headScaleOffset);
            foreheadHeightField?.SetValue(headSetting, foreheadHeight);
            foreheadRoundField?.SetValue(headSetting, foreheadRound);

            return headSetting;
        }

        /// <summary>
        /// åˆ›å»ºé»˜è®¤å¤´éƒ¨è®¾ç½®
        /// </summary>
        private object CreateDefaultHeadSetting()
        {
            // ä½¿ç”¨ä¸­é—´å€¼ä½œä¸ºé»˜è®¤
            return CreateHeadSetting(Color.white, 1.0f, 0.3f, 0.675f);
        }

        /// <summary>
        /// åˆ›å»ºéƒ¨ä½ä¿¡æ¯
        /// </summary>
        private object CreatePartInfo(PartInfo info)
        {
            object partInfo = Activator.CreateInstance(_customFacePartInfoType);

            AccessTools.Field(_customFacePartInfoType, "radius")?.SetValue(partInfo, info.Radius);
            AccessTools.Field(_customFacePartInfoType, "color")?.SetValue(partInfo, info.Color);
            AccessTools.Field(_customFacePartInfoType, "height")?.SetValue(partInfo, info.Height);
            AccessTools.Field(_customFacePartInfoType, "heightOffset")?.SetValue(partInfo, info.HeightOffset);
            AccessTools.Field(_customFacePartInfoType, "scale")?.SetValue(partInfo, info.Scale);
            AccessTools.Field(_customFacePartInfoType, "twist")?.SetValue(partInfo, info.Twist);
            AccessTools.Field(_customFacePartInfoType, "distanceAngle")?.SetValue(partInfo, info.DistanceAngle);
            AccessTools.Field(_customFacePartInfoType, "leftRightAngle")?.SetValue(partInfo, info.LeftRightAngle);

            return partInfo;
        }

        /// <summary>
        /// è®¾ç½®éƒ¨ä½
        /// </summary>
        private void SetPart(object customData, string idFieldName, string infoFieldName, int id, PartInfo? info)
        {
            var idField = AccessTools.Field(_customFaceSettingDataType, idFieldName);
            idField?.SetValue(customData, id);
            
            // åªæœ‰æ˜ç¡®æä¾›äº† PartInfo æ—¶æ‰è®¾ç½®
            // å¦åˆ™è®©æ¸¸æˆä½¿ç”¨é»˜è®¤çš„éƒ¨ä½ä½ç½®é…ç½®
            if (info.HasValue)
            {
                var infoField = AccessTools.Field(_customFaceSettingDataType, infoFieldName);
                object partInfo = CreatePartInfo(info.Value);
                infoField?.SetValue(customData, partInfo);
            }
            // ä¸è®¾ç½® infoField æ—¶ï¼Œå®ƒä¼šä¿æŒç»“æ„ä½“çš„é»˜è®¤å€¼ï¼Œè¿™é€šå¸¸æ˜¯åˆç†çš„
        }

        public void Dispose()
        {
            // æ¸…ç†èµ„æº
        }
    }

    /// <summary>
    /// è§’è‰²è‡ªå®šä¹‰é…ç½®
    /// </summary>
    public struct CharacterCustomization
    {
        // å¤´éƒ¨è®¾ç½®
        public Color MainColor;
        public float HeadScaleOffset;
        public float ForeheadHeight;
        public float ForeheadRound;

        // éƒ¨ä½ ID å’Œä¿¡æ¯
        public int HairID;
        public PartInfo? HairInfo;

        public int EyeID;
        public PartInfo? EyeInfo;

        public int EyebrowID;
        public PartInfo? EyebrowInfo;

        public int MouthID;
        public PartInfo? MouthInfo;

        public int TailID;
        public PartInfo? TailInfo;

        public int FootID;
        public PartInfo? FootInfo;

        public int WingID;
        public PartInfo? WingInfo;

        /// <summary>
        /// é»˜è®¤é…ç½®
        /// </summary>
        public static CharacterCustomization Default => new CharacterCustomization
        {
            MainColor = Color.white,
            HeadScaleOffset = 1.0f,      // ä¸­é—´å€¼
            ForeheadHeight = 0.3f,       // ä¸­é—´å€¼
            ForeheadRound = 0.675f,      // ä¸­é—´å€¼
            HairID = 0,
            EyeID = 0,
            EyebrowID = 0,
            MouthID = 0,
            TailID = 0,
            FootID = 0,
            WingID = 0
        };

        /// <summary>
        /// éšæœºé…ç½®
        /// </summary>
        public static CharacterCustomization Random
        {
            get
            {
                return new CharacterCustomization
                {
                    MainColor = UnityEngine.Random.ColorHSV(0f, 1f, 0.5f, 1f, 0.8f, 1f),
                    HeadScaleOffset = UnityEngine.Random.Range(0.6f, 1.4f),
                    ForeheadHeight = UnityEngine.Random.Range(0f, 0.6f),
                    ForeheadRound = UnityEngine.Random.Range(0.35f, 1.0f),
                    HairID = UnityEngine.Random.Range(0, 5),
                    HairInfo = PartInfo.RandomColor(),
                    EyeID = UnityEngine.Random.Range(0, 5),
                    EyeInfo = PartInfo.RandomColor(),
                    EyebrowID = UnityEngine.Random.Range(0, 3),
                    EyebrowInfo = PartInfo.RandomColor(),
                    MouthID = UnityEngine.Random.Range(0, 3),
                    MouthInfo = PartInfo.RandomColor(),
                    TailID = UnityEngine.Random.Range(0, 3),
                    TailInfo = PartInfo.RandomColor(),
                    FootID = UnityEngine.Random.Range(0, 2),
                    FootInfo = PartInfo.RandomColor(),
                    WingID = UnityEngine.Random.Range(0, 2),
                    WingInfo = PartInfo.RandomColor()
                };
            }
        }
    }

    /// <summary>
    /// éƒ¨ä½ä¿¡æ¯
    /// </summary>
    public struct PartInfo
    {
        public float Radius;
        public Color Color;
        public float Height;
        public float HeightOffset;
        public float Scale;
        public float Twist;
        public float DistanceAngle;      // çœ¼ç›ã€çœ‰æ¯›é—´è·
        public float LeftRightAngle;     // å˜´å·´å·¦å³åç§»

        public static PartInfo Default => new PartInfo
        {
            Radius = 1f,
            Color = Color.white,
            Height = 0f,
            HeightOffset = 0f,
            Scale = 1f,
            Twist = 0f,
            DistanceAngle = 0f,
            LeftRightAngle = 0f
        };

        public static PartInfo RandomColor()
        {
            var info = Default;
            info.Color = UnityEngine.Random.ColorHSV(0f, 1f, 0.5f, 1f, 0.8f, 1f);
            return info;
        }

        /// <summary>
        /// åˆ›å»ºéšæœºéƒ¨ä½ä¿¡æ¯
        /// </summary>
        public static PartInfo Random(float minScale = 0.3f, float maxScale = 4.0f)
        {
            return new PartInfo
            {
                Radius = 1f,
                Color = UnityEngine.Random.ColorHSV(0f, 1f, 0.5f, 1f, 0.8f, 1f),
                Height = UnityEngine.Random.Range(-0.3f, 0.3f),
                HeightOffset = 0f,
                Scale = UnityEngine.Random.Range(minScale, maxScale),
                Twist = UnityEngine.Random.Range(-90f, 90f),
                DistanceAngle = UnityEngine.Random.Range(0f, 90f),
                LeftRightAngle = UnityEngine.Random.Range(-50f, 50f)
            };
        }
    }
}


```

`Client\Core\DebugModule\AnimationDebugger.cs`:

```cs
using System;
using UnityEngine;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// åŠ¨ç”»è°ƒè¯•å™¨ - ç”¨äºè°ƒè¯•å’Œæµ‹è¯•å•ä½åŠ¨ç”»
    /// </summary>
    public class AnimationDebugger
    {
        public AnimationDebugger()
        {
        }

        /// <summary>
        /// è®°å½•åŠ¨ç”»ä¿¡æ¯åˆ°æ§åˆ¶å°
        /// </summary>
        public void LogAnimationInfo(GameObject unit)
        {
            if (unit == null)
            {
                UnityEngine.Debug.LogWarning("[AnimationDebugger] å•ä½å¯¹è±¡ä¸ºç©º");
                return;
            }

            var animator = unit.GetComponentInChildren<Animator>(true);
            if (animator == null)
            {
                UnityEngine.Debug.LogWarning($"[AnimationDebugger] å•ä½ {unit.name} æœªæ‰¾åˆ°Animator");
                return;
            }

            UnityEngine.Debug.Log($"=== {unit.name} åŠ¨ç”»ä¿¡æ¯ ===");
            UnityEngine.Debug.Log($"Controller: {(animator.runtimeAnimatorController != null ? animator.runtimeAnimatorController.name : "None")}");
            UnityEngine.Debug.Log($"Enabled: {animator.enabled}");
            UnityEngine.Debug.Log($"Parameters: {animator.parameterCount}");

            for (int i = 0; i < animator.parameterCount; i++)
            {
                var param = animator.parameters[i];
                object value = param.type switch
                {
                    AnimatorControllerParameterType.Float => animator.GetFloat(param.name),
                    AnimatorControllerParameterType.Int => animator.GetInteger(param.name),
                    AnimatorControllerParameterType.Bool => animator.GetBool(param.name),
                    AnimatorControllerParameterType.Trigger => "Trigger",
                    _ => "Unknown"
                };
                UnityEngine.Debug.Log($"  {param.name} ({param.type}): {value}");
            }
        }

        /// <summary>
        /// è®¾ç½®Animatoræµ®ç‚¹æ•°å‚æ•°
        /// </summary>
        public void SetAnimatorFloat(GameObject unit, string paramName, float value)
        {
            var animator = unit?.GetComponentInChildren<Animator>(true);
            if (animator != null)
            {
                animator.SetFloat(paramName, value);
            }
        }

        /// <summary>
        /// è®¾ç½®Animatoræ•´æ•°å‚æ•°
        /// </summary>
        public void SetAnimatorInt(GameObject unit, string paramName, int value)
        {
            var animator = unit?.GetComponentInChildren<Animator>(true);
            if (animator != null)
            {
                animator.SetInteger(paramName, value);
            }
        }

        /// <summary>
        /// è®¾ç½®Animatorå¸ƒå°”å‚æ•°
        /// </summary>
        public void SetAnimatorBool(GameObject unit, string paramName, bool value)
        {
            var animator = unit?.GetComponentInChildren<Animator>(true);
            if (animator != null)
            {
                animator.SetBool(paramName, value);
            }
        }

        /// <summary>
        /// è§¦å‘Animator Trigger
        /// </summary>
        public void TriggerAnimation(GameObject unit, string triggerName)
        {
            var animator = unit?.GetComponentInChildren<Animator>(true);
            if (animator != null)
            {
                animator.SetTrigger(triggerName);
            }
        }

        /// <summary>
        /// è®¾ç½®åŠ¨ç”»å±‚æƒé‡
        /// </summary>
        public void SetLayerWeight(GameObject unit, string layerName, float weight)
        {
            var animator = unit?.GetComponentInChildren<Animator>(true);
            if (animator != null)
            {
                for (int i = 0; i < animator.layerCount; i++)
                {
                    var layerNameFromAnimator = animator.GetLayerName(i);
                    if (layerNameFromAnimator == layerName)
                    {
                        animator.SetLayerWeight(i, weight);
                        return;
                    }
                }
                UnityEngine.Debug.LogWarning($"[AnimationDebugger] æœªæ‰¾åˆ°å±‚: {layerName}");
            }
        }

        /// <summary>
        /// æµ‹è¯•ç§»åŠ¨åŠ¨ç”»
        /// </summary>
        public void TestMovementAnimation(GameObject unit, float speed, Vector2 direction)
        {
            var animator = unit?.GetComponentInChildren<Animator>(true);
            if (animator != null)
            {
                animator.SetFloat("MoveSpeed", speed);
                animator.SetFloat("MoveDirX", direction.x);
                animator.SetFloat("MoveDirY", direction.y);
            }
        }

        /// <summary>
        /// è¯Šæ–­æœ¬åœ°ç©å®¶è§’è‰²
        /// </summary>
        public void DiagnoseLocalPlayerCharacter()
        {
            try
            {
                if (Core.GameContext.IsInitialized)
                {
                    var localPlayer = Core.GameContext.Instance.PlayerManager.LocalPlayer;
                    UnityEngine.Debug.Log("[AnimationDebugger] å¼€å§‹è¯Šæ–­æœ¬åœ°ç©å®¶è§’è‰²...");
                    // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šè¯Šæ–­é€»è¾‘
                }
                else
                {
                    UnityEngine.Debug.LogWarning("[AnimationDebugger] GameContextæœªåˆå§‹åŒ–");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[AnimationDebugger] è¯Šæ–­å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Core\DebugModule\AnimatorFixer.cs`:

```cs
using UnityEngine;
using HarmonyLib;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// Animatorä¿®å¤å·¥å…· - ç”¨äºç¦ç”¨/å¯ç”¨åŠ¨ç”»æ§åˆ¶ï¼Œé˜²æ­¢è„šæœ¬è¦†ç›–ç½‘ç»œåŒæ­¥çš„åŠ¨ç”»å‚æ•°
    /// </summary>
    public static class AnimatorFixer
    {
        /// <summary>
        /// è·å– CharacterAnimationControl ç±»å‹
        /// </summary>
        private static System.Type? GetAnimationControlType()
        {
            // ä½¿ç”¨ HarmonyLib çš„ AccessTools æŸ¥æ‰¾ç±»å‹ï¼ˆæ”¯æŒå¤šä¸ªå¯èƒ½çš„ç±»å‹åï¼‰
            var typeNames = new[]
            {
                "CharacterAnimationControl_MagicBlend",
                "CharacterAnimationControl",
                "AnimationControl"
            };

            foreach (var typeName in typeNames)
            {
                var type = AccessTools.TypeByName(typeName);
                if (type != null)
                {
                    return type;
                }
            }

            return null;
        }

        /// <summary>
        /// ç¦ç”¨åŠ¨ç”»æ§åˆ¶ï¼ˆç”¨äºè¿œç¨‹åŒæ­¥çš„è§’è‰²ï¼‰
        /// </summary>
        public static bool DisableAnimationControl(GameObject character)
        {
            if (character == null) return false;

            try
            {
                var animControlType = GetAnimationControlType();
                if (animControlType == null)
                {
                    UnityEngine.Debug.LogWarning($"[AnimatorFixer] æœªæ‰¾åˆ° CharacterAnimationControl ç±»å‹");
                    return false;
                }

                // æŸ¥æ‰¾å¹¶ç¦ç”¨ CharacterAnimationControl ç»„ä»¶
                var animControl = character.GetComponentInChildren(animControlType, true);
                
                if (animControl != null && animControl is MonoBehaviour mb)
                {
                    mb.enabled = false;
                    UnityEngine.Debug.Log($"[AnimatorFixer] å·²ç¦ç”¨åŠ¨ç”»æ§åˆ¶: {character.name}");
                    return true;
                }
                
                UnityEngine.Debug.LogWarning($"[AnimatorFixer] æœªæ‰¾åˆ° CharacterAnimationControl ç»„ä»¶: {character.name}");
                return false;
            }
            catch (System.Exception ex)
            {
                UnityEngine.Debug.LogError($"[AnimatorFixer] ç¦ç”¨åŠ¨ç”»æ§åˆ¶å¤±è´¥: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// å¯ç”¨åŠ¨ç”»æ§åˆ¶ï¼ˆæ¢å¤æœ¬åœ°æ§åˆ¶ï¼‰
        /// </summary>
        public static bool EnableAnimationControl(GameObject character)
        {
            if (character == null) return false;

            try
            {
                var animControlType = GetAnimationControlType();
                if (animControlType == null)
                {
                    UnityEngine.Debug.LogWarning($"[AnimatorFixer] æœªæ‰¾åˆ° CharacterAnimationControl ç±»å‹");
                    return false;
                }

                var animControl = character.GetComponentInChildren(animControlType, true);
                
                if (animControl != null && animControl is MonoBehaviour mb)
                {
                    mb.enabled = true;
                    UnityEngine.Debug.Log($"[AnimatorFixer] å·²å¯ç”¨åŠ¨ç”»æ§åˆ¶: {character.name}");
                    return true;
                }
                
                return false;
            }
            catch (System.Exception ex)
            {
                UnityEngine.Debug.LogError($"[AnimatorFixer] å¯ç”¨åŠ¨ç”»æ§åˆ¶å¤±è´¥: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// æ£€æŸ¥åŠ¨ç”»æ§åˆ¶æ˜¯å¦å·²å¯ç”¨
        /// </summary>
        public static bool IsAnimationControlEnabled(GameObject character)
        {
            if (character == null) return false;

            try
            {
                var animControlType = GetAnimationControlType();
                if (animControlType == null)
                {
                    return false;
                }

                var animControl = character.GetComponentInChildren(animControlType, true);
                
                if (animControl != null && animControl is MonoBehaviour mb)
                {
                    return mb.enabled;
                }
                
                return false;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// è¯Šæ–­å¹¶ä¿®å¤Animatoré—®é¢˜
        /// </summary>
        public static void DiagnoseAndFix(GameObject character)
        {
            if (character == null)
            {
                UnityEngine.Debug.LogWarning("[AnimatorFixer] è§’è‰²å¯¹è±¡ä¸ºç©º");
                return;
            }

            var animator = character.GetComponentInChildren<Animator>(true);
            if (animator == null)
            {
                UnityEngine.Debug.LogWarning($"[AnimatorFixer] è§’è‰² {character.name} æœªæ‰¾åˆ°Animator");
                return;
            }

            UnityEngine.Debug.Log($"[AnimatorFixer] Animatorè¯Šæ–­å®Œæˆ: {character.name}");
            UnityEngine.Debug.Log($"  - Controller: {(animator.runtimeAnimatorController != null ? animator.runtimeAnimatorController.name : "None")}");
            UnityEngine.Debug.Log($"  - Enabled: {animator.enabled}");
            UnityEngine.Debug.Log($"  - Parameters: {animator.parameterCount}");
        }
    }
}


```

`Client\Core\DebugModule\DebugModuleManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using DuckyNet.Client.RPC;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// è°ƒè¯•æ¨¡å—ç®¡ç†å™¨ - è‡ªåŠ¨å‘ç°å’Œç®¡ç†æ‰€æœ‰è°ƒè¯•æ¨¡å—
    /// </summary>
    public class DebugModuleManager : IDisposable
    {
        private readonly RpcClient _client;
        private readonly List<IDebugModule> _modules;

        /// <summary>
        /// <summary>
        /// è·å–æ‰€æœ‰æ¨¡å—
        /// </summary>
        public IReadOnlyList<IDebugModule> AllModules
        {
            get { return _modules.AsReadOnly(); }
        }

        public DebugModuleManager(RpcClient client)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _modules = new List<IDebugModule>();
        }

        /// <summary>
        /// å‘ç°å¹¶æ³¨å†Œæ‰€æœ‰è°ƒè¯•æ¨¡å—
        /// </summary>
        public void DiscoverAndRegisterModules()
        {
            try
            {
                // ä½¿ç”¨åå°„è‡ªåŠ¨å‘ç°æ‰€æœ‰å®ç°äº†IDebugModuleçš„ç±»
                var assembly = Assembly.GetExecutingAssembly();
                var moduleTypes = assembly.GetTypes()
                    .Where(t => t.IsClass && 
                               !t.IsAbstract && 
                               typeof(IDebugModule).IsAssignableFrom(t) &&
                               t != typeof(IDebugModule))
                    .ToList();

                foreach (var type in moduleTypes)
                {
                    try
                    {
                        // å°è¯•åˆ›å»ºå®ä¾‹ï¼ˆå°è¯•ä¸åŒçš„æ„é€ å‡½æ•°ç­¾åï¼‰
                        IDebugModule? module = null;
                        
                        // ä¼˜å…ˆå°è¯•å¸¦ RpcClient å‚æ•°çš„æ„é€ å‡½æ•°
                        var ctorWithClient = type.GetConstructor(new[] { typeof(RpcClient) });
                        if (ctorWithClient != null)
                        {
                            module = ctorWithClient.Invoke(new object[] { _client }) as IDebugModule;
                        }
                        else
                        {
                            // å°è¯•æ— å‚æ„é€ å‡½æ•°
                            var ctorNoParam = type.GetConstructor(Type.EmptyTypes);
                            if (ctorNoParam != null)
                            {
                                module = ctorNoParam.Invoke(null) as IDebugModule;
                            }
                        }

                        if (module != null)
                        {
                            _modules.Add(module);
                            UnityEngine.Debug.Log($"[DebugModuleManager] å·²æ³¨å†Œæ¨¡å—: {module.ModuleName} ({module.Category})");
                        }
                        else
                        {
                            UnityEngine.Debug.LogWarning($"[DebugModuleManager] æ— æ³•åˆ›å»ºæ¨¡å—å®ä¾‹: {type.Name}ï¼ˆç¼ºå°‘åˆé€‚çš„æ„é€ å‡½æ•°ï¼‰");
                        }
                    }
                    catch (Exception ex)
                    {
                        UnityEngine.Debug.LogError($"[DebugModuleManager] åˆ›å»ºæ¨¡å— {type.Name} å¤±è´¥: {ex.Message}");
                    }
                }

                UnityEngine.Debug.Log($"[DebugModuleManager] æ¨¡å—å‘ç°å®Œæˆï¼Œå…±æ‰¾åˆ° {_modules.Count} ä¸ªæ¨¡å—");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[DebugModuleManager] å‘ç°æ¨¡å—å¤±è´¥: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
            }
        }

        /// <summary>
        /// æ‰‹åŠ¨æ³¨å†Œæ¨¡å—ï¼ˆç”¨äºä¸æ”¯æŒåå°„å‘ç°çš„åœºæ™¯ï¼‰
        /// </summary>
        public void RegisterModule(IDebugModule module)
        {
            if (module == null)
                throw new ArgumentNullException(nameof(module));

            if (_modules.Contains(module))
            {
                UnityEngine.Debug.LogWarning($"[DebugModuleManager] æ¨¡å— {module.ModuleName} å·²å­˜åœ¨ï¼Œè·³è¿‡æ³¨å†Œ");
                return;
            }

            _modules.Add(module);
            UnityEngine.Debug.Log($"[DebugModuleManager] æ‰‹åŠ¨æ³¨å†Œæ¨¡å—: {module.ModuleName} ({module.Category})");
        }

        /// <summary>
        /// è·å–æ‰€æœ‰åˆ†ç±»
        /// </summary>
        public List<string> GetAllCategories()
        {
            return _modules.Select(m => m.Category)
                .Distinct()
                .OrderBy(c => c)
                .ToList();
        }

        /// <summary>
        /// æ ¹æ®åˆ†ç±»è·å–æ¨¡å—
        /// </summary>
        public IEnumerable<IDebugModule> GetModulesByCategory(string category)
        {
            return _modules.Where(m => m.Category == category);
        }

        /// <summary>
        /// æ›´æ–°æ‰€æœ‰æ¨¡å—
        /// </summary>
        public void Update()
        {
            foreach (var module in _modules.Where(m => m.IsEnabled))
            {
                try
                {
                    module.Update();
                }
                catch (Exception ex)
                {
                    UnityEngine.Debug.LogError($"[DebugModuleManager] æ¨¡å— {module.ModuleName} æ›´æ–°å¤±è´¥: {ex.Message}");
                }
            }
        }

        public void Dispose()
        {
            foreach (var module in _modules)
            {
                try
                {
                    if (module is IDisposable disposable)
                    {
                        disposable.Dispose();
                    }
                }
                catch (Exception ex)
                {
                    UnityEngine.Debug.LogError($"[DebugModuleManager] æ¨¡å— {module.ModuleName} æ¸…ç†å¤±è´¥: {ex.Message}");
                }
            }
            _modules.Clear();
        }
    }

    /// <summary>
    /// è°ƒè¯•æ¨¡å—æ¥å£
    /// </summary>
    public interface IDebugModule
    {
        string ModuleName { get; }
        string Category { get; }
        string Description { get; }
        bool IsEnabled { get; set; }
        void OnGUI();
        void Update();
    }
}


```

`Client\Core\DebugModule\Modules\AnimatorStateModule.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using DuckyNet.Client.Core;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// åŠ¨ç”»çŠ¶æ€æœºæ¨¡å— - ä» AnimatorStateViewer è½¬æ¢è€Œæ¥
    /// </summary>
    public class AnimatorStateModule : IDebugModule
    {
        private Animator? _playerAnimator;
        private float _updateInterval = 0.1f;
        private float _lastUpdateTime = 0f;

        private List<LayerStateInfo> _layerStates = new List<LayerStateInfo>();
        private Dictionary<string, AnimatorControllerParameter> _parameters = new Dictionary<string, AnimatorControllerParameter>();

        public string ModuleName => "çŠ¶æ€æœºå¯è§†åŒ–";
        public string Category => "åŠ¨ç”»";
        public string Description => "å®æ—¶æ˜¾ç¤ºç©å®¶åŠ¨ç”»çŠ¶æ€å’Œå‚æ•°";
        public bool IsEnabled { get; set; } = true;

        public AnimatorStateModule()
        {
        }

        public void OnGUI()
        {
            if (!GameContext.IsInitialized)
            {
                GUILayout.Label("æ¸¸æˆä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–", GUI.skin.label);
                return;
            }

            GUILayout.BeginVertical();

            if (GUILayout.Button("æŸ¥æ‰¾ç©å®¶ Animator"))
            {
                FindPlayerAnimator();
            }

            if (_playerAnimator == null)
            {
                GUILayout.Label("æœªæ‰¾åˆ°ç©å®¶ Animator", GUI.skin.label);
                GUILayout.EndVertical();
                return;
            }

            // Animator åŸºæœ¬ä¿¡æ¯
            GUILayout.Label("=== Animator ä¿¡æ¯ ===", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
            GUILayout.Label($"æ§åˆ¶å™¨: {_playerAnimator.runtimeAnimatorController?.name ?? "null"}");
            GUILayout.Label($"å±‚æ•°: {_playerAnimator.layerCount}");
            GUILayout.Label($"å‚æ•°æ•°: {_playerAnimator.parameterCount}");
            GUILayout.Label($"å¯ç”¨: {_playerAnimator.enabled}");

            GUILayout.Space(5);

            // åŠ¨ç”»å‚æ•°ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
            if (_parameters.Count > 0)
            {
                GUILayout.Label("=== å‚æ•°å€¼ ===", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
                
                // Float å‚æ•°
                var floatParams = _parameters.Values.Where(p => p.type == AnimatorControllerParameterType.Float).Take(5);
                foreach (var param in floatParams)
                {
                    float value = _playerAnimator.GetFloat(param.nameHash);
                    GUILayout.Label($"  {param.name}: {value:F2}");
                }

                // Bool å‚æ•°
                var boolParams = _parameters.Values.Where(p => p.type == AnimatorControllerParameterType.Bool).Take(5);
                foreach (var param in boolParams)
                {
                    bool value = _playerAnimator.GetBool(param.nameHash);
                    GUILayout.Label($"  {param.name}: {value}");
                }
            }

            GUILayout.Space(5);

            // åŠ¨ç”»å±‚çŠ¶æ€ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰
            if (_layerStates.Count > 0)
            {
                GUILayout.Label("=== å±‚çŠ¶æ€ ===", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
                
                foreach (var layerInfo in _layerStates)
                {
                    GUILayout.Label($"å±‚ {layerInfo.LayerIndex}: {layerInfo.LayerName}");
                    GUILayout.Label($"  æƒé‡: {layerInfo.Weight:F2}");
                    
                    if (layerInfo.CurrentState != null)
                    {
                        GUILayout.Label($"  å½“å‰: {layerInfo.CurrentState.Name}");
                        GUILayout.Label($"  è¿›åº¦: {layerInfo.CurrentState.NormalizedTime * 100:F0}%");
                    }

                    if (layerInfo.IsInTransition && layerInfo.NextState != null)
                    {
                        GUILayout.Label($"  è¿‡æ¸¡ä¸­ â†’ {layerInfo.NextState.Name}");
                        GUILayout.Label($"  è¿‡æ¸¡: {layerInfo.TransitionProgress * 100:F0}%");
                    }
                }
            }

            GUILayout.EndVertical();
        }

        public void Update()
        {
            if (!IsEnabled) return;

            // å®šæœŸæ›´æ–°çŠ¶æ€ä¿¡æ¯
            if (Time.time - _lastUpdateTime > _updateInterval)
            {
                UpdateAnimatorState();
                _lastUpdateTime = Time.time;
            }
        }

        private void FindPlayerAnimator()
        {
            try
            {
                var customizationManager = GameContext.Instance?.CharacterCustomizationManager;
                if (customizationManager != null)
                {
                    var getCharacterMethod = customizationManager.GetType().GetMethod("GetLocalPlayerCharacter",
                        System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                    
                    if (getCharacterMethod != null)
                    {
                        var character = getCharacterMethod.Invoke(customizationManager, null) as GameObject;
                        if (character != null)
                        {
                            _playerAnimator = character.GetComponentInChildren<Animator>();
                            if (_playerAnimator != null)
                            {
                                InitializeAnimator();
                                return;
                            }
                        }
                    }
                }

                // å¤‡ç”¨æ–¹æ³•ï¼šæŸ¥æ‰¾åœºæ™¯ä¸­çš„ Animator
                var allAnimators = GameObject.FindObjectsOfType<Animator>();
                foreach (var animator in allAnimators)
                {
                    if (animator.runtimeAnimatorController != null && 
                        animator.runtimeAnimatorController.name.Contains("Character"))
                    {
                        var character = animator.transform.root.gameObject;
                        if (!character.name.Contains("Custom") && !character.name.Contains("Test"))
                        {
                            _playerAnimator = animator;
                            InitializeAnimator();
                            return;
                        }
                    }
                }

                UnityEngine.Debug.LogWarning("[AnimatorStateModule] æœªæ‰¾åˆ°ç©å®¶è§’è‰²çš„ Animator");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[AnimatorStateModule] æŸ¥æ‰¾ Animator å¤±è´¥: {ex.Message}");
            }
        }

        private void InitializeAnimator()
        {
            _parameters.Clear();
            if (_playerAnimator != null)
            {
                foreach (var param in _playerAnimator.parameters)
                {
                    _parameters[param.name] = param;
                }
                
                UpdateAnimatorState();
            }
        }

        private void UpdateAnimatorState()
        {
            if (_playerAnimator == null) return;

            try
            {
                _layerStates.Clear();

                for (int i = 0; i < _playerAnimator.layerCount; i++)
                {
                    var layerInfo = new LayerStateInfo
                    {
                        LayerIndex = i,
                        LayerName = _playerAnimator.GetLayerName(i),
                        Weight = _playerAnimator.GetLayerWeight(i)
                    };

                    var currentStateInfo = _playerAnimator.GetCurrentAnimatorStateInfo(i);
                    layerInfo.CurrentState = new StateInfo
                    {
                        Name = $"State_{currentStateInfo.fullPathHash}",
                        NameHash = currentStateInfo.fullPathHash,
                        NormalizedTime = currentStateInfo.normalizedTime,
                        Speed = currentStateInfo.speed,
                        IsLooping = currentStateInfo.loop
                    };

                    if (_playerAnimator.IsInTransition(i))
                    {
                        layerInfo.IsInTransition = true;
                        var transitionInfo = _playerAnimator.GetAnimatorTransitionInfo(i);
                        layerInfo.TransitionProgress = transitionInfo.normalizedTime;

                        var nextStateInfo = _playerAnimator.GetNextAnimatorStateInfo(i);
                        layerInfo.NextState = new StateInfo
                        {
                            Name = $"State_{nextStateInfo.fullPathHash}",
                            NameHash = nextStateInfo.fullPathHash,
                            NormalizedTime = nextStateInfo.normalizedTime,
                            Speed = nextStateInfo.speed,
                            IsLooping = nextStateInfo.loop
                        };
                    }

                    _layerStates.Add(layerInfo);
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[AnimatorStateModule] æ›´æ–°çŠ¶æ€å¤±è´¥: {ex.Message}");
            }
        }

        private class LayerStateInfo
        {
            public int LayerIndex { get; set; }
            public string LayerName { get; set; } = "";
            public float Weight { get; set; }
            public StateInfo? CurrentState { get; set; }
            public bool IsInTransition { get; set; }
            public StateInfo? NextState { get; set; }
            public float TransitionProgress { get; set; }
        }

        private class StateInfo
        {
            public string Name { get; set; } = "";
            public int NameHash { get; set; }
            public float NormalizedTime { get; set; }
            public float Speed { get; set; }
            public bool IsLooping { get; set; }
        }
    }
}

```

`Client\Core\DebugModule\Modules\AnimatorSyncTestModule.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.Core.Utils;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// åŠ¨ç”»åŒæ­¥æµ‹è¯•è°ƒè¯•æ¨¡å— - åˆ›å»ºæµ‹è¯•å•ä½å¹¶æ¨¡æ‹Ÿè¿œç¨‹ç©å®¶åŠ¨ç”»åŒæ­¥
    /// </summary>
    public class AnimatorSyncTestModule : IDebugModule
    {
        public string ModuleName => "åŠ¨ç”»åŒæ­¥æµ‹è¯•";
        public string Category => "æµ‹è¯•";
        public string Description => "åˆ›å»ºæµ‹è¯•å•ä½å¹¶å®æ—¶åŒæ­¥æœ¬åœ°ç©å®¶çš„åŠ¨ç”»çŠ¶æ€";
        public bool IsEnabled { get; set; } = true;

        private object? _testCharacter;
        private Animator? _testAnimator;
        private Animator? _localAnimator;
        private string _statusInfo = "";
        private Vector3 _spawnOffset = new Vector3(3f, 0f, 0f); // é»˜è®¤åœ¨å³ä¾§3ç±³
        
        // åŒæ­¥é…ç½®
        private bool _autoSync = true;
        private float _syncInterval = 0.033f; // ~33msï¼ˆ30å¸§/ç§’ï¼‰
        private float _lastSyncTime = 0f;
        
        // ç»Ÿè®¡ä¿¡æ¯
        private int _syncCount = 0;
        private int _skippedCount = 0;
        private AnimatorSyncData? _lastSyncData = null;
        private AnimatorSyncData? _currentTargetData = null; // å½“å‰ç›®æ ‡æ•°æ®ï¼ˆç”¨äºæ¯å¸§åº”ç”¨ï¼‰

        public void OnGUI()
        {
            if (!IsEnabled) return;

            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label("=== åŠ¨ç”»åŒæ­¥æµ‹è¯•å·¥å…· ===", GUI.skin.box);
            
            // åç§»é‡è®¾ç½®
            GUILayout.BeginHorizontal();
            GUILayout.Label("ç”Ÿæˆåç§» X:", GUILayout.Width(80));
            if (float.TryParse(GUILayout.TextField(_spawnOffset.x.ToString("F1"), GUILayout.Width(60)), out float x))
                _spawnOffset.x = x;
            GUILayout.Label("Y:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnOffset.y.ToString("F1"), GUILayout.Width(60)), out float y))
                _spawnOffset.y = y;
            GUILayout.Label("Z:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnOffset.z.ToString("F1"), GUILayout.Width(60)), out float z))
                _spawnOffset.z = z;
            GUILayout.EndHorizontal();

            GUILayout.Space(5);

            // åŒæ­¥é—´éš”è®¾ç½®
            GUILayout.BeginHorizontal();
            GUILayout.Label("åŒæ­¥é—´éš”(ms):", GUILayout.Width(100));
            if (float.TryParse(GUILayout.TextField((_syncInterval * 1000).ToString("F0"), GUILayout.Width(60)), out float interval))
                _syncInterval = interval / 1000f;
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // æŒ‰é’®åŒºåŸŸ
            if (_testCharacter == null)
            {
                if (GUILayout.Button("ğŸ­ åˆ›å»ºæµ‹è¯•å•ä½", GUILayout.Height(50)))
                {
                    CreateTestCharacter();
                }
            }
            else
            {
                // è‡ªåŠ¨åŒæ­¥å¼€å…³
                GUILayout.BeginHorizontal();
                bool newAutoSync = GUILayout.Toggle(_autoSync, _autoSync ? "ğŸ”„ è‡ªåŠ¨åŒæ­¥ä¸­..." : "â¸ï¸ è‡ªåŠ¨åŒæ­¥(å…³é—­)");
                if (newAutoSync != _autoSync)
                {
                    _autoSync = newAutoSync;
                    if (_autoSync)
                    {
                        _syncCount = 0;
                        _skippedCount = 0;
                        _statusInfo += "\nâœ… è‡ªåŠ¨åŒæ­¥å·²å¼€å¯";
                    }
                    else
                    {
                        _statusInfo += "\nâ¸ï¸ è‡ªåŠ¨åŒæ­¥å·²æš‚åœ";
                    }
                }
                GUILayout.EndHorizontal();

                GUILayout.Space(5);

                if (GUILayout.Button("ğŸ¯ æ‰‹åŠ¨åŒæ­¥ä¸€æ¬¡", GUILayout.Height(40)))
                {
                    SyncAnimationOnce();
                }

                GUILayout.Space(5);

                if (GUILayout.Button("ğŸ—‘ï¸ åˆ é™¤æµ‹è¯•å•ä½", GUILayout.Height(40)))
                {
                    DestroyTestCharacter();
                }

                // ç»Ÿè®¡ä¿¡æ¯
                GUILayout.Space(10);
                GUILayout.BeginVertical(GUI.skin.box);
                GUILayout.Label($"åŒæ­¥æ¬¡æ•°: {_syncCount}");
                GUILayout.Label($"è·³è¿‡æ¬¡æ•°: {_skippedCount} (å¢é‡ä¼˜åŒ–)");
                if (_lastSyncData != null)
                {
                    GUILayout.Label($"å½“å‰çŠ¶æ€: {_lastSyncData.StateHash}");
                    GUILayout.Label($"å½’ä¸€åŒ–æ—¶é—´: {_lastSyncData.GetNormalizedTime():F2}");
                }
                GUILayout.EndVertical();
            }

            // çŠ¶æ€ä¿¡æ¯
            GUILayout.Space(10);
            GUILayout.Box(_statusInfo, GUILayout.ExpandHeight(true));
            
            GUILayout.EndVertical();
        }

        /// <summary>
        /// åˆ›å»ºæµ‹è¯•å•ä½
        /// </summary>
        private void CreateTestCharacter()
        {
            try
            {
                var mainChar = CharacterMainControl.Main;
                if (mainChar == null)
                {
                    _statusInfo = "âŒ æ— æ³•è·å–æœ¬åœ°ç©å®¶ä½ç½®";
                    return;
                }

                // è·å–æœ¬åœ°ç©å®¶çš„ Animator
                _localAnimator = mainChar.GetComponentInChildren<Animator>();
                if (_localAnimator == null)
                {
                    _statusInfo = "âŒ æœ¬åœ°ç©å®¶æ²¡æœ‰ Animator ç»„ä»¶";
                    return;
                }

                // è®¡ç®—ç”Ÿæˆä½ç½®
                var playerPos = mainChar.transform.position;
                var spawnPos = playerPos + _spawnOffset;

                _statusInfo = "â³ æ­£åœ¨åˆ›å»ºæµ‹è¯•å•ä½...";

                // 1. åˆ›å»ºè§’è‰²æ•°æ®é¡¹
                var characterItem = CharacterCreationUtils.CreateCharacterItem();
                if (characterItem == null)
                {
                    _statusInfo = "âŒ åˆ›å»ºè§’è‰²æ•°æ®é¡¹å¤±è´¥";
                    return;
                }

                // 2. è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“
                var modelPrefab = CharacterCreationUtils.GetCharacterModelPrefab();
                if (modelPrefab == null)
                {
                    _statusInfo = "âŒ è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“å¤±è´¥";
                    return;
                }

                // 3. å®ä¾‹åŒ–è§’è‰²
                var newCharacter = CharacterCreationUtils.CreateCharacterInstance(
                    characterItem, modelPrefab, spawnPos, Quaternion.identity
                );
                if (newCharacter == null)
                {
                    _statusInfo = "âŒ å®ä¾‹åŒ–è§’è‰²å¤±è´¥";
                    return;
                }

                // 4. é…ç½®è§’è‰²
                CharacterCreationUtils.ConfigureCharacter(newCharacter, "TestCharacter_AnimSync", spawnPos, team: 0);
                CharacterCreationUtils.ConfigureCharacterPreset(newCharacter, "åŠ¨ç”»æµ‹è¯•", showName: true);

                // 5. æ ‡è®°ä¸ºè¿œç¨‹ç©å®¶ï¼ˆç¦ç”¨ç§»åŠ¨ï¼‰
                CharacterCreationUtils.MarkAsRemotePlayer(newCharacter);

                // 6. ä»è·ç¦»ç³»ç»Ÿç§»é™¤
                CharacterCreationUtils.UnregisterFromDistanceSystem(newCharacter);

                // 7. è¯·æ±‚è¡€æ¡
                CharacterCreationUtils.RequestHealthBar(newCharacter, "åŠ¨ç”»æµ‹è¯•", null);

                // 8. è·å–æµ‹è¯•å•ä½çš„ Animator
                if (newCharacter is Component comp)
                {
                    _testAnimator = comp.GetComponentInChildren<Animator>();
                    if (_testAnimator == null)
                    {
                        _statusInfo = "âŒ æµ‹è¯•å•ä½æ²¡æœ‰ Animator ç»„ä»¶";
                        UnityEngine.Object.Destroy(comp.gameObject);
                        return;
                    }

                    // 9. ç¦ç”¨ CharacterAnimationControlï¼ˆé˜²æ­¢æœ¬åœ°é€»è¾‘è¦†ç›–åŒæ­¥çš„åŠ¨ç”»å‚æ•°ï¼‰
                    DisableAnimationControl(comp);
                }

                _testCharacter = newCharacter;
                _syncCount = 0;
                _skippedCount = 0;
                _statusInfo = $"âœ… æµ‹è¯•å•ä½åˆ›å»ºæˆåŠŸ\nä½ç½®: {spawnPos}\n\nå¯ä»¥å¼€å¯è‡ªåŠ¨åŒæ­¥æˆ–æ‰‹åŠ¨åŒæ­¥";
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ åˆ›å»ºæµ‹è¯•å•ä½å¼‚å¸¸:\n{ex.Message}";
                Debug.LogError($"[AnimatorSyncTestModule] {ex}");
            }
        }

        /// <summary>
        /// ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬ï¼ˆé˜²æ­¢æœ¬åœ°é€»è¾‘è¦†ç›–åŒæ­¥çš„åŠ¨ç”»å‚æ•°ï¼‰
        /// </summary>
        private void DisableAnimationControl(Component character)
        {
            try
            {
                // ç¦ç”¨ CharacterAnimationControl
                var animControlType = HarmonyLib.AccessTools.TypeByName("CharacterAnimationControl");
                if (animControlType != null)
                {
                    var animControl = character.GetComponentInChildren(animControlType) as MonoBehaviour;
                    if (animControl != null)
                    {
                        animControl.enabled = false;
                        Debug.Log("[AnimatorSyncTestModule] âœ… å·²ç¦ç”¨ CharacterAnimationControl");
                    }
                }

                // ç¦ç”¨ CharacterAnimationControl_MagicBlendï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                var magicBlendType = HarmonyLib.AccessTools.TypeByName("CharacterAnimationControl_MagicBlend");
                if (magicBlendType != null)
                {
                    var magicBlend = character.GetComponentInChildren(magicBlendType) as MonoBehaviour;
                    if (magicBlend != null)
                    {
                        magicBlend.enabled = false;
                        Debug.Log("[AnimatorSyncTestModule] âœ… å·²ç¦ç”¨ CharacterAnimationControl_MagicBlend");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[AnimatorSyncTestModule] ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åŒæ­¥ä¸€æ¬¡åŠ¨ç”»çŠ¶æ€
        /// </summary>
        private void SyncAnimationOnce()
        {
            if (_localAnimator == null || _testAnimator == null)
            {
                _statusInfo = "âŒ Animator ç»„ä»¶ç¼ºå¤±";
                return;
            }

            try
            {
                // 1. é‡‡é›†æœ¬åœ°ç©å®¶çš„åŠ¨ç”»çŠ¶æ€
                var syncData = CaptureAnimatorState(_localAnimator);
                if (syncData == null)
                {
                    _statusInfo = "âŒ é‡‡é›†åŠ¨ç”»çŠ¶æ€å¤±è´¥";
                    return;
                }

                // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦åŒæ­¥ï¼ˆå¢é‡ä¼˜åŒ–ï¼‰
                if (!HasDataChanged(syncData))
                {
                    _skippedCount++;
                    return;
                }

                // 3. åº”ç”¨åˆ°æµ‹è¯•å•ä½
                ApplyAnimatorState(_testAnimator, syncData);

                _lastSyncData = syncData;
                _currentTargetData = syncData; // ä¿å­˜å½“å‰ç›®æ ‡
                _syncCount++;
                _statusInfo = $"âœ… åŒæ­¥æˆåŠŸ (#{_syncCount})\nçŠ¶æ€: {syncData.StateHash}\næ—¶é—´: {syncData.GetNormalizedTime():F2}";
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ åŒæ­¥å¼‚å¸¸:\n{ex.Message}";
                Debug.LogError($"[AnimatorSyncTestModule] {ex}");
            }
        }

        /// <summary>
        /// æ¯å¸§æŒç»­åº”ç”¨åŠ¨ç”»å‚æ•°ï¼ˆå‚è€ƒ RemoteAnimatorSmoother.Updateï¼‰
        /// </summary>
        private void ContinuouslyApplyParameters()
        {
            if (_currentTargetData == null || _testAnimator == null) return;

            try
            {
                // Float å‚æ•° - æ¯å¸§ç›´æ¥è®¾ç½®ï¼ˆç§»é™¤ dampTimeï¼‰
                var floatParamNames = new string[] { "MoveSpeed", "MoveDirX", "MoveDirY", "", "", "", "", "" };
                for (int i = 0; i < Math.Min(floatParamNames.Length, 3); i++)
                {
                    if (string.IsNullOrEmpty(floatParamNames[i])) continue;
                    
                    try
                    {
                        int hash = Animator.StringToHash(floatParamNames[i]);
                        _testAnimator.SetFloat(hash, _currentTargetData.GetFloatParam(i));
                    }
                    catch { }
                }

                // Integer å‚æ•° - HandState
                try
                {
                    int handStateHash = Animator.StringToHash("HandState");
                    _testAnimator.SetInteger(handStateHash, (int)_currentTargetData.GetFloatParam(3));
                }
                catch { }

                // Bool å‚æ•° - æ¯å¸§æŒç»­è®¾ç½®
                var boolParamNames = new string[] { "Dashing", "RightHandOut", "Attack", "GunReady" };
                for (int i = 0; i < Math.Min(boolParamNames.Length, 4); i++)
                {
                    if (string.IsNullOrEmpty(boolParamNames[i])) continue;
                    
                    try
                    {
                        int hash = Animator.StringToHash(boolParamNames[i]);
                        _testAnimator.SetBool(hash, _currentTargetData.GetBoolParam(i));
                    }
                    catch { }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncTestModule] ContinuouslyApplyParameters: {ex}");
            }
        }

        /// <summary>
        /// é‡‡é›† Animator çŠ¶æ€ï¼ˆå‚è€ƒ AnimatorSyncManagerï¼‰
        /// </summary>
        private AnimatorSyncData? CaptureAnimatorState(Animator animator)
        {
            try
            {
                var syncData = new AnimatorSyncData();

                // è·å–å½“å‰çŠ¶æ€å“ˆå¸Œï¼ˆä¸»å±‚ï¼‰
                var currentState = animator.GetCurrentAnimatorStateInfo(0);
                syncData.StateHash = currentState.fullPathHash;
                syncData.SetNormalizedTime(currentState.normalizedTime);

                // é‡‡é›† Float å‚æ•°ï¼ˆä½¿ç”¨æ¸¸æˆå®é™…çš„å‚æ•°åï¼‰
                var floatParamNames = new string[]
                {
                    "MoveSpeed",    // 0: ç§»åŠ¨é€Ÿåº¦
                    "MoveDirX",     // 1: ç§»åŠ¨æ–¹å‘ X
                    "MoveDirY",     // 2: ç§»åŠ¨æ–¹å‘ Y
                    "",             // 3: é¢„ç•™ç»™ HandState (Integer)
                    "",             // 4: é¢„ç•™
                    "",             // 5: é¢„ç•™
                    "",             // 6: é¢„ç•™
                    ""              // 7: é¢„ç•™
                };

                for (int i = 0; i < Math.Min(floatParamNames.Length, 8); i++)
                {
                    if (string.IsNullOrEmpty(floatParamNames[i])) continue;
                    
                    try
                    {
                        int hash = Animator.StringToHash(floatParamNames[i]);
                        float value = animator.GetFloat(hash);
                        syncData.SetFloatParam(i, value);
                    }
                    catch
                    {
                        // å‚æ•°ä¸å­˜åœ¨ï¼Œè·³è¿‡
                    }
                }

                // é‡‡é›† Integer å‚æ•° - HandState
                try
                {
                    int handStateHash = Animator.StringToHash("HandState");
                    int handStateValue = animator.GetInteger(handStateHash);
                    // å­˜å‚¨åˆ°é¢„ç•™çš„ Float æ§½ä½ [3]
                    syncData.SetFloatParam(3, handStateValue);
                }
                catch
                {
                    // å‚æ•°ä¸å­˜åœ¨ï¼Œè·³è¿‡
                }

                // é‡‡é›† Bool å‚æ•°ï¼ˆä½¿ç”¨æ¸¸æˆå®é™…çš„å‚æ•°åï¼‰
                var boolParamNames = new string[]
                {
                    "Dashing",      // 0: ç¿»æ»š/å†²åˆº
                    "RightHandOut", // 1: å³æ‰‹æ˜¯å¦ä¼¸å‡º
                    "Attack",       // 2: æ”»å‡»çŠ¶æ€ (MagicBlend)
                    "GunReady",     // 3: æªæ¢°å‡†å¤‡ (MagicBlend)
                    "",             // 4: é¢„ç•™
                    "",             // 5: é¢„ç•™
                    "",             // 6: é¢„ç•™
                    "",             // 7: é¢„ç•™
                    "",             // 8-31: æ›´å¤šé¢„ç•™
                };

                for (int i = 0; i < Math.Min(boolParamNames.Length, 32); i++)
                {
                    if (string.IsNullOrEmpty(boolParamNames[i])) continue;
                    
                    try
                    {
                        int hash = Animator.StringToHash(boolParamNames[i]);
                        bool value = animator.GetBool(hash);
                        syncData.SetBoolParam(i, value);
                    }
                    catch
                    {
                        // å‚æ•°ä¸å­˜åœ¨ï¼Œè·³è¿‡
                    }
                }

                return syncData;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncTestModule] CaptureAnimatorState: {ex}");
                return null;
            }
        }

        /// <summary>
        /// åº”ç”¨åŠ¨ç”»çŠ¶æ€åˆ° Animatorï¼ˆåªè´Ÿè´£çŠ¶æ€åˆ‡æ¢ï¼Œå‚æ•°ç”± ContinuouslyApplyParameters å¤„ç†ï¼‰
        /// </summary>
        private void ApplyAnimatorState(Animator animator, AnimatorSyncData syncData)
        {
            try
            {
                // 1. æ’­æ”¾å¯¹åº”çŠ¶æ€
                var currentState = animator.GetCurrentAnimatorStateInfo(0);
                if (currentState.fullPathHash != syncData.StateHash)
                {
                    // çŠ¶æ€åˆ‡æ¢ - ä½¿ç”¨ CrossFade å¹³æ»‘è¿‡æ¸¡
                    animator.CrossFade(syncData.StateHash, 0.2f, 0, syncData.GetNormalizedTime());
                }
                else
                {
                    // åŒæ­¥å½’ä¸€åŒ–æ—¶é—´
                    float targetTime = syncData.GetNormalizedTime();
                    float currentTime = currentState.normalizedTime % 1f;
                    float timeDiff = Mathf.Abs(targetTime - currentTime);

                    if (timeDiff > 0.1f && timeDiff < 0.9f)
                    {
                        animator.Play(syncData.StateHash, 0, targetTime);
                    }
                }
                
                // æ³¨æ„ï¼šå‚æ•°ç”± ContinuouslyApplyParameters() æ¯å¸§æŒç»­è®¾ç½®
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncTestModule] ApplyAnimatorState: {ex}");
            }
        }

        /// <summary>
        /// æ£€æŸ¥æ•°æ®æ˜¯å¦æ”¹å˜ï¼ˆå¢é‡åŒæ­¥ä¼˜åŒ–ï¼‰
        /// </summary>
        private bool HasDataChanged(AnimatorSyncData newData)
        {
            if (_lastSyncData == null) return true;

            // çŠ¶æ€åˆ‡æ¢
            if (newData.StateHash != _lastSyncData.StateHash) return true;

            // Bool å‚æ•°æ”¹å˜
            if (newData.BoolParams != _lastSyncData.BoolParams) return true;

            // Float å‚æ•°æ”¹å˜ï¼ˆé˜ˆå€¼ 0.02ï¼‰
            for (int i = 0; i < 8; i++)
            {
                int diff = Math.Abs(newData.FloatParams[i] - _lastSyncData.FloatParams[i]);
                if (diff > 2) // 2 = 0.02 * 100
                {
                    return true;
                }
            }

            // å½’ä¸€åŒ–æ—¶é—´æ”¹å˜ï¼ˆé˜ˆå€¼ 0.05ï¼‰
            int timeDiff = Math.Abs(newData.NormalizedTime - _lastSyncData.NormalizedTime);
            if (timeDiff > 3276) // 3276 = 0.05 * 65535
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// åˆ é™¤æµ‹è¯•å•ä½
        /// </summary>
        private void DestroyTestCharacter()
        {
            try
            {
                if (_testCharacter != null && _testCharacter is Component component)
                {
                    UnityEngine.Object.Destroy(component.gameObject);
                    _testCharacter = null;
                    _testAnimator = null;
                    _localAnimator = null;
                    _lastSyncData = null;
                    _autoSync = false;
                    _statusInfo = $"âœ… æµ‹è¯•å•ä½å·²åˆ é™¤\næ€»åŒæ­¥: {_syncCount} æ¬¡\nè·³è¿‡: {_skippedCount} æ¬¡";
                }
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ åˆ é™¤å¤±è´¥:\n{ex.Message}";
                Debug.LogError($"[AnimatorSyncTestModule] {ex}");
            }
        }

        public void Update()
        {
            if (!IsEnabled || _testCharacter == null) return;

            // æ¯å¸§æŒç»­åº”ç”¨å‚æ•°ï¼ˆå…³é”®ï¼ï¼‰
            ContinuouslyApplyParameters();

            // å®šæœŸåŒæ­¥ï¼ˆä»…åœ¨ autoSync æ¨¡å¼ï¼‰
            if (_autoSync && Time.time - _lastSyncTime >= _syncInterval)
            {
                SyncAnimationOnce();
                _lastSyncTime = Time.time;
            }
        }

        public void OnEnable()
        {
            _statusInfo = "åŠ¨ç”»åŒæ­¥æµ‹è¯•å·¥å…·\n\nåŠŸèƒ½:\n- åˆ›å»ºæµ‹è¯•å•ä½\n- å®æ—¶åŒæ­¥æœ¬åœ°ç©å®¶åŠ¨ç”»\n- éªŒè¯è¿œç¨‹åŠ¨ç”»åŒæ­¥é€»è¾‘\n\nç‚¹å‡»åˆ›å»ºæŒ‰é’®å¼€å§‹";
        }

        public void OnDisable()
        {
            _autoSync = false;
        }
    }
}

```

`Client\Core\DebugModule\Modules\AppearanceTestModule.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.Core.Utils;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// å¤–è§‚æµ‹è¯•è°ƒè¯•æ¨¡å— - åœ¨æœ¬åœ°ç©å®¶æ—è¾¹åˆ›å»ºæµ‹è¯•å•ä½å¹¶å¤åˆ¶å¤–è§‚
    /// </summary>
    public class AppearanceTestModule : IDebugModule
    {
        public string ModuleName => "å¤–è§‚æµ‹è¯•";
        public string Category => "æµ‹è¯•";
        public string Description => "åœ¨æœ¬åœ°ç©å®¶æ—è¾¹åˆ›å»ºæµ‹è¯•å•ä½å¹¶å¤åˆ¶å¤–è§‚æ•°æ®";
        public bool IsEnabled { get; set; } = false;

        private object? _testCharacter;
        private string _statusInfo = "";
        private Vector3 _spawnOffset = new Vector3(2f, 0f, 0f); // é»˜è®¤åœ¨å³ä¾§2ç±³
        private CharacterAppearanceData? _cachedAppearance;

        public void OnGUI()
        {
            if (!IsEnabled) return;

            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label("=== å¤–è§‚æµ‹è¯•å·¥å…· ===", GUI.skin.box);
            
            // åç§»é‡è®¾ç½®
            GUILayout.BeginHorizontal();
            GUILayout.Label("ç”Ÿæˆåç§» X:", GUILayout.Width(80));
            if (float.TryParse(GUILayout.TextField(_spawnOffset.x.ToString("F1"), GUILayout.Width(60)), out float x))
                _spawnOffset.x = x;
            GUILayout.Label("Y:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnOffset.y.ToString("F1"), GUILayout.Width(60)), out float y))
                _spawnOffset.y = y;
            GUILayout.Label("Z:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnOffset.z.ToString("F1"), GUILayout.Width(60)), out float z))
                _spawnOffset.z = z;
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // æŒ‰é’®åŒºåŸŸ
            if (GUILayout.Button("1ï¸âƒ£ è·å–æœ¬åœ°ç©å®¶å¤–è§‚", GUILayout.Height(40)))
            {
                CaptureLocalPlayerAppearance();
            }

            if (GUILayout.Button("2ï¸âƒ£ åˆ›å»ºæµ‹è¯•å•ä½", GUILayout.Height(40)))
            {
                CreateTestCharacter();
            }

            if (GUILayout.Button("3ï¸âƒ£ åº”ç”¨å¤–è§‚åˆ°æµ‹è¯•å•ä½", GUILayout.Height(40)))
            {
                ApplyAppearanceToTestCharacter();
            }

            GUILayout.Space(10);

            if (GUILayout.Button("ğŸ”„ ä¸€é”®åˆ›å»ºå¹¶å¤åˆ¶å¤–è§‚", GUILayout.Height(50)))
            {
                QuickCreateAndCopy();
            }

            GUILayout.Space(10);

            if (_testCharacter != null && GUILayout.Button("ğŸ—‘ï¸ åˆ é™¤æµ‹è¯•å•ä½", GUILayout.Height(40)))
            {
                DestroyTestCharacter();
            }

            // çŠ¶æ€ä¿¡æ¯
            GUILayout.Space(10);
            GUILayout.Box(_statusInfo, GUILayout.ExpandHeight(true));
            
            GUILayout.EndVertical();
        }

        /// <summary>
        /// è·å–æœ¬åœ°ç©å®¶å¤–è§‚æ•°æ®
        /// </summary>
        private void CaptureLocalPlayerAppearance()
        {
            try
            {
                var mainChar = CharacterMainControl.Main;
                if (mainChar == null)
                {
                    _statusInfo = "âŒ æ— æ³•è·å–æœ¬åœ°ç©å®¶";
                    return;
                }

                _cachedAppearance = AppearanceConverter.GetCharacterAppearance(mainChar);
                if (_cachedAppearance != null)
                {
                    _statusInfo = $"âœ… æˆåŠŸè·å–æœ¬åœ°ç©å®¶å¤–è§‚\néƒ¨ä»¶æ•°é‡: {_cachedAppearance.Parts.Length}";
                }
                else
                {
                    _statusInfo = "âŒ è·å–å¤–è§‚æ•°æ®å¤±è´¥";
                }
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ è·å–å¤–è§‚å¼‚å¸¸:\n{ex.Message}";
                Debug.LogError($"[AppearanceTestModule] {ex}");
            }
        }

        /// <summary>
        /// åˆ›å»ºæµ‹è¯•å•ä½
        /// </summary>
        private void CreateTestCharacter()
        {
            try
            {
                var mainChar = CharacterMainControl.Main;
                if (mainChar == null)
                {
                    _statusInfo = "âŒ æ— æ³•è·å–æœ¬åœ°ç©å®¶ä½ç½®";
                    return;
                }

                // è®¡ç®—ç”Ÿæˆä½ç½®ï¼ˆåœ¨æœ¬åœ°ç©å®¶æ—è¾¹ï¼‰
                var playerPos = mainChar.transform.position;
                var spawnPos = playerPos + _spawnOffset;

                _statusInfo = "â³ æ­£åœ¨åˆ›å»ºæµ‹è¯•å•ä½...";

                // 1. åˆ›å»ºè§’è‰²æ•°æ®é¡¹
                var characterItem = CharacterCreationUtils.CreateCharacterItem();
                if (characterItem == null)
                {
                    _statusInfo = "âŒ åˆ›å»ºè§’è‰²æ•°æ®é¡¹å¤±è´¥";
                    return;
                }

                // 2. è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“
                var modelPrefab = CharacterCreationUtils.GetCharacterModelPrefab();
                if (modelPrefab == null)
                {
                    _statusInfo = "âŒ è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“å¤±è´¥";
                    return;
                }

                // 3. å®ä¾‹åŒ–è§’è‰²
                var newCharacter = CharacterCreationUtils.CreateCharacterInstance(
                    characterItem, modelPrefab, spawnPos, Quaternion.identity
                );
                if (newCharacter == null)
                {
                    _statusInfo = "âŒ å®ä¾‹åŒ–è§’è‰²å¤±è´¥";
                    return;
                }

                // 4. é…ç½®è§’è‰²
                CharacterCreationUtils.ConfigureCharacter(newCharacter, "TestCharacter_Appearance", spawnPos, team: 0);
                CharacterCreationUtils.ConfigureCharacterPreset(newCharacter, "æµ‹è¯•å•ä½", showName: true);

                // 5. æ ‡è®°ä¸ºè¿œç¨‹ç©å®¶ï¼ˆç¦ç”¨ç§»åŠ¨ï¼‰
                CharacterCreationUtils.MarkAsRemotePlayer(newCharacter);

                // 6. ä»è·ç¦»ç³»ç»Ÿç§»é™¤
                CharacterCreationUtils.UnregisterFromDistanceSystem(newCharacter);

                // 7. è¯·æ±‚è¡€æ¡
                CharacterCreationUtils.RequestHealthBar(newCharacter, "æµ‹è¯•å•ä½", null);

                _testCharacter = newCharacter;
                _statusInfo = $"âœ… æµ‹è¯•å•ä½åˆ›å»ºæˆåŠŸ\nä½ç½®: {spawnPos}";
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ åˆ›å»ºæµ‹è¯•å•ä½å¼‚å¸¸:\n{ex.Message}";
                Debug.LogError($"[AppearanceTestModule] {ex}");
            }
        }

        /// <summary>
        /// åº”ç”¨å¤–è§‚åˆ°æµ‹è¯•å•ä½
        /// </summary>
        private void ApplyAppearanceToTestCharacter()
        {
            try
            {
                if (_testCharacter == null)
                {
                    _statusInfo = "âŒ æµ‹è¯•å•ä½ä¸å­˜åœ¨\nè¯·å…ˆåˆ›å»ºæµ‹è¯•å•ä½";
                    return;
                }

                if (_cachedAppearance == null)
                {
                    _statusInfo = "âŒ æ²¡æœ‰ç¼“å­˜çš„å¤–è§‚æ•°æ®\nè¯·å…ˆè·å–æœ¬åœ°ç©å®¶å¤–è§‚";
                    return;
                }

                _statusInfo = "â³ æ­£åœ¨åº”ç”¨å¤–è§‚...";

                // å»¶è¿Ÿåº”ç”¨å¤–è§‚ï¼ˆç­‰å¾…è§’è‰²åˆå§‹åŒ–ï¼‰
                if (ModBehaviour.Instance != null)
                {
                    ModBehaviour.Instance.StartCoroutine(ApplyAppearanceDelayed());
                }
                else
                {
                    // ç›´æ¥åº”ç”¨
                    ApplyAppearanceNow();
                }
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ åº”ç”¨å¤–è§‚å¼‚å¸¸:\n{ex.Message}";
                Debug.LogError($"[AppearanceTestModule] {ex}");
            }
        }

        /// <summary>
        /// å»¶è¿Ÿåº”ç”¨å¤–è§‚
        /// </summary>
        private System.Collections.IEnumerator ApplyAppearanceDelayed()
        {
            // ç­‰å¾… 2 å¸§
            yield return null;
            yield return null;

            ApplyAppearanceNow();
        }

        /// <summary>
        /// ç«‹å³åº”ç”¨å¤–è§‚
        /// </summary>
        private void ApplyAppearanceNow()
        {
            if (_testCharacter == null || _cachedAppearance == null)
            {
                _statusInfo = "âŒ æµ‹è¯•å•ä½æˆ–å¤–è§‚æ•°æ®ä¸ºç©º";
                return;
            }

            bool success = AppearanceConverter.ApplyAppearanceToCharacter(_testCharacter!, _cachedAppearance);
            if (success)
            {
                _statusInfo = "âœ… å¤–è§‚åº”ç”¨æˆåŠŸï¼";
            }
            else
            {
                _statusInfo = "âŒ å¤–è§‚åº”ç”¨å¤±è´¥\næŸ¥çœ‹æ—¥å¿—äº†è§£è¯¦æƒ…";
            }
        }

        /// <summary>
        /// ä¸€é”®åˆ›å»ºå¹¶å¤åˆ¶å¤–è§‚
        /// </summary>
        private void QuickCreateAndCopy()
        {
            try
            {
                // 1. è·å–å¤–è§‚
                CaptureLocalPlayerAppearance();
                if (_cachedAppearance == null)
                {
                    return;
                }

                // 2. åˆ›å»ºè§’è‰²
                CreateTestCharacter();
                if (_testCharacter == null)
                {
                    return;
                }

                // 3. åº”ç”¨å¤–è§‚
                ApplyAppearanceToTestCharacter();
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ ä¸€é”®åˆ›å»ºå¼‚å¸¸:\n{ex.Message}";
                Debug.LogError($"[AppearanceTestModule] {ex}");
            }
        }

        /// <summary>
        /// åˆ é™¤æµ‹è¯•å•ä½
        /// </summary>
        private void DestroyTestCharacter()
        {
            try
            {
                if (_testCharacter != null && _testCharacter is Component component)
                {
                    UnityEngine.Object.Destroy(component.gameObject);
                    _testCharacter = null;
                    _statusInfo = "âœ… æµ‹è¯•å•ä½å·²åˆ é™¤";
                }
            }
            catch (Exception ex)
            {
                _statusInfo = $"âŒ åˆ é™¤å¤±è´¥:\n{ex.Message}";
                Debug.LogError($"[AppearanceTestModule] {ex}");
            }
        }

        public void OnDisable()
        {
            // æ¨¡å—ç¦ç”¨æ—¶å¯é€‰æ‹©æ¸…ç†
        }

        public void OnEnable()
        {
            _statusInfo = "ä½¿ç”¨æ­¥éª¤:\n1. è·å–æœ¬åœ°ç©å®¶å¤–è§‚\n2. åˆ›å»ºæµ‹è¯•å•ä½\n3. åº”ç”¨å¤–è§‚\n\næˆ–ç›´æ¥ç‚¹å‡»ä¸€é”®æŒ‰é’®";
        }

        public void Update()
        {
            // ä¸éœ€è¦æ¯å¸§æ›´æ–°
        }
    }
}

```

`Client\Core\DebugModule\Modules\CharacterAppearanceDebugModule.cs`:

```cs
using System;
using System.Reflection;
using HarmonyLib;
using UnityEngine;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core.Utils;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// è§’è‰²å¤–è§‚è°ƒè¯•æ¨¡å—
    /// ç”¨äºæŸ¥çœ‹å’Œå¯¼å‡ºæœ¬åœ°ç©å®¶åŠè¿œç¨‹ç©å®¶çš„å¤–è§‚æ•°æ®
    /// </summary>
    public class CharacterAppearanceDebugModule : IDebugModule
    {
        private Vector2 _scrollPosition;
        private string _appearanceInfo = "";
        private bool _autoRefresh = false;
        private float _refreshTimer = 0f;
        private const float REFRESH_INTERVAL = 1f;
        private CharacterAppearanceData? _cachedAppearanceData = null;

        public string ModuleName => "è§’è‰²å¤–è§‚è°ƒè¯•";
        public string Category => "è§’è‰²";
        public string Description => "æŸ¥çœ‹ã€å¯¼å‡ºå’Œå¯¼å…¥è§’è‰²å¤–è§‚æ•°æ®";
        public bool IsEnabled { get; set; } = false;

        public void OnGUI()
        {
            if (!IsEnabled) return;

            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label("=== è§’è‰²å¤–è§‚è°ƒè¯• ===", GUI.skin.box);

            // æ§åˆ¶æŒ‰é’®
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("è·å–æœ¬åœ°ç©å®¶å¤–è§‚", GUILayout.Width(150)))
            {
                GetLocalPlayerAppearance();
            }
            
            if (GUILayout.Button("åº”ç”¨åˆ°æœ¬åœ°ç©å®¶", GUILayout.Width(130)))
            {
                ApplyToLocalPlayer();
            }
            
            if (GUILayout.Button("æ¸…ç©º", GUILayout.Width(80)))
            {
                _appearanceInfo = "";
                _cachedAppearanceData = null;
            }
            
            _autoRefresh = GUILayout.Toggle(_autoRefresh, "è‡ªåŠ¨åˆ·æ–°", GUILayout.Width(100));
            GUILayout.EndHorizontal();
            
            // æ•°æ®ä¿¡æ¯
            if (_cachedAppearanceData != null)
            {
                GUILayout.BeginHorizontal();
                GUILayout.Label($"å·²ç¼“å­˜æ•°æ®: {_cachedAppearanceData.ToBytes().Length} bytes", GUILayout.Width(200));
                if (GUILayout.Button("å¤åˆ¶ Base64", GUILayout.Width(100)))
                {
                    CopyToClipboard();
                }
                GUILayout.EndHorizontal();
            }

            // æ˜¾ç¤ºå¤–è§‚ä¿¡æ¯
            if (!string.IsNullOrEmpty(_appearanceInfo))
            {
                _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(400));
                GUILayout.TextArea(_appearanceInfo, GUILayout.ExpandHeight(true));
                GUILayout.EndScrollView();
            }

            GUILayout.EndVertical();
        }

        public void Update()
        {
            if (!IsEnabled || !_autoRefresh) return;

            _refreshTimer += Time.deltaTime;
            if (_refreshTimer >= REFRESH_INTERVAL)
            {
                _refreshTimer = 0f;
                GetLocalPlayerAppearance();
            }
        }

        /// <summary>
        /// è·å–æœ¬åœ°ç©å®¶å¤–è§‚æ•°æ®
        /// </summary>
        private void GetLocalPlayerAppearance()
        {
            try
            {
                _appearanceInfo = "æ­£åœ¨è·å–å¤–è§‚æ•°æ®...\n";

                // ä½¿ç”¨ AppearanceConverter è·å–
                _cachedAppearanceData = AppearanceConverter.LoadMainCharacterAppearance();
                
                if (_cachedAppearanceData != null)
                {
                    _appearanceInfo = "âœ… æˆåŠŸè·å–å¤–è§‚æ•°æ®\n";
                    _appearanceInfo += $"æ•°æ®å¤§å°: {_cachedAppearanceData.ToBytes().Length} bytes\n";
                    _appearanceInfo += $"éƒ¨ä½æ•°é‡: {_cachedAppearanceData.Parts.Length}\n\n";
                    
                    // æ˜¾ç¤ºç®€è¦ä¿¡æ¯
                    string[] partNames = { "å‘å‹", "çœ¼ç›", "çœ‰æ¯›", "å˜´å·´", "å°¾å·´", "è„š", "ç¿…è†€" };
                    foreach (var part in _cachedAppearanceData.Parts)
                    {
                        string name = part.PartType < partNames.Length ? partNames[part.PartType] : $"éƒ¨ä½{part.PartType}";
                        _appearanceInfo += $"- {name}: ID={part.PartId}\n";
                    }
                    return;
                }

                _appearanceInfo = "âŒ æ— æ³•è·å–å¤–è§‚æ•°æ®\n";
                _appearanceInfo += "- CharacterMainControl.Main å¯èƒ½ä¸ºç©º\n";
            }
            catch (Exception ex)
            {
                _appearanceInfo = $"âŒ è·å–å¤±è´¥: {ex.Message}\n";
                Debug.LogError($"[CharacterAppearanceDebugModule] å¼‚å¸¸: {ex}");
            }
        }

        /// <summary>
        /// åº”ç”¨å¤–è§‚åˆ°æœ¬åœ°ç©å®¶
        /// </summary>
        private void ApplyToLocalPlayer()
        {
            try
            {
                if (_cachedAppearanceData == null)
                {
                    _appearanceInfo += "\nâŒ è¯·å…ˆè·å–å¤–è§‚æ•°æ®\n";
                    return;
                }

                var character = CharacterMainControl.Main;
                if (character == null)
                {
                    _appearanceInfo += "\nâŒ CharacterMainControl.Main ä¸ºç©º\n";
                    return;
                }

                bool success = AppearanceConverter.ApplyAppearanceToCharacter(character, _cachedAppearanceData);
                if (success)
                {
                    _appearanceInfo += "\nâœ… æˆåŠŸåº”ç”¨å¤–è§‚ï¼\n";
                }
                else
                {
                    _appearanceInfo += "\nâŒ åº”ç”¨å¤±è´¥ï¼ŒæŸ¥çœ‹æ—¥å¿—\n";
                }
            }
            catch (Exception ex)
            {
                _appearanceInfo += $"\nâŒ åº”ç”¨å¤±è´¥: {ex.Message}\n";
                Debug.LogError($"[CharacterAppearanceDebugModule] å¼‚å¸¸: {ex}");
            }
        }

        /// <summary>
        /// å¤åˆ¶åˆ°å‰ªè´´æ¿
        /// </summary>
        private void CopyToClipboard()
        {
            try
            {
                if (_cachedAppearanceData == null)
                {
                    _appearanceInfo += "\nâŒ æ²¡æœ‰æ•°æ®\n";
                    return;
                }

                byte[] bytes = _cachedAppearanceData.ToBytes();
                string base64 = Convert.ToBase64String(bytes);
                GUIUtility.systemCopyBuffer = base64;
                
                _appearanceInfo += $"\nâœ… å·²å¤åˆ¶ (Base64, {base64.Length} å­—ç¬¦)\n";
            }
            catch (Exception ex)
            {
                _appearanceInfo += $"\nâŒ å¤åˆ¶å¤±è´¥: {ex.Message}\n";
            }
        }

        public void OnDestroy()
        {
            // æ¸…ç†èµ„æº
        }
    }
}

```

`Client\Core\DebugModule\Modules\CharacterPresetScannerModule.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using HarmonyLib;
using UnityEngine;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// è§’è‰²é¢„è®¾æ‰«ææ¨¡å—
    /// æ‰«ææ¸¸æˆä¸­æ‰€æœ‰çš„ CharacterRandomPreset å¹¶æå– CharacterModel ä¿¡æ¯
    /// </summary>
    public class CharacterPresetScannerModule : IDebugModule
    {
        private Vector2 _scrollPosition;
        private List<PresetInfo> _scannedPresets = new List<PresetInfo>();
        private List<ModelInfo> _scannedModels = new List<ModelInfo>();
        private bool _isScanned = false;
        private string _statusMessage = "";
        private int _selectedTab = 0; // 0=é¢„è®¾åˆ—è¡¨, 1=æ¨¡å‹åˆ—è¡¨
        private string _searchText = "";

        public string ModuleName => "è§’è‰²é¢„è®¾æ‰«æå™¨";
        public string Category => "è§’è‰²";
        public string Description => "æ‰«ææ‰€æœ‰ CharacterRandomPreset å¹¶æå– CharacterModel";
        public bool IsEnabled { get; set; } = false;

        public void OnGUI()
        {
            if (!IsEnabled) return;

            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label("=== è§’è‰²é¢„è®¾æ‰«æå™¨ ===", GUI.skin.box);

            // æ§åˆ¶æŒ‰é’®
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("æ‰«æè§’è‰²é¢„è®¾", GUILayout.Width(120)))
            {
                ScanCharacterPresets();
            }

            if (GUILayout.Button("æ¸…ç©ºç»“æœ", GUILayout.Width(100)))
            {
                ClearResults();
            }

            if (_isScanned)
            {
                GUILayout.Label($"é¢„è®¾: {_scannedPresets.Count} | æ¨¡å‹: {_scannedModels.Count}", GUILayout.Width(200));
            }
            GUILayout.EndHorizontal();

            // çŠ¶æ€æ¶ˆæ¯
            if (!string.IsNullOrEmpty(_statusMessage))
            {
                GUILayout.Label(_statusMessage);
            }

            // æœç´¢æ¡†
            if (_isScanned)
            {
                GUILayout.BeginHorizontal();
                GUILayout.Label("æœç´¢:", GUILayout.Width(50));
                _searchText = GUILayout.TextField(_searchText, GUILayout.Width(200));
                if (GUILayout.Button("æ¸…ç©º", GUILayout.Width(60)))
                {
                    _searchText = "";
                }
                GUILayout.EndHorizontal();
            }

            // æ ‡ç­¾é¡µ
            if (_isScanned)
            {
                GUILayout.BeginHorizontal();
                if (GUILayout.Toggle(_selectedTab == 0, $"é¢„è®¾åˆ—è¡¨ ({_scannedPresets.Count})", GUI.skin.button))
                {
                    _selectedTab = 0;
                }
                if (GUILayout.Toggle(_selectedTab == 1, $"æ¨¡å‹åˆ—è¡¨ ({_scannedModels.Count})", GUI.skin.button))
                {
                    _selectedTab = 1;
                }
                GUILayout.EndHorizontal();

                // æ˜¾ç¤ºåˆ—è¡¨
                _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(400));

                if (_selectedTab == 0)
                {
                    DisplayPresetList();
                }
                else if (_selectedTab == 1)
                {
                    DisplayModelList();
                }

                GUILayout.EndScrollView();
            }

            GUILayout.EndVertical();
        }

        public void Update()
        {
            // æš‚æ—¶ä¸éœ€è¦æ›´æ–°é€»è¾‘
        }

        /// <summary>
        /// æ‰«ææ‰€æœ‰è§’è‰²é¢„è®¾
        /// </summary>
        private void ScanCharacterPresets()
        {
            try
            {
                _statusMessage = "æ­£åœ¨æ‰«æ...";
                _scannedPresets.Clear();
                _scannedModels.Clear();
                _isScanned = false;

                // æŸ¥æ‰¾ CharacterRandomPreset ç±»å‹
                var presetType = AccessTools.TypeByName("CharacterRandomPreset");
                if (presetType == null)
                {
                    _statusMessage = "âŒ æœªæ‰¾åˆ° CharacterRandomPreset ç±»å‹";
                    Debug.LogError("[CharacterPresetScanner] æœªæ‰¾åˆ° CharacterRandomPreset ç±»å‹");
                    return;
                }

                // æ‰«ææ‰€æœ‰é¢„è®¾
                var allPresets = Resources.FindObjectsOfTypeAll(presetType);
                Debug.Log($"[CharacterPresetScanner] æ‰¾åˆ° {allPresets.Length} ä¸ªé¢„è®¾å¯¹è±¡");

                var modelSet = new HashSet<UnityEngine.Object>();
                var modelField = AccessTools.Field(presetType, "characterModel");

                if (modelField == null)
                {
                    _statusMessage = "âŒ æœªæ‰¾åˆ° characterModel å­—æ®µ";
                    Debug.LogError("[CharacterPresetScanner] æœªæ‰¾åˆ° characterModel å­—æ®µ");
                    return;
                }

                foreach (var preset in allPresets)
                {
                    if (preset == null) continue;

                    var presetName = (preset as UnityEngine.Object)?.name ?? "Unknown";
                    var model = modelField.GetValue(preset) as UnityEngine.Object;

                    // è®°å½•é¢„è®¾ä¿¡æ¯
                    var presetInfo = new PresetInfo
                    {
                        Name = presetName,
                        ModelName = model?.name ?? "null",
                        HasModel = model != null
                    };
                    _scannedPresets.Add(presetInfo);

                    // æ”¶é›†å”¯ä¸€çš„æ¨¡å‹
                    if (model != null && !modelSet.Contains(model))
                    {
                        modelSet.Add(model);
                        Debug.Log($"[CharacterPresetScanner] æ‰¾åˆ°æ¨¡å‹: {model.name} (æ¥è‡ªé¢„è®¾: {presetName})");
                    }
                }

                // è½¬æ¢ä¸ºæ¨¡å‹åˆ—è¡¨
                _scannedModels = modelSet
                    .Select(m => new ModelInfo
                    {
                        Name = m.name,
                        Type = m.GetType().Name,
                        InstanceID = m.GetInstanceID()
                    })
                    .OrderBy(m => m.Name)
                    .ToList();

                _statusMessage = $"âœ… æ‰«æå®Œæˆ: {_scannedPresets.Count} ä¸ªé¢„è®¾, {_scannedModels.Count} ä¸ªå”¯ä¸€æ¨¡å‹";
                _isScanned = true;

                Debug.Log($"[CharacterPresetScanner] æ‰«æå®Œæˆ: {_scannedPresets.Count} é¢„è®¾, {_scannedModels.Count} æ¨¡å‹");
            }
            catch (Exception ex)
            {
                _statusMessage = $"âŒ æ‰«æå¤±è´¥: {ex.Message}";
                Debug.LogError($"[CharacterPresetScanner] æ‰«æå¼‚å¸¸: {ex}");
            }
        }

        /// <summary>
        /// æ¸…ç©ºæ‰«æç»“æœ
        /// </summary>
        private void ClearResults()
        {
            _scannedPresets.Clear();
            _scannedModels.Clear();
            _isScanned = false;
            _statusMessage = "";
            _searchText = "";
        }

        /// <summary>
        /// æ˜¾ç¤ºé¢„è®¾åˆ—è¡¨
        /// </summary>
        private void DisplayPresetList()
        {
            GUILayout.Label($"=== é¢„è®¾åˆ—è¡¨ ({_scannedPresets.Count}) ===", GUI.skin.box);

            var filteredPresets = string.IsNullOrEmpty(_searchText)
                ? _scannedPresets
                : _scannedPresets.Where(p =>
                    p.Name.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0 ||
                    p.ModelName.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0
                ).ToList();

            if (filteredPresets.Count == 0)
            {
                GUILayout.Label("æ²¡æœ‰åŒ¹é…çš„é¢„è®¾");
                return;
            }

            foreach (var preset in filteredPresets)
            {
                GUILayout.BeginVertical(GUI.skin.box);
                GUILayout.BeginHorizontal();
                
                // å·¦ä¾§ï¼šé¢„è®¾ä¿¡æ¯
                GUILayout.BeginVertical();
                GUILayout.Label($"é¢„è®¾: {preset.Name}");
                GUILayout.Label($"  æ¨¡å‹: {preset.ModelName} {(preset.HasModel ? "âœ“" : "âœ—")}");
                GUILayout.EndVertical();
                
                GUILayout.FlexibleSpace();
                
                // å³ä¾§ï¼šæ“ä½œæŒ‰é’®
                if (GUILayout.Button("åˆ›å»º NPC", GUILayout.Width(80)))
                {
                    CreateNPCFromPreset(preset.Name);
                }
                
                GUILayout.EndHorizontal();
                GUILayout.EndVertical();
                GUILayout.Space(2);
            }
        }

        /// <summary>
        /// æ˜¾ç¤ºæ¨¡å‹åˆ—è¡¨
        /// </summary>
        private void DisplayModelList()
        {
            GUILayout.Label($"=== æ¨¡å‹åˆ—è¡¨ ({_scannedModels.Count}) ===", GUI.skin.box);

            var filteredModels = string.IsNullOrEmpty(_searchText)
                ? _scannedModels
                : _scannedModels.Where(m =>
                    m.Name.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0 ||
                    m.Type.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0
                ).ToList();

            if (filteredModels.Count == 0)
            {
                GUILayout.Label("æ²¡æœ‰åŒ¹é…çš„æ¨¡å‹");
                return;
            }

            foreach (var model in filteredModels)
            {
                GUILayout.BeginVertical(GUI.skin.box);
                GUILayout.Label($"æ¨¡å‹: {model.Name}");
                GUILayout.Label($"  ç±»å‹: {model.Type}");
                GUILayout.Label($"  å®ä¾‹ID: {model.InstanceID}");
                
                // ç»Ÿè®¡ä½¿ç”¨æ­¤æ¨¡å‹çš„é¢„è®¾æ•°é‡
                int usageCount = _scannedPresets.Count(p => p.ModelName == model.Name);
                GUILayout.Label($"  ä½¿ç”¨æ¬¡æ•°: {usageCount}");
                
                GUILayout.EndVertical();
                GUILayout.Space(2);
            }
        }

        /// <summary>
        /// ä½¿ç”¨æŒ‡å®šé¢„è®¾åˆ›å»º NPC
        /// </summary>
        private void CreateNPCFromPreset(string presetName)
        {
            try
            {
                _statusMessage = $"æ­£åœ¨åˆ›å»º NPC: {presetName}...";
                
                // 1. æŸ¥æ‰¾é¢„è®¾ç±»å‹
                var presetType = AccessTools.TypeByName("CharacterRandomPreset");
                if (presetType == null)
                {
                    _statusMessage = "âŒ æœªæ‰¾åˆ° CharacterRandomPreset ç±»å‹";
                    Debug.LogError("[CharacterPresetScanner] æœªæ‰¾åˆ° CharacterRandomPreset ç±»å‹");
                    return;
                }

                // 2. æŸ¥æ‰¾æŒ‡å®šåç§°çš„é¢„è®¾
                var allPresets = Resources.FindObjectsOfTypeAll(presetType);
                object? targetPreset = null;
                
                foreach (var preset in allPresets)
                {
                    if ((preset as UnityEngine.Object)?.name == presetName)
                    {
                        targetPreset = preset;
                        break;
                    }
                }

                if (targetPreset == null)
                {
                    _statusMessage = $"âŒ æœªæ‰¾åˆ°é¢„è®¾: {presetName}";
                    Debug.LogError($"[CharacterPresetScanner] æœªæ‰¾åˆ°é¢„è®¾: {presetName}");
                    return;
                }

                // 3. è°ƒç”¨ CreateCharacterAsync æ–¹æ³•
                var createMethod = AccessTools.Method(presetType, "CreateCharacterAsync");
                if (createMethod == null)
                {
                    _statusMessage = "âŒ æœªæ‰¾åˆ° CreateCharacterAsync æ–¹æ³•";
                    Debug.LogError("[CharacterPresetScanner] æœªæ‰¾åˆ° CreateCharacterAsync æ–¹æ³•");
                    return;
                }

                // 4. è®¡ç®—ç”Ÿæˆä½ç½®ï¼ˆåœ¨ç©å®¶å‰æ–¹ 5 ç±³å¤„ï¼‰
                var playerPos = GetPlayerPosition();
                var playerForward = GetPlayerForward();
                var spawnPos = playerPos + playerForward * 5f;

                // 5. å‡†å¤‡å‚æ•°
                Vector3 direction = playerForward;
                int relatedScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene().buildIndex;
                object? group = null; // CharacterSpawnerGroupï¼Œå¯é€‰
                bool isLeader = false;

                Debug.Log($"[CharacterPresetScanner] å¼€å§‹åˆ›å»º NPC: {presetName} at {spawnPos}");

                // 6. è°ƒç”¨åˆ›å»ºæ–¹æ³•ï¼ˆå¼‚æ­¥æ–¹æ³•ä¼šåœ¨åå°æ‰§è¡Œï¼‰
                object? createTask = createMethod.Invoke(targetPreset, new object?[] 
                { 
                    spawnPos, 
                    direction, 
                    relatedScene, 
                    group, 
                    isLeader 
                });

                // 7. åˆ›å»ºä»»åŠ¡å·²æäº¤
                if (createTask != null)
                {
                    _statusMessage = $"âœ… å·²æäº¤åˆ›å»ºè¯·æ±‚: {presetName}";
                    Debug.Log($"[CharacterPresetScanner] âœ… å·²æäº¤åˆ›å»º NPC è¯·æ±‚: {presetName}");
                }
                else
                {
                    _statusMessage = $"âš ï¸ åˆ›å»ºä»»åŠ¡è¿”å›ä¸ºç©º: {presetName}";
                    Debug.LogWarning($"[CharacterPresetScanner] åˆ›å»ºä»»åŠ¡è¿”å›ä¸ºç©º: {presetName}");
                }
            }
            catch (Exception ex)
            {
                _statusMessage = $"âŒ åˆ›å»ºå¤±è´¥: {ex.Message}";
                Debug.LogError($"[CharacterPresetScanner] åˆ›å»º NPC å¤±è´¥: {ex}");
            }
        }

        /// <summary>
        /// è·å–ç©å®¶ä½ç½®
        /// </summary>
        private Vector3 GetPlayerPosition()
        {
            try
            {
                // å°è¯•é€šè¿‡ LevelManager è·å–ä¸»è§’ä½ç½®
                var levelManagerType = AccessTools.TypeByName("LevelManager");
                if (levelManagerType != null)
                {
                    var instanceProp = AccessTools.Property(levelManagerType, "Instance");
                    var levelManager = instanceProp?.GetValue(null);
                    
                    if (levelManager != null)
                    {
                        var mainCharProp = AccessTools.Property(levelManagerType, "MainCharacter");
                        var mainChar = mainCharProp?.GetValue(levelManager);
                        
                        if (mainChar is Component component)
                        {
                            return component.transform.position;
                        }
                    }
                }

                // å¤‡é€‰æ–¹æ¡ˆï¼šå°è¯•æŸ¥æ‰¾ CharacterMainControl
                var mainControlType = AccessTools.TypeByName("CharacterMainControl");
                if (mainControlType != null)
                {
                    var mainProp = AccessTools.Property(mainControlType, "Main");
                    var mainControl = mainProp?.GetValue(null);
                    
                    if (mainControl is Component component)
                    {
                        return component.transform.position;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[CharacterPresetScanner] è·å–ç©å®¶ä½ç½®å¤±è´¥: {ex.Message}");
            }
            
            return Vector3.zero;
        }

        /// <summary>
        /// è·å–ç©å®¶æœå‘
        /// </summary>
        private Vector3 GetPlayerForward()
        {
            try
            {
                // å°è¯•é€šè¿‡ LevelManager è·å–ä¸»è§’æœå‘
                var levelManagerType = AccessTools.TypeByName("LevelManager");
                if (levelManagerType != null)
                {
                    var instanceProp = AccessTools.Property(levelManagerType, "Instance");
                    var levelManager = instanceProp?.GetValue(null);
                    
                    if (levelManager != null)
                    {
                        var mainCharProp = AccessTools.Property(levelManagerType, "MainCharacter");
                        var mainChar = mainCharProp?.GetValue(levelManager);
                        
                        if (mainChar is Component component)
                        {
                            return component.transform.forward;
                        }
                    }
                }

                // å¤‡é€‰æ–¹æ¡ˆï¼šå°è¯•æŸ¥æ‰¾ CharacterMainControl
                var mainControlType = AccessTools.TypeByName("CharacterMainControl");
                if (mainControlType != null)
                {
                    var mainProp = AccessTools.Property(mainControlType, "Main");
                    var mainControl = mainProp?.GetValue(null);
                    
                    if (mainControl is Component component)
                    {
                        return component.transform.forward;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[CharacterPresetScanner] è·å–ç©å®¶æœå‘å¤±è´¥: {ex.Message}");
            }
            
            return Vector3.forward;
        }

        /// <summary>
        /// é¢„è®¾ä¿¡æ¯æ•°æ®ç»“æ„
        /// </summary>
        private class PresetInfo
        {
            public string Name { get; set; } = "";
            public string ModelName { get; set; } = "";
            public bool HasModel { get; set; }
        }

        /// <summary>
        /// æ¨¡å‹ä¿¡æ¯æ•°æ®ç»“æ„
        /// </summary>
        private class ModelInfo
        {
            public string Name { get; set; } = "";
            public string Type { get; set; } = "";
            public int InstanceID { get; set; }
        }
    }
}


```

`Client\Core\DebugModule\Modules\EquipmentSyncDebugModule.cs`:

```cs
using System;
using System.Collections.Generic;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Client.Core.Utils;
using DuckyNet.Shared.Data;
using ItemStatsSystem;
using ItemStatsSystem.Items;
using UnityEngine;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// è£…å¤‡åŒæ­¥è°ƒè¯•æ¨¡å—
    /// åŠŸèƒ½ï¼šåˆ›å»ºæµ‹è¯•å•ä½å¹¶å®æ—¶åŒæ­¥æœ¬åœ°ç©å®¶çš„è£…å¤‡å˜æ›´
    /// </summary>
    public class EquipmentSyncDebugModule : IDebugModule
    {
        public string ModuleName => "è£…å¤‡åŒæ­¥æµ‹è¯•";
        public string Category => "æµ‹è¯•";
        public string Description => "åˆ›å»ºæµ‹è¯•å•ä½å¹¶å®æ—¶åŒæ­¥æœ¬åœ°ç©å®¶çš„è£…å¤‡å˜æ›´";
        public bool IsEnabled { get; set; } = true;

        // æµ‹è¯•å•ä½åˆ—è¡¨
        private readonly List<TestCharacter> _testCharacters = new List<TestCharacter>();
        private int _nextCharacterId = 1;

        // è£…å¤‡åŒæ­¥å¼€å…³
        private bool _autoSyncEnabled = true;
        private bool _showEquipmentInfo = true;

        // UI çŠ¶æ€
        private Vector2 _scrollPosition;
        private bool _showCreateOptions = false;
        
        // åˆ›å»ºé€‰é¡¹
        private int _spawnDistance = 3;
        private bool _syncOnCreate = true;
        private bool _includeArmor = true;
        private bool _includeHelmet = true;
        private bool _includeFaceMask = true;
        private bool _includeBackpack = true;
        private bool _includeHeadset = true;

        // å»¶è¿ŸåŒæ­¥
        private TestCharacter? _pendingSyncCharacter = null;
        private float _syncDelay = 0f;

        // äº‹ä»¶è®¢é˜…æ ‡å¿—
        private bool _isEventSubscribed = false;

        public EquipmentSyncDebugModule()
        {
            // å°è¯•è®¢é˜…è£…å¤‡å˜æ›´äº‹ä»¶
            TrySubscribeToEvents();
        }

        public void Update()
        {
            // å°è¯•è®¢é˜…äº‹ä»¶ï¼ˆå¦‚æœè¿˜æœªè®¢é˜…ï¼‰
            if (!_isEventSubscribed)
            {
                TrySubscribeToEvents();
            }

            // å¤„ç†å»¶è¿ŸåŒæ­¥
            if (_pendingSyncCharacter != null && _syncDelay > 0f)
            {
                _syncDelay -= Time.deltaTime;
                if (_syncDelay <= 0f)
                {
                    SyncCharacterEquipment(_pendingSyncCharacter);
                    _pendingSyncCharacter = null;
                }
            }
        }

        /// <summary>
        /// å°è¯•è®¢é˜…è£…å¤‡å˜æ›´äº‹ä»¶
        /// </summary>
        private void TrySubscribeToEvents()
        {
            if (_isEventSubscribed) return;

            if (GameContext.IsInitialized && GameContext.Instance?.EventBus != null)
            {
                try
                {
                    GameContext.Instance.EventBus.Subscribe<EquipmentSlotChangedEvent>(OnLocalPlayerEquipmentChanged);
                    _isEventSubscribed = true;
                    Debug.Log("[EquipmentSyncDebugModule] âœ… å·²è®¢é˜…è£…å¤‡å˜æ›´äº‹ä»¶");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[EquipmentSyncDebugModule] è®¢é˜…äº‹ä»¶å¤±è´¥: {ex.Message}");
                }
            }
        }

        public void OnGUI()
        {
            GUILayout.Label("=== è£…å¤‡åŒæ­¥æµ‹è¯•å·¥å…· ===", GUI.skin.box);
            
            // å…¨å±€æ§åˆ¶
            DrawGlobalControls();
            
            GUILayout.Space(10);
            
            // åˆ›å»ºæµ‹è¯•å•ä½
            DrawCreateSection();
            
            GUILayout.Space(10);
            
            // æµ‹è¯•å•ä½åˆ—è¡¨
            DrawCharactersList();
        }

        #region UI ç»˜åˆ¶

        private void DrawGlobalControls()
        {
            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label("ğŸ® å…¨å±€æ§åˆ¶", GUI.skin.label);

            // äº‹ä»¶è®¢é˜…çŠ¶æ€
            string eventStatus = _isEventSubscribed ? "âœ… äº‹ä»¶å·²è®¢é˜…" : "âš ï¸ äº‹ä»¶æœªè®¢é˜…";
            GUILayout.Label(eventStatus, GUI.skin.label);

            GUILayout.BeginHorizontal();
            _autoSyncEnabled = GUILayout.Toggle(_autoSyncEnabled, " è‡ªåŠ¨åŒæ­¥è£…å¤‡å˜æ›´");
            _showEquipmentInfo = GUILayout.Toggle(_showEquipmentInfo, " æ˜¾ç¤ºè£…å¤‡è¯¦æƒ…");
            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            if (GUILayout.Button("ğŸ”„ åŒæ­¥æ‰€æœ‰å•ä½", GUILayout.Height(30)))
            {
                SyncAllCharacters();
            }
            if (GUILayout.Button("ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰å•ä½", GUILayout.Height(30)))
            {
                ClearAllCharacters();
            }
            GUILayout.EndHorizontal();

            // æµ‹è¯•æŒ‰é’®
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("ğŸ§ª æµ‹è¯•å¸ä¸‹æŠ¤ç”²", GUILayout.Height(25)))
            {
                TestUnequipArmor();
            }
            if (GUILayout.Button("ğŸ§ª æµ‹è¯•æ¸…ç©ºè£…å¤‡", GUILayout.Height(25)))
            {
                TestClearEquipment();
            }
            GUILayout.EndHorizontal();

            // ç»Ÿè®¡ä¿¡æ¯
            var mainChar = LevelManager.Instance?.MainCharacter;
            if (mainChar != null)
            {
                GUILayout.Label($"ğŸ“Š ç»Ÿè®¡: æµ‹è¯•å•ä½={_testCharacters.Count}, æœ¬åœ°ç©å®¶è£…å¤‡={CountEquippedSlots(mainChar.CharacterItem)}");
            }

            GUILayout.EndVertical();
        }

        private void DrawCreateSection()
        {
            GUILayout.BeginVertical(GUI.skin.box);
            
            GUILayout.BeginHorizontal();
            GUILayout.Label("â• åˆ›å»ºæµ‹è¯•å•ä½", GUI.skin.label);
            _showCreateOptions = GUILayout.Toggle(_showCreateOptions, _showCreateOptions ? "â–¼" : "â–¶", GUILayout.Width(30));
            GUILayout.EndHorizontal();

            if (_showCreateOptions)
            {
                GUILayout.BeginVertical(GUI.skin.box);
                
                // ç”Ÿæˆè·ç¦»
                GUILayout.BeginHorizontal();
                GUILayout.Label("ç”Ÿæˆè·ç¦»:", GUILayout.Width(80));
                _spawnDistance = (int)GUILayout.HorizontalSlider(_spawnDistance, 1, 10, GUILayout.Width(100));
                GUILayout.Label($"{_spawnDistance}m", GUILayout.Width(50));
                GUILayout.EndHorizontal();

                // åŒæ­¥é€‰é¡¹
                _syncOnCreate = GUILayout.Toggle(_syncOnCreate, " åˆ›å»ºæ—¶ç«‹å³åŒæ­¥è£…å¤‡");

                if (_syncOnCreate)
                {
                    GUILayout.Label("  åŒæ­¥æ§½ä½:");
                    GUILayout.BeginHorizontal();
                    _includeArmor = GUILayout.Toggle(_includeArmor, "æŠ¤ç”²");
                    _includeHelmet = GUILayout.Toggle(_includeHelmet, "å¤´ç›”");
                    _includeFaceMask = GUILayout.Toggle(_includeFaceMask, "é¢ç½©");
                    GUILayout.EndHorizontal();
                    GUILayout.BeginHorizontal();
                    _includeBackpack = GUILayout.Toggle(_includeBackpack, "èƒŒåŒ…");
                    _includeHeadset = GUILayout.Toggle(_includeHeadset, "è€³æœº");
                    GUILayout.EndHorizontal();
                }

                GUILayout.EndVertical();
            }

            // åˆ›å»ºæŒ‰é’®
            if (GUILayout.Button("ğŸ­ åˆ›å»ºæµ‹è¯•å•ä½", GUILayout.Height(35)))
            {
                CreateTestCharacter(CharacterType.MeleeAI);
            }

            GUILayout.EndVertical();
        }

        private void DrawCharactersList()
        {
            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label($"ğŸ‘¥ æµ‹è¯•å•ä½åˆ—è¡¨ ({_testCharacters.Count})", GUI.skin.label);

            if (_testCharacters.Count == 0)
            {
                GUILayout.Label("  æš‚æ— æµ‹è¯•å•ä½", GUI.skin.label);
            }
            else
            {
                _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, GUILayout.MaxHeight(300));

                for (int i = _testCharacters.Count - 1; i >= 0; i--)
                {
                    var testChar = _testCharacters[i];
                    
                    // æ£€æŸ¥å•ä½æ˜¯å¦è¿˜å­˜åœ¨
                    if (testChar.GameObject == null)
                    {
                        _testCharacters.RemoveAt(i);
                        continue;
                    }

                    DrawCharacterItem(testChar);
                    GUILayout.Space(5);
                }

                GUILayout.EndScrollView();
            }

            GUILayout.EndVertical();
        }

        private void DrawCharacterItem(TestCharacter testChar)
        {
            GUILayout.BeginVertical(GUI.skin.box);

            // æ ‡é¢˜è¡Œ
            GUILayout.BeginHorizontal();
            GUILayout.Label($"ğŸ¤– #{testChar.Id} - {testChar.Name}", GUI.skin.label);
            
            if (GUILayout.Button("ğŸ”„", GUILayout.Width(30)))
            {
                SyncCharacterEquipment(testChar);
            }
            if (GUILayout.Button("ğŸ—‘ï¸", GUILayout.Width(30)))
            {
                RemoveTestCharacter(testChar);
            }
            GUILayout.EndHorizontal();

            // ä½ç½®ä¿¡æ¯
            if (testChar.GameObject != null)
            {
                var pos = testChar.GameObject.transform.position;
                GUILayout.Label($"  ä½ç½®: ({pos.x:F1}, {pos.y:F1}, {pos.z:F1})", GUI.skin.label);
            }

            // è£…å¤‡ä¿¡æ¯
            if (_showEquipmentInfo && testChar.CharacterItem != null)
            {
                DrawEquipmentInfo(testChar.CharacterItem);
            }

            GUILayout.EndVertical();
        }

        private void DrawEquipmentInfo(Item characterItem)
        {
            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label("  è£…å¤‡:", GUI.skin.label);

            DrawSlotInfo("æŠ¤ç”²", characterItem, CharacterEquipmentController.armorHash);
            DrawSlotInfo("å¤´ç›”", characterItem, CharacterEquipmentController.helmatHash);
            DrawSlotInfo("é¢ç½©", characterItem, CharacterEquipmentController.faceMaskHash);
            DrawSlotInfo("èƒŒåŒ…", characterItem, CharacterEquipmentController.backpackHash);
            DrawSlotInfo("è€³æœº", characterItem, CharacterEquipmentController.headsetHash);

            GUILayout.EndVertical();
        }

        private void DrawSlotInfo(string slotName, Item characterItem, int slotHash)
        {
            var slot = characterItem.Slots.GetSlot(slotHash);
            string itemName = slot?.Content?.DisplayName ?? "æ— ";
            GUILayout.Label($"    {slotName}: {itemName}", GUI.skin.label);
        }

        #endregion

        #region æ ¸å¿ƒåŠŸèƒ½

        /// <summary>
        /// åˆ›å»ºæµ‹è¯•å•ä½ï¼ˆä½¿ç”¨ CharacterCreationUtils å·¥å…·ç±»ï¼‰
        /// </summary>
        private void CreateTestCharacter(CharacterType type)
        {
            try
            {
                var mainChar = LevelManager.Instance?.MainCharacter;
                if (mainChar == null)
                {
                    Debug.LogError("[EquipmentSyncDebugModule] ä¸»è§’è‰²æœªæ‰¾åˆ°");
                    return;
                }

                // è®¡ç®—ç”Ÿæˆä½ç½®ï¼ˆç©å®¶å‰æ–¹ï¼‰
                Vector3 spawnPos = mainChar.transform.position + mainChar.transform.forward * _spawnDistance;

                Debug.Log("[EquipmentSyncDebugModule] â³ æ­£åœ¨åˆ›å»ºæµ‹è¯•å•ä½...");

                // 1. åˆ›å»ºè§’è‰²æ•°æ®é¡¹
                var characterItem = CharacterCreationUtils.CreateCharacterItem();
                if (characterItem == null)
                {
                    Debug.LogError("[EquipmentSyncDebugModule] åˆ›å»ºè§’è‰²æ•°æ®é¡¹å¤±è´¥");
                    return;
                }

                // 2. è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“
                var modelPrefab = CharacterCreationUtils.GetCharacterModelPrefab();
                if (modelPrefab == null)
                {
                    Debug.LogError("[EquipmentSyncDebugModule] è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“å¤±è´¥");
                    return;
                }

                // 3. å®ä¾‹åŒ–è§’è‰²
                var newCharacter = CharacterCreationUtils.CreateCharacterInstance(
                    characterItem, 
                    modelPrefab, 
                    spawnPos, 
                    Quaternion.identity
                );
                if (newCharacter == null)
                {
                    Debug.LogError("[EquipmentSyncDebugModule] å®ä¾‹åŒ–è§’è‰²å¤±è´¥");
                    return;
                }

                // 4. é…ç½®è§’è‰²
                string testCharName = $"è£…å¤‡æµ‹è¯•-{_nextCharacterId}";
                CharacterCreationUtils.ConfigureCharacter(newCharacter, testCharName, spawnPos, team: 0);
                CharacterCreationUtils.ConfigureCharacterPreset(newCharacter, testCharName, showName: true);

                // 5. æ ‡è®°ä¸ºè¿œç¨‹ç©å®¶ï¼ˆç¦ç”¨è¾“å…¥æ§åˆ¶ï¼‰
                CharacterCreationUtils.MarkAsRemotePlayer(newCharacter);

                // 6. ä»è·ç¦»ç³»ç»Ÿç§»é™¤ï¼ˆé¿å…è¢«è‡ªåŠ¨æ¸…ç†ï¼‰
                CharacterCreationUtils.UnregisterFromDistanceSystem(newCharacter);

                // 7. è¯·æ±‚è¡€æ¡
                CharacterCreationUtils.RequestHealthBar(newCharacter, testCharName, null);

                // 8. è·å– GameObject
                GameObject? characterObj = null;
                if (newCharacter is Component component)
                {
                    characterObj = component.gameObject;
                }

                if (characterObj == null)
                {
                    Debug.LogError("[EquipmentSyncDebugModule] æ— æ³•è·å–è§’è‰² GameObject");
                    return;
                }

                // åˆ›å»ºæµ‹è¯•å•ä½è®°å½•
                var testChar = new TestCharacter
                {
                    Id = _nextCharacterId++,
                    Name = testCharName,
                    GameObject = characterObj,
                    CharacterMainControl = newCharacter as CharacterMainControl,
                    CharacterItem = characterItem as Item,
                    CreatedTime = DateTime.Now
                };

                _testCharacters.Add(testChar);

                Debug.Log($"[EquipmentSyncDebugModule] âœ… åˆ›å»ºæµ‹è¯•å•ä½æˆåŠŸ: {testChar.Name} at {spawnPos}");

                // å¦‚æœå¯ç”¨åˆ›å»ºæ—¶åŒæ­¥ï¼Œè®¾ç½®å»¶è¿ŸåŒæ­¥
                if (_syncOnCreate)
                {
                    _pendingSyncCharacter = testChar;
                    _syncDelay = 0.5f; // å»¶è¿Ÿ0.5ç§’åŒæ­¥
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentSyncDebugModule] åˆ›å»ºæµ‹è¯•å•ä½å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// åŒæ­¥å•ä¸ªè§’è‰²çš„è£…å¤‡
        /// </summary>
        private void SyncCharacterEquipment(TestCharacter testChar)
        {
            if (testChar == null || testChar.CharacterItem == null)
            {
                Debug.LogWarning("[EquipmentSyncDebugModule] æµ‹è¯•è§’è‰²æ— æ•ˆ");
                return;
            }

            var mainChar = LevelManager.Instance?.MainCharacter;
            if (mainChar == null || mainChar.CharacterItem == null)
            {
                Debug.LogError("[EquipmentSyncDebugModule] ä¸»è§’è‰²æœªæ‰¾åˆ°");
                return;
            }

            Debug.Log($"[EquipmentSyncDebugModule] å¼€å§‹åŒæ­¥è£…å¤‡: {testChar.Name}");

            int count = EquipmentTools.CopyAllEquipment(
                mainChar.CharacterItem,
                testChar.CharacterItem,
                _includeArmor,
                _includeHelmet,
                _includeFaceMask,
                _includeBackpack,
                _includeHeadset
            );

            Debug.Log($"[EquipmentSyncDebugModule] âœ… åŒæ­¥å®Œæˆ: {testChar.Name}, è£…å¤‡æ•°={count}");
        }

        /// <summary>
        /// åŒæ­¥æ‰€æœ‰æµ‹è¯•å•ä½çš„è£…å¤‡
        /// </summary>
        private void SyncAllCharacters()
        {
            Debug.Log($"[EquipmentSyncDebugModule] å¼€å§‹åŒæ­¥æ‰€æœ‰å•ä½: å…±{_testCharacters.Count}ä¸ª");

            int successCount = 0;
            foreach (var testChar in _testCharacters)
            {
                if (testChar.GameObject != null)
                {
                    SyncCharacterEquipment(testChar);
                    successCount++;
                }
            }

            Debug.Log($"[EquipmentSyncDebugModule] âœ… å…¨éƒ¨åŒæ­¥å®Œæˆ: {successCount}/{_testCharacters.Count}");
        }

        /// <summary>
        /// ç§»é™¤æµ‹è¯•å•ä½
        /// </summary>
        private void RemoveTestCharacter(TestCharacter testChar)
        {
            if (testChar.GameObject != null)
            {
                UnityEngine.Object.Destroy(testChar.GameObject);
            }
            _testCharacters.Remove(testChar);
            Debug.Log($"[EquipmentSyncDebugModule] ç§»é™¤æµ‹è¯•å•ä½: {testChar.Name}");
        }

        /// <summary>
        /// æ¸…é™¤æ‰€æœ‰æµ‹è¯•å•ä½
        /// </summary>
        private void ClearAllCharacters()
        {
            foreach (var testChar in _testCharacters)
            {
                if (testChar.GameObject != null)
                {
                    UnityEngine.Object.Destroy(testChar.GameObject);
                }
            }
            _testCharacters.Clear();
            Debug.Log("[EquipmentSyncDebugModule] å·²æ¸…é™¤æ‰€æœ‰æµ‹è¯•å•ä½");
        }

        /// <summary>
        /// æœ¬åœ°ç©å®¶è£…å¤‡å˜æ›´äº‹ä»¶å¤„ç†
        /// </summary>
        private void OnLocalPlayerEquipmentChanged(EquipmentSlotChangedEvent evt)
        {
            if (!_autoSyncEnabled) return;

            try
            {
                string action = evt.IsEquipped ? "è£…å¤‡" : "å¸ä¸‹";
                string itemName = "æ— ";
                
                if (evt.EquippedItem is UnityEngine.Object unityObj)
                {
                    itemName = unityObj.name;
                }

                Debug.Log($"[EquipmentSyncDebugModule] ğŸ¯ æ£€æµ‹åˆ°è£…å¤‡å˜æ›´: {evt.SlotType} - {action} - {itemName}");

                // åŒæ­¥åˆ°æ‰€æœ‰æµ‹è¯•å•ä½
                SyncSlotToAllCharacters(evt.SlotType, evt.EquippedItem as Item);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentSyncDebugModule] å¤„ç†è£…å¤‡å˜æ›´å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å°†ç‰¹å®šæ§½ä½åŒæ­¥åˆ°æ‰€æœ‰æµ‹è¯•å•ä½
        /// </summary>
        private void SyncSlotToAllCharacters(EquipmentSlotType slotType, Item? equippedItem)
        {
            if (_testCharacters.Count == 0) return;

            int slotHash = GetSlotHash(slotType);
            if (slotHash == 0) return;

            foreach (var testChar in _testCharacters)
            {
                if (testChar.GameObject == null || testChar.CharacterItem == null) continue;

                try
                {
                    var targetSlot = testChar.CharacterItem.Slots.GetSlot(slotHash);
                    if (targetSlot == null) continue;

                    if (equippedItem != null)
                    {
                        // è£…å¤‡äº†æ–°ç‰©å“ - å¤åˆ¶
                        Debug.Log($"[EquipmentSyncDebugModule] åŒæ­¥è£…å¤‡: {slotType} -> {equippedItem.DisplayName}");
                        
                        bool success = EquipmentTools.CreateAndEquip(
                            equippedItem.TypeID,
                            targetSlot,
                            unpluggedItem => 
                            {
                                Debug.Log($"[EquipmentSyncDebugModule] é”€æ¯æ—§è£…å¤‡: {unpluggedItem.DisplayName}");
                                unpluggedItem.DestroyTree();
                            }
                        );
                        
                        if (!success)
                        {
                            Debug.LogWarning($"[EquipmentSyncDebugModule] è£…å¤‡å¤±è´¥: {slotType}");
                        }
                    }
                    else
                    {
                        // å¸ä¸‹è£…å¤‡ - æ¸…ç©ºæ§½ä½
                        if (targetSlot.Content != null)
                        {
                            Debug.Log($"[EquipmentSyncDebugModule] å¸ä¸‹è£…å¤‡: {slotType} - {targetSlot.Content.DisplayName}");
                            
                            Item removedItem = targetSlot.Unplug();
                            if (removedItem != null)
                            {
                                removedItem.DestroyTree();
                                Debug.Log($"[EquipmentSyncDebugModule] âœ… å·²å¸ä¸‹å¹¶é”€æ¯è£…å¤‡");
                            }
                        }
                        else
                        {
                            Debug.Log($"[EquipmentSyncDebugModule] æ§½ä½ {slotType} å·²ç»ä¸ºç©ºï¼Œæ— éœ€å¸ä¸‹");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[EquipmentSyncDebugModule] åŒæ­¥æ§½ä½å¤±è´¥: {ex.Message}");
                }
            }
        }

        #endregion

        #region æµ‹è¯•æ–¹æ³•

        /// <summary>
        /// æµ‹è¯•å¸ä¸‹æ‰€æœ‰æµ‹è¯•å•ä½çš„æŠ¤ç”²
        /// </summary>
        private void TestUnequipArmor()
        {
            Debug.Log("[EquipmentSyncDebugModule] ğŸ§ª å¼€å§‹æµ‹è¯•å¸ä¸‹æŠ¤ç”²...");
            
            foreach (var testChar in _testCharacters)
            {
                if (testChar.CharacterItem != null)
                {
                    var armorSlot = testChar.CharacterItem.Slots.GetSlot(CharacterEquipmentController.armorHash);
                    if (armorSlot?.Content != null)
                    {
                        Debug.Log($"[EquipmentSyncDebugModule] å¸ä¸‹ {testChar.Name} çš„æŠ¤ç”²: {armorSlot.Content.DisplayName}");
                        Item removed = armorSlot.Unplug();
                        if (removed != null)
                        {
                            removed.DestroyTree();
                        }
                    }
                }
            }
        }

        /// <summary>
        /// æµ‹è¯•æ¸…ç©ºæ‰€æœ‰æµ‹è¯•å•ä½çš„è£…å¤‡
        /// </summary>
        private void TestClearEquipment()
        {
            Debug.Log("[EquipmentSyncDebugModule] ğŸ§ª å¼€å§‹æµ‹è¯•æ¸…ç©ºè£…å¤‡...");
            
            foreach (var testChar in _testCharacters)
            {
                if (testChar.CharacterItem != null)
                {
                    int count = EquipmentTools.ClearAllEquipment(testChar.CharacterItem, destroyItems: true);
                    Debug.Log($"[EquipmentSyncDebugModule] å·²æ¸…ç©º {testChar.Name} çš„ {count} ä»¶è£…å¤‡");
                }
            }
        }

        #endregion

        #region è¾…åŠ©æ–¹æ³•

        private int GetSlotHash(EquipmentSlotType slotType)
        {
            return slotType switch
            {
                EquipmentSlotType.Armor => CharacterEquipmentController.armorHash,
                EquipmentSlotType.Helmet => CharacterEquipmentController.helmatHash,
                EquipmentSlotType.FaceMask => CharacterEquipmentController.faceMaskHash,
                EquipmentSlotType.Backpack => CharacterEquipmentController.backpackHash,
                EquipmentSlotType.Headset => CharacterEquipmentController.headsetHash,
                _ => 0
            };
        }

        private int CountEquippedSlots(Item characterItem)
        {
            if (characterItem == null) return 0;

            int count = 0;
            int[] slotHashes = new[]
            {
                CharacterEquipmentController.armorHash,
                CharacterEquipmentController.helmatHash,
                CharacterEquipmentController.faceMaskHash,
                CharacterEquipmentController.backpackHash,
                CharacterEquipmentController.headsetHash
            };

            foreach (var hash in slotHashes)
            {
                var slot = characterItem.Slots.GetSlot(hash);
                if (slot?.Content != null) count++;
            }

            return count;
        }

        #endregion

        #region å†…éƒ¨ç±»

        private enum CharacterType
        {
            MeleeAI
        }

        private class TestCharacter
        {
            public int Id { get; set; }
            public string Name { get; set; } = "";
            public GameObject? GameObject { get; set; }
            public CharacterMainControl? CharacterMainControl { get; set; }
            public Item? CharacterItem { get; set; }
            public DateTime CreatedTime { get; set; }
        }

        #endregion
    }
}

```

`Client\Core\DebugModule\Modules\NetworkDebugModule.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.RPC;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// ç½‘ç»œè°ƒè¯•æ¨¡å— - æ˜¾ç¤ºè¿æ¥çŠ¶æ€å’Œ RPC ä¿¡æ¯
    /// </summary>
    public class NetworkDebugModule : IDebugModule
    {
        private readonly RpcClient _client;
        private int _totalRpcs = 0;
        private int _pendingRpcs = 0;

        public string ModuleName => "ç½‘ç»œçŠ¶æ€";
        public string Category => "ç½‘ç»œ";
        public string Description => "æ˜¾ç¤º RPC è¿æ¥çŠ¶æ€å’Œè°ƒç”¨ç»Ÿè®¡";
        public bool IsEnabled { get; set; } = true;

        public NetworkDebugModule(RpcClient client)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
        }

        public void OnGUI()
        {
            GUILayout.BeginVertical();

            // è¿æ¥çŠ¶æ€
            var statusStyle = new GUIStyle(GUI.skin.label);
            if (_client.IsConnected)
            {
                statusStyle.normal.textColor = Color.green;
                GUILayout.Label($"â— å·²è¿æ¥", statusStyle);
            }
            else
            {
                statusStyle.normal.textColor = Color.red;
                GUILayout.Label($"â— æœªè¿æ¥", statusStyle);
            }

            GUILayout.Label($"è¿æ¥çŠ¶æ€: {_client.ConnectionState}");

            // RPC ç»Ÿè®¡
            GUILayout.Space(5);
            GUILayout.Label($"æ€» RPC è°ƒç”¨: {_totalRpcs}", GUI.skin.label);
            GUILayout.Label($"å¾…å¤„ç† RPC: {_pendingRpcs}", GUI.skin.label);

            // æ“ä½œæŒ‰é’®
            GUILayout.Space(5);
            if (GUILayout.Button("é‡ç½®ç»Ÿè®¡"))
            {
                _totalRpcs = 0;
                _pendingRpcs = 0;
            }

            GUILayout.EndVertical();
        }

        public void Update()
        {
            // å¯ä»¥åœ¨è¿™é‡Œæ›´æ–°ç»Ÿè®¡æ•°æ®
            // æ³¨æ„ï¼šéœ€è¦è®¿é—® RpcClient çš„å†…éƒ¨å­—æ®µæ‰èƒ½è·å–çœŸå®ç»Ÿè®¡æ•°æ®
            // è¿™é‡Œæš‚æ—¶æ˜¾ç¤ºç¤ºä¾‹å€¼
        }
    }
}

```

`Client\Core\DebugModule\Modules\NpcManagerModule.cs`:

```cs
using System;
using System.Linq;
using UnityEngine;
using DuckyNet.Client.Core.DebugModule;

namespace DuckyNet.Client.Core.DebugModule.Modules
{
    /// <summary>
    /// NPC ç®¡ç†è°ƒè¯•æ¨¡å—
    /// </summary>
    public class NpcManagerModule : IDebugModule
    {
        public string ModuleName => "NPC ç®¡ç†å™¨";
        public string Category => "æ¸¸æˆ";
        public string Description => "ç®¡ç†å’Œç›‘æ§æ‰€æœ‰ NPC çš„çŠ¶æ€";
        public bool IsEnabled { get; set; } = true;

        private Vector2 _scrollPosition;
        private string _searchFilter = "";
        private bool _showAliveOnly = true;
        private bool _showDeadOnly = false;
        private NpcInfo? _selectedNpc;

        // GUI æ ·å¼
        private GUIStyle? _headerStyle;
        private GUIStyle? _aliveStyle;
        private GUIStyle? _deadStyle;
        private GUIStyle? _selectedStyle;

        public void OnGUI()
        {
            if (!GameContext.IsInitialized) return;

            InitializeStyles();

            var npcManager = GameContext.Instance.NpcManager;
            if (npcManager == null)
            {
                GUILayout.Label("âš ï¸ NPC ç®¡ç†å™¨æœªåˆå§‹åŒ–");
                return;
            }

            DrawControls(npcManager);
            DrawNpcList(npcManager);
            DrawSelectedNpcDetails();
        }

        /// <summary>
        /// åˆå§‹åŒ–æ ·å¼
        /// </summary>
        private void InitializeStyles()
        {
            if (_headerStyle != null) return;

            _headerStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 12,
                fontStyle = FontStyle.Bold,
                normal = { textColor = Color.white }
            };

            _aliveStyle = new GUIStyle(GUI.skin.box)
            {
                normal = { textColor = new Color(0.4f, 1f, 0.4f) },
                fontSize = 10
            };

            _deadStyle = new GUIStyle(GUI.skin.box)
            {
                normal = { textColor = new Color(1f, 0.4f, 0.4f) },
                fontSize = 10
            };

            _selectedStyle = new GUIStyle(GUI.skin.box)
            {
                normal = { background = MakeTexture(2, 2, new Color(0.3f, 0.6f, 1f, 0.3f)) }
            };
        }

        /// <summary>
        /// ç»˜åˆ¶æ§åˆ¶é¢æ¿
        /// </summary>
        private void DrawControls(NpcManager npcManager)
        {
            GUILayout.BeginHorizontal();

            // ç»Ÿè®¡ä¿¡æ¯
            var allNpcs = npcManager.GetAllNpcs().ToList();
            var aliveCount = allNpcs.Count(n => n.IsAlive);
            var deadCount = allNpcs.Count(n => !n.IsAlive);

            GUILayout.Label($"ğŸ“Š æ€»è®¡: {allNpcs.Count} | â¤ï¸ å­˜æ´»: {aliveCount} | ğŸ’€ æ­»äº¡: {deadCount}", _headerStyle);

            // å¯è§æ€§ç»Ÿè®¡
            var visStats = npcManager.VisibilityManager.GetStats();
                GUILayout.Label($"ğŸ” å¯è§æ€§: è¿½è¸ª{visStats.TrackedNpcs} | è¿œç¨‹{visStats.VisibleRemoteNpcs} | èŒƒå›´{visStats.SyncRange}m");

            // å¯¹è±¡æ± ç»Ÿè®¡
            var poolStats = npcManager.NpcPool.GetStats();
            GUILayout.Label($"â™»ï¸ å¯¹è±¡æ± : æ´»åŠ¨{poolStats.ActiveNpcs} | æ± ä¸­{poolStats.PooledNpcs} | å¤ç”¨ç‡{poolStats.ReuseRate:F1}% | ç±»å‹{poolStats.PoolTypes}");

            GUILayout.FlexibleSpace();

            // æ¸…ç†æŒ‰é’®
            if (GUILayout.Button("ğŸ—‘ï¸ æ¸…ç©º", GUILayout.Width(60), GUILayout.Height(25)))
            {
                npcManager.Clear();
                _selectedNpc = null;
            }

            GUILayout.EndHorizontal();

            GUILayout.Space(5);

            // è¿‡æ»¤å™¨
            GUILayout.BeginHorizontal();
            GUILayout.Label("ğŸ” æœç´¢:", GUILayout.Width(50));
            _searchFilter = GUILayout.TextField(_searchFilter, GUILayout.Width(150));

            GUILayout.Space(10);
            _showAliveOnly = GUILayout.Toggle(_showAliveOnly, "åªæ˜¾ç¤ºå­˜æ´»", GUILayout.Width(100));
            _showDeadOnly = GUILayout.Toggle(_showDeadOnly, "åªæ˜¾ç¤ºæ­»äº¡", GUILayout.Width(100));

            GUILayout.EndHorizontal();

            GUILayout.Space(5);
        }

        /// <summary>
        /// ç»˜åˆ¶ NPC åˆ—è¡¨
        /// </summary>
        private void DrawNpcList(NpcManager npcManager)
        {
            var npcs = npcManager.GetAllNpcs();

            // åº”ç”¨è¿‡æ»¤å™¨
            if (_showAliveOnly && !_showDeadOnly)
            {
                npcs = npcs.Where(n => n.IsAlive);
            }
            else if (_showDeadOnly && !_showAliveOnly)
            {
                npcs = npcs.Where(n => !n.IsAlive);
            }

            if (!string.IsNullOrEmpty(_searchFilter))
            {
                npcs = npcs.Where(n => n.Name.IndexOf(_searchFilter, StringComparison.OrdinalIgnoreCase) >= 0);
            }

            var npcList = npcs.OrderByDescending(n => n.IsAlive).ThenBy(n => n.Name).ToList();

            // åˆ—è¡¨
            _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(300));

            foreach (var npc in npcList)
            {
                DrawNpcItem(npc);
            }

            if (npcList.Count == 0)
            {
                GUILayout.Label("æ²¡æœ‰æ‰¾åˆ° NPC", GUILayout.Height(50));
            }

            GUILayout.EndScrollView();
        }

        /// <summary>
        /// ç»˜åˆ¶å•ä¸ª NPC é¡¹
        /// </summary>
        private void DrawNpcItem(NpcInfo npc)
        {
            var style = npc.IsAlive ? _aliveStyle : _deadStyle;
            var isSelected = _selectedNpc?.Id == npc.Id;

            if (isSelected)
            {
                GUILayout.BeginVertical(_selectedStyle);
            }
            else
            {
                GUILayout.BeginVertical(GUI.skin.box);
            }

            if (GUILayout.Button($"{(npc.IsAlive ? "â¤ï¸" : "ğŸ’€")} ID:{npc.Id} - {npc.Name}", style, GUILayout.Height(25)))
            {
                _selectedNpc = npc;
            }

            GUILayout.BeginHorizontal();

            // è¡€é‡æ¡
            if (npc.IsAlive)
            {
                DrawHealthBar(npc.CurrentHealth, npc.MaxHealth, 150, 15);
                GUILayout.Label($"{npc.CurrentHealth:F0}/{npc.MaxHealth:F0} ({npc.HealthPercent:F1}%)", GUILayout.Width(120));
            }
            else
            {
                GUILayout.Label($"ğŸ’€ æ­»äº¡æ—¶é—´: {npc.AliveTime:F1}s", GUILayout.Width(150));
            }

            GUILayout.FlexibleSpace();

            // ä½ç½®
            GUILayout.Label($"ğŸ“ ({npc.Position.x:F1}, {npc.Position.y:F1}, {npc.Position.z:F1})", GUILayout.Width(180));

            GUILayout.EndHorizontal();

            GUILayout.EndVertical();
            GUILayout.Space(2);
        }

        /// <summary>
        /// ç»˜åˆ¶é€‰ä¸­çš„ NPC è¯¦æƒ…
        /// </summary>
        private void DrawSelectedNpcDetails()
        {
            if (_selectedNpc == null) return;

            GUILayout.Space(10);
            GUILayout.Label("ğŸ“‹ é€‰ä¸­ NPC è¯¦æƒ…", _headerStyle);

            GUILayout.BeginVertical(GUI.skin.box);

            GUILayout.Label($"ğŸ†” ID: {_selectedNpc.Id}");
            GUILayout.Label($"ğŸ“› åç§°: {_selectedNpc.Name}");
            GUILayout.Label($"â¤ï¸ çŠ¶æ€: {(_selectedNpc.IsAlive ? "å­˜æ´»" : "æ­»äº¡")}");
            
            if (_selectedNpc.IsAlive)
            {
                GUILayout.Label($"ğŸ’š è¡€é‡: {_selectedNpc.CurrentHealth:F0}/{_selectedNpc.MaxHealth:F0} ({_selectedNpc.HealthPercent:F1}%)");
            }
            
            GUILayout.Label($"ğŸ“ ä½ç½®: ({_selectedNpc.Position.x:F2}, {_selectedNpc.Position.y:F2}, {_selectedNpc.Position.z:F2})");
            GUILayout.Label($"â±ï¸ {(_selectedNpc.IsAlive ? "å­˜æ´»æ—¶é—´" : "ç”Ÿå­˜æ—¶é•¿")}: {_selectedNpc.AliveTime:F2}s");

            GUILayout.Space(5);

            GUILayout.BeginHorizontal();

            // å®šä½æŒ‰é’®
            if (_selectedNpc.GameObject != null && GUILayout.Button("ğŸ“Œ å®šä½åˆ° NPC", GUILayout.Height(30)))
            {
                // è®©æ‘„åƒæœºçœ‹å‘ NPCï¼ˆå¦‚æœéœ€è¦å¯ä»¥å®ç°ï¼‰
                Debug.Log($"[NpcManagerModule] å®šä½åˆ° NPC: {_selectedNpc.Name} at {_selectedNpc.Position}");
            }

            // å–æ¶ˆé€‰æ‹©
            if (GUILayout.Button("âŒ å–æ¶ˆé€‰æ‹©", GUILayout.Height(30)))
            {
                _selectedNpc = null;
            }

            GUILayout.EndHorizontal();

            GUILayout.EndVertical();
        }

        /// <summary>
        /// ç»˜åˆ¶è¡€é‡æ¡
        /// </summary>
        private void DrawHealthBar(float current, float max, float width, float height)
        {
            Rect barRect = GUILayoutUtility.GetRect(width, height);
            
            // èƒŒæ™¯
            GUI.DrawTexture(barRect, MakeTexture(2, 2, new Color(0.2f, 0.2f, 0.2f, 0.8f)));
            
            // å‰æ™¯
            float percent = max > 0 ? current / max : 0f;
            Rect fillRect = new Rect(barRect.x, barRect.y, barRect.width * percent, barRect.height);
            
            Color barColor = percent > 0.6f ? new Color(0.2f, 0.8f, 0.2f) : 
                             percent > 0.3f ? new Color(0.8f, 0.8f, 0.2f) : 
                             new Color(0.8f, 0.2f, 0.2f);
            
            GUI.DrawTexture(fillRect, MakeTexture(2, 2, barColor));
        }

        /// <summary>
        /// åˆ›å»ºçº¹ç†
        /// </summary>
        private Texture2D MakeTexture(int width, int height, Color color)
        {
            Color[] pixels = new Color[width * height];
            for (int i = 0; i < pixels.Length; i++)
            {
                pixels[i] = color;
            }

            Texture2D texture = new Texture2D(width, height);
            texture.SetPixels(pixels);
            texture.Apply();
            return texture;
        }

        public void Update()
        {
            // æ¯å¸§æ›´æ–°
        }
    }
}


```

`Client\Core\DebugModule\Modules\PlayerModelDebugModule.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.Core;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// ç©å®¶æ¨¡å‹è°ƒè¯•æ¨¡å— - æ˜¾ç¤ºå’Œç®¡ç†ç©å®¶æ¨¡å‹çŠ¶æ€
    /// </summary>
    public class PlayerModelDebugModule : IDebugModule
    {
        public string ModuleName => "ç©å®¶æ¨¡å‹";
        public string Category => "åœºæ™¯";
        public string Description => "æ˜¾ç¤ºç©å®¶æ¨¡å‹ç®¡ç†çŠ¶æ€";
        public bool IsEnabled { get; set; } = true;

        public PlayerModelDebugModule()
        {
        }

        public void OnGUI()
        {
            if (!GameContext.IsInitialized)
            {
                GUILayout.Label("æ¸¸æˆä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–", GUI.skin.label);
                return;
            }

            
            GUILayout.BeginVertical();


            GUILayout.Space(5);

            if (GUILayout.Button("åˆ·æ–°"))
            {
                // å¯ä»¥è§¦å‘åˆ·æ–°æ“ä½œ
                UnityEngine.Debug.Log("[PlayerModelDebugModule] å·²åˆ·æ–°ç©å®¶æ¨¡å‹ä¿¡æ¯");
            }

            GUILayout.EndVertical();
        }

        public void Update()
        {
            // å¯ä»¥åœ¨è¿™é‡Œæ›´æ–°ç©å®¶æ¨¡å‹ä¿¡æ¯
        }
    }
}

```

`Client\Core\DebugModule\Modules\RemotePlayerDebugModule.cs`:

```cs
using System;
using System.Linq;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.Players;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// è¿œç¨‹ç©å®¶è°ƒè¯•æ¨¡å— - æ˜¾ç¤ºæ‰€æœ‰è¿œç¨‹ç©å®¶ä¿¡æ¯å¹¶æä¾›è°ƒè¯•åŠŸèƒ½
    /// </summary>
    public class RemotePlayerDebugModule : IDebugModule
    {
        public string ModuleName => "è¿œç¨‹ç©å®¶è°ƒè¯•";
        public string Category => "è°ƒè¯•";
        public string Description => "æ˜¾ç¤ºè¿œç¨‹ç©å®¶ä¿¡æ¯,æä¾›ä¼ é€ã€æ˜¾ç¤º/éšè—ç­‰è°ƒè¯•åŠŸèƒ½";
        public bool IsEnabled { get; set; } = true;

        private Vector2 _scrollPosition = Vector2.zero;
        private bool _showDetails = true;
        private bool _autoRefresh = true;
        private float _refreshTimer = 0f;
        private float _refreshInterval = 0.5f; // æ¯0.5ç§’åˆ·æ–°ä¸€æ¬¡

        public void OnGUI()
        {
            if (!GameContext.IsInitialized)
            {
                GUILayout.Label("æ¸¸æˆä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–", GUI.skin.label);
                return;
            }

            var playerManager = GameContext.Instance.PlayerManager;
            if (playerManager == null)
            {
                GUILayout.Label("ç©å®¶ç®¡ç†å™¨æœªåˆå§‹åŒ–", GUI.skin.label);
                return;
            }

            GUILayout.BeginVertical("box");
            
            // æ ‡é¢˜
            GUILayout.Label("â•â•â• è¿œç¨‹ç©å®¶è°ƒè¯• â•â•â•", new GUIStyle(GUI.skin.label) 
            { 
                fontSize = 14, 
                fontStyle = FontStyle.Bold,
                alignment = TextAnchor.MiddleCenter
            });
            
            GUILayout.Space(10);

            // ç»Ÿè®¡ä¿¡æ¯
            int remotePlayerCount = playerManager.RemotePlayers.Count();
            int withCharacter = playerManager.RemotePlayers.Count(p => p.CharacterObject != null);
            
            GUILayout.BeginHorizontal("box");
            GUILayout.Label($"è¿œç¨‹ç©å®¶æ€»æ•°: {remotePlayerCount}", new GUIStyle(GUI.skin.label) 
            { 
                fontStyle = FontStyle.Bold,
                normal = { textColor = Color.cyan }
            });
            GUILayout.FlexibleSpace();
            GUILayout.Label($"æœ‰è§’è‰²æ¨¡å‹: {withCharacter}", new GUIStyle(GUI.skin.label) 
            { 
                normal = { textColor = withCharacter > 0 ? Color.green : Color.red }
            });
            GUILayout.EndHorizontal();

            GUILayout.Space(5);

            // æ§åˆ¶é€‰é¡¹
            GUILayout.BeginHorizontal();
            _showDetails = GUILayout.Toggle(_showDetails, "æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯");
            _autoRefresh = GUILayout.Toggle(_autoRefresh, "è‡ªåŠ¨åˆ·æ–°");
            if (GUILayout.Button("æ‰‹åŠ¨åˆ·æ–°", GUILayout.Width(100)))
            {
                // å¼ºåˆ¶åˆ·æ–°
            }
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // æœ¬åœ°ç©å®¶ä¿¡æ¯
            if (playerManager.LocalPlayer?.CharacterObject != null)
            {
                GUILayout.Label("æœ¬åœ°ç©å®¶:", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
                var localPos = playerManager.LocalPlayer.CharacterObject.transform.position;
                GUILayout.Label($"ä½ç½®: {localPos.x:F2}, {localPos.y:F2}, {localPos.z:F2}");
                GUILayout.Space(5);
            }

            if (remotePlayerCount == 0)
            {
                GUILayout.Label("å½“å‰æ²¡æœ‰è¿œç¨‹ç©å®¶", new GUIStyle(GUI.skin.label) 
                { 
                    alignment = TextAnchor.MiddleCenter,
                    normal = { textColor = Color.gray }
                });
            }
            else
            {
                // è¿œç¨‹ç©å®¶åˆ—è¡¨ï¼ˆæ»šåŠ¨è§†å›¾ï¼‰
                _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(400));
                
                foreach (var remotePlayer in playerManager.RemotePlayers)
                {
                    if (playerManager.LocalPlayer != null)
                    {
                        DrawRemotePlayerPanel(remotePlayer, playerManager.LocalPlayer);
                    }
                    GUILayout.Space(5);
                }
                
                GUILayout.EndScrollView();
            }

            GUILayout.EndVertical();
        }

        private void DrawRemotePlayerPanel(RemotePlayer remotePlayer, LocalPlayer localPlayer)
        {
            GUILayout.BeginVertical("box");
            
            // ç©å®¶åç§°å’ŒçŠ¶æ€
            GUILayout.BeginHorizontal();
            
            bool hasCharacter = remotePlayer.CharacterObject != null;
            Color statusColor = hasCharacter ? Color.green : Color.red;
            string statusText = hasCharacter ? "â—" : "â—‹";
            
            GUILayout.Label(statusText, new GUIStyle(GUI.skin.label) 
            { 
                fontSize = 16,
                normal = { textColor = statusColor }
            }, GUILayout.Width(20));
            
            GUILayout.Label(remotePlayer.Info.SteamName, new GUIStyle(GUI.skin.label) 
            { 
                fontSize = 12,
                fontStyle = FontStyle.Bold
            });
            
            GUILayout.FlexibleSpace();
            
            // Steam ID
            GUILayout.Label($"ID: {remotePlayer.Info.SteamId.Substring(0, 8)}...", 
                new GUIStyle(GUI.skin.label) { fontSize = 10 });
            
            GUILayout.EndHorizontal();

            // åœºæ™¯ä¿¡æ¯
            string remoteSceneName = string.IsNullOrEmpty(remotePlayer.CurrentSceneName) 
                ? "æœªè¿›å…¥åœºæ™¯" 
                : remotePlayer.CurrentSceneName;
            string localSceneName = GameContext.Instance?.SceneClientManager?._scenelDataList?.SceneName ?? "æœªçŸ¥";
            
            // åœºæ™¯åŒ¹é…çŠ¶æ€
            bool sceneMatches = !string.IsNullOrEmpty(remotePlayer.CurrentSceneName) 
                && remotePlayer.CurrentSceneName == localSceneName;
            Color sceneColor = sceneMatches ? Color.green : Color.yellow;
            
            GUILayout.BeginHorizontal();
            GUILayout.Label($"åœºæ™¯: {remoteSceneName}", 
                new GUIStyle(GUI.skin.label) { fontSize = 10, normal = { textColor = sceneColor } });
            
            if (!sceneMatches)
            {
                GUILayout.Label($"(æœ¬åœ°: {localSceneName})", 
                    new GUIStyle(GUI.skin.label) { fontSize = 9, normal = { textColor = Color.gray } });
            }
            GUILayout.EndHorizontal();

            if (hasCharacter && _showDetails && remotePlayer.CharacterObject != null)
            {
                var characterPos = remotePlayer.CharacterObject.transform.position;
                var characterRot = remotePlayer.CharacterObject.transform.rotation.eulerAngles;
                
                // ä½ç½®ä¿¡æ¯
                GUILayout.BeginHorizontal();
                GUILayout.Label($"ä½ç½®: ", GUILayout.Width(40));
                GUILayout.Label($"X: {characterPos.x:F2}", GUILayout.Width(80));
                GUILayout.Label($"Y: {characterPos.y:F2}", GUILayout.Width(80));
                GUILayout.Label($"Z: {characterPos.z:F2}", GUILayout.Width(80));
                GUILayout.EndHorizontal();

                // æ—‹è½¬ä¿¡æ¯
                GUILayout.BeginHorizontal();
                GUILayout.Label($"æ—‹è½¬: ", GUILayout.Width(40));
                GUILayout.Label($"Y: {characterRot.y:F1}Â°", GUILayout.Width(80));
                GUILayout.EndHorizontal();

                // è·ç¦»ä¿¡æ¯
                if (localPlayer != null && localPlayer.CharacterObject != null)
                {
                    var localPos = localPlayer.CharacterObject.transform.position;
                    float distance = Vector3.Distance(localPos, characterPos);
                    Color distanceColor = distance < 10 ? Color.green : 
                                        distance < 50 ? Color.yellow : Color.red;
                    
                    GUILayout.Label($"è·ç¦»: {distance:F2}ç±³", new GUIStyle(GUI.skin.label) 
                    { 
                        normal = { textColor = distanceColor }
                    });
                }

                // æ¿€æ´»çŠ¶æ€
                GUILayout.BeginHorizontal();
                GUILayout.Label($"æ¿€æ´»: {remotePlayer.CharacterObject.activeSelf}", GUILayout.Width(100));
                GUILayout.Label($"Layer: {remotePlayer.CharacterObject.layer}", GUILayout.Width(80));
                GUILayout.EndHorizontal();

                GUILayout.Space(5);

                // æ“ä½œæŒ‰é’®
                GUILayout.BeginHorizontal();
                
                // ä¼ é€åˆ°è¿œç¨‹ç©å®¶
                if (GUILayout.Button("ä¼ é€è¿‡å»", GUILayout.Height(25)))
                {
                    if (localPlayer != null)
                    {
                        TeleportToRemotePlayer(remotePlayer, localPlayer);
                    }
                }
                
                // ä¼ é€è¿œç¨‹ç©å®¶åˆ°è‡ªå·±
                if (GUILayout.Button("ä¼ é€è¿‡æ¥", GUILayout.Height(25)))
                {
                    if (localPlayer != null)
                    {
                        TeleportRemotePlayerToLocal(remotePlayer, localPlayer);
                    }
                }
                
                // æ˜¾ç¤º/éšè—
                string toggleText = remotePlayer.CharacterObject.activeSelf ? "éšè—" : "æ˜¾ç¤º";
                if (GUILayout.Button(toggleText, GUILayout.Height(25)))
                {
                    ToggleRemotePlayerVisibility(remotePlayer);
                }
                
                // é”€æ¯è§’è‰²
                GUI.backgroundColor = Color.red;
                if (GUILayout.Button("é”€æ¯", GUILayout.Height(25), GUILayout.Width(60)))
                {
                    DestroyRemotePlayerCharacter(remotePlayer);
                }
                GUI.backgroundColor = Color.white;
                
                GUILayout.EndHorizontal();
            }
            else if (!hasCharacter)
            {
                GUILayout.Label("æœªåˆ›å»ºè§’è‰²æ¨¡å‹", new GUIStyle(GUI.skin.label) 
                { 
                    normal = { textColor = Color.yellow }
                });
                
                if (GUILayout.Button("å°è¯•åˆ›å»ºè§’è‰²", GUILayout.Height(25)))
                {
                    TryCreateRemotePlayerCharacter(remotePlayer);
                }
            }

            GUILayout.EndVertical();
        }

        private void TeleportToRemotePlayer(RemotePlayer remotePlayer, LocalPlayer localPlayer)
        {
            if (remotePlayer.CharacterObject == null || localPlayer?.CharacterObject == null)
            {
                Debug.LogWarning("[RemotePlayerDebugModule] æ— æ³•ä¼ é€ï¼šè§’è‰²å¯¹è±¡ä¸å­˜åœ¨");
                return;
            }

            try
            {
                var targetPos = remotePlayer.CharacterObject.transform.position;
                localPlayer.CharacterObject.transform.position = targetPos + new Vector3(2, 0, 0); // åç§»2ç±³é¿å…é‡å 
                Debug.Log($"[RemotePlayerDebugModule] å·²ä¼ é€åˆ° {remotePlayer.Info.SteamName} é™„è¿‘");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerDebugModule] ä¼ é€å¤±è´¥: {ex.Message}");
            }
        }

        private void TeleportRemotePlayerToLocal(RemotePlayer remotePlayer, LocalPlayer localPlayer)
        {
            if (remotePlayer.CharacterObject == null || localPlayer?.CharacterObject == null)
            {
                Debug.LogWarning("[RemotePlayerDebugModule] æ— æ³•ä¼ é€ï¼šè§’è‰²å¯¹è±¡ä¸å­˜åœ¨");
                return;
            }

            try
            {
                var targetPos = localPlayer.CharacterObject.transform.position;
                remotePlayer.CharacterObject.transform.position = targetPos + new Vector3(-2, 0, 0); // åç§»-2ç±³é¿å…é‡å 
                Debug.Log($"[RemotePlayerDebugModule] å·²å°† {remotePlayer.Info.SteamName} ä¼ é€åˆ°èº«è¾¹");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerDebugModule] ä¼ é€å¤±è´¥: {ex.Message}");
            }
        }

        private void ToggleRemotePlayerVisibility(RemotePlayer remotePlayer)
        {
            if (remotePlayer.CharacterObject == null)
            {
                Debug.LogWarning("[RemotePlayerDebugModule] æ— æ³•åˆ‡æ¢æ˜¾ç¤ºï¼šè§’è‰²å¯¹è±¡ä¸å­˜åœ¨");
                return;
            }

            try
            {
                bool newState = !remotePlayer.CharacterObject.activeSelf;
                remotePlayer.CharacterObject.SetActive(newState);
                Debug.Log($"[RemotePlayerDebugModule] {remotePlayer.Info.SteamName} å·²{(newState ? "æ˜¾ç¤º" : "éšè—")}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerDebugModule] åˆ‡æ¢æ˜¾ç¤ºå¤±è´¥: {ex.Message}");
            }
        }

        private void DestroyRemotePlayerCharacter(RemotePlayer remotePlayer)
        {
            if (remotePlayer.CharacterObject == null)
            {
                Debug.LogWarning("[RemotePlayerDebugModule] æ— æ³•é”€æ¯ï¼šè§’è‰²å¯¹è±¡ä¸å­˜åœ¨");
                return;
            }

            try
            {
                remotePlayer.DestroyCharacter();
                Debug.Log($"[RemotePlayerDebugModule] å·²é”€æ¯ {remotePlayer.Info.SteamName} çš„è§’è‰²");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerDebugModule] é”€æ¯å¤±è´¥: {ex.Message}");
            }
        }

        private void TryCreateRemotePlayerCharacter(RemotePlayer remotePlayer)
        {
            if (remotePlayer.CharacterObject != null)
            {
                Debug.LogWarning("[RemotePlayerDebugModule] è§’è‰²å·²å­˜åœ¨");
                return;
            }

            try
            {
                // åœ¨æœ¬åœ°ç©å®¶å‰æ–¹5ç±³å¤„åˆ›å»º
                Vector3 spawnPos = Vector3.zero;
                
                if (GameContext.Instance.PlayerManager?.LocalPlayer?.CharacterObject != null)
                {
                    var localTransform = GameContext.Instance.PlayerManager.LocalPlayer.CharacterObject.transform;
                    spawnPos = localTransform.position + localTransform.forward * 5f;
                }

                bool success = remotePlayer.CreateCharacter(spawnPos);
                if (success)
                {
                    Debug.Log($"[RemotePlayerDebugModule] å·²åˆ›å»º {remotePlayer.Info.SteamName} çš„è§’è‰²");
                }
                else
                {
                    Debug.LogWarning($"[RemotePlayerDebugModule] åˆ›å»º {remotePlayer.Info.SteamName} çš„è§’è‰²å¤±è´¥");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerDebugModule] åˆ›å»ºå¤±è´¥: {ex.Message}");
            }
        }

        public void Update()
        {
            if (!_autoRefresh) return;

            _refreshTimer += Time.deltaTime;
            if (_refreshTimer >= _refreshInterval)
            {
                _refreshTimer = 0f;
                // è‡ªåŠ¨åˆ·æ–°é€»è¾‘ï¼ˆå¦‚æœéœ€è¦ï¼‰
            }
        }
    }
}

```

`Client\Core\DebugModule\Modules\RemotePlayerSpawnerModule.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.Players;
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Core.DebugModule
{
    /// <summary>
    /// è¿œç¨‹ç©å®¶ç”Ÿæˆå™¨è°ƒè¯•æ¨¡å— - ç”¨äºæ‰‹åŠ¨åˆ›å»ºæµ‹è¯•ç”¨çš„è¿œç¨‹ç©å®¶
    /// </summary>
    public class RemotePlayerSpawnerModule : IDebugModule
    {
        public string ModuleName => "è¿œç¨‹ç©å®¶ç”Ÿæˆå™¨";
        public string Category => "æµ‹è¯•";
        public string Description => "æ‰‹åŠ¨åˆ›å»ºæµ‹è¯•ç”¨çš„è¿œç¨‹ç©å®¶å•ä½";
        public bool IsEnabled { get; set; } = true;

        private string _playerName = "TestPlayer";
        private string _steamId = "76561199999999999";
        private Vector3 _spawnPosition = Vector3.zero;
        private int _testPlayerCount = 0;
        private GameObject? _lastCreatedCharacter = null;
        private Vector3 _lastKnownPosition = Vector3.zero;
        
        // ğŸ”¥ æ–°å¢ï¼šå¤´åƒç›¸å…³
        private bool _useCustomAvatar = false;
        private Texture2D? _customAvatarTexture = null;
        private string _avatarColorR = "255";
        private string _avatarColorG = "100";
        private string _avatarColorB = "100";

        public RemotePlayerSpawnerModule()
        {
        }

        public void OnGUI()
        {
            if (!GameContext.IsInitialized)
            {
                GUILayout.Label("æ¸¸æˆä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–", GUI.skin.label);
                return;
            }

            GUILayout.BeginVertical("box");
            
            // æ ‡é¢˜
            GUILayout.Label("â•â•â• è¿œç¨‹ç©å®¶ç”Ÿæˆå™¨ â•â•â•", new GUIStyle(GUI.skin.label) 
            { 
                fontSize = 14, 
                fontStyle = FontStyle.Bold,
                alignment = TextAnchor.MiddleCenter
            });
            
            GUILayout.Space(10);

            // ç©å®¶åç§°è¾“å…¥
            GUILayout.BeginHorizontal();
            GUILayout.Label("ç©å®¶åç§°:", GUILayout.Width(80));
            _playerName = GUILayout.TextField(_playerName, GUILayout.Width(200));
            GUILayout.EndHorizontal();

            // SteamID è¾“å…¥
            GUILayout.BeginHorizontal();
            GUILayout.Label("Steam ID:", GUILayout.Width(80));
            _steamId = GUILayout.TextField(_steamId, GUILayout.Width(200));
            GUILayout.EndHorizontal();

            GUILayout.Space(10);
            
            // ğŸ”¥ å¤´åƒè®¾ç½®
            GUILayout.Label("å¤´åƒè®¾ç½®:", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
            
            _useCustomAvatar = GUILayout.Toggle(_useCustomAvatar, "ä½¿ç”¨è‡ªå®šä¹‰å¤´åƒ");
            
            if (_useCustomAvatar)
            {
                GUILayout.BeginHorizontal();
                GUILayout.Label("é¢œè‰² RGB:", GUILayout.Width(80));
                GUILayout.Label("R:", GUILayout.Width(20));
                _avatarColorR = GUILayout.TextField(_avatarColorR, 3, GUILayout.Width(40));
                GUILayout.Label("G:", GUILayout.Width(20));
                _avatarColorG = GUILayout.TextField(_avatarColorG, 3, GUILayout.Width(40));
                GUILayout.Label("B:", GUILayout.Width(20));
                _avatarColorB = GUILayout.TextField(_avatarColorB, 3, GUILayout.Width(40));
                GUILayout.EndHorizontal();
                
                GUILayout.BeginHorizontal();
                if (GUILayout.Button("ç”Ÿæˆå¤´åƒ", GUILayout.Width(100)))
                {
                    GenerateCustomAvatar();
                }
                if (_customAvatarTexture != null)
                {
                    GUILayout.Label("âœ“ å¤´åƒå·²ç”Ÿæˆ", new GUIStyle(GUI.skin.label) { normal = { textColor = Color.green } });
                }
                GUILayout.EndHorizontal();
            }

            GUILayout.Space(10);

            // ç”Ÿæˆä½ç½®è¾“å…¥
            GUILayout.Label("ç”Ÿæˆä½ç½®:", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
            
            GUILayout.BeginHorizontal();
            GUILayout.Label("X:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnPosition.x.ToString("F2"), GUILayout.Width(60)), out float x))
                _spawnPosition.x = x;
            
            GUILayout.Label("Y:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnPosition.y.ToString("F2"), GUILayout.Width(60)), out float y))
                _spawnPosition.y = y;
            
            GUILayout.Label("Z:", GUILayout.Width(20));
            if (float.TryParse(GUILayout.TextField(_spawnPosition.z.ToString("F2"), GUILayout.Width(60)), out float z))
                _spawnPosition.z = z;
            GUILayout.EndHorizontal();

            GUILayout.Space(5);

            // å¿«æ·æŒ‰é’®
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("åŸç‚¹(0,0,0)", GUILayout.Width(100)))
            {
                _spawnPosition = Vector3.zero;
            }
            if (GUILayout.Button("æœ¬åœ°ç©å®¶ä½ç½®", GUILayout.Width(120)))
            {
                SetPositionToLocalPlayer();
            }
            if (GUILayout.Button("ç›¸æœºå‰æ–¹", GUILayout.Width(100)))
            {
                SetPositionToFrontOfCamera();
            }
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // åˆ›å»ºæŒ‰é’®
            GUI.backgroundColor = Color.green;
            if (GUILayout.Button("åˆ›å»ºè¿œç¨‹ç©å®¶", GUILayout.Height(40)))
            {
                CreateTestRemotePlayer();
            }
            GUI.backgroundColor = Color.white;

            GUILayout.Space(10);

            // å¿«é€Ÿåˆ›å»ºæŒ‰é’®
            GUILayout.Label("å¿«é€Ÿåˆ›å»º:", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("åˆ›å»º 3 ä¸ª"))
            {
                CreateMultipleTestPlayers(3);
            }
            if (GUILayout.Button("åˆ›å»º 5 ä¸ª"))
            {
                CreateMultipleTestPlayers(5);
            }
            if (GUILayout.Button("åˆ›å»º 10 ä¸ª"))
            {
                CreateMultipleTestPlayers(10);
            }
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // ç»Ÿè®¡ä¿¡æ¯
            GUILayout.Label($"å·²åˆ›å»ºæµ‹è¯•ç©å®¶æ•°é‡: {_testPlayerCount}", new GUIStyle(GUI.skin.label) 
            { 
                fontStyle = FontStyle.Bold,
                normal = { textColor = Color.cyan }
            });

            GUILayout.Space(10);

            // ä½ç½®ç›‘æ§
            GUILayout.Label("ä½ç½®ç›‘æ§:", new GUIStyle(GUI.skin.label) { fontStyle = FontStyle.Bold });
            
            if (_lastCreatedCharacter != null)
            {
                var currentPos = _lastCreatedCharacter.transform.position;
                GUILayout.Label($"æœ€ååˆ›å»ºçš„è§’è‰²: {_lastCreatedCharacter.name}");
                GUILayout.Label($"å½“å‰ä½ç½®: {currentPos:F3}");
                GUILayout.Label($"åˆå§‹ä½ç½®: {_lastKnownPosition:F3}");
                
                var distance = Vector3.Distance(currentPos, _lastKnownPosition);
                var color = distance > 0.1f ? Color.red : Color.green;
                GUILayout.Label($"ç§»åŠ¨è·ç¦»: {distance:F3} ç±³", new GUIStyle(GUI.skin.label) 
                { 
                    normal = { textColor = color }
                });
                
                if (distance > 0.1f)
                {
                    GUILayout.Label("âš ï¸ è§’è‰²æ­£åœ¨ç§»åŠ¨/æ‰è½ï¼", new GUIStyle(GUI.skin.label) 
                    { 
                        fontStyle = FontStyle.Bold,
                        normal = { textColor = Color.red }
                    });
                }
            }
            else
            {
                GUILayout.Label("å°šæœªåˆ›å»ºè§’è‰²");
            }

            GUILayout.EndVertical();
        }

        /// <summary>
        /// åˆ›å»ºæµ‹è¯•ç”¨çš„è¿œç¨‹ç©å®¶
        /// </summary>
        private void CreateTestRemotePlayer()
        {
            try
            {
                // åˆ›å»ºç©å®¶ä¿¡æ¯
                var playerInfo = new PlayerInfo
                {
                    SteamId = _steamId,
                    SteamName = _playerName,
                    AvatarUrl = string.Empty,
                    CurrentScenelData = new Shared.Data.ScenelData("Base", "Base_SceneV2")
                };

                // åˆ›å»ºè¿œç¨‹ç©å®¶å¯¹è±¡
                var remotePlayer = new RemotePlayer(playerInfo);
                
                // ğŸ”¥ å¦‚æœå¯ç”¨è‡ªå®šä¹‰å¤´åƒ,è®¾ç½®å¤´åƒ
                if (_useCustomAvatar && _customAvatarTexture != null)
                {
                    remotePlayer.SetAvatarTexture(_customAvatarTexture);
                    Debug.Log($"[RemotePlayerSpawnerModule] å·²è®¾ç½®è‡ªå®šä¹‰å¤´åƒ");
                }

                // ğŸ”¥ åˆ›å»ºè§’è‰²æ¨¡å‹ - ä¸ä¼ åå­—,è®©RemotePlayerä»Info.SteamNameè‡ªåŠ¨è·å–
                bool success = remotePlayer.CreateCharacter(_spawnPosition);

                if (success)
                {
                    _testPlayerCount++;
                    Debug.Log($"[RemotePlayerSpawnerModule] æˆåŠŸåˆ›å»ºæµ‹è¯•ç©å®¶: {_playerName} åœ¨ä½ç½® {_spawnPosition}");
                    
                    // æ‰“å°è§’è‰²ä¸Šçš„æ‰€æœ‰ç»„ä»¶
                    if (remotePlayer.CharacterObject != null)
                    {
                        PrintAllComponents(remotePlayer.CharacterObject);
                    }
                    
                    // è‡ªåŠ¨ç”Ÿæˆä¸‹ä¸€ä¸ªç©å®¶çš„ä¿¡æ¯
                    _playerName = $"TestPlayer{_testPlayerCount + 1}";
                    _steamId = $"7656119999999{_testPlayerCount:D4}";
                }
                else
                {
                    Debug.LogError($"[RemotePlayerSpawnerModule] åˆ›å»ºæµ‹è¯•ç©å®¶å¤±è´¥: {_playerName}");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerSpawnerModule] åˆ›å»ºæµ‹è¯•ç©å®¶å¼‚å¸¸: {ex.Message}");
                Debug.LogException(ex);
            }
        }
        
        /// <summary>
        /// ç”Ÿæˆè‡ªå®šä¹‰å¤´åƒçº¹ç†
        /// </summary>
        private void GenerateCustomAvatar()
        {
            try
            {
                // è§£æRGBå€¼
                if (!byte.TryParse(_avatarColorR, out byte r)) r = 255;
                if (!byte.TryParse(_avatarColorG, out byte g)) g = 100;
                if (!byte.TryParse(_avatarColorB, out byte b)) b = 100;
                
                // åˆ›å»º64x64çš„çº¯è‰²å¤´åƒ
                _customAvatarTexture = new Texture2D(64, 64, TextureFormat.RGBA32, false);
                Color avatarColor = new Color(r / 255f, g / 255f, b / 255f, 1f);
                
                Color[] pixels = new Color[64 * 64];
                for (int i = 0; i < pixels.Length; i++)
                {
                    pixels[i] = avatarColor;
                }
                
                _customAvatarTexture.SetPixels(pixels);
                _customAvatarTexture.Apply();
                
                Debug.Log($"[RemotePlayerSpawnerModule] ç”Ÿæˆè‡ªå®šä¹‰å¤´åƒ: RGB({r}, {g}, {b})");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerSpawnerModule] ç”Ÿæˆå¤´åƒå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ‰“å°æ¸¸æˆå¯¹è±¡ä¸Šçš„æ‰€æœ‰ç»„ä»¶
        /// </summary>
        private void PrintAllComponents(GameObject gameObject)
        {
            if (gameObject == null)
            {
                Debug.LogWarning("[RemotePlayerSpawnerModule] GameObject ä¸ºç©ºï¼Œæ— æ³•æ‰“å°ç»„ä»¶");
                return;
            }

            Debug.Log($"[RemotePlayerSpawnerModule] ========== è§’è‰²ç»„ä»¶åˆ—è¡¨: {gameObject.name} ==========");
            
            // è·å–æ ¹å¯¹è±¡çš„æ‰€æœ‰ç»„ä»¶
            var components = gameObject.GetComponents<Component>();
            Debug.Log($"[RemotePlayerSpawnerModule] æ ¹å¯¹è±¡ '{gameObject.name}' ä¸Šçš„ç»„ä»¶æ•°é‡: {components.Length}");
            
            for (int i = 0; i < components.Length; i++)
            {
                var comp = components[i];
                if (comp != null)
                {
                    string enabledStatus = "";
                    if (comp is Behaviour behaviour)
                    {
                        enabledStatus = behaviour.enabled ? " [å·²å¯ç”¨]" : " [å·²ç¦ç”¨]";
                    }
                    Debug.Log($"[RemotePlayerSpawnerModule]   [{i}] {comp.GetType().FullName}{enabledStatus}");
                }
            }
            
            // é€’å½’æ‰“å°æ‰€æœ‰å­å¯¹è±¡çš„ç»„ä»¶
            Debug.Log($"[RemotePlayerSpawnerModule] æ£€æŸ¥å­å¯¹è±¡ç»„ä»¶...");
            var allComponents = gameObject.GetComponentsInChildren<Component>(true);
            Debug.Log($"[RemotePlayerSpawnerModule] æ‰€æœ‰ç»„ä»¶æ€»æ•°ï¼ˆåŒ…æ‹¬å­å¯¹è±¡ï¼‰: {allComponents.Length}");
            
            // æŒ‰ç±»å‹åˆ†ç»„ç»Ÿè®¡
            var componentTypes = new System.Collections.Generic.Dictionary<string, int>();
            foreach (var comp in allComponents)
            {
                if (comp != null)
                {
                    string typeName = comp.GetType().Name;
                    if (componentTypes.ContainsKey(typeName))
                        componentTypes[typeName]++;
                    else
                        componentTypes[typeName] = 1;
                }
            }
            
            Debug.Log($"[RemotePlayerSpawnerModule] ç»„ä»¶ç±»å‹ç»Ÿè®¡:");
            foreach (var kvp in componentTypes)
            {
                Debug.Log($"[RemotePlayerSpawnerModule]   {kvp.Key}: {kvp.Value} ä¸ª");
            }
            
            Debug.Log($"[RemotePlayerSpawnerModule] ========================================");
        }

        /// <summary>
        /// æ‰¹é‡åˆ›å»ºå¤šä¸ªæµ‹è¯•ç©å®¶
        /// </summary>
        private void CreateMultipleTestPlayers(int count)
        {
            for (int i = 0; i < count; i++)
            {
                // åœ¨åŸç‚¹å‘¨å›´éšæœºç”Ÿæˆä½ç½®
                Vector3 randomOffset = new Vector3(
                    UnityEngine.Random.Range(-5f, 5f),
                    0f,
                    UnityEngine.Random.Range(-5f, 5f)
                );
                _spawnPosition = randomOffset;
                
                CreateTestRemotePlayer();
            }
        }

        /// <summary>
        /// è®¾ç½®ä½ç½®ä¸ºæœ¬åœ°ç©å®¶ä½ç½®
        /// </summary>
        private void SetPositionToLocalPlayer()
        {
            try
            {
                var localPlayer = GameContext.Instance.PlayerManager?.LocalPlayer;
                if (localPlayer?.CharacterObject != null)
                {
                    _spawnPosition = localPlayer.CharacterObject.transform.position;
                    Debug.Log($"[RemotePlayerSpawnerModule] å·²è®¾ç½®ä½ç½®ä¸ºæœ¬åœ°ç©å®¶ä½ç½®: {_spawnPosition}");
                }
                else
                {
                    Debug.LogWarning("[RemotePlayerSpawnerModule] æœ¬åœ°ç©å®¶è§’è‰²ä¸å­˜åœ¨");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerSpawnerModule] è·å–æœ¬åœ°ç©å®¶ä½ç½®å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// è®¾ç½®ä½ç½®ä¸ºç›¸æœºå‰æ–¹
        /// </summary>
        private void SetPositionToFrontOfCamera()
        {
            try
            {
                var mainCamera = Camera.main;
                if (mainCamera != null)
                {
                    // åœ¨ç›¸æœºå‰æ–¹ 5 ç±³å¤„ç”Ÿæˆ
                    _spawnPosition = mainCamera.transform.position + mainCamera.transform.forward * 5f;
                    Debug.Log($"[RemotePlayerSpawnerModule] å·²è®¾ç½®ä½ç½®ä¸ºç›¸æœºå‰æ–¹: {_spawnPosition}");
                }
                else
                {
                    Debug.LogWarning("[RemotePlayerSpawnerModule] ä¸»ç›¸æœºä¸å­˜åœ¨");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemotePlayerSpawnerModule] è·å–ç›¸æœºä½ç½®å¤±è´¥: {ex.Message}");
            }
        }

        public void Update()
        {
            // è¿™ä¸ªæ¨¡å—ä¸éœ€è¦æ¯å¸§æ›´æ–°
        }
    }
}

```

`Client\Core\DebugModule\Modules\ShadowNpcTestModule.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.DebugModule.Modules
{
    /// <summary>
    /// å½±å­ NPC æµ‹è¯•æ¨¡å— - ç”¨äºæµ‹è¯•å½±å­ NPC çš„åˆ›å»ºå’Œç®¡ç†
    /// </summary>
    public class ShadowNpcTestModule : IDebugModule
    {
        public string ModuleName => "å½±å­ NPC æµ‹è¯•";
        public string Category => "æµ‹è¯•å·¥å…·";
        public string Description => "åœ¨ç©å®¶é™„è¿‘åˆ›å»ºæµ‹è¯•ç”¨çš„å½±å­ NPC";
        public bool IsEnabled { get; set; } = true;

        private string _npcType = "Character(Clone)";
        private float _distance = 5f;
        private float _angle = 0f;
        private string _lastCreatedId = "";
        private GameObject? _lastCreatedNpc = null;

        public void Update()
        {
            // æ¨¡å—ä¸éœ€è¦æ¯å¸§æ›´æ–°
        }

        public void OnGUI()
        {
            GUILayout.Label("=== å½±å­ NPC åˆ›å»ºæµ‹è¯• ===");

            // NPC ç±»å‹
            GUILayout.BeginHorizontal();
            GUILayout.Label("NPC ç±»å‹:", GUILayout.Width(100));
            _npcType = GUILayout.TextField(_npcType, GUILayout.Width(200));
            GUILayout.EndHorizontal();

            // è·ç¦»
            GUILayout.BeginHorizontal();
            GUILayout.Label($"è·ç¦»: {_distance:F1}m", GUILayout.Width(100));
            _distance = GUILayout.HorizontalSlider(_distance, 1f, 20f, GUILayout.Width(200));
            GUILayout.EndHorizontal();

            // è§’åº¦
            GUILayout.BeginHorizontal();
            GUILayout.Label($"è§’åº¦: {_angle:F0}Â°", GUILayout.Width(100));
            _angle = GUILayout.HorizontalSlider(_angle, 0f, 360f, GUILayout.Width(200));
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // åˆ›å»ºæŒ‰é’®
            if (GUILayout.Button("ğŸ­ åœ¨ç©å®¶é™„è¿‘åˆ›å»ºå½±å­ NPC", GUILayout.Height(30)))
            {
                CreateShadowNpcNearPlayer();
            }

            GUILayout.Space(5);

            // åˆ›å»ºå¤šä¸ªæµ‹è¯•æŒ‰é’®
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("åˆ›å»º 3 ä¸ª NPC"))
            {
                CreateMultipleShadowNpcs(3);
            }
            if (GUILayout.Button("åˆ›å»º 5 ä¸ª NPC"))
            {
                CreateMultipleShadowNpcs(5);
            }
            if (GUILayout.Button("åˆ›å»ºç¯å½¢ (8ä¸ª)"))
            {
                CreateCircleOfNpcs(8, 5f);
            }
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // æœ€ååˆ›å»ºçš„ NPC ä¿¡æ¯
            if (!string.IsNullOrEmpty(_lastCreatedId))
            {
                GUILayout.Label("=== æœ€ååˆ›å»ºçš„ NPC ===");
                GUILayout.Label($"ID: {_lastCreatedId}");
                GUILayout.Label($"çŠ¶æ€: {(_lastCreatedNpc != null ? "å­˜åœ¨" : "å·²é”€æ¯")}");

                if (_lastCreatedNpc != null)
                {
                    var pos = _lastCreatedNpc.transform.position;
                    GUILayout.Label($"ä½ç½®: ({pos.x:F2}, {pos.y:F2}, {pos.z:F2})");

                    if (GUILayout.Button("ğŸ—‘ï¸ é”€æ¯æ­¤ NPC", GUILayout.Height(25)))
                    {
                        DestroyShadowNpc();
                    }
                }
            }

            GUILayout.Space(10);

            // æ¸…ç†æ‰€æœ‰æŒ‰é’®
            GUI.backgroundColor = Color.red;
            if (GUILayout.Button("ğŸ§¹ æ¸…ç†æ‰€æœ‰å½±å­ NPC", GUILayout.Height(30)))
            {
                ClearAllShadowNpcs();
            }
            GUI.backgroundColor = Color.white;

            GUILayout.Space(5);
            GUILayout.Label($"ğŸ’¡ æç¤º: å½±å­ NPC æ²¡æœ‰ AIï¼Œä»…ç”¨äºæµ‹è¯•ç½‘ç»œåŒæ­¥");
        }

        /// <summary>
        /// åœ¨ç©å®¶é™„è¿‘åˆ›å»ºå½±å­ NPC
        /// </summary>
        private void CreateShadowNpcNearPlayer()
        {
            try
            {
                var player = GameContext.Instance.PlayerManager?.LocalPlayer;
                if (player?.CharacterObject == null)
                {
                    Debug.LogWarning("[ShadowNpcTest] æœ¬åœ°ç©å®¶ä¸å­˜åœ¨");
                    return;
                }

                // è®¡ç®—åˆ›å»ºä½ç½®ï¼ˆåŸºäºè§’åº¦å’Œè·ç¦»ï¼‰
                var playerPos = player.CharacterObject.transform.position;
                var playerRot = player.CharacterObject.transform.rotation.eulerAngles.y;
                
                float radians = (_angle + playerRot) * Mathf.Deg2Rad;
                Vector3 spawnPos = new Vector3(
                    playerPos.x + _distance * Mathf.Sin(radians),
                    playerPos.y,
                    playerPos.z + _distance * Mathf.Cos(radians)
                );

                // åˆ›å»º NPC æ•°æ®
                var npcData = new NpcSpawnData
                {
                    NpcId = Guid.NewGuid().ToString(),
                    NpcType = _npcType,
                    SceneName = player.Info?.CurrentScenelData?.SceneName ?? "",
                    SubSceneName = player.Info?.CurrentScenelData?.SubSceneName ?? "",
                    PositionX = spawnPos.x,
                    PositionY = spawnPos.y,
                    PositionZ = spawnPos.z,
                    RotationY = UnityEngine.Random.Range(0f, 360f),
                    MaxHealth = 100f
                };

                // åˆ›å»ºå½±å­ NPC
                var shadowNpc = ShadowNpcFactory.CreateShadowNpc(npcData);
                if (shadowNpc != null && shadowNpc is Component comp)
                {
                    _lastCreatedId = npcData.NpcId;
                    _lastCreatedNpc = comp.gameObject;

                    // ä¹Ÿæ·»åŠ åˆ° NpcManagerï¼ˆä½œä¸ºè¿œç¨‹ NPCï¼‰
                    GameContext.Instance.NpcManager?.AddRemoteNpc(
                        npcData.NpcId,
                        shadowNpc,
                        comp.gameObject,
                        npcData.NpcType,
                        npcData.SceneName,
                        npcData.SubSceneName
                    );

                    Debug.Log($"[ShadowNpcTest] âœ… åˆ›å»ºæˆåŠŸ: {_npcType} at ({spawnPos.x:F2}, {spawnPos.y:F2}, {spawnPos.z:F2})");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ShadowNpcTest] åˆ›å»ºå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åˆ›å»ºå¤šä¸ªå½±å­ NPC
        /// </summary>
        private void CreateMultipleShadowNpcs(int count)
        {
            for (int i = 0; i < count; i++)
            {
                _angle = UnityEngine.Random.Range(0f, 360f);
                _distance = UnityEngine.Random.Range(3f, 10f);
                CreateShadowNpcNearPlayer();
            }
        }

        /// <summary>
        /// åˆ›å»ºç¯å½¢åˆ†å¸ƒçš„ NPC
        /// </summary>
        private void CreateCircleOfNpcs(int count, float radius)
        {
            float angleStep = 360f / count;
            for (int i = 0; i < count; i++)
            {
                _angle = i * angleStep;
                _distance = radius;
                CreateShadowNpcNearPlayer();
            }
        }

        /// <summary>
        /// é”€æ¯æœ€ååˆ›å»ºçš„ NPC
        /// </summary>
        private void DestroyShadowNpc()
        {
            if (_lastCreatedNpc != null)
            {
                // ä» NpcManager ç§»é™¤
                if (!string.IsNullOrEmpty(_lastCreatedId))
                {
                    GameContext.Instance.NpcManager?.RemoveRemoteNpc(_lastCreatedId);
                }

                UnityEngine.Object.Destroy(_lastCreatedNpc);
                _lastCreatedNpc = null;
                Debug.Log("[ShadowNpcTest] å·²é”€æ¯ NPC");
            }
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰å½±å­ NPC
        /// </summary>
        private void ClearAllShadowNpcs()
        {
            try
            {
                var markers = UnityEngine.Object.FindObjectsOfType<ShadowNpcMarker>();
                int count = 0;

                foreach (var marker in markers)
                {
                    if (marker != null && marker.gameObject != null)
                    {
                        // ä» NpcManager ç§»é™¤
                        GameContext.Instance.NpcManager?.RemoveRemoteNpc(marker.NpcId);
                        
                        UnityEngine.Object.Destroy(marker.gameObject);
                        count++;
                    }
                }

                _lastCreatedNpc = null;
                _lastCreatedId = "";

                Debug.Log($"[ShadowNpcTest] å·²æ¸…ç† {count} ä¸ªå½±å­ NPC");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ShadowNpcTest] æ¸…ç†å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Core\DebugModule\Modules\WeaponInfoModule.cs`:

```cs
using System;
using System.Reflection;
using UnityEngine;
using DuckyNet.Client.Core.DebugModule;
using DuckyNet.Client.Core.Utils;
using HarmonyLib;

namespace DuckyNet.Client.Core.DebugModule.Modules
{
    /// <summary>
    /// æ­¦å™¨ä¿¡æ¯è°ƒè¯•æ¨¡å— - æ˜¾ç¤ºå½“å‰æ‰‹æŒæ­¦å™¨çš„è¯¦ç»†å‚æ•°
    /// </summary>
    public class WeaponInfoModule : IDebugModule
    {
        public string ModuleName => "æ­¦å™¨ä¿¡æ¯";
        public string Category => "ç©å®¶";
        public string Description => "æ˜¾ç¤ºå½“å‰æ‰‹æŒæ­¦å™¨çš„è¯¦ç»†å‚æ•°ï¼ˆç‰¹æ•ˆã€å­å¼¹ã€éŸ³æ•ˆç­‰ï¼‰";
        public bool IsEnabled { get; set; } = true;

        // ç¼“å­˜åå°„ä¿¡æ¯
        private static Type? _characterMainControlType;
        private static Type? _itemAgentGunType;
        private static Type? _itemSettingGunType;
        private static Type? _gameplayDataSettingsType;
        private static Type? _projectileType;
        
        private static PropertyInfo? _mainProperty;
        private static MethodInfo? _getGunMethod;
        private static PropertyInfo? _gunItemSettingProperty;
        private static FieldInfo? _shellParticleField;
        private static PropertyInfo? _muzzleProperty;
        private static PropertyInfo? _silencedProperty;

        // æ­¦å™¨ä¿¡æ¯ç¼“å­˜
        private string _weaponInfo = "ç­‰å¾…è·å–æ­¦å™¨ä¿¡æ¯...";
        private float _lastUpdateTime = 0f;
        private const float UPDATE_INTERVAL = 0.5f; // æ¯0.5ç§’æ›´æ–°ä¸€æ¬¡

        public WeaponInfoModule()
        {
            InitializeReflection();
            WeaponEffectsPlayer.Initialize();
        }

        /// <summary>
        /// åˆå§‹åŒ–åå°„ç±»å‹å’Œæ–¹æ³•
        /// </summary>
        private void InitializeReflection()
        {
            try
            {
                // è·å–ç±»å‹
                _characterMainControlType = AccessTools.TypeByName("CharacterMainControl");
                _itemAgentGunType = AccessTools.TypeByName("ItemAgent_Gun");
                _itemSettingGunType = AccessTools.TypeByName("ItemSetting_Gun");
                _gameplayDataSettingsType = AccessTools.TypeByName("GameplayDataSettings");
                _projectileType = AccessTools.TypeByName("Projectile");

                if (_characterMainControlType != null)
                {
                    // CharacterMainControl.Main (é™æ€å±æ€§)
                    _mainProperty = AccessTools.Property(_characterMainControlType, "Main");
                    
                    // CharacterMainControl.GetGun() æ–¹æ³•
                    _getGunMethod = AccessTools.Method(_characterMainControlType, "GetGun");
                }

                if (_itemAgentGunType != null)
                {
                    // ItemAgent_Gun.GunItemSetting å±æ€§
                    _gunItemSettingProperty = AccessTools.Property(_itemAgentGunType, "GunItemSetting");
                    
                    // ItemAgent_Gun.shellParticle ç§æœ‰å­—æ®µ
                    _shellParticleField = AccessTools.Field(_itemAgentGunType, "shellParticle");
                    
                    // ItemAgent_Gun.muzzle å±æ€§
                    _muzzleProperty = AccessTools.Property(_itemAgentGunType, "muzzle");
                    
                    // ItemAgent_Gun.Silenced å±æ€§
                    _silencedProperty = AccessTools.Property(_itemAgentGunType, "Silenced");
                }

                Debug.Log("[WeaponInfoModule] åå°„åˆå§‹åŒ–å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponInfoModule] åå°„åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        public void Update()
        {
            // æ¯éš”ä¸€æ®µæ—¶é—´æ›´æ–°æ­¦å™¨ä¿¡æ¯
            if (Time.time - _lastUpdateTime > UPDATE_INTERVAL)
            {
                _lastUpdateTime = Time.time;
                UpdateWeaponInfo();
            }
        }

        /// <summary>
        /// æ›´æ–°æ­¦å™¨ä¿¡æ¯
        /// </summary>
        private void UpdateWeaponInfo()
        {
            try
            {
                if (_mainProperty == null || _getGunMethod == null)
                {
                    _weaponInfo = "âŒ åå°„åˆå§‹åŒ–å¤±è´¥";
                    return;
                }

                // è·å–ä¸»è§’
                object? mainCharacter = _mainProperty.GetValue(null);
                if (mainCharacter == null)
                {
                    _weaponInfo = "âš ï¸ ä¸»è§’ä¸å­˜åœ¨ï¼ˆå¯èƒ½æœªè¿›å…¥æ¸¸æˆï¼‰";
                    return;
                }

                // è·å–å½“å‰æ‰‹æŒçš„æªæ¢°
                object? gun = _getGunMethod.Invoke(mainCharacter, null);
                if (gun == null)
                {
                    _weaponInfo = "âš ï¸ å½“å‰æœªæŒæœ‰æªæ¢°";
                    return;
                }

                // æ„å»ºæ­¦å™¨ä¿¡æ¯
                var info = new System.Text.StringBuilder();
                info.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                info.AppendLine("ğŸ”« å½“å‰æ­¦å™¨ä¿¡æ¯");
                info.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                info.AppendLine();

                // è·å– GunItemSetting
                object? gunItemSetting = _gunItemSettingProperty?.GetValue(gun);
                if (gunItemSetting != null && _itemSettingGunType != null)
                {
                    // 1. æªå£ç«ç„°ç‰¹æ•ˆ
                    var muzzleFxPfbField = AccessTools.Field(_itemSettingGunType, "muzzleFxPfb");
                    GameObject? muzzleFxPfb = muzzleFxPfbField?.GetValue(gunItemSetting) as GameObject;
                    info.AppendLine($"ğŸ”¥ æªå£ç‰¹æ•ˆ: {muzzleFxPfb?.name ?? "æ— "}");

                    // 2. å­å¼¹é¢„åˆ¶ä½“
                    var bulletPfbField = AccessTools.Field(_itemSettingGunType, "bulletPfb");
                    object? bulletPfb = bulletPfbField?.GetValue(gunItemSetting);
                    
                    if (bulletPfb == null && _gameplayDataSettingsType != null)
                    {
                        // è·å–é»˜è®¤å­å¼¹
                        var prefabsProperty = AccessTools.Property(_gameplayDataSettingsType, "Prefabs");
                        if (prefabsProperty != null)
                        {
                            object? prefabs = prefabsProperty.GetValue(null);
                            if (prefabs != null)
                            {
                                var defaultBulletField = AccessTools.Field(prefabs.GetType(), "DefaultBullet");
                                bulletPfb = defaultBulletField?.GetValue(prefabs);
                            }
                        }
                    }
                    
                    string bulletName = "æ— ";
                    if (bulletPfb != null)
                    {
                        var nameProperty = bulletPfb.GetType().GetProperty("name");
                        bulletName = nameProperty?.GetValue(bulletPfb) as string ?? bulletPfb.ToString();
                    }
                    info.AppendLine($"ğŸ’¥ å­å¼¹é¢„åˆ¶ä½“: {bulletName}");

                    // 3. éŸ³æ•ˆé…ç½®
                    var shootKeyField = AccessTools.Field(_itemSettingGunType, "shootKey");
                    var reloadKeyField = AccessTools.Field(_itemSettingGunType, "reloadKey");
                    
                    string shootKey = shootKeyField?.GetValue(gunItemSetting) as string ?? "æœªé…ç½®";
                    string reloadKey = reloadKeyField?.GetValue(gunItemSetting) as string ?? "æœªé…ç½®";
                    
                    bool isSilenced = (bool)(_silencedProperty?.GetValue(gun) ?? false);
                    string shootSoundPath = $"SFX/Combat/Gun/Shoot/{shootKey.ToLower()}";
                    if (isSilenced)
                    {
                        shootSoundPath += "_mute";
                    }
                    
                    info.AppendLine();
                    info.AppendLine("ğŸ”Š éŸ³æ•ˆé…ç½®:");
                    info.AppendLine($"  â€¢ å¼€æªéŸ³æ•ˆé”®: {shootKey}");
                    info.AppendLine($"  â€¢ å®Œæ•´è·¯å¾„: {shootSoundPath}");
                    info.AppendLine($"  â€¢ æ¢å¼¹éŸ³æ•ˆé”®: {reloadKey}");
                    info.AppendLine($"  â€¢ æ¶ˆéŸ³å™¨: {(isSilenced ? "å·²å®‰è£…" : "æœªå®‰è£…")}");
                }
                else
                {
                    info.AppendLine("âŒ æ— æ³•è·å– GunItemSetting");
                }

                info.AppendLine();

                // 4. æªå£ä½ç½®
                Transform? muzzleTransform = _muzzleProperty?.GetValue(gun) as Transform;
                if (muzzleTransform != null)
                {
                    info.AppendLine("ğŸ“ æªå£ä½ç½®:");
                    info.AppendLine($"  â€¢ ä½ç½®: {muzzleTransform.position}");
                    info.AppendLine($"  â€¢ æ–¹å‘: {muzzleTransform.forward}");
                    info.AppendLine($"  â€¢ åç§°: {muzzleTransform.name}");
                }
                else
                {
                    info.AppendLine("ğŸ“ æªå£ä½ç½®: æœªæ‰¾åˆ°");
                }

                info.AppendLine();

                // 5. å¼¹å£³ç²’å­ç³»ç»Ÿï¼ˆç§æœ‰å­—æ®µï¼Œéœ€è¦åå°„ï¼‰
                ParticleSystem? shellParticle = _shellParticleField?.GetValue(gun) as ParticleSystem;
                if (shellParticle != null)
                {
                    var main = shellParticle.main;
                    info.AppendLine("ğŸ† å¼¹å£³ç²’å­ç³»ç»Ÿ:");
                    info.AppendLine($"  â€¢ åç§°: {shellParticle.name}");
                    info.AppendLine($"  â€¢ æœ€å¤§ç²’å­æ•°: {main.maxParticles}");
                    info.AppendLine($"  â€¢ ç”Ÿå‘½å‘¨æœŸ: {main.startLifetime.constant}s");
                    info.AppendLine($"  â€¢ æ’­æ”¾çŠ¶æ€: {(shellParticle.isPlaying ? "æ’­æ”¾ä¸­" : "å·²åœæ­¢")}");
                }
                else
                {
                    info.AppendLine("ğŸ† å¼¹å£³ç²’å­: æœªé…ç½®");
                }

                info.AppendLine();

                // 6. æªæ¢°åŸºæœ¬ä¿¡æ¯
                var itemComponentField = AccessTools.Field(_itemAgentGunType, "item");
                if (itemComponentField != null)
                {
                    object? itemComponent = itemComponentField.GetValue(gun);
                    if (itemComponent != null)
                    {
                        var itemNameProperty = AccessTools.Property(itemComponent.GetType(), "ItemName");
                        string itemName = itemNameProperty?.GetValue(itemComponent) as string ?? "æœªçŸ¥";
                        
                        info.AppendLine("â„¹ï¸ æªæ¢°ä¿¡æ¯:");
                        info.AppendLine($"  â€¢ åç§°: {itemName}");
                    }
                }

                info.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

                _weaponInfo = info.ToString();
            }
            catch (Exception ex)
            {
                _weaponInfo = $"âŒ è·å–æ­¦å™¨ä¿¡æ¯å¤±è´¥:\n{ex.Message}\n\n{ex.StackTrace}";
                Debug.LogError($"[WeaponInfoModule] æ›´æ–°å¤±è´¥: {ex}");
            }
        }

        public void OnGUI()
        {
            if (!IsEnabled) return;

            GUILayout.BeginVertical("box");
            
            // æ ‡é¢˜
            GUILayout.Label("ğŸ”« æ­¦å™¨å‚æ•°æŸ¥çœ‹å™¨", new GUIStyle(GUI.skin.label)
            {
                fontSize = 16,
                fontStyle = FontStyle.Bold,
                alignment = TextAnchor.MiddleCenter
            });

            GUILayout.Space(10);

            // åˆ·æ–°æŒ‰é’®
            if (GUILayout.Button("ğŸ”„ ç«‹å³åˆ·æ–°", GUILayout.Height(30)))
            {
                UpdateWeaponInfo();
            }

            GUILayout.Space(5);

            // ç¬¬äºŒè¡Œï¼šç‰¹æ•ˆæ’­æ”¾æŒ‰é’®ç»„
            GUILayout.Label("ğŸ¬ ç‰¹æ•ˆæµ‹è¯•:", new GUIStyle(GUI.skin.label)
            {
                fontSize = 13,
                fontStyle = FontStyle.Bold
            });

            // FMOD 3D éŸ³æ•ˆè¯´æ˜
            GUILayout.Label("ğŸ’¡ æ‰€æœ‰éŸ³æ•ˆä½¿ç”¨ FMOD 3D ç©ºé—´éŸ³æ•ˆç³»ç»Ÿ", new GUIStyle(GUI.skin.label)
            {
                fontSize = 10,
                normal = { textColor = new Color(0.3f, 0.8f, 1f) },
                fontStyle = FontStyle.Italic
            });
            GUILayout.Label("   â€¢ éŸ³é‡éšè·ç¦»è¡°å‡ â€¢ å£°éŸ³æ–¹å‘æ€§ â€¢ å®æ—¶ä½ç½®æ›´æ–°", new GUIStyle(GUI.skin.label)
            {
                fontSize = 9,
                normal = { textColor = new Color(0.6f, 0.6f, 0.6f) }
            });

            GUILayout.Space(3);

            GUILayout.BeginHorizontal();
            
            // æ’­æ”¾æªå£ç«ç„°
            if (GUILayout.Button("ğŸ”¥ æªå£ç«ç„°", GUILayout.Height(35)))
            {
                WeaponEffectsPlayer.PlayMuzzleFlash();
            }

            // æ’­æ”¾å¼¹å£³æŠ›å‡º
            if (GUILayout.Button("ğŸ† å¼¹å£³æŠ›å‡º", GUILayout.Height(35)))
            {
                WeaponEffectsPlayer.PlayShellEjection();
            }

            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();

            // æ’­æ”¾å¼€æªéŸ³æ•ˆ
            if (GUILayout.Button("ğŸ”Š å¼€æªéŸ³æ•ˆ (3D)", GUILayout.Height(35)))
            {
                WeaponEffectsPlayer.PlayShootSound();
            }

            // åˆ›å»ºå­å¼¹
            var oldBgColor = GUI.backgroundColor;
            GUI.backgroundColor = new Color(1f, 0.5f, 0.3f); // æ©™è‰²è­¦å‘Š
            
            if (GUILayout.Button("ğŸ’¥ åˆ›å»ºå­å¼¹", GUILayout.Height(35)))
            {
                WeaponEffectsPlayer.CreateBullet();
            }
            
            GUI.backgroundColor = oldBgColor;

            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();

            // æ’­æ”¾å®Œæ•´ç‰¹æ•ˆï¼ˆä¸å«å­å¼¹ï¼‰
            oldBgColor = GUI.backgroundColor;
            GUI.backgroundColor = new Color(0.3f, 0.8f, 1f); // è“è‰²ï¼ˆå®‰å…¨ï¼‰
            
            if (GUILayout.Button("âœ¨ å®Œæ•´ç‰¹æ•ˆ (æ— å­å¼¹)", GUILayout.Height(35)))
            {
                WeaponEffectsPlayer.PlayFullFireEffects(includeBullet: false);
            }
            
            GUI.backgroundColor = oldBgColor;

            // æ’­æ”¾å®Œæ•´ç‰¹æ•ˆï¼ˆå«å­å¼¹ï¼‰
            GUI.backgroundColor = new Color(1f, 0.3f, 0.3f); // çº¢è‰²è­¦å‘Š
            
            if (GUILayout.Button("âš ï¸ å®Œæ•´ç‰¹æ•ˆ (å«å­å¼¹)", GUILayout.Height(35)))
            {
                WeaponEffectsPlayer.PlayFullFireEffects(includeBullet: true);
            }
            
            GUI.backgroundColor = oldBgColor;

            GUILayout.EndHorizontal();

            // å­å¼¹è­¦å‘Šæç¤º
            GUILayout.Label("âš ï¸ å«å­å¼¹çš„ç‰¹æ•ˆä¼šé€ æˆçœŸå®ä¼¤å®³ï¼Œè¯·è°¨æ…ä½¿ç”¨ï¼", new GUIStyle(GUI.skin.label)
            {
                fontSize = 9,
                normal = { textColor = new Color(1f, 0.3f, 0.3f) },
                fontStyle = FontStyle.Bold
            });

            GUILayout.Space(5);

            // æ˜¾ç¤ºæ­¦å™¨ä¿¡æ¯ï¼ˆä½¿ç”¨æ»šåŠ¨è§†å›¾ï¼‰
            GUILayout.BeginVertical("box");
            GUILayout.Label(_weaponInfo, new GUIStyle(GUI.skin.label)
            {
                fontSize = 12,
                wordWrap = false,
                richText = true
            });
            GUILayout.EndVertical();

            GUILayout.Space(5);

            // åº•éƒ¨æç¤º
            GUILayout.Label($"è‡ªåŠ¨æ›´æ–°é—´éš”: {UPDATE_INTERVAL}ç§’", new GUIStyle(GUI.skin.label)
            {
                fontSize = 10,
                alignment = TextAnchor.MiddleRight,
                normal = { textColor = Color.gray }
            });

            GUILayout.EndVertical();
        }
    }
}


```

`Client\Core\EventBus\EventBus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace DuckyNet.Client.Core.EventBus
{
    /// <summary>
    /// å…¨å±€äº‹ä»¶æ€»çº¿
    /// æä¾›ç»Ÿä¸€çš„äº‹ä»¶å‘å¸ƒ/è®¢é˜…æœºåˆ¶ï¼Œå®ç°ç³»ç»Ÿé—´çš„è§£è€¦é€šä¿¡
    /// </summary>
    public class EventBus : IDisposable
    {
        private static EventBus? _instance;
        
        /// <summary>
        /// å…¨å±€å®ä¾‹
        /// </summary>
        public static EventBus Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new EventBus();
                }
                return _instance;
            }
        }

        /// <summary>
        /// äº‹ä»¶è®¢é˜…å­—å…¸ï¼šäº‹ä»¶ç±»å‹ -> è®¢é˜…è€…åˆ—è¡¨
        /// </summary>
        private readonly Dictionary<Type, List<WeakReference>> _subscribers = new Dictionary<Type, List<WeakReference>>();

        /// <summary>
        /// é”å¯¹è±¡ï¼Œç”¨äºçº¿ç¨‹å®‰å…¨
        /// </summary>
        private readonly object _lock = new object();

        /// <summary>
        /// æ˜¯å¦å¯ç”¨è¯¦ç»†æ—¥å¿—ï¼ˆè°ƒè¯•ç”¨ï¼‰
        /// </summary>
        public bool EnableVerboseLogging { get; set; } = false;

        private EventBus()
        {
        }

        /// <summary>
        /// è®¢é˜…äº‹ä»¶
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="handler">äº‹ä»¶å¤„ç†å™¨</param>
        public void Subscribe<TEvent>(Action<TEvent> handler) where TEvent : class
        {
            if (handler == null)
                throw new ArgumentNullException(nameof(handler));

            lock (_lock)
            {
                var eventType = typeof(TEvent);
                if (!_subscribers.ContainsKey(eventType))
                {
                    _subscribers[eventType] = new List<WeakReference>();
                }

                // ä½¿ç”¨ WeakReference é¿å…å†…å­˜æ³„æ¼
                _subscribers[eventType].Add(new WeakReference(handler));
                
                if (EnableVerboseLogging)
                {
                    Debug.Log($"[EventBus] è®¢é˜…äº‹ä»¶: {eventType.Name}, å½“å‰è®¢é˜…è€…æ•°: {_subscribers[eventType].Count}");
                }
            }
        }

        /// <summary>
        /// å–æ¶ˆè®¢é˜…äº‹ä»¶
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="handler">äº‹ä»¶å¤„ç†å™¨</param>
        public void Unsubscribe<TEvent>(Action<TEvent> handler) where TEvent : class
        {
            if (handler == null)
                return;

            lock (_lock)
            {
                var eventType = typeof(TEvent);
                if (!_subscribers.ContainsKey(eventType))
                    return;

                var subscribers = _subscribers[eventType];
                var toRemove = subscribers
                    .Where(wr => (wr.IsAlive && Equals(wr.Target, handler)) || !wr.IsAlive)
                    .ToList();

                foreach (var wr in toRemove)
                {
                    subscribers.Remove(wr);
                }

                // å¦‚æœæ²¡æœ‰è®¢é˜…è€…äº†ï¼Œç§»é™¤äº‹ä»¶ç±»å‹
                if (subscribers.Count == 0)
                {
                    _subscribers.Remove(eventType);
                }
                
                if (EnableVerboseLogging)
                {
                    Debug.Log($"[EventBus] å–æ¶ˆè®¢é˜…äº‹ä»¶: {eventType.Name}, å‰©ä½™è®¢é˜…è€…æ•°: {subscribers.Count}");
                }
            }
        }

        /// <summary>
        /// å‘å¸ƒäº‹ä»¶
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="eventData">äº‹ä»¶æ•°æ®</param>
        public void Publish<TEvent>(TEvent eventData) where TEvent : class
        {
            if (eventData == null)
            {
                Debug.LogWarning("[EventBus] å°è¯•å‘å¸ƒç©ºäº‹ä»¶ï¼Œå·²å¿½ç•¥");
                return;
            }

            var eventType = typeof(TEvent);
            List<WeakReference>? subscribers = null;

            lock (_lock)
            {
                if (!_subscribers.ContainsKey(eventType))
                {
                    if (EnableVerboseLogging)
                    {
                        Debug.LogWarning($"[EventBus] å‘å¸ƒäº‹ä»¶å¤±è´¥: {eventType.Name} - æ²¡æœ‰è®¢é˜…è€…");
                    }
                    return;
                }

                // å¤åˆ¶è®¢é˜…è€…åˆ—è¡¨ï¼Œé¿å…åœ¨è¿­ä»£æ—¶ä¿®æ”¹
                subscribers = _subscribers[eventType].ToList();
                
                #if UNITY_EDITOR || DEBUG_EVENTBUS
                if (EnableVerboseLogging)
                {
                    Debug.Log($"[EventBus] å‘å¸ƒäº‹ä»¶: {eventType.Name}, è®¢é˜…è€…æ•°: {subscribers.Count}");
                }
                #endif
            }

            // åœ¨é”å¤–æ‰§è¡Œå›è°ƒï¼Œé¿å…æ­»é”
            var deadRefs = new List<WeakReference>();
            int handlerCount = 0;
            int successCount = 0;
            
            foreach (var weakRef in subscribers)
            {
                if (!weakRef.IsAlive)
                {
                    deadRefs.Add(weakRef);
                    continue;
                }

                var handler = weakRef.Target as Action<TEvent>;
                if (handler != null)
                {
                    try
                    {
                        handlerCount++;
                        #if UNITY_EDITOR || DEBUG_EVENTBUS
                        if (EnableVerboseLogging)
                        {
                            Debug.Log($"[EventBus] è°ƒç”¨äº‹ä»¶å¤„ç†å™¨ #{handlerCount} ({eventType.Name})");
                        }
                        #endif
                        handler(eventData);
                        successCount++;
                    }
                    catch (Exception ex)
                    {
                        Debug.LogError($"[EventBus] äº‹ä»¶å¤„ç†å¼‚å¸¸ ({eventType.Name}): {ex.Message}");
                        Debug.LogException(ex);
                    }
                }
                else
                {
                    deadRefs.Add(weakRef);
                }
            }

            // æ¸…ç†æ­»å¼•ç”¨
            if (deadRefs.Count > 0)
            {
                CleanupDeadReferences(eventType, deadRefs);
            }

            #if UNITY_EDITOR || DEBUG_EVENTBUS
            if (EnableVerboseLogging)
            {
                Debug.Log($"[EventBus] äº‹ä»¶ {eventType.Name} å‘å¸ƒå®Œæˆ: æˆåŠŸ {successCount}/{handlerCount}, æ¸…ç†æ­»å¼•ç”¨ {deadRefs.Count}");
            }
            #endif
        }

        /// <summary>
        /// æ¸…ç†æ­»å¼•ç”¨
        /// </summary>
        private void CleanupDeadReferences(Type eventType, List<WeakReference> deadRefs)
        {
            lock (_lock)
            {
                if (_subscribers.ContainsKey(eventType))
                {
                    foreach (var deadRef in deadRefs)
                    {
                        _subscribers[eventType].Remove(deadRef);
                    }

                    if (_subscribers[eventType].Count == 0)
                    {
                        _subscribers.Remove(eventType);
                    }
                }
            }
        }

        /// <summary>
        /// å¼‚æ­¥å‘å¸ƒäº‹ä»¶ï¼ˆä¸ç­‰å¾…å®Œæˆï¼‰
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="eventData">äº‹ä»¶æ•°æ®</param>
        public void PublishAsync<TEvent>(TEvent eventData) where TEvent : class
        {
            System.Threading.Tasks.Task.Run(() => Publish(eventData));
        }

        /// <summary>
        /// è·å–æŒ‡å®šäº‹ä»¶ç±»å‹çš„è®¢é˜…è€…æ•°é‡ï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰
        /// </summary>
        public int GetSubscriberCount<TEvent>() where TEvent : class
        {
            lock (_lock)
            {
                var eventType = typeof(TEvent);
                if (!_subscribers.ContainsKey(eventType))
                    return 0;

                return _subscribers[eventType].Count(wr => wr.IsAlive);
            }
        }

        /// <summary>
        /// è·å–æ‰€æœ‰äº‹ä»¶ç±»å‹ï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰
        /// </summary>
        public IEnumerable<Type> GetRegisteredEventTypes()
        {
            lock (_lock)
            {
                return _subscribers.Keys.ToList();
            }
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰æ­»å¼•ç”¨
        /// </summary>
        public void CleanupAllDeadReferences()
        {
            lock (_lock)
            {
                var eventTypesToRemove = new List<Type>();
                
                foreach (var kvp in _subscribers)
                {
                    var deadRefs = kvp.Value.Where(wr => !wr.IsAlive).ToList();
                    foreach (var deadRef in deadRefs)
                    {
                        kvp.Value.Remove(deadRef);
                    }
                    
                    if (kvp.Value.Count == 0)
                    {
                        eventTypesToRemove.Add(kvp.Key);
                    }
                }
                
                foreach (var eventType in eventTypesToRemove)
                {
                    _subscribers.Remove(eventType);
                }
                
                if (eventTypesToRemove.Count > 0 && EnableVerboseLogging)
                {
                    Debug.Log($"[EventBus] æ¸…ç†å®Œæˆï¼Œç§»é™¤ {eventTypesToRemove.Count} ä¸ªç©ºäº‹ä»¶ç±»å‹");
                }
            }
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰è®¢é˜…ï¼ˆç”¨äºæµ‹è¯•å’Œé‡ç½®ï¼‰
        /// </summary>
        public void Clear()
        {
            lock (_lock)
            {
                _subscribers.Clear();
                Debug.Log("[EventBus] å·²æ¸…ç©ºæ‰€æœ‰è®¢é˜…");
            }
        }

        public void Dispose()
        {
            Clear();
            _instance = null;
        }
    }
}


```

`Client\Core\EventBus\EventSubscriberHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace DuckyNet.Client.Core.EventBus
{
    /// <summary>
    /// EventBus è®¢é˜…è¾…åŠ©ç±» - ç»Ÿä¸€ç®¡ç†äº‹ä»¶è®¢é˜…ï¼Œå‡å°‘æ ·æ¿ä»£ç 
    /// </summary>
    public class EventSubscriberHelper : IDisposable
    {
        private EventBus? _eventBus;
        private readonly List<IDisposableSubscription> _subscriptions = new List<IDisposableSubscription>();
        private bool _isDisposed = false;

        /// <summary>
        /// è·å– EventBus å®ä¾‹ï¼ˆè‡ªåŠ¨åˆå§‹åŒ–ï¼‰
        /// </summary>
        public EventBus EventBus
        {
            get
            {
                if (_eventBus == null && GameContext.IsInitialized)
                {
                    _eventBus = GameContext.Instance.EventBus;
                }
                return _eventBus ?? throw new InvalidOperationException("EventBus æœªåˆå§‹åŒ–ï¼ŒGameContext å¯èƒ½å°šæœªåˆå§‹åŒ–");
            }
        }

        /// <summary>
        /// æ˜¯å¦å·²åˆå§‹åŒ–
        /// </summary>
        public bool IsInitialized => _eventBus != null;

        /// <summary>
        /// è®¢é˜…äº‹ä»¶æ•°é‡
        /// </summary>
        public int SubscriptionCount => _subscriptions.Count;

        /// <summary>
        /// è®¢é˜…äº‹ä»¶ï¼ˆè‡ªåŠ¨ç®¡ç†ï¼Œå¦‚æœ GameContext æœªåˆå§‹åŒ–åˆ™å»¶è¿Ÿè®¢é˜…ï¼‰
        /// </summary>
        public void Subscribe<TEvent>(Action<TEvent> handler) where TEvent : class
        {
            if (_isDisposed)
            {
                Debug.LogWarning("[EventSubscriberHelper] å°è¯•åœ¨å·²é‡Šæ”¾çš„ Helper ä¸Šè®¢é˜…äº‹ä»¶ï¼Œå·²å¿½ç•¥");
                return;
            }

            if (handler == null)
            {
                Debug.LogWarning("[EventSubscriberHelper] å°è¯•è®¢é˜…ç©ºå¤„ç†å™¨ï¼Œå·²å¿½ç•¥");
                return;
            }

            try
            {
                // å¦‚æœ GameContext å·²åˆå§‹åŒ–ï¼Œç«‹å³è®¢é˜…
                if (GameContext.IsInitialized)
                {
                    var eventBus = GameContext.Instance.EventBus;
                    eventBus.Subscribe(handler);
                    _subscriptions.Add(new Subscription<TEvent>(eventBus, handler));
                    Debug.Log($"[EventSubscriberHelper] å·²è®¢é˜…äº‹ä»¶: {typeof(TEvent).Name}");
                }
                else
                {
                    // å¦‚æœæœªåˆå§‹åŒ–ï¼Œå…ˆä¿å­˜ handlerï¼Œç¨åé€šè¿‡ EnsureInitializedAndSubscribe è®¢é˜…
                    Debug.LogWarning($"[EventSubscriberHelper] GameContext æœªåˆå§‹åŒ–ï¼Œå·²ä¿å­˜è®¢é˜…è¯·æ±‚ {typeof(TEvent).Name}ï¼Œè¯·ç¨åè°ƒç”¨ EnsureInitializedAndSubscribe");
                    _subscriptions.Add(new PendingSubscription<TEvent>(handler));
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EventSubscriberHelper] è®¢é˜…äº‹ä»¶å¤±è´¥ {typeof(TEvent).Name}: {ex.Message}");
            }
        }

        /// <summary>
        /// ç¡®ä¿å·²åˆå§‹åŒ–å¹¶å®Œæˆæ‰€æœ‰å¾…å¤„ç†çš„è®¢é˜…
        /// </summary>
        public void EnsureInitializedAndSubscribe()
        {
            if (_isDisposed)
            {
                Debug.LogWarning("[EventSubscriberHelper] å°è¯•åœ¨å·²é‡Šæ”¾çš„ Helper ä¸Šåˆå§‹åŒ–è®¢é˜…ï¼Œå·²å¿½ç•¥");
                return;
            }

            if (!GameContext.IsInitialized)
            {
                Debug.LogWarning("[EventSubscriberHelper] GameContext ä»æœªåˆå§‹åŒ–ï¼Œæ— æ³•å®Œæˆè®¢é˜…");
                return;
            }

            var eventBus = GameContext.Instance.EventBus;
            _eventBus = eventBus;

            // å¤„ç†æ‰€æœ‰å¾…å¤„ç†çš„è®¢é˜…
            int processedCount = 0;
            for (int i = _subscriptions.Count - 1; i >= 0; i--)
            {
                if (_subscriptions[i] is PendingSubscription pending)
                {
                    var subscription = pending.Subscribe(eventBus);
                    if (subscription != null)
                    {
                        _subscriptions[i] = subscription;
                        processedCount++;
                    }
                    else
                    {
                        _subscriptions.RemoveAt(i);
                    }
                }
            }

            if (processedCount > 0)
            {
                Debug.Log($"[EventSubscriberHelper] å·²å®Œæˆ {processedCount} ä¸ªå¾…å¤„ç†è®¢é˜…");
            }
        }

        /// <summary>
        /// ç¡®ä¿å·²åˆå§‹åŒ–ï¼ˆç”¨äºå»¶è¿Ÿåˆå§‹åŒ–ï¼‰
        /// </summary>
        public void EnsureInitialized()
        {
            if (_eventBus == null && GameContext.IsInitialized)
            {
                _eventBus = GameContext.Instance.EventBus;
            }
        }

        /// <summary>
        /// å–æ¶ˆæ‰€æœ‰è®¢é˜…
        /// </summary>
        public void UnsubscribeAll()
        {
            foreach (var subscription in _subscriptions)
            {
                try
                {
                    subscription.Dispose();
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[EventSubscriberHelper] å–æ¶ˆè®¢é˜…å¤±è´¥: {ex.Message}");
                }
            }
            _subscriptions.Clear();
            Debug.Log("[EventSubscriberHelper] å·²å–æ¶ˆæ‰€æœ‰è®¢é˜…");
        }

        public void Dispose()
        {
            if (_isDisposed)
                return;

            UnsubscribeAll();
            _eventBus = null;
            _isDisposed = true;
        }

        // å†…éƒ¨æ¥å£ï¼šå¯å–æ¶ˆçš„è®¢é˜…
        private interface IDisposableSubscription : IDisposable { }

        // æŠ½è±¡åŸºç±»ï¼šå¾…å¤„ç†çš„è®¢é˜…
        private abstract class PendingSubscription : IDisposableSubscription
        {
            public abstract IDisposableSubscription? Subscribe(EventBus eventBus);
            public void Dispose() { } // å¾…å¤„ç†çš„è®¢é˜…ä¸éœ€è¦å–æ¶ˆ
        }

        // å…·ä½“ç±»ï¼šå¾…å¤„ç†çš„ç±»å‹åŒ–è®¢é˜…
        private class PendingSubscription<TEvent> : PendingSubscription where TEvent : class
        {
            private readonly Action<TEvent> _handler;

            public PendingSubscription(Action<TEvent> handler)
            {
                _handler = handler;
            }

            public override IDisposableSubscription? Subscribe(EventBus eventBus)
            {
                try
                {
                    eventBus.Subscribe(_handler);
                    return new Subscription<TEvent>(eventBus, _handler);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[EventSubscriberHelper] å»¶è¿Ÿè®¢é˜…å¤±è´¥ {typeof(TEvent).Name}: {ex.Message}");
                    return null;
                }
            }
        }

        // å†…éƒ¨ç±»ï¼šç±»å‹åŒ–çš„è®¢é˜…
        private class Subscription<TEvent> : IDisposableSubscription where TEvent : class
        {
            private readonly EventBus _eventBus;
            private readonly Action<TEvent> _handler;

            public Subscription(EventBus eventBus, Action<TEvent> handler)
            {
                _eventBus = eventBus;
                _handler = handler;
            }

            public void Dispose()
            {
                _eventBus.Unsubscribe(_handler);
            }
        }
    }
}


```

`Client\Core\EventBus\Events\AllEvents.cs`:

```cs
// ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰äº‹ä»¶ç±»å‹ï¼Œæ–¹ä¾¿å…¶ä»–æ¨¡å—å¼•ç”¨
// ä½¿ç”¨æ–¹å¼ï¼šusing DuckyNet.Client.Core.EventBus.Events;

// æ­¤æ–‡ä»¶ä»…ç”¨äºæ–‡æ¡£è¯´æ˜ï¼Œæ‰€æœ‰äº‹ä»¶ç±»å‹å·²åœ¨å„è‡ªçš„æ–‡ä»¶ä¸­å®šä¹‰
// 
// äº‹ä»¶åˆ†ç±»ï¼š
// - NetworkEvents.cs: ç½‘ç»œç›¸å…³äº‹ä»¶
// - SceneEvents.cs: åœºæ™¯ç›¸å…³äº‹ä»¶  
// - RoomEvents.cs: æˆ¿é—´ç›¸å…³äº‹ä»¶
// - PlayerEvents.cs: ç©å®¶ç›¸å…³äº‹ä»¶
// - CharacterEvents.cs: è§’è‰²ç›¸å…³äº‹ä»¶
// - SyncEvents.cs: åŒæ­¥ç›¸å…³äº‹ä»¶
// - ChatEvents.cs: èŠå¤©ç›¸å…³äº‹ä»¶

namespace DuckyNet.Client.Core.EventBus.Events
{
    // æ­¤å‘½åç©ºé—´åŒ…å«æ‰€æœ‰äº‹ä»¶å®šä¹‰
    // å¯ä»¥ç›´æ¥ using æ­¤å‘½åç©ºé—´æ¥è®¿é—®æ‰€æœ‰äº‹ä»¶ç±»å‹
}


```

`Client\Core\EventBus\Events\CharacterEvents.cs`:

```cs
using UnityEngine;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// è§’è‰²åˆ›å»ºå®Œæˆäº‹ä»¶
    /// </summary>
    public class CharacterCreatedEvent
    {
        public string SteamId { get; }
        public GameObject? Character { get; }
        
        public CharacterCreatedEvent(string steamId, GameObject? character)
        {
            SteamId = steamId;
            Character = character;
        }
    }

    /// <summary>
    /// ä¸»è§’è‰²åˆ›å»ºå®Œæˆäº‹ä»¶ï¼ˆæœ¬åœ°ç©å®¶è§’è‰²åˆ›å»ºå®Œæˆï¼‰
    /// </summary>
    public class MainCharacterCreatedEvent
    {
        public GameObject Character { get; }
        
        public MainCharacterCreatedEvent(GameObject character)
        {
            Character = character;
        }
    }

    /// <summary>
    /// åˆ›å»ºè¿œç¨‹è§’è‰²è¯·æ±‚äº‹ä»¶
    /// </summary>
    public class CreateRemoteCharacterRequestEvent
    {
        public string PlayerId { get; }
        
        public CreateRemoteCharacterRequestEvent(string playerId)
        {
            PlayerId = playerId;
        }
    }

    /// <summary>
    /// è¿œç¨‹è§’è‰²å·²åˆ›å»ºäº‹ä»¶
    /// </summary>
    public class RemoteCharacterCreatedEvent
    {
        public string PlayerId { get; }
        public GameObject? Character { get; }
        
        public RemoteCharacterCreatedEvent(string playerId, GameObject? character)
        {
            PlayerId = playerId;
            Character = character;
        }
    }

    /// <summary>
    /// ç©å®¶å¤–è§‚æ›´æ–°äº‹ä»¶
    /// </summary>
    public class PlayerAppearanceUpdatedEvent
    {
        public string SteamId { get; }
        public byte[] AppearanceData { get; }
        
        public PlayerAppearanceUpdatedEvent(string steamId, byte[] appearanceData)
        {
            SteamId = steamId;
            AppearanceData = appearanceData;
        }
    }

    /// <summary>
    /// è§’è‰²å¤–è§‚æ•°æ®æ¥æ”¶äº‹ä»¶
    /// </summary>
    public class CharacterAppearanceReceivedEvent
    {
        public string SteamId { get; }
        public byte[] AppearanceData { get; }
        
        public CharacterAppearanceReceivedEvent(string steamId, byte[] appearanceData)
        {
            SteamId = steamId;
            AppearanceData = appearanceData;
        }
    }
}


```

`Client\Core\EventBus\Events\CharacterLifecycleEvents.cs`:

```cs
using UnityEngine;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// å•ä½ï¼ˆæ€ªç‰©/NPCï¼‰åˆ›å»ºäº‹ä»¶
    /// å½“åœºæ™¯ä¸­ç”Ÿæˆæ–°çš„ CharacterMainControl æ—¶è§¦å‘
    /// </summary>
    public class CharacterSpawnedEvent
    {
        /// <summary>
        /// è§’è‰²æ§åˆ¶å™¨
        /// </summary>
        public object CharacterMainControl { get; }
        
        /// <summary>
        /// è§’è‰² GameObjectï¼ˆå¯èƒ½ä¸º nullï¼‰
        /// </summary>
        public GameObject? GameObject { get; }
        
        /// <summary>
        /// å…¨å±€å”¯ä¸€ IDï¼ˆæ ¼å¼ï¼š{ClientId}-{Sequence}-{InstanceId}ï¼‰
        /// </summary>
        public string CharacterId { get; }

        public CharacterSpawnedEvent(object characterMainControl, GameObject? gameObject, string characterId)
        {
            CharacterMainControl = characterMainControl;
            GameObject = gameObject;
            CharacterId = characterId;
        }
    }

    /// <summary>
    /// å•ä½é”€æ¯äº‹ä»¶
    /// å½“ CharacterMainControl è¢«é”€æ¯æ—¶è§¦å‘
    /// </summary>
    public class CharacterDestroyedEvent
    {
        /// <summary>
        /// è§’è‰²æ§åˆ¶å™¨
        /// </summary>
        public object CharacterMainControl { get; }
        
        /// <summary>
        /// è§’è‰² GameObjectï¼ˆå¯èƒ½ä¸º nullï¼‰
        /// </summary>
        public GameObject? GameObject { get; }
        
        /// <summary>
        /// è§’è‰² ID
        /// </summary>
        public string CharacterId { get; }

        public CharacterDestroyedEvent(object characterMainControl, GameObject? gameObject, string characterId)
        {
            CharacterMainControl = characterMainControl;
            GameObject = gameObject;
            CharacterId = characterId;
        }
    }

    /// <summary>
    /// å•ä½æ­»äº¡äº‹ä»¶
    /// å½“ Health ç»„ä»¶è§¦å‘æ­»äº¡æ—¶è§¦å‘ï¼ˆç”Ÿå‘½å€¼ä¸º0ï¼‰
    /// </summary>
    public class CharacterDeathEvent
    {
        /// <summary>
        /// Health ç»„ä»¶
        /// </summary>
        public object Health { get; }
        
        /// <summary>
        /// ä¼¤å®³ä¿¡æ¯
        /// </summary>
        public object DamageInfo { get; }
        
        /// <summary>
        /// è§’è‰²æ§åˆ¶å™¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        /// </summary>
        public object? CharacterMainControl { get; }
        
        /// <summary>
        /// è§’è‰² GameObject
        /// </summary>
        public GameObject? GameObject { get; }
        
        /// <summary>
        /// è§’è‰² IDï¼ˆä¸åˆ›å»º/é”€æ¯äº‹ä»¶ç›¸åŒçš„IDï¼‰
        /// </summary>
        public string CharacterId { get; }

        public CharacterDeathEvent(object health, object damageInfo, object? characterMainControl, GameObject? gameObject, string characterId)
        {
            Health = health;
            DamageInfo = damageInfo;
            CharacterMainControl = characterMainControl;
            GameObject = gameObject;
            CharacterId = characterId;
        }
    }
}


```

`Client\Core\EventBus\Events\ChatEvents.cs`:

```cs
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// èŠå¤©æ¶ˆæ¯æ¥æ”¶äº‹ä»¶
    /// å½“æœåŠ¡å™¨è½¬å‘å…¶ä»–ç©å®¶å‘é€çš„èŠå¤©æ¶ˆæ¯æ—¶è§¦å‘æ­¤äº‹ä»¶
    /// </summary>
    public class ChatMessageReceivedEvent
    {
        /// <summary>
        /// å‘é€æ¶ˆæ¯çš„ç©å®¶ä¿¡æ¯
        /// </summary>
        public PlayerInfo Sender { get; }
        
        /// <summary>
        /// èŠå¤©æ¶ˆæ¯å†…å®¹
        /// </summary>
        public string Message { get; }
        
        public ChatMessageReceivedEvent(PlayerInfo sender, string message)
        {
            Sender = sender;
            Message = message;
        }
    }
}


```

`Client\Core\EventBus\Events\DamageEvents.cs`:

```cs
using UnityEngine;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// ä¼¤å®³åº”ç”¨å‰äº‹ä»¶
    /// å…è®¸åœ¨ä¼¤å®³è®¡ç®—å‰ä¿®æ”¹ä¼¤å®³å€¼ã€æš´å‡»ç‡ã€æŠ¤ç”²ç©¿é€ç­‰å‚æ•°
    /// </summary>
    public class BeforeDamageAppliedEvent
    {
        /// <summary>
        /// Health ç»„ä»¶å®ä¾‹
        /// </summary>
        public object Health { get; }

        /// <summary>
        /// åŸå§‹ DamageInfo å¯¹è±¡ï¼ˆåªè¯»å‚è€ƒï¼‰
        /// </summary>
        public object OriginalDamageInfo { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ GameObjectï¼ˆå¯èƒ½ä¸º nullï¼‰
        /// </summary>
        public GameObject? TargetGameObject { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ CharacterMainControlï¼ˆå¯èƒ½ä¸º nullï¼‰
        /// </summary>
        public object? TargetCharacter { get; }

        /// <summary>
        /// è§’è‰² IDï¼ˆå¦‚æœå·²æ³¨å†Œï¼‰
        /// </summary>
        public int? CharacterId { get; }



        // ===== å¯ä¿®æ”¹çš„ä¼¤å®³å‚æ•° =====

        /// <summary>
        /// åŸºç¡€ä¼¤å®³å€¼ï¼ˆå¯ä¿®æ”¹ï¼‰
        /// </summary>
        public float DamageValue { get; set; }

        /// <summary>
        /// æ˜¯å¦å¿½ç•¥æŠ¤ç”²ï¼ˆå¯ä¿®æ”¹ï¼‰
        /// </summary>
        public bool IgnoreArmor { get; set; }

        /// <summary>
        /// æ˜¯å¦å¿½ç•¥éš¾åº¦ç³»æ•°ï¼ˆå¯ä¿®æ”¹ï¼‰
        /// </summary>
        public bool IgnoreDifficulty { get; set; }

        /// <summary>
        /// æš´å‡»ç‡ï¼ˆå¯ä¿®æ”¹ï¼ŒèŒƒå›´ 0-1ï¼‰
        /// </summary>
        public float CritRate { get; set; }

        /// <summary>
        /// æš´å‡»ä¼¤å®³å€ç‡ï¼ˆå¯ä¿®æ”¹ï¼‰
        /// </summary>
        public float CritDamageFactor { get; set; }

        /// <summary>
        /// æŠ¤ç”²ç©¿é€ï¼ˆå¯ä¿®æ”¹ï¼‰
        /// </summary>
        public float ArmorPiercing { get; set; }

        /// <summary>
        /// æ˜¯å¦å–æ¶ˆä¼¤å®³ï¼ˆè®¾ç½®ä¸º true å°†å®Œå…¨é˜»æ­¢ä¼¤å®³ï¼‰
        /// </summary>
        public bool CancelDamage { get; set; }

        public BeforeDamageAppliedEvent(
            object health,
            object originalDamageInfo,
            GameObject? targetGameObject,
            object? targetCharacter,
            int? characterId,
            float damageValue,
            bool ignoreArmor,
            bool ignoreDifficulty,
            float critRate,
            float critDamageFactor,
            float armorPiercing)
        {
            Health = health;
            OriginalDamageInfo = originalDamageInfo;
            TargetGameObject = targetGameObject;
            TargetCharacter = targetCharacter;
            CharacterId = characterId;
            DamageValue = damageValue;
            IgnoreArmor = ignoreArmor;
            IgnoreDifficulty = ignoreDifficulty;
            CritRate = critRate;
            CritDamageFactor = critDamageFactor;
            ArmorPiercing = armorPiercing;
            CancelDamage = false;
        }
    }

    /// <summary>
    /// ä¼¤å®³åº”ç”¨åäº‹ä»¶
    /// åœ¨ä¼¤å®³å·²åº”ç”¨åè§¦å‘ï¼Œç”¨äºç»Ÿè®¡ã€æ—¥å¿—ç­‰
    /// </summary>
    public class AfterDamageAppliedEvent
    {
        /// <summary>
        /// Health ç»„ä»¶å®ä¾‹
        /// </summary>
        public object Health { get; }

        /// <summary>
        /// DamageInfo å¯¹è±¡
        /// </summary>
        public object DamageInfo { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ GameObject
        /// </summary>
        public GameObject? TargetGameObject { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ CharacterMainControl
        /// </summary>
        public object? TargetCharacter { get; }

        /// <summary>
        /// è§’è‰² ID
        /// </summary>
        public int? CharacterId { get; }

        /// <summary>
        /// æ˜¯å¦æ˜¯è¿œç¨‹ç©å®¶
        /// </summary>
        public bool IsRemotePlayer { get; }

        /// <summary>
        /// æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        public bool IsLocalPlayer { get; }

        /// <summary>
        /// å®é™…é€ æˆçš„ä¼¤å®³å€¼
        /// </summary>
        public float ActualDamage { get; }

        /// <summary>
        /// å‰©ä½™ç”Ÿå‘½å€¼
        /// </summary>
        public float RemainingHealth { get; }

        /// <summary>
        /// æ˜¯å¦å¯¼è‡´æ­»äº¡
        /// </summary>
        public bool CausedDeath { get; }

        public AfterDamageAppliedEvent(
            object health,
            object damageInfo,
            GameObject? targetGameObject,
            object? targetCharacter,
            int? characterId,
            bool isRemotePlayer,
            bool isLocalPlayer,
            float actualDamage,
            float remainingHealth,
            bool causedDeath)
        {
            Health = health;
            DamageInfo = damageInfo;
            TargetGameObject = targetGameObject;
            TargetCharacter = targetCharacter;
            CharacterId = characterId;
            IsRemotePlayer = isRemotePlayer;
            IsLocalPlayer = isLocalPlayer;
            ActualDamage = actualDamage;
            RemainingHealth = remainingHealth;
            CausedDeath = causedDeath;
        }
    }

    /// <summary>
    /// è§’è‰²è¡€é‡å˜åŒ–äº‹ä»¶
    /// </summary>
    public class HealthChangedEvent
    {
        /// <summary>
        /// Health ç»„ä»¶å®ä¾‹
        /// </summary>
        public object Health { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ GameObject
        /// </summary>
        public GameObject? TargetGameObject { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ CharacterMainControl
        /// </summary>
        public object? TargetCharacter { get; }

        /// <summary>
        /// æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        public bool IsLocalPlayer { get; }

        /// <summary>
        /// å½“å‰è¡€é‡
        /// </summary>
        public float CurrentHealth { get; }

        /// <summary>
        /// æœ€å¤§è¡€é‡
        /// </summary>
        public float MaxHealth { get; }

        public HealthChangedEvent(
            object health,
            GameObject? targetGameObject,
            object? targetCharacter,
            bool isLocalPlayer,
            float currentHealth,
            float maxHealth)
        {
            Health = health;
            TargetGameObject = targetGameObject;
            TargetCharacter = targetCharacter;
            IsLocalPlayer = isLocalPlayer;
            CurrentHealth = currentHealth;
            MaxHealth = maxHealth;
        }
    }

    /// <summary>
    /// è§’è‰²æœ€å¤§è¡€é‡å˜åŒ–äº‹ä»¶
    /// </summary>
    public class MaxHealthChangedEvent
    {
        /// <summary>
        /// Health ç»„ä»¶å®ä¾‹
        /// </summary>
        public object Health { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ GameObject
        /// </summary>
        public GameObject? TargetGameObject { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ CharacterMainControl
        /// </summary>
        public object? TargetCharacter { get; }

        /// <summary>
        /// æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        public bool IsLocalPlayer { get; }

        /// <summary>
        /// æ–°çš„æœ€å¤§è¡€é‡
        /// </summary>
        public float MaxHealth { get; }

        public MaxHealthChangedEvent(
            object health,
            GameObject? targetGameObject,
            object? targetCharacter,
            bool isLocalPlayer,
            float maxHealth)
        {
            Health = health;
            TargetGameObject = targetGameObject;
            TargetCharacter = targetCharacter;
            IsLocalPlayer = isLocalPlayer;
            MaxHealth = maxHealth;
        }
    }

    /// <summary>
    /// è§’è‰²å—ä¼¤äº‹ä»¶
    /// </summary>
    public class CharacterHurtEvent
    {
        /// <summary>
        /// Health ç»„ä»¶å®ä¾‹
        /// </summary>
        public object Health { get; }

        /// <summary>
        /// DamageInfo å¯¹è±¡
        /// </summary>
        public object DamageInfo { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ GameObject
        /// </summary>
        public GameObject? TargetGameObject { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ CharacterMainControl
        /// </summary>
        public object? TargetCharacter { get; }

        /// <summary>
        /// æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        public bool IsLocalPlayer { get; }

        /// <summary>
        /// å½“å‰è¡€é‡
        /// </summary>
        public float CurrentHealth { get; }

        /// <summary>
        /// æœ€å¤§è¡€é‡
        /// </summary>
        public float MaxHealth { get; }

        public CharacterHurtEvent(
            object health,
            object damageInfo,
            GameObject? targetGameObject,
            object? targetCharacter,
            bool isLocalPlayer,
            float currentHealth,
            float maxHealth)
        {
            Health = health;
            DamageInfo = damageInfo;
            TargetGameObject = targetGameObject;
            TargetCharacter = targetCharacter;
            IsLocalPlayer = isLocalPlayer;
            CurrentHealth = currentHealth;
            MaxHealth = maxHealth;
        }
    }

    /// <summary>
    /// è§’è‰²æ­»äº¡äº‹ä»¶
    /// </summary>
    public class CharacterDeadEvent
    {
        /// <summary>
        /// Health ç»„ä»¶å®ä¾‹
        /// </summary>
        public object Health { get; }

        /// <summary>
        /// DamageInfo å¯¹è±¡
        /// </summary>
        public object DamageInfo { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ GameObject
        /// </summary>
        public GameObject? TargetGameObject { get; }

        /// <summary>
        /// å—ä¼¤è§’è‰²çš„ CharacterMainControl
        /// </summary>
        public object? TargetCharacter { get; }

        /// <summary>
        /// æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        public bool IsLocalPlayer { get; }

        public CharacterDeadEvent(
            object health,
            object damageInfo,
            GameObject? targetGameObject,
            object? targetCharacter,
            bool isLocalPlayer)
        {
            Health = health;
            DamageInfo = damageInfo;
            TargetGameObject = targetGameObject;
            TargetCharacter = targetCharacter;
            IsLocalPlayer = isLocalPlayer;
        }
    }

    /// <summary>
    /// è¿œç¨‹ç©å®¶è¡€é‡åŒæ­¥äº‹ä»¶
    /// </summary>
    public class RemotePlayerHealthSyncEvent
    {
        /// <summary>
        /// è¡€é‡åŒæ­¥æ•°æ®
        /// </summary>
        public Shared.Data.HealthSyncData HealthData { get; }

        public RemotePlayerHealthSyncEvent(Shared.Data.HealthSyncData healthData)
        {
            HealthData = healthData;
        }
    }
}


```

`Client\Core\EventBus\Events\EquipmentEvents.cs`:

```cs
using EquipmentSlotType = DuckyNet.Shared.Data.EquipmentSlotType;

namespace DuckyNet.Client.Core.EventBus.Events
{
    // ä½¿ç”¨ Shared ä¸­å®šä¹‰çš„ EquipmentSlotTypeï¼Œé¿å…é‡å¤å®šä¹‰

    /// <summary>
    /// è£…å¤‡æ§½ä½å˜æ›´äº‹ä»¶åŸºç±»
    /// å½“æœ¬åœ°ç©å®¶çš„è£…å¤‡è¢«è£…å¤‡æˆ–å¸ä¸‹æ—¶è§¦å‘
    /// 
    /// ğŸ¯ ä½œç”¨åŸŸï¼š
    /// - ä»…é’ˆå¯¹æœ¬åœ°ç©å®¶ï¼ˆä¸»è§’è‰²ï¼‰çš„è£…å¤‡å˜æ›´
    /// - ä¸ä¼šè§¦å‘å…¶ä»–ç©å®¶æˆ–NPCçš„è£…å¤‡äº‹ä»¶
    /// 
    /// âš ï¸ é‡è¦æç¤ºï¼š
    /// - æ­¤äº‹ä»¶æŒæœ‰å¯¹æ¸¸æˆå¯¹è±¡çš„å¼•ç”¨ï¼Œè®¢é˜…è€…åº”ç«‹å³å¤„ç†äº‹ä»¶ï¼Œé¿å…é•¿æœŸæŒæœ‰å¼•ç”¨
    /// - Slot å’Œ EquippedItem å¯¹è±¡å¯èƒ½åœ¨äº‹ä»¶å¤„ç†åè¢«é”€æ¯ï¼Œä¸è¦åœ¨å¼‚æ­¥æ“ä½œä¸­ä½¿ç”¨
    /// - è®¢é˜…è€…åº”åœ¨ä¸å†éœ€è¦æ—¶å–æ¶ˆè®¢é˜…ï¼Œé¿å…å†…å­˜æ³„æ¼
    /// - äº‹ä»¶åœ¨æ¸¸æˆä¸»çº¿ç¨‹è§¦å‘ï¼Œå¤„ç†é€»è¾‘åº”é¿å…é˜»å¡æ“ä½œ
    /// 
    /// ğŸ“– ä½¿ç”¨ç¤ºä¾‹ï¼š
    /// <code>
    /// GameContext.Instance.EventBus.Subscribe&lt;ArmorSlotChangedEvent&gt;(evt =>
    /// {
    ///     if (evt.EquippedItem is UnityEngine.Object item)
    ///     {
    ///         Debug.Log($"æœ¬åœ°ç©å®¶è£…å¤‡äº†: {item.name}");
    ///     }
    /// });
    /// </code>
    /// </summary>
    public class EquipmentSlotChangedEvent
    {
        /// <summary>æ§½ä½ç±»å‹</summary>
        public EquipmentSlotType SlotType { get; }

        /// <summary>æ§½ä½å¯¹è±¡ (ItemStatsSystem.Items.Slotï¼Œå¯èƒ½ä¸º null)</summary>
        public object? Slot { get; }

        /// <summary>è£…å¤‡çš„ç‰©å“ (ItemStatsSystem.Items.Itemï¼Œnullè¡¨ç¤ºå¸ä¸‹)</summary>
        public object? EquippedItem { get; }

        /// <summary>æ˜¯å¦æ˜¯è£…å¤‡æ“ä½œï¼ˆfalseè¡¨ç¤ºå¸ä¸‹ï¼‰</summary>
        public bool IsEquipped => EquippedItem != null;

        /// <summary>è£…å¤‡æ§åˆ¶å™¨å®ä¾‹ (CharacterEquipmentController)</summary>
        public object EquipmentController { get; }

        public EquipmentSlotChangedEvent(
            EquipmentSlotType slotType,
            object? slot,
            object? equippedItem,
            object equipmentController)
        {
            SlotType = slotType;
            Slot = slot;
            EquippedItem = equippedItem;
            EquipmentController = equipmentController;
        }
    }

    /// <summary>
    /// æŠ¤ç”²æ§½ä½å˜æ›´äº‹ä»¶
    /// </summary>
    public class ArmorSlotChangedEvent : EquipmentSlotChangedEvent
    {
        public ArmorSlotChangedEvent(object? slot, object? equippedItem, object equipmentController)
            : base(EquipmentSlotType.Armor, slot, equippedItem, equipmentController)
        {
        }
    }

    /// <summary>
    /// å¤´ç›”æ§½ä½å˜æ›´äº‹ä»¶
    /// </summary>
    public class HelmetSlotChangedEvent : EquipmentSlotChangedEvent
    {
        public HelmetSlotChangedEvent(object? slot, object? equippedItem, object equipmentController)
            : base(EquipmentSlotType.Helmet, slot, equippedItem, equipmentController)
        {
        }
    }

    /// <summary>
    /// é¢ç½©æ§½ä½å˜æ›´äº‹ä»¶
    /// </summary>
    public class FaceMaskSlotChangedEvent : EquipmentSlotChangedEvent
    {
        public FaceMaskSlotChangedEvent(object? slot, object? equippedItem, object equipmentController)
            : base(EquipmentSlotType.FaceMask, slot, equippedItem, equipmentController)
        {
        }
    }

    /// <summary>
    /// èƒŒåŒ…æ§½ä½å˜æ›´äº‹ä»¶
    /// </summary>
    public class BackpackSlotChangedEvent : EquipmentSlotChangedEvent
    {
        public BackpackSlotChangedEvent(object? slot, object? equippedItem, object equipmentController)
            : base(EquipmentSlotType.Backpack, slot, equippedItem, equipmentController)
        {
        }
    }

    /// <summary>
    /// è€³æœºæ§½ä½å˜æ›´äº‹ä»¶
    /// </summary>
    public class HeadsetSlotChangedEvent : EquipmentSlotChangedEvent
    {
        public HeadsetSlotChangedEvent(object? slot, object? equippedItem, object equipmentController)
            : base(EquipmentSlotType.Headset, slot, equippedItem, equipmentController)
        {
        }
    }
}


```

`Client\Core\EventBus\Events\NetworkEvents.cs`:

```cs
namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// ç½‘ç»œè¿æ¥æˆåŠŸäº‹ä»¶
    /// </summary>
    public class NetworkConnectedEvent
    {
        public static NetworkConnectedEvent Instance { get; } = new NetworkConnectedEvent();
        private NetworkConnectedEvent() { }
    }

    /// <summary>
    /// ç½‘ç»œæ–­å¼€è¿æ¥äº‹ä»¶
    /// </summary>
    public class NetworkDisconnectedEvent
    {
        public string Reason { get; }
        
        public NetworkDisconnectedEvent(string reason)
        {
            Reason = reason;
        }
    }

    /// <summary>
    /// ç½‘ç»œè¿æ¥å¤±è´¥äº‹ä»¶
    /// </summary>
    public class NetworkConnectionFailedEvent
    {
        public string Reason { get; }
        
        public NetworkConnectionFailedEvent(string reason)
        {
            Reason = reason;
        }
    }
}


```

`Client\Core\EventBus\Events\PlayerEvents.cs`:

```cs
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// ç©å®¶åŠ å…¥æ¸¸æˆäº‹ä»¶
    /// å½“æœ‰æ–°ç©å®¶æˆåŠŸç™»å½•åŠ å…¥æ¸¸æˆæ—¶è§¦å‘æ­¤äº‹ä»¶
    /// </summary>
    public class PlayerJoinedEvent
    {
        /// <summary>
        /// åŠ å…¥æ¸¸æˆçš„ç©å®¶ä¿¡æ¯
        /// </summary>
        public PlayerInfo Player { get; }
        
        public PlayerJoinedEvent(PlayerInfo player)
        {
            Player = player;
        }
    }

    /// <summary>
    /// ç©å®¶ç¦»å¼€æ¸¸æˆäº‹ä»¶
    /// å½“ç©å®¶ç™»å‡ºæˆ–æ–­å¼€è¿æ¥æ—¶è§¦å‘æ­¤äº‹ä»¶
    /// </summary>
    public class PlayerLeftEvent
    {
        /// <summary>
        /// ç¦»å¼€æ¸¸æˆçš„ç©å®¶ä¿¡æ¯
        /// </summary>
        public PlayerInfo Player { get; }
        
        public PlayerLeftEvent(PlayerInfo player)
        {
            Player = player;
        }
    }
}


```

`Client\Core\EventBus\Events\RoomEvents.cs`:

```cs
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// åŠ å…¥æˆ¿é—´äº‹ä»¶ï¼ˆè‡ªå·±çš„åŠ å…¥äº‹ä»¶ï¼‰
    /// </summary>
    public class RoomJoinedEvent
    {
        public PlayerInfo Player { get; }
        public RoomInfo Room { get; }
        
        public RoomJoinedEvent(PlayerInfo player, RoomInfo room)
        {
            Player = player;
            Room = room;
        }
    }

    /// <summary>
    /// ç¦»å¼€æˆ¿é—´äº‹ä»¶ï¼ˆè‡ªå·±çš„ç¦»å¼€äº‹ä»¶ï¼‰
    /// </summary>
    public class RoomLeftEvent
    {
        public PlayerInfo Player { get; }
        public RoomInfo Room { get; }
        
        public RoomLeftEvent(PlayerInfo player, RoomInfo room)
        {
            Player = player;
            Room = room;
        }
    }
    /// <summary>
    /// è¢«è¸¢å‡ºæˆ¿é—´äº‹ä»¶
    /// </summary>
    public class KickedFromRoomEvent
    {
        public string Reason { get; }
        
        public KickedFromRoomEvent(string reason)
        {
            Reason = reason;
        }
    }

    /// <summary>
    /// ç©å®¶åŠ å…¥æˆ¿é—´äº‹ä»¶ï¼ˆå…¶ä»–ç©å®¶åŠ å…¥æˆ¿é—´ï¼‰
    /// </summary>
    public class PlayerJoinedRoomEvent
    {
        public PlayerInfo Player { get; }
        public RoomInfo Room { get; }
        
        public PlayerJoinedRoomEvent(PlayerInfo player, RoomInfo room)
        {
            Player = player;
            Room = room;
        }
    }

    /// <summary>
    /// ç©å®¶ç¦»å¼€æˆ¿é—´äº‹ä»¶ï¼ˆå…¶ä»–ç©å®¶ç¦»å¼€æˆ¿é—´ï¼‰
    /// </summary>
    public class PlayerLeftRoomEvent
    {
        public PlayerInfo Player { get; }
        public RoomInfo Room { get; }
        
        public PlayerLeftRoomEvent(PlayerInfo player, RoomInfo room)
        {
            Player = player;
            Room = room;
        }
    }
}


```

`Client\Core\EventBus\Events\SceneEvents.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// åœºæ™¯åŠ è½½å®Œæˆäº‹ä»¶ï¼ˆåŒ…å«å­åœºæ™¯IDï¼‰
    /// </summary>
    public class SceneLoadedDetailEvent
    {
        public ScenelData ScenelData { get; }
        
        public SceneLoadedDetailEvent(ScenelData scenelData)
        {
            ScenelData = scenelData;
        }
    }

    /// <summary>
    /// åœºæ™¯å¸è½½äº‹ä»¶ï¼ˆåŒ…å«å­åœºæ™¯IDï¼‰
    /// </summary>
    public class SceneUnloadingDetailEvent
    {
        public ScenelData ScenelData { get; }
        
        public SceneUnloadingDetailEvent(ScenelData scenelData)
        {
            ScenelData = scenelData;
        }
    }

    /// <summary>
    /// ç½‘ç»œé€šçŸ¥ç©å®¶è¿›å…¥åœºæ™¯äº‹ä»¶
    /// </summary>
    public class PlayerEnteredSceneEvent
    {
        public PlayerInfo PlayerInfo { get; }
        public ScenelData ScenelData { get; }
        
        public PlayerEnteredSceneEvent(PlayerInfo playerInfo, ScenelData scenelData)
        {
            PlayerInfo = playerInfo;
            ScenelData = scenelData;
        }
    }

    /// <summary>
    /// ç½‘ç»œé€šçŸ¥ç©å®¶ç¦»å¼€åœºæ™¯äº‹ä»¶
    /// </summary>
    public class PlayerLeftSceneEvent
    {
        public PlayerInfo PlayerInfo { get; }
        public ScenelData ScenelData { get; }
        
        public PlayerLeftSceneEvent(PlayerInfo playerInfo, ScenelData scenelData)
        {
            PlayerInfo = playerInfo;
            ScenelData = scenelData;
        }
    }
}


```

`Client\Core\EventBus\Events\SyncEvents.cs`:

```cs
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// è¯·æ±‚å¯åŠ¨åŒæ­¥äº‹ä»¶
    /// </summary>
    public class SyncStartRequestEvent
    {
        public static SyncStartRequestEvent Instance { get; } = new SyncStartRequestEvent();
        private SyncStartRequestEvent() { }
    }

    /// <summary>
    /// è¯·æ±‚åœæ­¢åŒæ­¥äº‹ä»¶
    /// </summary>
    public class SyncStopRequestEvent
    {
        public static SyncStopRequestEvent Instance { get; } = new SyncStopRequestEvent();
        private SyncStopRequestEvent() { }
    }

    /// <summary>
    /// ç©å®¶ä½ç½®åŒæ­¥äº‹ä»¶
    /// å½“æ¥æ”¶åˆ°å…¶ä»–ç©å®¶çš„ä½ç½®åŒæ­¥æ•°æ®æ—¶è§¦å‘æ­¤äº‹ä»¶
    /// </summary>
    public class PlayerUnitySyncEvent
    {
        /// <summary>
        /// å…¶ä»–ç©å®¶çš„ä½ç½®åŒæ­¥æ•°æ®ï¼ˆåŒ…å«ä½ç½®ã€æ—‹è½¬ã€é€Ÿåº¦ç­‰ï¼‰
        /// </summary>
        public UnitySyncData SyncData { get; }
        public string SteamID { get; }

        public PlayerUnitySyncEvent(string steamID, UnitySyncData syncData)
        {
            SteamID = steamID;
            SyncData = syncData;
        }
    }

    /// <summary>
    /// è¿œç¨‹ç©å®¶åŠ¨ç”»æ›´æ–°äº‹ä»¶
    /// å½“æ¥æ”¶åˆ°å…¶ä»–ç©å®¶çš„åŠ¨ç”»åŒæ­¥æ•°æ®æ—¶è§¦å‘æ­¤äº‹ä»¶
    /// </summary>
    public class RemoteAnimatorUpdateEvent
    {
        /// <summary>
        /// ç©å®¶ID
        /// </summary>
        public string PlayerId { get; }
        
        /// <summary>
        /// åŠ¨ç”»åŒæ­¥æ•°æ®
        /// </summary>
        public AnimatorSyncData AnimatorData { get; }

        public RemoteAnimatorUpdateEvent(string playerId, AnimatorSyncData animatorData)
        {
            PlayerId = playerId;
            AnimatorData = animatorData;
        }
    }
}


```

`Client\Core\EventBus\Events\WeaponEvents.cs`:

```cs
using UnityEngine;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// æœ¬åœ°ç©å®¶å¼€æªäº‹ä»¶
    /// å½“ä¸»è§’å¼€æªæ—¶è§¦å‘ï¼ˆè®¢é˜…è‡ª ItemAgent_Gun.OnMainCharacterShootEventï¼‰
    /// </summary>
    public class LocalPlayerShootEvent
    {
        /// <summary>
        /// æªæ¢°å¯¹è±¡ï¼ˆItemAgent_Gunï¼‰
        /// </summary>
        public object Gun { get; }
        
        /// <summary>
        /// æªå£ä½ç½®
        /// </summary>
        public Vector3 MuzzlePosition { get; }
        
        /// <summary>
        /// å°„å‡»æ–¹å‘ï¼ˆæªå£æœå‘ï¼‰
        /// </summary>
        public Vector3 ShootDirection { get; }
        
        /// <summary>
        /// æªå£ Transform
        /// </summary>
        public Transform? Muzzle { get; }

        public LocalPlayerShootEvent(object gun, Vector3 muzzlePosition, Vector3 shootDirection, Transform? muzzle)
        {
            Gun = gun;
            MuzzlePosition = muzzlePosition;
            ShootDirection = shootDirection;
            Muzzle = muzzle;
        }
    }
}


```

`Client\Core\EventBus\Events\WeaponSyncEvents.cs`:

```cs
using ItemStatsSystem;
using ItemStatsSystem.Items;
using WeaponSlotType = DuckyNet.Shared.Data.WeaponSlotType;

namespace DuckyNet.Client.Core.EventBus.Events
{
    /// <summary>
    /// æ­¦å™¨æ§½ä½å˜åŒ–äº‹ä»¶
    /// å½“æœ¬åœ°ç©å®¶çš„æ­¦å™¨è¢«è£…å¤‡æˆ–å¸ä¸‹æ—¶è§¦å‘
    /// 
    /// ğŸ¯ ä½œç”¨åŸŸï¼š
    /// - ä»…é’ˆå¯¹æœ¬åœ°ç©å®¶ï¼ˆä¸»è§’è‰²ï¼‰çš„æ­¦å™¨å˜æ›´
    /// - ä¸ä¼šè§¦å‘å…¶ä»–ç©å®¶æˆ–NPCçš„æ­¦å™¨äº‹ä»¶
    /// 
    /// âš ï¸ é‡è¦æç¤ºï¼š
    /// - æ­¤äº‹ä»¶æŒæœ‰å¯¹æ¸¸æˆå¯¹è±¡çš„å¼•ç”¨ï¼Œè®¢é˜…è€…åº”ç«‹å³å¤„ç†äº‹ä»¶
    /// - Weapon å¯¹è±¡å¯èƒ½åœ¨äº‹ä»¶å¤„ç†åè¢«é”€æ¯ï¼Œä¸è¦åœ¨å¼‚æ­¥æ“ä½œä¸­ä½¿ç”¨
    /// - è®¢é˜…è€…åº”åœ¨ä¸å†éœ€è¦æ—¶å–æ¶ˆè®¢é˜…ï¼Œé¿å…å†…å­˜æ³„æ¼
    /// </summary>
    public class WeaponSlotChangedEvent
    {
        /// <summary>æ§½ä½å¯¹è±¡</summary>
        public object? Slot { get; }

        /// <summary>æ­¦å™¨ç‰©å“ï¼ˆnullè¡¨ç¤ºå¸ä¸‹ï¼‰</summary>
        public object? Weapon { get; }

        /// <summary>æ§½ä½ç±»å‹æšä¸¾</summary>
        public WeaponSlotType SlotType { get; }

        /// <summary>æ§½ä½ç±»å‹åç§°ï¼ˆä¸­æ–‡ï¼‰</summary>
        public string SlotTypeName { get; }

        /// <summary>æ˜¯å¦æ˜¯è£…å¤‡æ“ä½œï¼ˆfalseè¡¨ç¤ºå¸ä¸‹ï¼‰</summary>
        public bool IsEquipped { get; }

        public WeaponSlotChangedEvent(
            object? slot,
            object? weapon,
            WeaponSlotType slotType,
            string slotTypeName,
            bool isEquipped)
        {
            Slot = slot;
            Weapon = weapon;
            SlotType = slotType;
            SlotTypeName = slotTypeName;
            IsEquipped = isEquipped;
        }
    }
}


```

`Client\Core\EventBus\README.md`:

```md
# EventBus æ¨¡å—

## æ¦‚è¿°

EventBus æ˜¯ DuckyNet çš„å…¨å±€äº‹ä»¶æ€»çº¿ç³»ç»Ÿï¼Œæä¾›ç»Ÿä¸€çš„äº‹ä»¶å‘å¸ƒ/è®¢é˜…æœºåˆ¶ï¼Œå®ç°ç³»ç»Ÿé—´çš„è§£è€¦é€šä¿¡ã€‚

## ç›®å½•ç»“æ„

```
EventBus/
â”œâ”€â”€ EventBus.cs                 # æ ¸å¿ƒäº‹ä»¶æ€»çº¿ç±»
â”œâ”€â”€ EventSubscriberHelper.cs    # è®¢é˜…è¾…åŠ©ç±»ï¼ˆç®€åŒ–è®¢é˜…ç®¡ç†ï¼‰
â”œâ”€â”€ Events/                     # äº‹ä»¶å®šä¹‰ç›®å½•
â”‚   â”œâ”€â”€ NetworkEvents.cs        # ç½‘ç»œç›¸å…³äº‹ä»¶
â”‚   â”œâ”€â”€ SceneEvents.cs          # åœºæ™¯ç›¸å…³äº‹ä»¶
â”‚   â”œâ”€â”€ RoomEvents.cs           # æˆ¿é—´ç›¸å…³äº‹ä»¶
â”‚   â”œâ”€â”€ PlayerEvents.cs         # ç©å®¶ç›¸å…³äº‹ä»¶
â”‚   â”œâ”€â”€ CharacterEvents.cs      # è§’è‰²ç›¸å…³äº‹ä»¶
â”‚   â”œâ”€â”€ SyncEvents.cs           # åŒæ­¥ç›¸å…³äº‹ä»¶
â”‚   â”œâ”€â”€ ChatEvents.cs           # èŠå¤©ç›¸å…³äº‹ä»¶
â”‚   â””â”€â”€ AllEvents.cs            # äº‹ä»¶ç´¢å¼•æ–‡æ¡£
â””â”€â”€ README.md                   # æœ¬æ–‡æ¡£
```

## ä½¿ç”¨æ–¹æ³•

### 1. å¼•ç”¨å‘½åç©ºé—´

```csharp
using DuckyNet.Client.Core.EventBus;           // EventBus æ ¸å¿ƒç±»
using DuckyNet.Client.Core.EventBus.Events;    // æ‰€æœ‰äº‹ä»¶ç±»å‹
```

### 2. è®¢é˜…äº‹ä»¶

#### æ–¹å¼ä¸€ï¼šä½¿ç”¨ EventSubscriberHelperï¼ˆæ¨èï¼‰

```csharp
public class MyManager : IDisposable
{
    private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
    
    public MyManager()
    {
        // ç¡®ä¿å·²åˆå§‹åŒ–
        _eventSubscriber.EnsureInitializedAndSubscribe();
        
        // è®¢é˜…äº‹ä»¶
        _eventSubscriber.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
        _eventSubscriber.Subscribe<ChatMessageReceivedEvent>(OnChatMessage);
    }
    
    private void OnPlayerJoined(PlayerJoinedEvent evt)
    {
        Debug.Log($"ç©å®¶åŠ å…¥: {evt.Player.SteamName}");
    }
    
    private void OnChatMessage(ChatMessageReceivedEvent evt)
    {
        Debug.Log($"[{evt.Sender.SteamName}]: {evt.Message}");
    }
    
    public void Dispose()
    {
        // è‡ªåŠ¨å–æ¶ˆæ‰€æœ‰è®¢é˜…
        _eventSubscriber?.Dispose();
    }
}
```

#### æ–¹å¼äºŒï¼šç›´æ¥ä½¿ç”¨ EventBus

```csharp
public void SubscribeEvents()
{
    var eventBus = GameContext.Instance.EventBus;
    eventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
}

public void UnsubscribeEvents()
{
    var eventBus = GameContext.Instance.EventBus;
    eventBus.Unsubscribe<PlayerJoinedEvent>(OnPlayerJoined);
}
```

### 3. å‘å¸ƒäº‹ä»¶

```csharp
// å‘å¸ƒäº‹ä»¶
GameContext.Instance.EventBus.Publish(new PlayerJoinedEvent(playerInfo));

// å¼‚æ­¥å‘å¸ƒï¼ˆä¸ç­‰å¾…å®Œæˆï¼‰
GameContext.Instance.EventBus.PublishAsync(new ChatMessageReceivedEvent(sender, message));
```

## äº‹ä»¶åˆ†ç±»

### ç½‘ç»œäº‹ä»¶ (NetworkEvents.cs)
- `NetworkConnectedEvent` - ç½‘ç»œè¿æ¥æˆåŠŸ
- `NetworkDisconnectedEvent` - ç½‘ç»œæ–­å¼€è¿æ¥
- `NetworkConnectionFailedEvent` - ç½‘ç»œè¿æ¥å¤±è´¥

### åœºæ™¯äº‹ä»¶ (SceneEvents.cs)
- `SceneLoadedDetailEvent` - åœºæ™¯åŠ è½½å®Œæˆ
- `SceneUnloadingDetailEvent` - åœºæ™¯å¸è½½
- `PlayerEnteredSceneEvent` - ç©å®¶è¿›å…¥åœºæ™¯
- `PlayerLeftSceneEvent` - ç©å®¶ç¦»å¼€åœºæ™¯

### æˆ¿é—´äº‹ä»¶ (RoomEvents.cs)
- `RoomJoinedEvent` - è‡ªå·±åŠ å…¥æˆ¿é—´
- `RoomLeftEvent` - è‡ªå·±ç¦»å¼€æˆ¿é—´
- `PlayerJoinedRoomEvent` - å…¶ä»–ç©å®¶åŠ å…¥æˆ¿é—´
- `PlayerLeftRoomEvent` - å…¶ä»–ç©å®¶ç¦»å¼€æˆ¿é—´
- `KickedFromRoomEvent` - è¢«è¸¢å‡ºæˆ¿é—´

### ç©å®¶äº‹ä»¶ (PlayerEvents.cs)
- `PlayerJoinedEvent` - ç©å®¶åŠ å…¥æ¸¸æˆ
- `PlayerLeftEvent` - ç©å®¶ç¦»å¼€æ¸¸æˆ

### è§’è‰²äº‹ä»¶ (CharacterEvents.cs)
- `CharacterCreatedEvent` - è§’è‰²åˆ›å»ºå®Œæˆ
- `MainCharacterCreatedEvent` - ä¸»è§’è‰²åˆ›å»ºå®Œæˆ
- `CreateRemoteCharacterRequestEvent` - åˆ›å»ºè¿œç¨‹è§’è‰²è¯·æ±‚
- `RemoteCharacterCreatedEvent` - è¿œç¨‹è§’è‰²å·²åˆ›å»º
- `PlayerAppearanceUpdatedEvent` - ç©å®¶å¤–è§‚æ›´æ–°
- `CharacterAppearanceReceivedEvent` - è§’è‰²å¤–è§‚æ•°æ®æ¥æ”¶

### åŒæ­¥äº‹ä»¶ (SyncEvents.cs)
- `SyncStartRequestEvent` - è¯·æ±‚å¯åŠ¨åŒæ­¥
- `SyncStopRequestEvent` - è¯·æ±‚åœæ­¢åŒæ­¥
- `PlayerUnitySyncEvent` - ç©å®¶ä½ç½®åŒæ­¥
- `RemoteAnimatorUpdateEvent` - è¿œç¨‹ç©å®¶åŠ¨ç”»æ›´æ–°

### èŠå¤©äº‹ä»¶ (ChatEvents.cs)
- `ChatMessageReceivedEvent` - èŠå¤©æ¶ˆæ¯æ¥æ”¶

### å•ä½ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ (CharacterLifecycleEvents.cs)
- `CharacterSpawnedEvent` - å•ä½ï¼ˆæ€ªç‰©/NPCï¼‰åˆ›å»º
- `CharacterDestroyedEvent` - å•ä½é”€æ¯
- `CharacterDeathEvent` - å•ä½æ­»äº¡ï¼ˆç”Ÿå‘½å€¼ä¸º0ï¼‰

## è®¾è®¡ç‰¹ç‚¹

1. **è§£è€¦é€šä¿¡**: é€šè¿‡äº‹ä»¶æ€»çº¿å®ç°ç³»ç»Ÿé—´çš„æ¾è€¦åˆé€šä¿¡
2. **å¼±å¼•ç”¨ç®¡ç†**: ä½¿ç”¨ WeakReference é¿å…å†…å­˜æ³„æ¼
3. **çº¿ç¨‹å®‰å…¨**: æ”¯æŒå¤šçº¿ç¨‹ç¯å¢ƒ
4. **è‡ªåŠ¨æ¸…ç†**: EventSubscriberHelper è‡ªåŠ¨ç®¡ç†è®¢é˜…ç”Ÿå‘½å‘¨æœŸ
5. **åˆ†ç±»ç»„ç»‡**: äº‹ä»¶æŒ‰åŠŸèƒ½åˆ†ç±»åˆ°ä¸åŒæ–‡ä»¶ï¼Œæ˜“äºç»´æŠ¤

## æœ€ä½³å®è·µ

1. **ä½¿ç”¨ EventSubscriberHelper**: æ¨èä½¿ç”¨ EventSubscriberHelper æ¥ç®¡ç†è®¢é˜…ï¼Œå®ƒä¼šè‡ªåŠ¨å¤„ç†å–æ¶ˆè®¢é˜…
2. **åŠæ—¶å–æ¶ˆè®¢é˜…**: åœ¨å¯¹è±¡é”€æ¯æ—¶åŠ¡å¿…å–æ¶ˆè®¢é˜…ï¼Œé¿å…å†…å­˜æ³„æ¼
3. **å¼‚å¸¸å¤„ç†**: äº‹ä»¶å¤„ç†å™¨ä¸­çš„å¼‚å¸¸ä¼šè¢«æ•è·å¹¶è®°å½•ï¼Œä¸ä¼šå½±å“å…¶ä»–è®¢é˜…è€…
4. **é¿å…å¾ªç¯ä¾èµ–**: ä¸è¦åœ¨äº‹ä»¶å¤„ç†å™¨ä¸­å‘å¸ƒä¼šå¯¼è‡´å¾ªç¯çš„äº‹ä»¶
5. **å‘½åè§„èŒƒ**: äº‹ä»¶åç§°åº”æ¸…æ™°æè¿°äº‹ä»¶å†…å®¹ï¼Œä½¿ç”¨ Event åç¼€

## è¿ç§»æŒ‡å—

ä»æ—§çš„äº‹ä»¶ç³»ç»Ÿè¿ç§»ï¼š

1. å°† `using DuckyNet.Client.Core;` æ”¹ä¸ºï¼š
   ```csharp
   using DuckyNet.Client.Core.EventBus;
   using DuckyNet.Client.Core.EventBus.Events;
   ```

2. EventBus ç±»å‹å¼•ç”¨éœ€è¦å®Œå…¨é™å®šï¼š
   ```csharp
   // æ—§ä»£ç 
   public EventBus EventBus { get; private set; }
   
   // æ–°ä»£ç 
   public EventBus.EventBus EventBus { get; private set; }
   ```

3. EventSubscriberHelper å¼•ç”¨ä¸éœ€è¦æ”¹å˜ï¼Œä½†éœ€è¦æ·»åŠ å‘½åç©ºé—´ï¼š
   ```csharp
   using DuckyNet.Client.Core.EventBus;
   ```


```

`Client\Core\GameContext.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core.Players;
using EventBusCore = DuckyNet.Client.Core.EventBus.EventBus;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// æ¸¸æˆä¸Šä¸‹æ–‡ - å…¨å±€æœåŠ¡å®¹å™¨
    /// ä½¿ç”¨ Service Locator æ¨¡å¼ç®¡ç†æ‰€æœ‰æ ¸å¿ƒæœåŠ¡
    /// </summary>
    public class GameContext
    {
        private static GameContext? _instance;
        
        /// <summary>
        /// å…¨å±€å®ä¾‹
        /// </summary>
        public static GameContext Instance
        {
            get
            {
                if (_instance == null)
                {
                    throw new InvalidOperationException("GameContext æœªåˆå§‹åŒ–ï¼è¯·å…ˆè°ƒç”¨ Initialize()");
                }
                return _instance;
            }
        }

        /// <summary>
        /// ç©å®¶æœåŠ¡
        /// </summary>
        public PlayerManager PlayerManager { get; private set; }

        /// <summary>
        /// RPC å®¢æˆ·ç«¯æœåŠ¡
        /// </summary>
        public RpcClient RpcClient { get; private set; }

        /// <summary>
        /// UI ç®¡ç†å™¨
        /// </summary>
        public UIManager UIManager { get; private set; }

        /// <summary>
        /// è¾“å…¥ç®¡ç†å™¨
        /// </summary>
        public InputManager InputManager { get; private set; }

        /// <summary>
        /// å¤´åƒç®¡ç†å™¨
        /// </summary>
        public AvatarManager AvatarManager { get; private set; }


        /// <summary>
        /// åœºæ™¯å®¢æˆ·ç«¯ç®¡ç†å™¨
        /// </summary>
        public SceneClientManager SceneClientManager { get; private set; }

        /// <summary>
        /// æˆ¿é—´å®¢æˆ·ç«¯ç®¡ç†å™¨
        /// </summary>
        public RoomManager RoomManager { get; private set; }

        /// <summary>
        /// è§’è‰²è‡ªå®šä¹‰ç®¡ç†å™¨
        /// </summary>
        public CharacterCustomizationManager CharacterCustomizationManager { get; private set; }

        /// <summary>
        /// åŠ¨ç”»åŒæ­¥ç®¡ç†å™¨
        /// </summary>
        public AnimatorSyncManager AnimatorSyncManager { get; private set; }

        /// <summary>
        /// åŠ¨ç”»åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡
        /// </summary>
        public Services.AnimatorSyncClientServiceImpl? AnimatorSyncClientService { get; set; }

        /// <summary>
        /// ç‰©å“ç½‘ç»œåè°ƒå™¨
        /// </summary>
        public Services.ItemNetworkCoordinator? ItemNetworkCoordinator { get; set; }

        /// <summary>
        /// NPC ç®¡ç†å™¨
        /// </summary>
        public NpcManager NpcManager { get; private set; }

        /// <summary>
        /// å…¨å±€äº‹ä»¶æ€»çº¿
        /// </summary>
        public EventBusCore EventBus { get; private set; }

        /// <summary>
        /// æ˜¯å¦å·²åˆå§‹åŒ–
        /// </summary>
        public static bool IsInitialized => _instance != null;

        private GameContext()
        {
            PlayerManager = null!;
            RpcClient = null!;
            UIManager = null!;
            InputManager = null!;
            AvatarManager = null!;
            CharacterCustomizationManager = null!;
            SceneClientManager = null!;
            RoomManager = null!;
            AnimatorSyncManager = null!;
            NpcManager = null!;
            EventBus = EventBusCore.Instance;
        }

        /// <summary>
        /// åˆå§‹åŒ–æ¸¸æˆä¸Šä¸‹æ–‡
        /// </summary>
        public static void Initialize()
        {
            if (_instance != null)
            {
                UnityEngine.Debug.LogWarning("[GameContext] å·²ç»åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–");
                return;
            }

            _instance = new GameContext();
            UnityEngine.Debug.Log("[GameContext] æ¸¸æˆä¸Šä¸‹æ–‡å·²åˆ›å»º");
        }

        // RegisterService æ–¹æ³•å·²ç§»é™¤ï¼Œæ”¹ä¸ºåœ¨æ¯ä¸ªæ³¨å†Œæ–¹æ³•ä¸­ç›´æ¥å®ç°

        /// <summary>
        /// æ³¨å†Œæœ¬åœ°ç©å®¶æœåŠ¡
        /// </summary>
        public void RegisterPlayerManager(PlayerManager playerManager)
        {
            PlayerManager = playerManager ?? throw new ArgumentNullException(nameof(playerManager));
            UnityEngine.Debug.Log("[GameContext] æœ¬åœ°ç©å®¶æœåŠ¡å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œ RPC å®¢æˆ·ç«¯æœåŠ¡
        /// </summary>
        public void RegisterRpcClient(RpcClient rpcClient)
        {
            RpcClient = rpcClient ?? throw new ArgumentNullException(nameof(rpcClient));
            UnityEngine.Debug.Log("[GameContext] RPC å®¢æˆ·ç«¯æœåŠ¡å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œ UI ç®¡ç†å™¨
        /// </summary>
        public void RegisterUIManager(UIManager uiManager)
        {
            UIManager = uiManager ?? throw new ArgumentNullException(nameof(uiManager));
            UnityEngine.Debug.Log("[GameContext] UI ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œè¾“å…¥ç®¡ç†å™¨
        /// </summary>
        public void RegisterInputManager(InputManager inputManager)
        {
            InputManager = inputManager ?? throw new ArgumentNullException(nameof(inputManager));
            UnityEngine.Debug.Log("[GameContext] è¾“å…¥ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œå¤´åƒç®¡ç†å™¨
        /// </summary>
        public void RegisterAvatarManager(AvatarManager avatarManager)
        {
            AvatarManager = avatarManager ?? throw new ArgumentNullException(nameof(avatarManager));
            UnityEngine.Debug.Log("[GameContext] å¤´åƒç®¡ç†å™¨å·²æ³¨å†Œ");
        }



        /// <summary>
        /// æ³¨å†Œè§’è‰²è‡ªå®šä¹‰ç®¡ç†å™¨
        /// </summary>
        public void RegisterCharacterCustomizationManager(CharacterCustomizationManager customizationManager)
        {
            CharacterCustomizationManager = customizationManager ?? throw new ArgumentNullException(nameof(customizationManager));
            UnityEngine.Debug.Log("[GameContext] è§’è‰²è‡ªå®šä¹‰ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†ŒåŠ¨ç”»åŒæ­¥ç®¡ç†å™¨
        /// </summary>
        public void RegisterAnimatorSyncManager(AnimatorSyncManager animatorSyncManager)
        {
            AnimatorSyncManager = animatorSyncManager ?? throw new ArgumentNullException(nameof(animatorSyncManager));
            UnityEngine.Debug.Log("[GameContext] åŠ¨ç”»åŒæ­¥ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œåœºæ™¯å®¢æˆ·ç«¯ç®¡ç†å™¨
        /// </summary>
        public void RegisterSceneClientManager(SceneClientManager sceneClientManager)
        {
            SceneClientManager = sceneClientManager ?? throw new ArgumentNullException(nameof(sceneClientManager));
            UnityEngine.Debug.Log("[GameContext] åœºæ™¯å®¢æˆ·ç«¯ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œæˆ¿é—´å®¢æˆ·ç«¯ç®¡ç†å™¨
        /// </summary>
        public void RegisterRoomManager(RoomManager roomManager)
        {
            RoomManager = roomManager ?? throw new ArgumentNullException(nameof(roomManager));
            UnityEngine.Debug.Log("[GameContext] æˆ¿é—´ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œç‰©å“ç½‘ç»œåè°ƒå™¨
        /// </summary>
        public void RegisterItemNetworkCoordinator(Services.ItemNetworkCoordinator itemNetworkCoordinator)
        {
            ItemNetworkCoordinator = itemNetworkCoordinator ?? throw new ArgumentNullException(nameof(itemNetworkCoordinator));
            UnityEngine.Debug.Log("[GameContext] ç‰©å“ç½‘ç»œåè°ƒå™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œ NPC ç®¡ç†å™¨
        /// </summary>
        public void RegisterNpcManager(NpcManager npcManager)
        {
            NpcManager = npcManager ?? throw new ArgumentNullException(nameof(npcManager));
            UnityEngine.Debug.Log("[GameContext] NPC ç®¡ç†å™¨å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ¸…ç†æ¸¸æˆä¸Šä¸‹æ–‡
        /// </summary>
        public static void Cleanup()
        {
            if (_instance == null) return;

            try
            {
                _instance.NpcManager?.Dispose();
                _instance.CharacterCustomizationManager?.Dispose();
                _instance.InputManager?.Dispose();
                _instance.UIManager?.Dispose();
                _instance.AvatarManager?.Dispose();
                _instance.AnimatorSyncManager?.Dispose();
                _instance.RpcClient?.Disconnect();
                _instance.PlayerManager?.Dispose();
                _instance.SceneClientManager?.Dispose();
                _instance.RoomManager?.Dispose();
                _instance.EventBus?.Dispose();
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[GameContext] æ¸…ç†å¤±è´¥: {ex.Message}");
            }
            finally
            {
                _instance = null;
            }
        }

        /// <summary>
        /// æ›´æ–°æ‰€æœ‰æœåŠ¡ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        public void Update()
        {
            RpcClient?.Update();
            InputManager?.Update();
            UIManager?.Update();
            PlayerManager?.Update();
            NpcManager?.Update(); // åŒæ­¥ NPC ä½ç½®
            AnimatorSyncManager?.Update();
            AnimatorSyncClientService?.Update(); // å¹³æ»‘æ’å€¼è¿œç¨‹ç©å®¶åŠ¨ç”»
        }

        /// <summary>
        /// LateUpdate - åŠ¨ç”»åå¤„ç†ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        public void LateUpdate()
        {
            // ğŸ¯ æ›´æ–°è¿œç¨‹ç©å®¶åŠ¨ç”»ï¼ˆåœ¨ LateUpdate ä¸­ç»Ÿä¸€æäº¤åˆ° Animatorï¼‰
            PlayerManager?.LateUpdate();
        }

        /// <summary>
        /// æ¸²æŸ“æ‰€æœ‰ GUIï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        public void OnGUI()
        {
            UIManager?.OnGUI();
        }
    }
}


```

`Client\Core\Helpers\CharacterAppearanceConverter.cs`:

```cs
using System;
using UnityEngine;
using HarmonyLib;
using DuckyNet.Shared.Data;


namespace DuckyNet.Client.Core.Helpers
{
    /// <summary>
    /// è§’è‰²å¤–è§‚è½¬æ¢å™¨ - åœ¨æ¸¸æˆæ•°æ®å’Œç½‘ç»œæ•°æ®ä¹‹é—´è½¬æ¢
    /// </summary>
    public class CharacterAppearanceConverter
    {
        private Type? _customFaceSettingDataType;
        private Type? _customFaceHeadSettingType;
        private Type? _customFacePartInfoType;
        private bool _initialized = false;

        public CharacterAppearanceConverter()
        {
            InitializeTypes();
        }

        private void InitializeTypes()
        {
            try
            {
                _customFaceSettingDataType = AccessTools.TypeByName("CustomFaceSettingData");
                _customFaceHeadSettingType = AccessTools.TypeByName("CustomFaceHeadSetting");
                _customFacePartInfoType = AccessTools.TypeByName("CustomFacePartInfo");

                _initialized = _customFaceSettingDataType != null 
                    && _customFaceHeadSettingType != null 
                    && _customFacePartInfoType != null;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceConverter] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// ä»æ¸¸æˆæ•°æ®è½¬æ¢ä¸ºç½‘ç»œæ•°æ®
        /// </summary>
        public CharacterAppearanceData? ConvertToNetworkData(object gameCustomData)
        {
            if (!_initialized || gameCustomData == null)
                return null;

            try
            {
                var result = new CharacterAppearanceData();

                // è½¬æ¢å¤´éƒ¨è®¾ç½®
                var headSettingField = AccessTools.Field(_customFaceSettingDataType, "headSetting");
                object? headSetting = headSettingField?.GetValue(gameCustomData);
                if (headSetting != null)
                {
                    result.HeadSetting = ConvertHeadSetting(headSetting);
                }

                // è½¬æ¢éƒ¨ä½æ•°æ®
                var partsField = AccessTools.Field(_customFaceSettingDataType, "parts");
                object? partsArray = partsField?.GetValue(gameCustomData);
                if (partsArray is Array parts && parts.Length > 0)
                {
                    result.Parts = new PartData[parts.Length];
                    for (int i = 0; i < parts.Length; i++)
                    {
                        object? part = parts.GetValue(i);
                        if (part != null)
                        {
                            result.Parts[i] = ConvertPart(part);
                        }
                    }
                }

                return result;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceConverter] è½¬æ¢åˆ°ç½‘ç»œæ•°æ®å¤±è´¥: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// ä»ç½‘ç»œæ•°æ®è½¬æ¢ä¸ºæ¸¸æˆæ•°æ®
        /// </summary>
        public object? ConvertToGameData(CharacterAppearanceData networkData)
        {
            if (!_initialized || networkData == null || _customFaceSettingDataType == null)
                return null;

            try
            {
                object customData = Activator.CreateInstance(_customFaceSettingDataType);

                // è½¬æ¢å¤´éƒ¨è®¾ç½®
                object headSetting = ConvertHeadSettingToGame(networkData.HeadSetting);
                var headSettingField = AccessTools.Field(_customFaceSettingDataType, "headSetting");
                headSettingField?.SetValue(customData, headSetting);

                // è½¬æ¢éƒ¨ä½æ•°æ®
                if (networkData.Parts.Length > 0)
                {
                    var partsList = new System.Collections.Generic.List<object>();
                    foreach (var partData in networkData.Parts)
                    {
                        object? gamePart = ConvertPartToGame(partData);
                        if (gamePart != null)
                        {
                            partsList.Add(gamePart);
                        }
                    }

                    var partsField = AccessTools.Field(_customFaceSettingDataType, "parts");
                    var partsArrayType = partsField?.FieldType;
                    if (partsArrayType != null)
                    {
                        var partsArray = Array.CreateInstance(partsArrayType.GetElementType()!, partsList.Count);
                        for (int i = 0; i < partsList.Count; i++)
                        {
                            partsArray.SetValue(partsList[i], i);
                        }
                        partsField?.SetValue(customData, partsArray);
                    }
                }

                return customData;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceConverter] è½¬æ¢åˆ°æ¸¸æˆæ•°æ®å¤±è´¥: {ex.Message}");
                return null;
            }
        }

        private HeadSettingData ConvertHeadSetting(object gameHeadSetting)
        {
            var scaleField = AccessTools.Field(_customFaceHeadSettingType, "scale");
            var offsetField = AccessTools.Field(_customFaceHeadSettingType, "offset");
            var rotationField = AccessTools.Field(_customFaceHeadSettingType, "rotation");

            Vector3 scale = (Vector3)(scaleField?.GetValue(gameHeadSetting) ?? Vector3.one);
            Vector3 offset = (Vector3)(offsetField?.GetValue(gameHeadSetting) ?? Vector3.zero);
            Vector3 rotation = (Vector3)(rotationField?.GetValue(gameHeadSetting) ?? Vector3.zero);

            var scaleCompressed = FloatCompression.CompressVector3(scale.x, scale.y, scale.z);
            var offsetCompressed = FloatCompression.CompressVector3(offset.x, offset.y, offset.z);
            var rotationCompressed = FloatCompression.CompressVector3(rotation.x, rotation.y, rotation.z);

            return new HeadSettingData
            {
                ScaleX = scaleCompressed.x,
                ScaleY = scaleCompressed.y,
                ScaleZ = scaleCompressed.z,
                OffsetX = offsetCompressed.x,
                OffsetY = offsetCompressed.y,
                OffsetZ = offsetCompressed.z,
                RotationX = rotationCompressed.x,
                RotationY = rotationCompressed.y,
                RotationZ = rotationCompressed.z
            };
        }

        private object ConvertHeadSettingToGame(HeadSettingData data)
        {
            object headSetting = Activator.CreateInstance(_customFaceHeadSettingType!);

            var scale = FloatCompression.DecompressVector3(data.ScaleX, data.ScaleY, data.ScaleZ);
            var offset = FloatCompression.DecompressVector3(data.OffsetX, data.OffsetY, data.OffsetZ);
            var rotation = FloatCompression.DecompressVector3(data.RotationX, data.RotationY, data.RotationZ);

            var scaleField = AccessTools.Field(_customFaceHeadSettingType, "scale");
            var offsetField = AccessTools.Field(_customFaceHeadSettingType, "offset");
            var rotationField = AccessTools.Field(_customFaceHeadSettingType, "rotation");

            scaleField?.SetValue(headSetting, new Vector3(scale.x, scale.y, scale.z));
            offsetField?.SetValue(headSetting, new Vector3(offset.x, offset.y, offset.z));
            rotationField?.SetValue(headSetting, new Vector3(rotation.x, rotation.y, rotation.z));

            return headSetting;
        }

        private PartData ConvertPart(object gamePart)
        {
            var typeField = AccessTools.Field(_customFacePartInfoType, "type");
            var idField = AccessTools.Field(_customFacePartInfoType, "id");
            var scaleField = AccessTools.Field(_customFacePartInfoType, "scale");
            var offsetField = AccessTools.Field(_customFacePartInfoType, "offset");
            var rotationField = AccessTools.Field(_customFacePartInfoType, "rotation");

            int type = (int)(typeField?.GetValue(gamePart) ?? 0);
            int id = (int)(idField?.GetValue(gamePart) ?? 0);
            Vector3 scale = (Vector3)(scaleField?.GetValue(gamePart) ?? Vector3.one);
            Vector3 offset = (Vector3)(offsetField?.GetValue(gamePart) ?? Vector3.zero);
            Vector3 rotation = (Vector3)(rotationField?.GetValue(gamePart) ?? Vector3.zero);

            var scaleCompressed = FloatCompression.CompressVector3(scale.x, scale.y, scale.z);
            var offsetCompressed = FloatCompression.CompressVector3(offset.x, offset.y, offset.z);
            var rotationCompressed = FloatCompression.CompressVector3(rotation.x, rotation.y, rotation.z);

            return new PartData
            {
                PartType = (byte)type,
                PartId = (ushort)id,
                ScaleX = scaleCompressed.x,
                ScaleY = scaleCompressed.y,
                ScaleZ = scaleCompressed.z,
                OffsetX = offsetCompressed.x,
                OffsetY = offsetCompressed.y,
                OffsetZ = offsetCompressed.z,
                RotationX = rotationCompressed.x,
                RotationY = rotationCompressed.y,
                RotationZ = rotationCompressed.z
            };
        }

        private object? ConvertPartToGame(PartData data)
        {
            try
            {
                object part = Activator.CreateInstance(_customFacePartInfoType!);

                var scale = FloatCompression.DecompressVector3(data.ScaleX, data.ScaleY, data.ScaleZ);
                var offset = FloatCompression.DecompressVector3(data.OffsetX, data.OffsetY, data.OffsetZ);
                var rotation = FloatCompression.DecompressVector3(data.RotationX, data.RotationY, data.RotationZ);

                var typeField = AccessTools.Field(_customFacePartInfoType, "type");
                var idField = AccessTools.Field(_customFacePartInfoType, "id");
                var scaleField = AccessTools.Field(_customFacePartInfoType, "scale");
                var offsetField = AccessTools.Field(_customFacePartInfoType, "offset");
                var rotationField = AccessTools.Field(_customFacePartInfoType, "rotation");

                typeField?.SetValue(part, (int)data.PartType);
                idField?.SetValue(part, (int)data.PartId);
                scaleField?.SetValue(part, new Vector3(scale.x, scale.y, scale.z));
                offsetField?.SetValue(part, new Vector3(offset.x, offset.y, offset.z));
                rotationField?.SetValue(part, new Vector3(rotation.x, rotation.y, rotation.z));

                return part;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceConverter] è½¬æ¢éƒ¨ä½åˆ°æ¸¸æˆæ•°æ®å¤±è´¥: {ex.Message}");
                return null;
            }
        }
    }
}


```

`Client\Core\Helpers\CharacterAppearanceHelper.cs`:

```cs
using System;
using System.Threading.Tasks;
using UnityEngine;
using HarmonyLib;
using DuckyNet.Shared.Data;
using DuckyNet.Client.RPC;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using CharacterServiceClientProxy = DuckyNet.Shared.Services.Generated.CharacterServiceClientProxy;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;


namespace DuckyNet.Client.Core.Helpers
{
    /// <summary>
    /// è§’è‰²å¤–è§‚åŠ©æ‰‹ - æä¾›å¤–è§‚ä¸Šä¼ å’Œä¸‹è½½åŠŸèƒ½
    /// </summary>
    public static class CharacterAppearanceHelper
    {
        // é™æ€äº‹ä»¶è®¢é˜…ç®¡ç†å™¨
        private static EventSubscriberHelper? _eventSubscriber;
        /// <summary>
        /// ä¸Šä¼ å½“å‰è§’è‰²çš„å¤–è§‚æ•°æ®åˆ°æœåŠ¡å™¨
        /// </summary>
        public static async Task<bool> UploadCurrentAppearanceAsync()
        {
            if (!GameContext.IsInitialized)
            {
                Debug.LogError("[CharacterAppearanceHelper] GameContext æœªåˆå§‹åŒ–");
                return false;
            }

            try
            {
                var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                var rpcClient = GameContext.Instance.RpcClient;
                var customizationManager = GameContext.Instance.CharacterCustomizationManager;

                // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥åˆ°æœåŠ¡å™¨
                if (!rpcClient.IsConnected)
                {
                    Debug.Log("[CharacterAppearanceHelper] æœªè¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè·³è¿‡è‡ªåŠ¨ä¸Šä¼ ï¼ˆè¿™æ˜¯æ­£å¸¸çš„ï¼‰");
                    return false;
                }

                // è·å–æœ¬åœ°ç©å®¶è§’è‰²å¯¹è±¡
                var localCharacter = customizationManager.GetLocalPlayerCharacter();
                if (localCharacter == null)
                {
                    Debug.LogWarning("[CharacterAppearanceHelper] æ— æ³•è·å–æœ¬åœ°ç©å®¶è§’è‰²å¯¹è±¡");
                    return false;
                }

                // ä»è§’è‰²å¯¹è±¡æå–å¤–è§‚æ•°æ®
                var customData = customizationManager.GetCustomizationFromCharacter(localCharacter);
                if (customData == null)
                {
                    Debug.LogWarning("[CharacterAppearanceHelper] æ— æ³•ä»è§’è‰²æå–å¤–è§‚æ•°æ®");
                    return false;
                }

                // è½¬æ¢ä¸ºç½‘ç»œæ•°æ®æ ¼å¼
                var converter = new Helpers.CharacterAppearanceConverter();
                var networkData = converter.ConvertToNetworkData(customData);
                
                if (networkData == null)
                {
                    Debug.LogError("[CharacterAppearanceHelper] å¤–è§‚æ•°æ®è½¬æ¢å¤±è´¥");
                    return false;
                }

                // å‹ç¼©ä¸ºå­—èŠ‚æ•°ç»„
                byte[] appearanceBytes = networkData.ToBytes();

                // ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼ˆä½¿ç”¨å‰é¢å·²å£°æ˜çš„ rpcClientï¼‰
                var context = new ClientServerContext(rpcClient);
                var proxy = new CharacterServiceClientProxy(context);
                
                bool success = await proxy.UpdateAppearanceAsync(appearanceBytes);
                
                if (success)
                {
                    Debug.Log($"[CharacterAppearanceHelper] âœ… å¤–è§‚ä¸Šä¼ æˆåŠŸ ({appearanceBytes.Length} bytes)");
                    
                    // åŒæ—¶æ ‡è®°è§’è‰²å·²åˆ›å»ºå¹¶æ›´æ–°æœ¬åœ°çŠ¶æ€
                    localPlayer.Info.HasCharacter = true;
                    localPlayer.Info.AppearanceData = appearanceBytes;
                }
                else
                {
                    Debug.LogError("[CharacterAppearanceHelper] å¤–è§‚ä¸Šä¼ å¤±è´¥");
                }

                return success;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceHelper] ä¸Šä¼ å¤–è§‚å¼‚å¸¸: {ex.Message}");
                Debug.LogException(ex);
                return false;
            }
        }

        /// <summary>
        /// ä»æœåŠ¡å™¨ä¸‹è½½æŒ‡å®šç©å®¶çš„å¤–è§‚æ•°æ®
        /// </summary>
        public static async Task<CharacterAppearanceData?> DownloadAppearanceAsync(string steamId)
        {
            if (!GameContext.IsInitialized)
            {
                Debug.LogError("[CharacterAppearanceHelper] GameContext æœªåˆå§‹åŒ–");
                return null;
            }

            try
            {
                var rpcClient = GameContext.Instance.RpcClient;
                var context = new ClientServerContext(rpcClient);
                var proxy = new CharacterServiceClientProxy(context);
                
                byte[]? appearanceBytes = await proxy.GetAppearanceAsync(steamId);
                
                if (appearanceBytes == null || appearanceBytes.Length == 0)
                {
                    Debug.LogWarning($"[CharacterAppearanceHelper] ç©å®¶ {steamId} æ²¡æœ‰å¤–è§‚æ•°æ®");
                    return null;
                }

                Debug.Log($"[CharacterAppearanceHelper] ä¸‹è½½å¤–è§‚æ•°æ®: {steamId} ({appearanceBytes.Length} bytes)");
                
                var appearanceData = CharacterAppearanceData.FromBytes(appearanceBytes);
                return appearanceData;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceHelper] ä¸‹è½½å¤–è§‚å¼‚å¸¸: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// åº”ç”¨å¤–è§‚æ•°æ®åˆ°è§’è‰²å¯¹è±¡
        /// </summary>
        public static bool ApplyAppearance(GameObject character, CharacterAppearanceData appearanceData)
        {
            if (!GameContext.IsInitialized)
            {
                Debug.LogError("[CharacterAppearanceHelper] GameContext æœªåˆå§‹åŒ–");
                return false;
            }

            try
            {
                var converter = new Helpers.CharacterAppearanceConverter();
                var customData = converter.ConvertToGameData(appearanceData);
                
                if (customData == null)
                {
                    Debug.LogError("[CharacterAppearanceHelper] å¤–è§‚æ•°æ®è½¬æ¢å¤±è´¥");
                    return false;
                }

                var customizationManager = GameContext.Instance.CharacterCustomizationManager;
                customizationManager.ApplyToCharacter(character, customData);
                
                return true;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceHelper] åº”ç”¨å¤–è§‚å¼‚å¸¸: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// ç›‘å¬å¹¶è‡ªåŠ¨ä¸Šä¼ è§’è‰²å¤–è§‚ï¼ˆé€šè¿‡ EventSubscriberHelper è®¢é˜…ï¼‰
        /// </summary>
        public static void StartAutoUpload()
        {
            if (!GameContext.IsInitialized)
            {
                Debug.LogError("[CharacterAppearanceHelper] GameContext æœªåˆå§‹åŒ–");
                return;
            }

            try
            {
                // åˆ›å»ºæˆ–é‡ç”¨äº‹ä»¶è®¢é˜…ç®¡ç†å™¨
                if (_eventSubscriber == null)
                {
                    _eventSubscriber = new EventSubscriberHelper();
                }

                // è®¢é˜…ä¸»è§’è‰²åˆ›å»ºå®Œæˆäº‹ä»¶ï¼ˆä½¿ç”¨ EventSubscriberHelperï¼‰
                _eventSubscriber.EnsureInitializedAndSubscribe();
                _eventSubscriber.Subscribe<MainCharacterCreatedEvent>(OnMainCharacterCreated);
                Debug.Log("[CharacterAppearanceHelper] å·²è®¢é˜…ä¸»è§’è‰²åˆ›å»ºäº‹ä»¶ï¼ˆEventSubscriberHelperï¼‰");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceHelper] å¯åŠ¨è‡ªåŠ¨ä¸Šä¼ å¤±è´¥: {ex.Message}");
            }
        }

        // é˜²æŠ–æœºåˆ¶ï¼šé¿å…é‡å¤ä¸Šä¼ 
        private static DateTime _lastUploadTime = DateTime.MinValue;
        private static readonly TimeSpan _uploadDebounceInterval = TimeSpan.FromSeconds(2); // 2ç§’å†…åªä¸Šä¼ ä¸€æ¬¡
        private static bool _isUploading = false;

        /// <summary>
        /// ä¸»è§’è‰²åˆ›å»ºå®Œæˆäº‹ä»¶å¤„ç†
        /// </summary>
        private static async void OnMainCharacterCreated(MainCharacterCreatedEvent evt)
        {
            try
            {
                if (!GameContext.IsInitialized) return;
                
                // é˜²æŠ–ï¼šæ£€æŸ¥è·ç¦»ä¸Šæ¬¡ä¸Šä¼ çš„æ—¶é—´é—´éš”
                var now = DateTime.Now;
                if (now - _lastUploadTime < _uploadDebounceInterval)
                {
                    Debug.Log($"[CharacterAppearanceHelper] å¿½ç•¥é‡å¤ä¸Šä¼ è¯·æ±‚ï¼ˆè·ç¦»ä¸Šæ¬¡ {((now - _lastUploadTime).TotalSeconds):F1}ç§’ï¼‰");
                    return;
                }
                
                // é˜²æ­¢å¹¶å‘ä¸Šä¼ 
                if (_isUploading)
                {
                    Debug.Log("[CharacterAppearanceHelper] å·²æœ‰ä¸Šä¼ ä»»åŠ¡æ­£åœ¨è¿›è¡Œï¼Œè·³è¿‡");
                    return;
                }
                
                _isUploading = true;
                
                // å¤šæ¬¡é‡è¯•ï¼Œç­‰å¾…è§’è‰²å®Œå…¨åˆå§‹åŒ–
                int maxRetries = 10;
                int[] retryDelays = { 500, 500, 1000, 1000, 2000, 2000, 3000, 3000, 5000, 5000 };
                
                for (int i = 0; i < maxRetries; i++)
                {
                    // å»¶è¿Ÿç­‰å¾…
                    await System.Threading.Tasks.Task.Delay(retryDelays[i]);
                    
                    // å¦‚æœæœªè¿æ¥åˆ°æœåŠ¡å™¨ï¼Œç›´æ¥åœæ­¢é‡è¯•
                    if (GameContext.IsInitialized && !GameContext.Instance.RpcClient.IsConnected)
                    {
                        _isUploading = false;
                        return;
                    }
                    
                    bool success = await UploadCurrentAppearanceAsync();
                    
                    if (success)
                    {
                        _lastUploadTime = DateTime.Now;
                        _isUploading = false;
                        Debug.Log($"[CharacterAppearanceHelper] âœ… è‡ªåŠ¨ä¸Šä¼ å¤–è§‚æˆåŠŸ (å°è¯• {i + 1} æ¬¡)");
                        return; // æˆåŠŸåç«‹å³è¿”å›
                    }
                }
                
                _isUploading = false;
                Debug.LogWarning("[CharacterAppearanceHelper] âš ï¸ è‡ªåŠ¨ä¸Šä¼ å¤–è§‚å¤±è´¥ï¼ˆå¯èƒ½æœªè¿æ¥æœåŠ¡å™¨ï¼‰");
            }
            catch (Exception ex)
            {
                _isUploading = false;
                Debug.LogError($"[CharacterAppearanceHelper] è‡ªåŠ¨ä¸Šä¼ å¤–è§‚å¼‚å¸¸: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// åœæ­¢è‡ªåŠ¨ä¸Šä¼ ç›‘å¬
        /// </summary>
        public static void StopAutoUpload()
        {
            try
            {
                // ä½¿ç”¨ EventSubscriberHelper è‡ªåŠ¨ç®¡ç†å–æ¶ˆè®¢é˜…
                _eventSubscriber?.Dispose();
                _eventSubscriber = null;
                Debug.Log("[CharacterAppearanceHelper] å·²å–æ¶ˆè®¢é˜…ä¸»è§’è‰²åˆ›å»ºäº‹ä»¶ï¼ˆEventSubscriberHelperï¼‰");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterAppearanceHelper] åœæ­¢è‡ªåŠ¨ä¸Šä¼ å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Core\Helpers\SceneInfoProvider.cs`:

```cs
using DuckyNet.Client.Patches;

namespace DuckyNet.Client.Core.Helpers
{
    /// <summary>
    /// åœºæ™¯ä¿¡æ¯æä¾›è€… - æä¾›ç»Ÿä¸€çš„åœºæ™¯æŸ¥è¯¢æ¥å£
    /// </summary>
    public static class SceneInfoProvider
    {
        private static SceneEventBridge? _sceneBridge;

        /// <summary>
        /// åˆå§‹åŒ–åœºæ™¯ä¿¡æ¯æä¾›è€…ï¼ˆç”± SceneManager è°ƒç”¨ï¼‰
        /// </summary>
        public static void Initialize(SceneEventBridge sceneBridge)
        {
            _sceneBridge = sceneBridge;
        }

    }
}

```

`Client\Core\InputManager.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// è¾“å…¥ç®¡ç†å™¨
    /// ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æŒ‰é”®è¾“å…¥å’Œå¿«æ·é”®
    /// </summary>
    public class InputManager : IDisposable
    {
        private readonly Dictionary<KeyCode, Action> _keyBindings;
        private bool _isEnabled;

        public InputManager()
        {
            _keyBindings = new Dictionary<KeyCode, Action>();
            _isEnabled = true;
        }

        /// <summary>
        /// å¯ç”¨/ç¦ç”¨è¾“å…¥ç®¡ç†å™¨
        /// </summary>
        public bool IsEnabled
        {
            get => _isEnabled;
            set
            {
                _isEnabled = value;
               UnityEngine.Debug.Log($"[InputManager] è¾“å…¥ç®¡ç†å™¨å·²{(value ? "å¯ç”¨" : "ç¦ç”¨")}");
            }
        }

        /// <summary>
        /// æ³¨å†ŒæŒ‰é”®ç»‘å®š
        /// </summary>
        public void RegisterKey(KeyCode key, Action action, string description = "")
        {
            if (_keyBindings.ContainsKey(key))
            {
                UnityEngine.Debug.LogWarning($"[InputManager] æŒ‰é”® {key} å·²è¢«æ³¨å†Œï¼Œå°†è¢«è¦†ç›–");
            }

            _keyBindings[key] = action;
            
            var desc = string.IsNullOrEmpty(description) ? "" : $" ({description})";
            UnityEngine.Debug.Log($"[InputManager] æŒ‰é”® {key} å·²æ³¨å†Œ{desc}");
        }

        /// <summary>
        /// å–æ¶ˆæŒ‰é”®ç»‘å®š
        /// </summary>
        public void UnregisterKey(KeyCode key)
        {
            if (_keyBindings.Remove(key))
            {
                UnityEngine.Debug.Log($"[InputManager] æŒ‰é”® {key} å·²å–æ¶ˆæ³¨å†Œ");
            }
        }

        /// <summary>
        /// æ¸…é™¤æ‰€æœ‰æŒ‰é”®ç»‘å®š
        /// </summary>
        public void ClearAllBindings()
        {
            _keyBindings.Clear();
            UnityEngine.Debug.Log("[InputManager] æ‰€æœ‰æŒ‰é”®ç»‘å®šå·²æ¸…é™¤");
        }

        /// <summary>
        /// æ›´æ–°è¾“å…¥ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        public void Update()
        {
            if (!_isEnabled) return;

            try
            {
                foreach (var kvp in _keyBindings)
                {
                    if (Input.GetKeyDown(kvp.Key))
                    {
                        try
                        {
                            kvp.Value?.Invoke();
                        }
                        catch (Exception ex)
                        {
                            UnityEngine.Debug.LogError($"[InputManager] æ‰§è¡ŒæŒ‰é”® {kvp.Key} çš„å›è°ƒæ—¶å‡ºé”™: {ex.Message}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[InputManager] æ›´æ–°è¾“å…¥æ—¶å‡ºé”™: {ex.Message}");
            }
        }

        /// <summary>
        /// æ¸…ç†èµ„æº
        /// </summary>
        public void Dispose()
        {
            ClearAllBindings();
            UnityEngine.Debug.Log("[InputManager] è¾“å…¥ç®¡ç†å™¨å·²æ¸…ç†");
        }
    }
}


```

`Client\Core\NetworkLifecycleManager.cs`:

```cs
using System;
using System.Threading.Tasks;
using UnityEngine;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus.Events;


namespace DuckyNet.Client.Core
{
    /// <summary>
    /// ç½‘ç»œç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†ç½‘ç»œè¿æ¥ã€æˆ¿é—´åŠ å…¥/ç¦»å¼€ç­‰ç”Ÿå‘½å‘¨æœŸäº‹ä»¶
    /// </summary>
    public class NetworkLifecycleManager : IDisposable
    {
        private readonly GameContext _context;
        public NetworkLifecycleManager(GameContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        public void Dispose()
        {
        }

        /// <summary>
        /// å¤„ç†è¿æ¥æˆåŠŸ
        /// </summary>
        public void HandleConnected()
        {
            try
            {
                Debug.Log("[NetworkLifecycleManager] å¤„ç†è¿æ¥æˆåŠŸäº‹ä»¶");
                // å‘å¸ƒ EventBus äº‹ä»¶
                if (GameContext.IsInitialized)
                {
                    _context.EventBus.Publish(NetworkConnectedEvent.Instance);
                }

            }
            catch (Exception ex)
            {
                Debug.LogError($"[NetworkLifecycleManager] å¤„ç†è¿æ¥äº‹ä»¶å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// å¤„ç†æ–­å¼€è¿æ¥
        /// </summary>
        public void HandleDisconnected(string reason)
        {
            try
            {
                Debug.LogWarning($"[NetworkLifecycleManager] ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥: {reason}");

                // å‘å¸ƒ EventBus äº‹ä»¶
                if (GameContext.IsInitialized)
                {
                    _context.EventBus.Publish(new NetworkDisconnectedEvent(reason));
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NetworkLifecycleManager] å¤„ç†æ–­å¼€è¿æ¥äº‹ä»¶å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

    }
}



```

`Client\Core\NpcManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using HarmonyLib;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// NPC ç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†æœ¬åœ°å’Œè¿œç¨‹ NPC
    /// æœ¬åœ° NPCï¼šç”±æ¸¸æˆåŸç”Ÿç”Ÿæˆï¼Œå¸¦ AI
    /// è¿œç¨‹ NPCï¼šç”±æœåŠ¡å™¨åŒæ­¥åˆ›å»ºï¼Œæ—  AIï¼ˆå½±å­æ¨¡å¼ï¼‰
    /// </summary>
    public class NpcManager : IDisposable
    {
        // æœ¬åœ° NPCï¼ˆå¸¦ AIï¼‰
        private readonly Dictionary<string, NpcInfo> _localNpcs = new Dictionary<string, NpcInfo>();
        
        // è¿œç¨‹ NPCï¼ˆå½±å­æ¨¡å¼ï¼Œæ—  AIï¼‰
        private readonly Dictionary<string, NpcInfo> _remoteNpcs = new Dictionary<string, NpcInfo>();
        
        private readonly EventSubscriberHelper _eventSub = new EventSubscriberHelper();

        // åå°„ç¼“å­˜
        private static Type? _healthType;
        private static Type? _characterMainControlType;
        private static System.Reflection.PropertyInfo? _currentHealthProperty;
        private static System.Reflection.PropertyInfo? _maxHealthProperty;
        private static System.Reflection.FieldInfo? _healthField;

        // ä½ç½®åŒæ­¥
        private float _lastSyncTime;
        private const float SyncInterval = 0.1f; // æ¯ 100ms åŒæ­¥ä¸€æ¬¡

        // å¯è§æ€§ç®¡ç†å™¨
        private readonly NpcVisibilityManager _visibilityManager;

        // å¯¹è±¡æ± 
        private readonly ShadowNpcPool _npcPool;

        // NPC è¯·æ±‚ç®¡ç†ï¼ˆå»é‡å’ŒèŠ‚æµï¼‰
        private readonly HashSet<string> _pendingRequests = new HashSet<string>(); // æ­£åœ¨è¯·æ±‚çš„ NPC
        private readonly HashSet<string> _failedRequests = new HashSet<string>(); // è¯·æ±‚å¤±è´¥çš„ NPCï¼ˆé¿å…é‡å¤è¯·æ±‚ï¼‰
        private float _lastRequestTime = 0f;
        private const float RequestThrottle = 0.2f; // è¯·æ±‚èŠ‚æµï¼š200ms å†…æœ€å¤šè¯·æ±‚ä¸€æ¬¡

        public NpcManager()
        {
            _visibilityManager = new NpcVisibilityManager
            {
                SyncRange = 100f, // åŒæ­¥èŒƒå›´ 100 ç±³
                PositionThreshold = 0.1f, // ä½ç½®å˜åŒ–é˜ˆå€¼ 0.1 ç±³
                RotationThreshold = 5f // æ—‹è½¬å˜åŒ–é˜ˆå€¼ 5 åº¦
            };

            _npcPool = new ShadowNpcPool
            {
                DefaultPoolSize = 10,
                MaxPoolSize = 50,
                AutoRecycleTime = 60f
            };

            // é¢„çƒ­å¸¸ç”¨ NPC ç±»å‹
            _npcPool.WarmUp("Character(Clone)", 5);

            InitializeReflection();
            
            _eventSub.EnsureInitializedAndSubscribe();
            _eventSub.Subscribe<CharacterSpawnedEvent>(OnNpcSpawned);
            _eventSub.Subscribe<CharacterDestroyedEvent>(OnNpcDestroyed);
            _eventSub.Subscribe<CharacterDeathEvent>(OnNpcDeath);
            
            // è®¢é˜…åœºæ™¯è¿›å…¥äº‹ä»¶ï¼ˆä¸­é€”åŠ å…¥æ—¶è¯·æ±‚åœºæ™¯ NPCï¼‰
            _eventSub.Subscribe<SceneLoadedDetailEvent>(OnSceneLoaded);

            Debug.Log("[NpcManager] NPC ç®¡ç†å™¨å·²åˆå§‹åŒ–");
        }

        /// <summary>
        /// åˆå§‹åŒ–åå°„
        /// </summary>
        private void InitializeReflection()
        {
            if (_healthType != null) return;

            _healthType = AccessTools.TypeByName("Health");
            _characterMainControlType = AccessTools.TypeByName("CharacterMainControl");

            if (_healthType != null)
            {
                _currentHealthProperty = AccessTools.Property(_healthType, "CurrentHealth");
                _maxHealthProperty = AccessTools.Property(_healthType, "MaxHealth");
            }

            if (_characterMainControlType != null)
            {
                _healthField = AccessTools.Field(_characterMainControlType, "health");
            }
        }

        /// <summary>
        /// æœ¬åœ° NPC åˆ›å»ºäº‹ä»¶ï¼ˆæ¸¸æˆåŸç”Ÿç”Ÿæˆï¼‰
        /// </summary>
        private void OnNpcSpawned(CharacterSpawnedEvent evt)
        {
            try
            {
                // è¿‡æ»¤æ‰æœ¬åœ°ç©å®¶
                if (IsLocalPlayer(evt.CharacterMainControl)) return;

                // è·å–å½“å‰åœºæ™¯ä¿¡æ¯
                var sceneData = GameContext.Instance.PlayerManager?.LocalPlayer?.Info?.CurrentScenelData;

                var npcInfo = new NpcInfo
                {
                    Id = evt.CharacterId,
                    CharacterMainControl = evt.CharacterMainControl,
                    GameObject = evt.GameObject,
                    Name = evt.GameObject?.name ?? "Unknown",
                    SpawnTime = Time.time,
                    IsAlive = true,
                    IsLocal = true, // æ ‡è®°ä¸ºæœ¬åœ° NPC
                    SceneName = sceneData?.SceneName ?? "",
                    SubSceneName = sceneData?.SubSceneName ?? ""
                };

                // è·å–åˆå§‹ä½ç½®å’Œæ—‹è½¬
                if (evt.GameObject != null)
                {
                    npcInfo.Position = evt.GameObject.transform.position;
                    npcInfo.Rotation = evt.GameObject.transform.rotation;
                }

                // è·å–è¡€é‡ä¿¡æ¯
                UpdateHealth(npcInfo);

                _localNpcs[evt.CharacterId] = npcInfo;
                
                Debug.Log($"[NpcManager] æœ¬åœ° NPC å·²æ³¨å†Œ: {npcInfo.Name} (ID: {npcInfo.Id})");
                
                // å‘é€åˆ°æœåŠ¡å™¨ï¼ˆè®©å…¶ä»–ç©å®¶çœ‹åˆ°ï¼‰
                SendNpcSpawnToServer(npcInfo);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] å¤„ç† NPC åˆ›å»ºå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æœ¬åœ° NPC é”€æ¯äº‹ä»¶
        /// </summary>
        private void OnNpcDestroyed(CharacterDestroyedEvent evt)
        {
            if (_localNpcs.TryGetValue(evt.CharacterId, out var npc))
            {
                Debug.Log($"[NpcManager] æœ¬åœ° NPC å·²ç§»é™¤: {npc.Name} (ID: {evt.CharacterId})");
                
                // æ¸…ç†å¯è§æ€§çŠ¶æ€
                _visibilityManager.RemoveNpcState(evt.CharacterId);
                
                // å‘é€åˆ°æœåŠ¡å™¨
                SendNpcDestroyToServer(evt.CharacterId, npc.SceneName, npc.SubSceneName);
                
                _localNpcs.Remove(evt.CharacterId);
            }
        }

        /// <summary>
        /// æœ¬åœ° NPC æ­»äº¡äº‹ä»¶
        /// </summary>
        private void OnNpcDeath(CharacterDeathEvent evt)
        {
            if (_localNpcs.TryGetValue(evt.CharacterId, out var npcInfo))
            {
                npcInfo.IsAlive = false;
                npcInfo.DeathTime = Time.time;
            }
        }

        /// <summary>
        /// æ›´æ–° NPC è¡€é‡ä¿¡æ¯
        /// </summary>
        private void UpdateHealth(NpcInfo npcInfo)
        {
            try
            {
                if (npcInfo.CharacterMainControl == null || _healthField == null) return;

                object? health = _healthField.GetValue(npcInfo.CharacterMainControl);
                if (health == null) return;

                npcInfo.CurrentHealth = (float?)_currentHealthProperty?.GetValue(health) ?? 0f;
                npcInfo.MaxHealth = (float?)_maxHealthProperty?.GetValue(health) ?? 0f;
            }
            catch
            {
                // é™é»˜å¤±è´¥
            }
        }

        private float _sceneLoadTime;
        private bool _hasPendingNpcRequest;

        /// <summary>
        /// åœºæ™¯åŠ è½½å®Œæˆäº‹ä»¶ï¼ˆä¸­é€”åŠ å…¥æ—¶è¯·æ±‚åœºæ™¯ NPCï¼‰
        /// </summary>
        private void OnSceneLoaded(SceneLoadedDetailEvent evt)
        {
            Debug.Log($"[NpcManager] åœºæ™¯åŠ è½½å®Œæˆï¼Œå»¶è¿Ÿ 1 ç§’åè¯·æ±‚åœºæ™¯ NPCï¼ˆç­‰å¾…ä½ç½®åŒæ­¥ï¼‰");
            
            // ğŸ”¥ æ ‡è®°éœ€è¦å»¶è¿Ÿè¯·æ±‚ï¼Œåœ¨ Update ä¸­å¤„ç†
            _sceneLoadTime = Time.time;
            _hasPendingNpcRequest = true;
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        private bool IsLocalPlayer(object? characterMainControl)
        {
            if (characterMainControl == null || _characterMainControlType == null) return false;

            try
            {
                var isMainCharacterProperty = AccessTools.Property(_characterMainControlType, "IsMainCharacter");
                return (bool)(isMainCharacterProperty?.GetValue(characterMainControl) ?? false);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// è·å–æ‰€æœ‰ NPC åˆ—è¡¨ï¼ˆæœ¬åœ° + è¿œç¨‹ï¼‰
        /// </summary>
        public IEnumerable<NpcInfo> GetAllNpcs()
        {
            // æ›´æ–°æœ¬åœ° NPC çš„å®æ—¶ä¿¡æ¯
            foreach (var npc in _localNpcs.Values)
            {
                if (npc.IsAlive && npc.GameObject != null)
                {
                    var transform = npc.GameObject.transform;
                    npc.Position = transform.position;
                    npc.Rotation = transform.rotation;
                    UpdateHealth(npc);
                }
            }

            // åˆå¹¶æœ¬åœ°å’Œè¿œç¨‹ NPC
            return _localNpcs.Values.Concat(_remoteNpcs.Values).ToList();
        }

        /// <summary>
        /// è·å–æ´»ç€çš„ NPC
        /// </summary>
        public IEnumerable<NpcInfo> GetAliveNpcs()
        {
            return GetAllNpcs().Where(n => n.IsAlive);
        }

        /// <summary>
        /// è·å–æ­»äº¡çš„ NPC
        /// </summary>
        public IEnumerable<NpcInfo> GetDeadNpcs()
        {
            return GetAllNpcs().Where(n => !n.IsAlive);
        }

        /// <summary>
        /// æ ¹æ® ID è·å– NPC
        /// </summary>
        public NpcInfo? GetNpc(string id)
        {
            if (_localNpcs.TryGetValue(id, out var npc))
                return npc;
            
            if (_remoteNpcs.TryGetValue(id, out npc))
                return npc;
            
            return null;
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰ NPC
        /// </summary>
        public void Clear()
        {
            _localNpcs.Clear();
            _remoteNpcs.Clear();
        }

        /// <summary>
        /// æ·»åŠ è¿œç¨‹ NPCï¼ˆä»å¯¹è±¡æ± è·å–ï¼‰
        /// </summary>
        public void AddRemoteNpc(string npcId, NpcSpawnData spawnData)
        {
            try
            {
                // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬åœ° NPCï¼ˆé¿å…é‡å¤ï¼‰
                if (_localNpcs.ContainsKey(npcId))
                {
                    Debug.Log($"[NpcManager] â­ï¸ è·³è¿‡è¿œç¨‹ NPCï¼š{npcId} æ˜¯æœ¬åœ° NPC");
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                if (_remoteNpcs.ContainsKey(npcId))
                {
                    Debug.Log($"[NpcManager] â­ï¸ è¿œç¨‹ NPC å·²å­˜åœ¨: {npcId}");
                    return;
                }

                // ä»å¯¹è±¡æ± è·å–
                var (characterMainControl, gameObject) = _npcPool.Get(spawnData);
                
                if (characterMainControl == null || gameObject == null)
                {
                    Debug.LogError($"[NpcManager] ä»å¯¹è±¡æ± è·å– NPC å¤±è´¥: {spawnData.NpcType}");
                    return;
                }

                var npcInfo = new NpcInfo
                {
                    Id = npcId,
                    CharacterMainControl = characterMainControl,
                    GameObject = gameObject,
                    Name = spawnData.NpcType,
                    SpawnTime = Time.time,
                    IsAlive = true,
                    IsLocal = false, // è¿œç¨‹ NPC
                    SceneName = spawnData.SceneName,
                    SubSceneName = spawnData.SubSceneName
                };

                npcInfo.Position = gameObject.transform.position;
                npcInfo.Rotation = gameObject.transform.rotation;
                // åˆå§‹åŒ–ç›®æ ‡ä½ç½®ï¼ˆé˜²æ­¢ä» (0,0,0) æ’å€¼ï¼‰
                npcInfo.TargetPosition = gameObject.transform.position;
                npcInfo.TargetRotation = gameObject.transform.rotation;

                _remoteNpcs[npcId] = npcInfo;
                Debug.Log($"[NpcManager] âœ… è¿œç¨‹ NPC å·²æ·»åŠ : {spawnData.NpcType} (ID: {npcId})");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] æ·»åŠ è¿œç¨‹ NPC å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ·»åŠ è¿œç¨‹ NPCï¼ˆæ—§æ–¹æ³•ï¼Œå…¼å®¹æ€§ï¼‰
        /// </summary>
        public void AddRemoteNpc(string npcId, object characterMainControl, GameObject? gameObject, 
            string npcType, string sceneName, string subSceneName)
        {
            var spawnData = new NpcSpawnData
            {
                NpcId = npcId,
                NpcType = npcType,
                SceneName = sceneName,
                SubSceneName = subSceneName,
                PositionX = gameObject?.transform.position.x ?? 0,
                PositionY = gameObject?.transform.position.y ?? 0,
                PositionZ = gameObject?.transform.position.z ?? 0,
                RotationY = gameObject?.transform.rotation.eulerAngles.y ?? 0
            };
            
            AddRemoteNpc(npcId, spawnData);
        }

        /// <summary>
        /// æ›´æ–°è¿œç¨‹ NPC ä½ç½®ï¼ˆè®¾ç½®ç›®æ ‡ä½ç½®ï¼Œä¸ç›´æ¥è®¾ç½®ï¼‰
        /// </summary>
        public void UpdateRemoteNpcTransform(string npcId, Vector3 position, float rotationY)
        {
            if (_remoteNpcs.TryGetValue(npcId, out var npc))
            {
                // è®¾ç½®ç›®æ ‡ä½ç½®å’Œæ—‹è½¬ï¼ˆç”¨äºå¹³æ»‘æ’å€¼ï¼‰
                npc.TargetPosition = position;
                npc.TargetRotation = Quaternion.Euler(0, rotationY, 0);

                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ¥æ”¶ä½ç½®ï¼Œç›´æ¥è®¾ç½®
                if (npc.GameObject != null && Vector3.Distance(npc.Position, Vector3.zero) < 0.01f)
                {
                    npc.Position = position;
                    npc.Rotation = Quaternion.Euler(0, rotationY, 0);
                    npc.GameObject.transform.position = position;
                    npc.GameObject.transform.rotation = Quaternion.Euler(0, rotationY, 0);
                }
            }
        }

        /// <summary>
        /// æ£€æµ‹å¹¶è¯·æ±‚ç¼ºå¤±çš„ NPCï¼ˆæ”¶åˆ°ä½ç½®æ›´æ–°ä½†æœ¬åœ°æ²¡æœ‰æ—¶ï¼‰
        /// </summary>
        public bool CheckAndRequestMissingNpc(string npcId)
        {
            // 1. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆæœ¬åœ°æˆ–è¿œç¨‹ï¼‰
            if (_localNpcs.ContainsKey(npcId) || _remoteNpcs.ContainsKey(npcId))
            {
                return false; // å·²å­˜åœ¨ï¼Œæ— éœ€è¯·æ±‚
            }

            // 2. æ£€æŸ¥æ˜¯å¦æ­£åœ¨è¯·æ±‚æˆ–å·²å¤±è´¥
            if (_pendingRequests.Contains(npcId) || _failedRequests.Contains(npcId))
            {
                return false; // é¿å…é‡å¤è¯·æ±‚
            }

            // 3. èŠ‚æµæ£€æŸ¥
            if (Time.time - _lastRequestTime < RequestThrottle)
            {
                return false; // å¤ªé¢‘ç¹ï¼Œç­‰å¾…ä¸‹æ¬¡
            }

            // 4. å‘èµ·è¯·æ±‚
            RequestSingleNpcAsync(npcId);
            return true;
        }

        /// <summary>
        /// è¯·æ±‚å•ä¸ª NPCï¼ˆå¼‚æ­¥ï¼‰
        /// </summary>
        private async void RequestSingleNpcAsync(string npcId)
        {
            try
            {
                if (!GameContext.IsInitialized || GameContext.Instance.RpcClient == null) return;

                _pendingRequests.Add(npcId);
                _lastRequestTime = Time.time;

                Debug.Log($"[NpcManager] ğŸ” è¯·æ±‚ç¼ºå¤± NPC: {npcId}");

                var serverContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                var npcService = new Shared.Services.Generated.NpcSyncServiceClientProxy(serverContext);
                var npcData = await npcService.RequestSingleNpc(npcId);

                if (npcData != null)
                {
                    Debug.Log($"[NpcManager] âœ… æ”¶åˆ° NPC æ•°æ®: {npcData.NpcType} (ID: {npcId})");
                    
                    // æ£€æŸ¥åœºæ™¯æ˜¯å¦åŒ¹é…
                    var localSceneData = GameContext.Instance.PlayerManager?.LocalPlayer?.Info?.CurrentScenelData;
                    if (localSceneData != null &&
                        localSceneData.SceneName == npcData.SceneName &&
                        localSceneData.SubSceneName == npcData.SubSceneName)
                    {
                        // åˆ›å»ºè¿œç¨‹ NPC
                        AddRemoteNpc(npcId, npcData);
                    }
                    else
                    {
                        Debug.Log($"[NpcManager] â­ï¸ NPC ä¸åœ¨å½“å‰åœºæ™¯ï¼Œè·³è¿‡åˆ›å»º");
                    }
                }
                else
                {
                    Debug.LogWarning($"[NpcManager] âš ï¸ NPC ä¸å­˜åœ¨æˆ–è¶…å‡ºèŒƒå›´: {npcId}");
                    _failedRequests.Add(npcId); // æ ‡è®°ä¸ºå¤±è´¥ï¼Œé¿å…é‡å¤è¯·æ±‚
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] è¯·æ±‚å•ä¸ª NPC å¤±è´¥: {ex.Message}");
                _failedRequests.Add(npcId);
            }
            finally
            {
                _pendingRequests.Remove(npcId);
            }
        }

        /// <summary>
        /// ç§»é™¤è¿œç¨‹ NPCï¼ˆå›æ”¶åˆ°å¯¹è±¡æ± ï¼‰
        /// </summary>
        public void RemoveRemoteNpc(string npcId)
        {
            if (_remoteNpcs.TryGetValue(npcId, out var npc))
            {
                // å›æ”¶åˆ°å¯¹è±¡æ± ï¼ˆè€Œä¸æ˜¯ç›´æ¥é”€æ¯ï¼‰
                _npcPool.Recycle(npcId);

                _remoteNpcs.Remove(npcId);
                Debug.Log($"[NpcManager] è¿œç¨‹ NPC å·²ç§»é™¤å¹¶å›æ”¶: {npc.Name} (ID: {npcId})");
            }
        }

        /// <summary>
        /// è¯·æ±‚å½“å‰åœºæ™¯çš„æ‰€æœ‰è¿œç¨‹ NPCï¼ˆä¸­é€”åŠ å…¥æ—¶ï¼‰
        /// </summary>
        public async void RequestSceneNpcs()
        {
            try
            {
                if (!GameContext.IsInitialized) return;

                var sceneData = GameContext.Instance.PlayerManager?.LocalPlayer?.Info?.CurrentScenelData;
                if (sceneData == null) return;

                Debug.Log($"[NpcManager] ğŸ“¥ è¯·æ±‚åœºæ™¯ NPC: {sceneData.SceneName}/{sceneData.SubSceneName}");

                var serverContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                var npcService = new Shared.Services.Generated.NpcSyncServiceClientProxy(serverContext);
                var npcs = await npcService.RequestSceneNpcs(sceneData.SceneName, sceneData.SubSceneName);
                
                Debug.Log($"[NpcManager] âœ… æ”¶åˆ° {npcs.Length} ä¸ªåœºæ™¯ NPC");

                // æ‰¹é‡åˆ›å»ºå½±å­ NPCï¼ˆä½¿ç”¨å¯¹è±¡æ± ï¼‰
                foreach (var npcData in npcs)
                {
                    AddRemoteNpc(npcData.NpcId, npcData);
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] è¯·æ±‚åœºæ™¯ NPC å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å‘é€ NPC ç”Ÿæˆåˆ°æœåŠ¡å™¨
        /// </summary>
        private async void SendNpcSpawnToServer(NpcInfo npcInfo)
        {
            try
            {
                if (!GameContext.IsInitialized || GameContext.Instance.RpcClient == null) return;

                var spawnData = new NpcSpawnData
                {
                    NpcId = npcInfo.Id,
                    SceneName = npcInfo.SceneName,
                    SubSceneName = npcInfo.SubSceneName,
                    NpcType = npcInfo.Name,
                    PositionX = npcInfo.Position.x,
                    PositionY = npcInfo.Position.y,
                    PositionZ = npcInfo.Position.z,
                    RotationY = npcInfo.Rotation.eulerAngles.y,
                    MaxHealth = npcInfo.MaxHealth
                };

                var serverContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                var npcService = new Shared.Services.Generated.NpcSyncServiceClientProxy(serverContext);
                await npcService.NotifyNpcSpawned(spawnData);
                
                Debug.Log($"[NpcManager] âœ… NPC ç”Ÿæˆå·²å‘é€åˆ°æœåŠ¡å™¨");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] å‘é€ NPC ç”Ÿæˆå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å‘é€ NPC é”€æ¯åˆ°æœåŠ¡å™¨
        /// </summary>
        private async void SendNpcDestroyToServer(string npcId, string sceneName, string subSceneName)
        {
            try
            {
                if (!GameContext.IsInitialized || GameContext.Instance.RpcClient == null) return;

                var destroyData = new NpcDestroyData
                {
                    NpcId = npcId,
                    Reason = 0 // æ­£å¸¸é”€æ¯
                };

                var serverContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                var npcService = new Shared.Services.Generated.NpcSyncServiceClientProxy(serverContext);
                await npcService.NotifyNpcDestroyed(destroyData);
                
                Debug.Log($"[NpcManager] âœ… NPC é”€æ¯å·²é€šçŸ¥æœåŠ¡å™¨");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] å‘é€ NPC é”€æ¯å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ¯å¸§æ›´æ–° - å®šæœŸåŒæ­¥æœ¬åœ° NPC ä½ç½® + å¹³æ»‘è¿œç¨‹ NPC
        /// </summary>
        public void Update()
        {
            // å¤„ç†å»¶è¿Ÿçš„ NPC è¯·æ±‚ï¼ˆç­‰å¾…ä½ç½®åŒæ­¥ï¼‰
            if (_hasPendingNpcRequest && Time.time - _sceneLoadTime >= 1f)
            {
                _hasPendingNpcRequest = false;
                Debug.Log($"[NpcManager] ğŸ“¥ å»¶è¿Ÿè¯·æ±‚å®Œæˆï¼Œå¼€å§‹è¯·æ±‚åœºæ™¯ NPC");
                RequestSceneNpcs();
            }

            // å¹³æ»‘æ›´æ–°è¿œç¨‹ NPC ä½ç½®
            UpdateRemoteNpcSmoothing();

            // å®šæœŸåŒæ­¥æœ¬åœ° NPC ä½ç½®
            if (Time.time - _lastSyncTime >= SyncInterval)
            {
                SendNpcTransformBatch();
                _lastSyncTime = Time.time;
            }
        }

        /// <summary>
        /// å¹³æ»‘æ›´æ–°è¿œç¨‹ NPC çš„ä½ç½®å’Œæ—‹è½¬ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        private void UpdateRemoteNpcSmoothing()
        {
            foreach (var npc in _remoteNpcs.Values)
            {
                if (npc.GameObject == null || !npc.IsAlive) continue;

                // å¹³æ»‘æ’å€¼åˆ°ç›®æ ‡ä½ç½®
                float distance = Vector3.Distance(npc.Position, npc.TargetPosition);
                if (distance > 0.01f) // åªæœ‰è·ç¦»è¶³å¤Ÿå¤§æ‰æ’å€¼
                {
                    npc.Position = Vector3.Lerp(
                        npc.Position,
                        npc.TargetPosition,
                        Time.deltaTime * npc.SmoothSpeed
                    );
                    npc.GameObject.transform.position = npc.Position;
                }

                // å¹³æ»‘æ’å€¼æ—‹è½¬
                if (Quaternion.Angle(npc.Rotation, npc.TargetRotation) > 0.1f)
                {
                    npc.Rotation = Quaternion.Slerp(
                        npc.Rotation,
                        npc.TargetRotation,
                        Time.deltaTime * npc.SmoothSpeed
                    );
                    npc.GameObject.transform.rotation = npc.Rotation;
                }
            }
        }

        /// <summary>
        /// æ‰¹é‡å‘é€æœ¬åœ° NPC ä½ç½®åˆ°æœåŠ¡å™¨ï¼ˆå¸¦ä¼˜åŒ–ï¼‰
        /// </summary>
        private async void SendNpcTransformBatch()
        {
            try
            {
                if (!GameContext.IsInitialized || GameContext.Instance.RpcClient == null) return;
                if (_localNpcs.Count == 0) return;

                // è·å–æœ¬åœ°ç©å®¶ä½ç½®
                var localPlayer = GameContext.Instance.PlayerManager?.LocalPlayer;
                if (localPlayer?.CharacterObject == null) return;

                var playerPosition = localPlayer.CharacterObject.transform.position;

                // ä½¿ç”¨å¯è§æ€§ç®¡ç†å™¨è¿‡æ»¤éœ€è¦åŒæ­¥çš„ NPC
                var npcsToSync = _visibilityManager.GetNpcsToSync(_localNpcs, playerPosition, null);

                if (npcsToSync.Count == 0) return;

                var transforms = new List<NpcTransformData>();

                foreach (var npcId in npcsToSync)
                {
                    if (_localNpcs.TryGetValue(npcId, out var npc) && npc.GameObject != null)
                    {
                        var pos = npc.GameObject.transform.position;
                        var rot = npc.GameObject.transform.rotation.eulerAngles.y;

                        transforms.Add(new NpcTransformData
                        {
                            NpcId = npc.Id,
                            PositionX = pos.x,
                            PositionY = pos.y,
                            PositionZ = pos.z,
                            RotationY = rot
                        });
                    }
                }

                if (transforms.Count > 0)
                {
                    var batchData = new NpcBatchTransformData
                    {
                        Count = transforms.Count,
                        NpcIds = transforms.Select(t => t.NpcId).ToArray(),
                        PositionsX = transforms.Select(t => t.PositionX).ToArray(),
                        PositionsY = transforms.Select(t => t.PositionY).ToArray(),
                        PositionsZ = transforms.Select(t => t.PositionZ).ToArray(),
                        RotationsY = transforms.Select(t => t.RotationY).ToArray()
                    };

                    var serverContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                    var npcService = new Shared.Services.Generated.NpcSyncServiceClientProxy(serverContext);
                    await npcService.NotifyNpcBatchTransform(batchData);

                    // Debug.Log($"[NpcManager] åŒæ­¥ {transforms.Count}/{_localNpcs.Count} ä¸ª NPC");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcManager] å‘é€ä½ç½®æ›´æ–°å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// è·å–å¯è§æ€§ç®¡ç†å™¨ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        /// </summary>
        public NpcVisibilityManager VisibilityManager => _visibilityManager;

        /// <summary>
        /// è·å–å¯¹è±¡æ± ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        /// </summary>
        public ShadowNpcPool NpcPool => _npcPool;

        public void Dispose()
        {
            _eventSub.Dispose();
            _visibilityManager.Dispose();
            _npcPool.Dispose();
            _localNpcs.Clear();
            _remoteNpcs.Clear();
            _pendingRequests.Clear();
            _failedRequests.Clear();
            Debug.Log("[NpcManager] NPC ç®¡ç†å™¨å·²é‡Šæ”¾");
        }
    }

    /// <summary>
    /// NPC ä¿¡æ¯
    /// </summary>
    public class NpcInfo
    {
        public string Id { get; set; } = "";
        public object? CharacterMainControl { get; set; }
        public GameObject? GameObject { get; set; }
        public string Name { get; set; } = "Unknown";
        public Vector3 Position { get; set; }
        public Quaternion Rotation { get; set; }
        public float CurrentHealth { get; set; }
        public float MaxHealth { get; set; }
        public bool IsAlive { get; set; }
        public float SpawnTime { get; set; }
        public float? DeathTime { get; set; }
        
        /// <summary>
        /// æ˜¯å¦æ˜¯æœ¬åœ° NPCï¼ˆå¸¦ AIï¼‰
        /// </summary>
        public bool IsLocal { get; set; }
        
        /// <summary>
        /// åœºæ™¯åç§°ï¼ˆåˆ›å»ºæ—¶è®°å½•ï¼Œä¸ä¼šå˜åŒ–ï¼‰
        /// </summary>
        public string SceneName { get; set; } = "";
        
        /// <summary>
        /// å­åœºæ™¯åç§°
        /// </summary>
        public string SubSceneName { get; set; } = "";

        // å¹³æ»‘åŒæ­¥ï¼ˆä»…è¿œç¨‹ NPCï¼‰
        internal Vector3 TargetPosition { get; set; }
        internal Quaternion TargetRotation { get; set; }
        internal float SmoothSpeed { get; set; } = 10f; // å¹³æ»‘é€Ÿåº¦

        /// <summary>
        /// è¡€é‡ç™¾åˆ†æ¯”
        /// </summary>
        public float HealthPercent => MaxHealth > 0 ? (CurrentHealth / MaxHealth) * 100f : 0f;

        /// <summary>
        /// å­˜æ´»æ—¶é—´ï¼ˆç§’ï¼‰
        /// </summary>
        public float AliveTime
        {
            get
            {
                if (!IsAlive && DeathTime.HasValue)
                {
                    return DeathTime.Value - SpawnTime;
                }
                return Time.time - SpawnTime;
            }
        }
    }
}


```

`Client\Core\NpcVisibilityManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// NPC å¯è§æ€§ç®¡ç†å™¨ï¼ˆå®¢æˆ·ç«¯ï¼‰
    /// 
    /// åŠŸèƒ½ï¼š
    /// 1. åªåŒæ­¥æœ‰å˜åŒ–çš„ NPCï¼ˆä½ç½®/æ—‹è½¬å˜åŒ–æ£€æµ‹ï¼‰
    /// 2. åŸºäºè·ç¦»çš„åŒæ­¥èŒƒå›´é™åˆ¶ï¼ˆ100mï¼‰
    /// 3. å˜åŒ–æ£€æµ‹ï¼ˆé¿å…æ— æ•ˆåŒæ­¥ï¼‰
    /// </summary>
    public class NpcVisibilityManager : IDisposable
    {
        // é…ç½®å‚æ•°
        public float SyncRange { get; set; } = 100f; // åŒæ­¥èŒƒå›´ï¼ˆç±³ï¼‰
        public float PositionThreshold { get; set; } = 0.1f; // ä½ç½®å˜åŒ–é˜ˆå€¼
        public float RotationThreshold { get; set; } = 5f; // æ—‹è½¬å˜åŒ–é˜ˆå€¼ï¼ˆåº¦ï¼‰

        // NPC ä¸Šæ¬¡åŒæ­¥çš„çŠ¶æ€
        private readonly Dictionary<string, NpcSyncState> _lastSyncStates = new Dictionary<string, NpcSyncState>();

        // å¯è§çš„è¿œç¨‹ NPC é›†åˆï¼ˆç”¨äºè¿½è¸ªå“ªäº›æ˜¯æˆ‘ä»¬åˆ›å»ºçš„ï¼‰
        private readonly HashSet<string> _visibleRemoteNpcs = new HashSet<string>();

        /// <summary>
        /// æ£€æµ‹ NPC æ˜¯å¦æœ‰å˜åŒ–ï¼ˆä½ç½®æˆ–æ—‹è½¬ï¼‰
        /// </summary>
        public bool HasChanged(string npcId, Vector3 position, float rotationY)
        {
            if (!_lastSyncStates.TryGetValue(npcId, out var lastState))
            {
                // ç¬¬ä¸€æ¬¡åŒæ­¥ï¼Œè®°å½•çŠ¶æ€
                _lastSyncStates[npcId] = new NpcSyncState
                {
                    Position = position,
                    RotationY = rotationY,
                    LastSyncTime = Time.time
                };
                return true; // ç¬¬ä¸€æ¬¡æ€»æ˜¯åŒæ­¥
            }

            // æ£€æŸ¥ä½ç½®å˜åŒ–
            float positionDelta = Vector3.Distance(position, lastState.Position);
            if (positionDelta > PositionThreshold)
            {
                // æ›´æ–°çŠ¶æ€
                lastState.Position = position;
                lastState.RotationY = rotationY;
                lastState.LastSyncTime = Time.time;
                return true;
            }

            // æ£€æŸ¥æ—‹è½¬å˜åŒ–
            float rotationDelta = Mathf.Abs(Mathf.DeltaAngle(rotationY, lastState.RotationY));
            if (rotationDelta > RotationThreshold)
            {
                // æ›´æ–°çŠ¶æ€
                lastState.Position = position;
                lastState.RotationY = rotationY;
                lastState.LastSyncTime = Time.time;
                return true;
            }

            return false; // æ²¡æœ‰æ˜¾è‘—å˜åŒ–
        }

        /// <summary>
        /// æ£€æŸ¥ NPC æ˜¯å¦åœ¨åŒæ­¥èŒƒå›´å†…
        /// </summary>
        public bool IsInRange(Vector3 npcPosition, Vector3 playerPosition)
        {
            float distance = Vector3.Distance(npcPosition, playerPosition);
            return distance <= SyncRange;
        }

        /// <summary>
        /// è·å–éœ€è¦åŒæ­¥çš„ NPC åˆ—è¡¨ï¼ˆè¿‡æ»¤å˜åŒ– + èŒƒå›´ï¼‰
        /// </summary>
        public List<string> GetNpcsToSync(Dictionary<string, NpcInfo> localNpcs, Vector3 playerPosition, List<Vector3>? remotePlayerPositions = null)
        {
            var npcsToSync = new List<string>();

            foreach (var kvp in localNpcs)
            {
                var npcId = kvp.Key;
                var npc = kvp.Value;

                if (!npc.IsAlive || npc.GameObject == null)
                    continue;

                var npcPos = npc.GameObject.transform.position;
                var npcRot = npc.GameObject.transform.rotation.eulerAngles.y;

                // æ£€æŸ¥æ˜¯å¦åœ¨åŸºç¡€åŒæ­¥èŒƒå›´å†…ï¼ˆæœåŠ¡å™¨ç«¯å·²å¤„ç†çƒ­åŒºï¼‰
                bool inPlayerRange = IsInRange(npcPos, playerPosition);

                if (inPlayerRange)
                {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
                    if (HasChanged(npcId, npcPos, npcRot))
                    {
                        npcsToSync.Add(npcId);
                    }
                }
            }

            return npcsToSync;
        }

        /// <summary>
        /// æ ‡è®°è¿œç¨‹ NPC ä¸ºå¯è§
        /// </summary>
        public void MarkRemoteNpcVisible(string npcId)
        {
            _visibleRemoteNpcs.Add(npcId);
        }

        /// <summary>
        /// æ ‡è®°è¿œç¨‹ NPC ä¸ºä¸å¯è§
        /// </summary>
        public void MarkRemoteNpcInvisible(string npcId)
        {
            _visibleRemoteNpcs.Remove(npcId);
        }

        /// <summary>
        /// æ£€æŸ¥è¿œç¨‹ NPC æ˜¯å¦å¯è§
        /// </summary>
        public bool IsRemoteNpcVisible(string npcId)
        {
            return _visibleRemoteNpcs.Contains(npcId);
        }

        /// <summary>
        /// æ¸…ç† NPC çŠ¶æ€
        /// </summary>
        public void RemoveNpcState(string npcId)
        {
            _lastSyncStates.Remove(npcId);
            _visibleRemoteNpcs.Remove(npcId);
        }

        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public VisibilityStats GetStats()
        {
            return new VisibilityStats
            {
                TrackedNpcs = _lastSyncStates.Count,
                VisibleRemoteNpcs = _visibleRemoteNpcs.Count,
                SyncRange = SyncRange
            };
        }

        public void Dispose()
        {
            _lastSyncStates.Clear();
            _visibleRemoteNpcs.Clear();
        }
    }

    /// <summary>
    /// NPC åŒæ­¥çŠ¶æ€
    /// </summary>
    internal class NpcSyncState
    {
        public Vector3 Position { get; set; }
        public float RotationY { get; set; }
        public float LastSyncTime { get; set; }
    }

    /// <summary>
    /// å¯è§æ€§ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    public struct VisibilityStats
    {
        public int TrackedNpcs;
        public int VisibleRemoteNpcs;
        public float SyncRange;
    }
}


```

`Client\Core\Players\BasePlayer.cs`:

```cs
using System;
using UnityEngine;
using static UnityEngine.Debug;
using Steamworks;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.Utils;

namespace DuckyNet.Client.Core.Players
{
    /// <summary>
    /// ç©å®¶åŸºç±» - ç®¡ç†ç©å®¶ä¿¡æ¯å’Œå…³è”çš„è§’è‰²å¯¹è±¡
    /// </summary>
    public abstract class BasePlayer: IDisposable
    {
        /// <summary>
        /// ç©å®¶ä¿¡æ¯
        /// </summary>
        public PlayerInfo Info { get; set; }

        /// <summary>
        /// Steam å¤´åƒçº¹ç†ï¼ˆå¦‚æœå·²åŠ è½½ï¼‰
        /// </summary>
        public Texture2D? AvatarTexture { get; set; }

        /// <summary>
        /// è§’è‰²æ¸¸æˆå¯¹è±¡
        /// </summary>
        public GameObject? CharacterObject { get; protected set; }

        /// <summary>
        /// è§’è‰²æ˜¯å¦å·²åˆ›å»º
        /// </summary>
        public bool IsCharacterCreated => CharacterObject != null;

        public BasePlayer(PlayerInfo info)
        {
            Info = info;
        }

        /// <summary>
        /// é”€æ¯è§’è‰²å¯¹è±¡
        /// </summary>
        public virtual void DestroyCharacter()
        {
            if (CharacterObject != null)
            {
                Log($"[{GetType().Name}] é”€æ¯è§’è‰²: {Info.SteamName}");
                UnityEngine.Object.Destroy(CharacterObject);
                CharacterObject = null;
            }
        }

        /// <summary>
        /// è®¾ç½®è§’è‰²ä½ç½®
        /// </summary>
        public void SetCharacterPosition(Vector3 position)
        {
            if (CharacterObject != null)
            {
                CharacterObject.transform.position = position;
            }
        }

        /// <summary>
        /// è·å–è§’è‰²ä½ç½®
        /// </summary>
        public Vector3 GetCharacterPosition()
        {
            return CharacterObject != null ? CharacterObject.transform.position : Vector3.zero;
        }

        public abstract void SetAvatarTexture(Texture2D texture);

        public virtual void Dispose()
        {
            // é”€æ¯è§’è‰²å¯¹è±¡
            DestroyCharacter();
        }
    }
}
```

`Client\Core\Players\LocalPlayer.cs`:

```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using static UnityEngine.Debug;
using Steamworks;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Shared.Data;
using Unity.VisualScripting;
using DuckyNet.Client.RPC;
using DuckyNet.Shared.Services.Generated;

namespace DuckyNet.Client.Core.Players
{
    /// <summary>
    /// æœ¬åœ°ç©å®¶ç®¡ç†å™¨
    /// è´Ÿè´£ç®¡ç†æœ¬åœ°ç©å®¶ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä» Steam API è·å–ç©å®¶æ•°æ®
    /// </summary>
    public class LocalPlayer : BasePlayer
    {
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        private CharacterMainControl? _characterMainControl;
        private ClientServerContext? _serverContext;
        private PlayerUnitySyncServiceClientProxy? _playerService;
        private SceneServiceClientProxy? _sceneServiceClient;
        private Shared.Services.Generated.HealthSyncServiceClientProxy? _healthSyncService;

        // ä½ç½®åŒæ­¥ç›¸å…³
        private Vector3 _lastSyncedPosition;
        private Quaternion _lastSyncedRotation;
        private Vector3 _lastSyncedVelocity;
        private Vector3 _lastFramePosition; // ğŸ”¥ ä¸Šä¸€å¸§ä½ç½®ï¼ˆç”¨äºè®¡ç®—é€Ÿåº¦ï¼‰
        private float _lastFrameTime;       // ğŸ”¥ ä¸Šä¸€å¸§æ—¶é—´
        private float _positionThreshold = 0.01f; // 1cm ç§»åŠ¨é˜ˆå€¼
        private float _rotationThreshold = 0.5f; // 0.5åº¦æ—‹è½¬é˜ˆå€¼
        private float _velocityThreshold = 0.1f; // 0.1 m/s é€Ÿåº¦é˜ˆå€¼

        // ä¸»çº¿ç¨‹å®šæ—¶åŒæ­¥ç›¸å…³
        private float _syncInterval = 0.05f; // 50ms åŒæ­¥é—´éš” (20 times/sec)
        private float _syncTimer = 0f; // åŒæ­¥è®¡æ—¶å™¨
        private uint _sequenceNumber = 0; // åŒæ­¥åŒ…åºåˆ—å·
        private bool _isSyncEnabled = false; // æ˜¯å¦å¯ç”¨åŒæ­¥

        // è¡€é‡åŒæ­¥ç›¸å…³
        private float _lastSyncedHealth = -1f; // ä¸Šæ¬¡åŒæ­¥çš„è¡€é‡å€¼
        private float _lastSyncedMaxHealth = -1f; // ä¸Šæ¬¡åŒæ­¥çš„æœ€å¤§è¡€é‡å€¼
        private float _healthThreshold = 0.5f; // è¡€é‡å˜åŒ–é˜ˆå€¼ï¼ˆ0.5 ç‚¹ï¼‰

        public LocalPlayer(PlayerInfo info) : base(info)
        {

            _eventSubscriber.EnsureInitializedAndSubscribe();
            _eventSubscriber.Subscribe<SceneLoadedDetailEvent>(OnSceneLoaded);
            _eventSubscriber.Subscribe<SceneUnloadingDetailEvent>(OnSceneUnloading);
            _eventSubscriber.Subscribe<RoomJoinedEvent>(OnRoomJoined);
            _eventSubscriber.Subscribe<RoomLeftEvent>(OnRoomLeft);
            // åŠ å…¥åœºæ™¯
            _eventSubscriber.Subscribe<PlayerEnteredSceneEvent>(OnPlayerEnteredScene);
            _eventSubscriber.Subscribe<PlayerLeftSceneEvent>(OnPlayerLeftScene);
            _eventSubscriber.Subscribe<LocalPlayerShootEvent>(OnLocalPlayerShoot);
            _eventSubscriber.Subscribe<BeforeDamageAppliedEvent>(OnBeforeDamageApplied);
            
            // è®¢é˜…è¡€é‡ç›¸å…³äº‹ä»¶
            _eventSubscriber.Subscribe<HealthChangedEvent>(OnHealthChanged);
            _eventSubscriber.Subscribe<MaxHealthChangedEvent>(OnMaxHealthChanged);
            _eventSubscriber.Subscribe<CharacterHurtEvent>(OnCharacterHurt);
            _eventSubscriber.Subscribe<CharacterDeadEvent>(OnCharacterDead);
            
            Initialize();
        }

        #region è¡€é‡äº‹ä»¶å¤„ç†

        /// <summary>
        /// è¡€é‡å˜åŒ–äº‹ä»¶å¤„ç†å™¨
        /// </summary>
        private void OnHealthChanged(HealthChangedEvent @event)
        {
            // åªå¤„ç†æœ¬åœ°ç©å®¶çš„è¡€é‡å˜åŒ–
            if (!@event.IsLocalPlayer) return;

            try
            {
                // ğŸ”¥ å»é‡ï¼šåªåœ¨è¡€é‡çœŸæ­£å˜åŒ–æ—¶æ‰åŒæ­¥
                float healthDelta = Math.Abs(@event.CurrentHealth - _lastSyncedHealth);
                float maxHealthDelta = Math.Abs(@event.MaxHealth - _lastSyncedMaxHealth);
                
                // å¦‚æœè¡€é‡æˆ–æœ€å¤§è¡€é‡å˜åŒ–è¶…è¿‡é˜ˆå€¼ï¼Œæ‰åŒæ­¥
                if (healthDelta >= _healthThreshold || maxHealthDelta >= _healthThreshold)
                {
                    // UnityEngine.Debug.Log($"[LocalPlayer] ğŸ’š è¡€é‡å˜åŒ–: {_lastSyncedHealth:F0}/{_lastSyncedMaxHealth:F0} â†’ {@event.CurrentHealth:F0}/{@event.MaxHealth:F0}");
                    
                    // åŒæ­¥è¡€é‡åˆ°æœåŠ¡å™¨
                    SyncHealthToServer(@event.CurrentHealth, @event.MaxHealth, false);
                    
                    // æ›´æ–°ç¼“å­˜
                    _lastSyncedHealth = @event.CurrentHealth;
                    _lastSyncedMaxHealth = @event.MaxHealth;
                }
                // else: è¡€é‡å˜åŒ–å¤ªå°ï¼Œè·³è¿‡åŒæ­¥ï¼ˆå‡å°‘ç½‘ç»œæµé‡ï¼‰
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] å¤„ç†è¡€é‡å˜åŒ–äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æœ€å¤§è¡€é‡å˜åŒ–äº‹ä»¶å¤„ç†å™¨
        /// </summary>
        private void OnMaxHealthChanged(MaxHealthChangedEvent @event)
        {
            // åªå¤„ç†æœ¬åœ°ç©å®¶çš„æœ€å¤§è¡€é‡å˜åŒ–
            if (!@event.IsLocalPlayer) return;

            try
            {
                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ’ª æœ€å¤§è¡€é‡å˜åŒ–: {@event.MaxHealth:F0}");
                
                // TODO: åŒæ­¥æœ€å¤§è¡€é‡åˆ°æœåŠ¡å™¨ï¼ˆå¦‚æœéœ€è¦ï¼‰
                // SyncMaxHealthToServer(@event.MaxHealth);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] å¤„ç†æœ€å¤§è¡€é‡å˜åŒ–äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// è§’è‰²å—ä¼¤äº‹ä»¶å¤„ç†å™¨
        /// </summary>
        private void OnCharacterHurt(CharacterHurtEvent @event)
        {
            // åªå¤„ç†æœ¬åœ°ç©å®¶å—ä¼¤
            if (!@event.IsLocalPlayer) return;

            try
            {
                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ©¸ å—ä¼¤: å‰©ä½™è¡€é‡ {@event.CurrentHealth:F0}/{@event.MaxHealth:F0}");
                
                // TODO: é€šçŸ¥æœåŠ¡å™¨ç©å®¶å—ä¼¤ï¼ˆå¦‚æœéœ€è¦ï¼‰
                // NotifyServerPlayerHurt(@event.DamageInfo, @event.CurrentHealth);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] å¤„ç†å—ä¼¤äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// è§’è‰²æ­»äº¡äº‹ä»¶å¤„ç†å™¨
        /// </summary>
        private void OnCharacterDead(CharacterDeadEvent @event)
        {
            // åªå¤„ç†æœ¬åœ°ç©å®¶æ­»äº¡
            if (!@event.IsLocalPlayer) return;

            try
            {
                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ’€ æœ¬åœ°ç©å®¶æ­»äº¡");
                
                // é€šçŸ¥æœåŠ¡å™¨ç©å®¶æ­»äº¡ï¼ˆåŒæ­¥è¡€é‡ä¸º 0ï¼Œæ— æ¡ä»¶å‘é€ï¼‰
                SyncHealthToServer(0, 0, true);
                
                // æ›´æ–°ç¼“å­˜ï¼ˆé¿å…æ­»äº¡åçš„è¡€é‡å˜åŒ–å†æ¬¡è§¦å‘åŒæ­¥ï¼‰
                _lastSyncedHealth = 0;
                _lastSyncedMaxHealth = 0;
                
                // åœæ­¢ä½ç½®åŒæ­¥
                StopMainThreadSync();
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] å¤„ç†æ­»äº¡äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åŒæ­¥è¡€é‡åˆ°æœåŠ¡å™¨
        /// </summary>
        private void SyncHealthToServer(float currentHealth, float maxHealth, bool isDead)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦å·²åŠ å…¥æˆ¿é—´
                if (!GameContext.IsInitialized || GameContext.Instance.RoomManager?.CurrentRoom == null)
                {
                    return;
                }

                // æ£€æŸ¥è¡€é‡åŒæ­¥æœåŠ¡æ˜¯å¦å·²åˆå§‹åŒ–
                if (_healthSyncService == null)
                {
                    // å°è¯•å»¶è¿Ÿåˆå§‹åŒ–
                    if (_serverContext != null)
                    {
                        _healthSyncService = new Shared.Services.Generated.HealthSyncServiceClientProxy(_serverContext);
                    }
                    else
                    {
                        UnityEngine.Debug.LogWarning("[LocalPlayer] è¡€é‡åŒæ­¥æœåŠ¡æœªåˆå§‹åŒ–");
                        return;
                    }
                }

                // åˆ›å»ºè¡€é‡åŒæ­¥æ•°æ®
                var healthData = new Shared.Data.HealthSyncData
                {
                    SteamId = Info.SteamId,
                    CurrentHealth = currentHealth,
                    MaxHealth = maxHealth,
                    IsDead = isDead
                };

                // å‘é€åˆ°æœåŠ¡å™¨
                _healthSyncService.SendHealthSync(healthData);

            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] åŒæ­¥è¡€é‡åˆ°æœåŠ¡å™¨å¤±è´¥: {ex.Message}");
            }
        }

        #endregion

        private void OnBeforeDamageApplied(BeforeDamageAppliedEvent @event)
        {
            // åˆ¤æ–­å—ä¼¤çš„æ˜¯å¦æ˜¯å½“å‰ LocalPlayer å®ä¾‹çš„è§’è‰²
   
        }

        private void OnPlayerLeftScene(PlayerLeftSceneEvent @event)
        {

        }

        private void OnPlayerEnteredScene(PlayerEnteredSceneEvent @event)
        {
            if (@event.PlayerInfo.SteamId != Info.SteamId)
            {
                return;
            }
            if (CharacterObject != null && !string.IsNullOrEmpty(Info.CurrentScenelData.SceneName))
            {
                SendImmediatePositionSync();

                // å¦‚æœè§’è‰²å·²åˆ›å»ºï¼Œç«‹å³ä¸Šä¼ å¤–è§‚æ•°æ®
                UploadAppearanceData();

                // ğŸ”¥ ç«‹å³ä¸Šä¼ è£…å¤‡æ•°æ®å’Œæ­¦å™¨æ•°æ®
                UploadEquipmentData();
                UploadWeaponData();
            }
        }

        /// <summary>
        /// æœ¬åœ°ç©å®¶å¼€æªäº‹ä»¶å¤„ç†å™¨
        /// </summary>
        private void OnLocalPlayerShoot(LocalPlayerShootEvent evt)
        {
            try
            {
                // è·å–æªæ¢°åç§°
                string gunName = "Unknown";
                if (evt.Gun is Component gunComponent)
                {
                    gunName = gunComponent.gameObject.name;
                }

            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] å¤„ç†å¼€æªäº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        private void OnRoomJoined(RoomJoinedEvent @event)
        {
            if (@event.Player.SteamId != Info.SteamId)
            {
                return;
            }
            UnityEngine.Debug.Log($"[LocalPlayer] åŠ å…¥æˆ¿é—´: {@event.Room.RoomId}ï¼Œå¯åŠ¨ä½ç½®åŒæ­¥");

            // è¿™æ ·å…¶ä»–ç©å®¶åŠ å…¥æˆ¿é—´æ—¶,æœåŠ¡å™¨ç¼“å­˜ä¸­å°±æœ‰æˆ‘çš„ä½ç½®äº†
            if (CharacterObject != null && !string.IsNullOrEmpty(Info.CurrentScenelData.SceneName))
            {
                SendImmediatePositionSync();

                // å¦‚æœè§’è‰²å·²åˆ›å»ºï¼Œç«‹å³ä¸Šä¼ å¤–è§‚æ•°æ®
                UploadAppearanceData();

                // ğŸ”¥ ç«‹å³ä¸Šä¼ è£…å¤‡æ•°æ®å’Œæ­¦å™¨æ•°æ®
                UploadEquipmentData();
                UploadWeaponData();
            }
            // å‘é€åŠ å…¥åœºæ™¯
            if (Info.CurrentScenelData.SceneName != "" && Info.CurrentScenelData.SubSceneName != "")
            {
                _sceneServiceClient?.EnterSceneAsync(Info.CurrentScenelData);
            }

            StartMainThreadSync();
        }

        private void OnRoomLeft(RoomLeftEvent @event)
        {
            if (@event.Player.SteamId != Info.SteamId)
            {
                return;
            }
            UnityEngine.Debug.Log($"[LocalPlayer] ç¦»å¼€æˆ¿é—´: {@event.Room.RoomId}ï¼Œåœæ­¢ä½ç½®åŒæ­¥");
            StopMainThreadSync();
        }

        private void OnSceneUnloading(SceneUnloadingDetailEvent @event)
        {
            _sceneServiceClient?.LeaveSceneAsync(Info.CurrentScenelData);
            Info.CurrentScenelData = new ScenelData("", "");

            // ğŸ”¥ ä¿®å¤ï¼šæ›´æ–° RoomManager.RoomPlayers ä¸­è‡ªå·±çš„åœºæ™¯ä¿¡æ¯
            if (GameContext.IsInitialized && GameContext.Instance.RoomManager != null)
            {
                var myself = GameContext.Instance.RoomManager.RoomPlayers.Find(p => p.SteamId == Info.SteamId);
                if (myself != null)
                {
                    myself.CurrentScenelData = new ScenelData("", "");
                    UnityEngine.Debug.Log($"[LocalPlayer] âœ… å·²æ¸…ç©ºæˆ¿é—´åˆ—è¡¨ä¸­è‡ªå·±çš„åœºæ™¯ä¿¡æ¯");
                }
            }
        }

        private void OnSceneLoaded(SceneLoadedDetailEvent @event)
        {
            Info.CurrentScenelData = @event.ScenelData;
            CharacterObject = CharacterMainControl.Main?.gameObject;
            _characterMainControl = CharacterMainControl.Main;

            // é‡ç½®ä¸Šæ¬¡åŒæ­¥çš„ä½ç½®ä¿¡æ¯
            if (CharacterObject != null)
            {
                _lastSyncedPosition = CharacterObject.transform.position;
                _lastSyncedRotation = CharacterObject.transform.rotation;
                _lastFramePosition = _lastSyncedPosition; // ğŸ”¥ åˆå§‹åŒ–
                _lastFrameTime = Time.time;
            }

            // ğŸ”¥ ä¿®å¤ï¼šæ›´æ–° RoomManager.RoomPlayers ä¸­è‡ªå·±çš„åœºæ™¯ä¿¡æ¯
            if (GameContext.IsInitialized && GameContext.Instance.RoomManager != null)
            {
                var myself = GameContext.Instance.RoomManager.RoomPlayers.Find(p => p.SteamId == Info.SteamId);
                if (myself != null)
                {
                    myself.CurrentScenelData = @event.ScenelData;
                }
            }
            _sceneServiceClient?.EnterSceneAsync(Info.CurrentScenelData);
            if (CharacterObject != null)
            {
                UploadAppearanceData();
                UploadEquipmentData();
                UploadWeaponData();
            }



            // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œå¯åŠ¨åŒæ­¥ï¼Œç”±åŠ å…¥æˆ¿é—´äº‹ä»¶è§¦å‘
        }

        /// <summary>
        /// ä» Steam API åˆå§‹åŒ–ç©å®¶ä¿¡æ¯
        /// </summary>
        private void Initialize()
        {
            try
            {
                // å»¶è¿Ÿåˆå§‹åŒ– RPC å®¢æˆ·ç«¯ï¼ˆåœ¨ GameContext å®Œå…¨åˆå§‹åŒ–åï¼‰
                if (GameContext.IsInitialized && GameContext.Instance.RpcClient != null)
                {
                    _serverContext = new ClientServerContext(GameContext.Instance.RpcClient);
                    _playerService = new PlayerUnitySyncServiceClientProxy(_serverContext);
                    _sceneServiceClient = new SceneServiceClientProxy(_serverContext);
                    _healthSyncService = new Shared.Services.Generated.HealthSyncServiceClientProxy(_serverContext);
                    UnityEngine.Debug.Log($"[LocalPlayer] RPC å®¢æˆ·ç«¯å·²åˆå§‹åŒ–");
                }
                else
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] GameContext æœªåˆå§‹åŒ–æˆ– RpcClient ä¸ºç©º");
                }

                if (!SteamManager.Initialized)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] Steam æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨é»˜è®¤ç©å®¶ä¿¡æ¯");
                    InitializeWithDefaultInfo();
                    return;
                }

                // ä» Steam è·å–ç©å®¶ä¿¡æ¯
                CSteamID steamId = SteamUser.GetSteamID();
                string steamUsername = SteamFriends.GetPersonaName();
                string avatarUrl = GetSteamAvatarUrl(steamId);

                Info = new PlayerInfo
                {
                    SteamId = steamId.ToString(),
                    SteamName = steamUsername,
                    AvatarUrl = avatarUrl,
                };
                // å¼‚æ­¥åŠ è½½å¤´åƒçº¹ç†
                LoadAvatarTexture(steamId);

            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
                InitializeWithDefaultInfo();
            }

        }

        /// <summary>
        /// ä½¿ç”¨é»˜è®¤ä¿¡æ¯åˆå§‹åŒ–ï¼ˆSteamä¸å¯ç”¨æ—¶ï¼‰
        /// </summary>
        private void InitializeWithDefaultInfo()
        {
            Info = new PlayerInfo
            {
                SteamId = "default_" + Guid.NewGuid().ToString().Substring(0, 8),
                SteamName = "Player_" + UnityEngine.Random.Range(1000, 9999),
                AvatarUrl = string.Empty,
            };
        }

        /// <summary>
        /// è·å– Steam å¤´åƒ URLï¼ˆå…¬å¼€ CDN ç›´é“¾ï¼‰
        /// </summary>
        private string GetSteamAvatarUrl(CSteamID steamId)
        {
            try
            {
                string steamId64 = steamId.ToString();
                
                // ğŸ”¥ Steam ç¤¾åŒºå¤´åƒ APIï¼ˆå…¬å¼€è®¿é—®ï¼Œæ— éœ€è®¤è¯ï¼‰
                // è¿™ä¸ª URL ä¼šè‡ªåŠ¨é‡å®šå‘åˆ°å®é™…çš„ CDN åœ°å€
                // æ”¯æŒçš„å°ºå¯¸ï¼š
                // - avatar.jpg (32x32)
                // - avatarmedium.jpg (64x64)
                // - avatarfull.jpg (184x184)
                string avatarUrl = $"https://steamcommunity.com/profiles/{steamId64}/avatar_medium.jpg";
                
                UnityEngine.Debug.Log($"[LocalPlayer] Steam å¤´åƒ URL: {avatarUrl}");
                return avatarUrl;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogWarning($"[LocalPlayer] è·å–å¤´åƒ URL å¤±è´¥: {ex.Message}");
                return string.Empty;
            }
        }

        /// <summary>
        /// åŠ è½½ Steam å¤´åƒçº¹ç†
        /// </summary>
        private void LoadAvatarTexture(CSteamID steamId)
        {
            try
            {
                // è·å–ä¸­ç­‰å°ºå¯¸å¤´åƒå¥æŸ„
                int avatarHandle = SteamFriends.GetMediumFriendAvatar(steamId);

                if (avatarHandle == -1 || avatarHandle == 0)
                {
                    UnityEngine.Debug.LogWarning($"[LocalPlayer] æ— æ•ˆçš„å¤´åƒå¥æŸ„");
                    return;
                }

                // è·å–å¤´åƒå°ºå¯¸
                bool success = SteamUtils.GetImageSize(avatarHandle, out uint width, out uint height);
                if (!success || width == 0 || height == 0)
                {
                    UnityEngine.Debug.LogWarning($"[LocalPlayer] æ— æ³•è·å–å¤´åƒå°ºå¯¸");
                    return;
                }

                // åˆ›å»ºçº¹ç†
                byte[] imageData = new byte[width * height * 4]; // RGBA
                success = SteamUtils.GetImageRGBA(avatarHandle, imageData, (int)(width * height * 4));

                if (!success)
                {
                    UnityEngine.Debug.LogWarning($"[LocalPlayer] æ— æ³•è·å–å¤´åƒæ•°æ®");
                    return;
                }

                // åˆ›å»º Unity çº¹ç†
                this.AvatarTexture = new Texture2D((int)width, (int)height, TextureFormat.RGBA32, false);
                AvatarTexture.LoadRawTextureData(imageData);
                AvatarTexture.Apply();

                // å‚ç›´ç¿»è½¬ï¼ˆSteam å›¾åƒæ˜¯ä¸Šä¸‹é¢ å€’çš„ï¼‰
                FlipTextureVertically(AvatarTexture);

                UnityEngine.Debug.Log($"[LocalPlayer] å¤´åƒçº¹ç†å·²åŠ è½½: {width}x{height}");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogWarning($"[LocalPlayer] åŠ è½½å¤´åƒçº¹ç†å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å‚ç›´ç¿»è½¬çº¹ç†
        /// </summary>
        private void FlipTextureVertically(Texture2D texture)
        {
            Color[] pixels = texture.GetPixels();
            Color[] flipped = new Color[pixels.Length];

            int width = texture.width;
            int height = texture.height;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    flipped[x + y * width] = pixels[x + (height - y - 1) * width];
                }
            }

            texture.SetPixels(flipped);
            texture.Apply();
        }

        /// <summary>
        /// Unity LateUpdate - ä¸»çº¿ç¨‹å®šæ—¶åŒæ­¥ä½ç½®
        /// </summary>
        public void LateUpdate()
        {
            // å¦‚æœ RPC æœåŠ¡å°šæœªåˆå§‹åŒ–ï¼Œå°è¯•åˆå§‹åŒ–
            if (_playerService == null && GameContext.IsInitialized && GameContext.Instance.RpcClient != null)
            {
                _serverContext = new ClientServerContext(GameContext.Instance.RpcClient);
                _playerService = new PlayerUnitySyncServiceClientProxy(_serverContext);
                UnityEngine.Debug.Log("[LocalPlayer] RPC å®¢æˆ·ç«¯å»¶è¿Ÿåˆå§‹åŒ–æˆåŠŸ");

                // å¦‚æœåœºæ™¯å·²åŠ è½½ä¸”è¿˜æ²¡å¯åŠ¨åŒæ­¥ï¼Œç«‹å³å¯åŠ¨
                if (CharacterObject != null && !_isSyncEnabled)
                {
                    UnityEngine.Debug.Log("[LocalPlayer] LateUpdate ä¸­è§¦å‘åŒæ­¥å¯åŠ¨");
                    StartMainThreadSync();
                }
            }

            // å¦‚æœåŒæ­¥æœªå¯ç”¨ï¼Œç›´æ¥è¿”å›
            if (!_isSyncEnabled)
                return;

            // ç´¯åŠ æ—¶é—´
            _syncTimer += Time.deltaTime;

            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾åŒæ­¥é—´éš”
            if (_syncTimer >= _syncInterval)
            {
                _syncTimer = 0f;
                SendPositionSync();
            }
        }

        /// <summary>
        /// å¯åŠ¨ä¸»çº¿ç¨‹åŒæ­¥
        /// </summary>
        private void StartMainThreadSync()
        {
            if (_playerService == null)
            {
                UnityEngine.Debug.LogWarning("[LocalPlayer] _playerService æœªåˆå§‹åŒ–ï¼Œæ— æ³•å¯åŠ¨ä¸»çº¿ç¨‹åŒæ­¥");
                return;
            }

            UnityEngine.Debug.Log($"[LocalPlayer] å¯åŠ¨ä¸»çº¿ç¨‹åŒæ­¥å¾ªç¯ (é—´éš”: {_syncInterval}s, é¢‘ç‡: 30/sec)");
            _isSyncEnabled = true;
            _syncTimer = 0f;
        }

        /// <summary>
        /// åœæ­¢ä¸»çº¿ç¨‹åŒæ­¥
        /// </summary>
        private void StopMainThreadSync()
        {
            UnityEngine.Debug.Log("[LocalPlayer] åœæ­¢ä¸»çº¿ç¨‹åŒæ­¥");
            _isSyncEnabled = false;
            _syncTimer = 0f;
        }

        /// <summary>
        /// å‘é€ä½ç½®åŒæ­¥æ•°æ® (åœ¨ä¸»çº¿ç¨‹è°ƒç”¨)
        /// </summary>
        private void SendPositionSync()
        {
            // ========== æ£€æŸ¥å‰ç½®æ¡ä»¶ ==========
            if (CharacterObject == null || _playerService == null)
                return;

            // æ£€æŸ¥æ˜¯å¦å·²è¿›å…¥åœºæ™¯
            if (string.IsNullOrEmpty(Info.CurrentScenelData.SceneName) ||
                string.IsNullOrEmpty(Info.CurrentScenelData.SubSceneName))
            {
                // æœªåŠ å…¥åœºæ™¯/å­åœºæ™¯ï¼Œä¸å‘é€
                return;
            }

            try
            {
                // ========== åœ¨ä¸»çº¿ç¨‹å®‰å…¨åœ°è¯»å– Unity å¯¹è±¡æ•°æ® ==========
                Vector3 currentPosition = CharacterObject.transform.position;

                // ğŸ”¥ ä½¿ç”¨ CharacterMainControl.CurrentAimDirection è·å–è§’è‰²æœå‘
                Quaternion currentRotation = Quaternion.identity;
                if (_characterMainControl != null)
                {
                    Vector3 aimDirection = _characterMainControl.CurrentAimDirection;
                    if (aimDirection != Vector3.zero)
                    {
                        currentRotation = Quaternion.LookRotation(aimDirection);
                    }
                }

                Vector3 currentVelocity = Vector3.zero;

                // ğŸ”¥ æ”¹è¿›é€Ÿåº¦è®¡ç®—ï¼šä¼˜å…ˆä½¿ç”¨ Rigidbodyï¼Œå¦åˆ™æ‰‹åŠ¨è®¡ç®—
                Rigidbody rb = CharacterObject.GetComponent<Rigidbody>();
                if (rb != null)
                {
                    currentVelocity = rb.velocity;
                }
                else
                {
                    // æ²¡æœ‰ Rigidbodyï¼Œé€šè¿‡ä½ç½®å·®è®¡ç®—é€Ÿåº¦
                    float deltaTime = Time.time - _lastFrameTime;
                    if (deltaTime > 0.001f) // é˜²æ­¢é™¤0
                    {
                        currentVelocity = (currentPosition - _lastFramePosition) / deltaTime;
                    }
                    _lastFramePosition = currentPosition;
                    _lastFrameTime = Time.time;
                }

                // ========== æ£€æŸ¥æ•°æ®æ˜¯å¦æœ‰å®è´¨æ€§å˜åŒ– ==========
                float positionDelta = Vector3.Distance(currentPosition, _lastSyncedPosition);
                float rotationDelta = Quaternion.Angle(currentRotation, _lastSyncedRotation);
                float velocityDelta = Vector3.Distance(currentVelocity, _lastSyncedVelocity);

                // å¦‚æœæ•°æ®å˜åŒ–ä¸è¶³é˜ˆå€¼ï¼Œè·³è¿‡å‘é€
                if (positionDelta < _positionThreshold &&
                    rotationDelta < _rotationThreshold &&
                    velocityDelta < _velocityThreshold)
                {
                    return;
                }

                // ========== åˆ›å»ºå¹¶å‘é€åŒæ­¥æ•°æ® ==========
                UnitySyncData syncData = new UnitySyncData
                {
                    SteamId = Info.SteamId,
                    SequenceNumber = ++_sequenceNumber, // é€’å¢åºåˆ—å·
                };

                // è®¾ç½®ä½ç½®
                syncData.SetPosition(currentPosition.x, currentPosition.y, currentPosition.z);

                // è®¾ç½®æ—‹è½¬
                syncData.SetRotation(currentRotation.x, currentRotation.y, currentRotation.z, currentRotation.w);

                // è®¾ç½®é€Ÿåº¦
                syncData.SetVelocity(currentVelocity.x, currentVelocity.y, currentVelocity.z);

                // å‘é€åŒæ­¥æ•°æ®
                _playerService.SendPlayerUnitySync(syncData);

                // æ›´æ–°ä¸Šæ¬¡åŒæ­¥çš„æ•°æ®
                _lastSyncedPosition = currentPosition;
                _lastSyncedRotation = currentRotation;
                _lastSyncedVelocity = currentVelocity;

            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] å‘é€ä½ç½®åŒæ­¥å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// ç«‹å³å‘é€ä¸€æ¬¡ä½ç½®åŒæ­¥ï¼ˆç”¨äºåŠ å…¥æˆ¿é—´æ—¶ï¼‰
        /// </summary>
        private void SendImmediatePositionSync()
        {
            if (_playerService == null || CharacterObject == null)
            {
                UnityEngine.Debug.LogWarning("[LocalPlayer] æ— æ³•ç«‹å³å‘é€ä½ç½®åŒæ­¥ï¼šRPCæœåŠ¡æˆ–è§’è‰²å¯¹è±¡ä¸ºç©º");
                return;
            }

            try
            {
                var currentPosition = CharacterObject.transform.position;

                // ğŸ”¥ ä½¿ç”¨ CharacterMainControl.CurrentAimDirection è·å–è§’è‰²æœå‘
                Quaternion currentRotation = Quaternion.identity;
                if (_characterMainControl != null)
                {
                    Vector3 aimDirection = _characterMainControl.CurrentAimDirection;
                    if (aimDirection != Vector3.zero)
                    {
                        currentRotation = Quaternion.LookRotation(aimDirection);
                    }
                }

                var currentVelocity = Vector3.zero;

                // å°è¯•è·å–é€Ÿåº¦
                Rigidbody rb = CharacterObject.GetComponent<Rigidbody>();
                if (rb != null)
                {
                    currentVelocity = rb.velocity;
                }
                else
                {
                    // æ²¡æœ‰Rigidbodyï¼Œæ‰‹åŠ¨è®¡ç®—é€Ÿåº¦
                    if (_lastFrameTime > 0)
                    {
                        float deltaTime = Time.time - _lastFrameTime;
                        if (deltaTime > 0.001f)
                        {
                            currentVelocity = (currentPosition - _lastFramePosition) / deltaTime;
                        }
                    }
                }

                // åˆ›å»ºåŒæ­¥æ•°æ®
                UnitySyncData syncData = new UnitySyncData
                {
                    SteamId = Info.SteamId,
                    SequenceNumber = ++_sequenceNumber,
                };

                syncData.SetPosition(currentPosition.x, currentPosition.y, currentPosition.z);
                syncData.SetRotation(currentRotation.x, currentRotation.y, currentRotation.z, currentRotation.w);
                syncData.SetVelocity(currentVelocity.x, currentVelocity.y, currentVelocity.z);

                // ç«‹å³å‘é€
                _playerService.SendPlayerUnitySync(syncData);

                // æ›´æ–°ç¼“å­˜
                _lastSyncedPosition = currentPosition;
                _lastSyncedRotation = currentRotation;
                _lastSyncedVelocity = currentVelocity;
                _lastFramePosition = currentPosition;
                _lastFrameTime = Time.time;

                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ”¥ ç«‹å³å‘é€ä½ç½®åŒæ­¥: Pos({currentPosition.x:F2},{currentPosition.y:F2},{currentPosition.z:F2}) " +
                    $"Rot(Y:{currentRotation.eulerAngles.y:F1}Â°) " +
                    $"åœºæ™¯:{Info.CurrentScenelData.SceneName}/{Info.CurrentScenelData.SubSceneName}");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] ç«‹å³å‘é€ä½ç½®åŒæ­¥å¤±è´¥: {ex.Message}");
            }
        }


        public override void SetAvatarTexture(Texture2D texture)
        {
            this.AvatarTexture = texture;
        }

        /// <summary>
        /// ä¸Šä¼ è§’è‰²å¤–è§‚æ•°æ®åˆ°æœåŠ¡å™¨
        /// </summary>
        private void UploadAppearanceData()
        {
            try
            {
                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ¨ å¼€å§‹ä¸Šä¼ è§’è‰²å¤–è§‚æ•°æ®...");

                // æ£€æŸ¥è§’è‰²æ˜¯å¦å·²åˆ›å»º
                if (CharacterObject == null || _characterMainControl == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âš ï¸ è§’è‰²å°šæœªåˆ›å»ºï¼Œè·³è¿‡ä¸Šä¼ å¤–è§‚æ•°æ®");
                    return;
                }

                // è·å–æœ¬åœ°ç©å®¶å¤–è§‚æ•°æ®
                var appearanceData = Utils.AppearanceConverter.LoadMainCharacterAppearance();
                if (appearanceData == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âŒ æ— æ³•è·å–è§’è‰²å¤–è§‚æ•°æ®");
                    return;
                }

                UnityEngine.Debug.Log($"[LocalPlayer] âœ… æˆåŠŸè·å–å¤–è§‚æ•°æ® - HeadScale: {appearanceData.HeadSetting.ScaleX}, Parts: {appearanceData.Parts.Length}");

                // è°ƒç”¨ RPC ä¸Šä¼ å¤–è§‚
                if (GameContext.IsInitialized && GameContext.Instance.RpcClient != null)
                {
                    UnityEngine.Debug.Log($"[LocalPlayer] ğŸ“¤ æ­£åœ¨é€šè¿‡RPCä¸Šä¼ å¤–è§‚æ•°æ®åˆ°æœåŠ¡å™¨...");
                    GameContext.Instance.RpcClient.InvokeServer<Shared.Services.ICharacterAppearanceService>(
                        nameof(Shared.Services.ICharacterAppearanceService.UploadAppearance),
                        appearanceData
                    );
                    UnityEngine.Debug.Log($"[LocalPlayer] âœ… å¤–è§‚æ•°æ®å·²å‘é€åˆ°æœåŠ¡å™¨");
                }
                else
                {
                    UnityEngine.Debug.LogError("[LocalPlayer] âŒ RpcClientæœªåˆå§‹åŒ–ï¼Œæ— æ³•ä¸Šä¼ å¤–è§‚æ•°æ®");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] âŒ ä¸Šä¼ å¤–è§‚æ•°æ®å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// ä¸Šä¼ è£…å¤‡æ•°æ®åˆ°æœåŠ¡å™¨ï¼ˆåŠ å…¥æˆ¿é—´æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        private async void UploadEquipmentData()
        {
            try
            {
                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ½ å¼€å§‹ä¸Šä¼ è§’è‰²è£…å¤‡æ•°æ®...");

                if (CharacterObject == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âš ï¸ è§’è‰²å°šæœªåˆ›å»ºï¼Œè·³è¿‡ä¸Šä¼ è£…å¤‡æ•°æ®");
                    return;
                }

                var characterMainControl = CharacterObject.GetComponent<CharacterMainControl>();
                if (characterMainControl == null || characterMainControl.CharacterItem == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âŒ æ— æ³•è·å–è§’è‰²è£…å¤‡æ•°æ®");
                    return;
                }

                var characterItem = characterMainControl.CharacterItem;

                // è·å–æ‰€æœ‰è£…å¤‡æ§½ä½
                var equipmentSlots = new[]
                {
                    (CharacterEquipmentController.armorHash, Shared.Data.EquipmentSlotType.Armor, "æŠ¤ç”²"),
                    (CharacterEquipmentController.helmatHash, Shared.Data.EquipmentSlotType.Helmet, "å¤´ç›”"),
                    (CharacterEquipmentController.faceMaskHash, Shared.Data.EquipmentSlotType.FaceMask, "é¢ç½©"),
                    (CharacterEquipmentController.backpackHash, Shared.Data.EquipmentSlotType.Backpack, "èƒŒåŒ…"),
                    (CharacterEquipmentController.headsetHash, Shared.Data.EquipmentSlotType.Headset, "è€³æœº")
                };

                if (_serverContext == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âŒ RPCä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œæ— æ³•ä¸Šä¼ è£…å¤‡æ•°æ®");
                    return;
                }

                // åˆ›å»ºè£…å¤‡æœåŠ¡ä»£ç†
                var equipmentService = new Shared.Services.Generated.EquipmentServiceClientProxy(_serverContext);
                int uploadedCount = 0;

                // ä¸Šä¼ æ¯ä¸ªæ§½ä½çš„è£…å¤‡
                foreach (var (slotHash, slotType, slotName) in equipmentSlots)
                {
                    var slot = characterItem.Slots.GetSlot(slotHash);
                    int? itemTypeId = slot?.Content?.TypeID;

                    if (itemTypeId.HasValue && itemTypeId.Value > 0)
                    {
                        var request = new Shared.Data.EquipmentSlotUpdateRequest
                        {
                            SlotType = slotType,
                            ItemTypeId = itemTypeId
                        };

                        bool success = await equipmentService.UpdateEquipmentSlotAsync(request);
                        if (success)
                        {
                            uploadedCount++;
                            UnityEngine.Debug.Log($"[LocalPlayer] âœ… å·²ä¸Šä¼ è£…å¤‡: {slotName} = TypeID {itemTypeId}");
                        }
                    }
                }

                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ½ è£…å¤‡æ•°æ®ä¸Šä¼ å®Œæˆ: {uploadedCount} ä»¶è£…å¤‡");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] âŒ ä¸Šä¼ è£…å¤‡æ•°æ®å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// ä¸Šä¼ æ­¦å™¨æ•°æ®åˆ°æœåŠ¡å™¨ï¼ˆåŠ å…¥æˆ¿é—´æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        private async void UploadWeaponData()
        {
            try
            {
                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ”« å¼€å§‹ä¸Šä¼ è§’è‰²æ­¦å™¨æ•°æ®...");

                if (CharacterObject == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âš ï¸ è§’è‰²å°šæœªåˆ›å»ºï¼Œè·³è¿‡ä¸Šä¼ æ­¦å™¨æ•°æ®");
                    return;
                }

                var characterMainControl = CharacterObject.GetComponent<CharacterMainControl>();
                if (characterMainControl == null || characterMainControl.CharacterItem == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âŒ æ— æ³•è·å–è§’è‰²æ­¦å™¨æ•°æ®");
                    return;
                }

                var characterItem = characterMainControl.CharacterItem;

                // è·å–æ‰€æœ‰æ­¦å™¨æ§½ä½
                var weaponSlots = new[]
                {
                    ("PrimaryWeapon".GetHashCode(), Shared.Data.WeaponSlotType.PrimaryWeapon, "ä¸»æ­¦å™¨"),
                    ("SecondaryWeapon".GetHashCode(), Shared.Data.WeaponSlotType.SecondaryWeapon, "å‰¯æ­¦å™¨"),
                    ("MeleeWeapon".GetHashCode(), Shared.Data.WeaponSlotType.MeleeWeapon, "è¿‘æˆ˜æ­¦å™¨")
                };

                if (_serverContext == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âŒ RPCä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œæ— æ³•ä¸Šä¼ æ­¦å™¨æ•°æ®");
                    return;
                }

                // åˆ›å»ºæ­¦å™¨æœåŠ¡ä»£ç†
                var weaponService = new Shared.Services.Generated.WeaponSyncServiceClientProxy(_serverContext);
                int uploadedCount = 0;

                // ä¸Šä¼ æ¯ä¸ªæ§½ä½çš„æ­¦å™¨
                foreach (var (slotHash, slotType, slotName) in weaponSlots)
                {
                    var slot = characterItem.Slots.GetSlot(slotHash);
                    if (slot?.Content != null)
                    {
                        var weaponItem = slot.Content;

                        // ä½¿ç”¨ WeaponSyncHelper åˆ›å»ºè¯·æ±‚ï¼ˆåŒ…å«åºåˆ—åŒ–æ•°æ®ï¼‰
                        var request = Services.WeaponSyncHelper.CreateWeaponSlotUpdateRequest(slotType, weaponItem);

                        bool success = await weaponService.EquipWeaponAsync(request);
                        if (success)
                        {
                            uploadedCount++;
                            string dataInfo = request.IsDefaultItem ? "é»˜è®¤" : $"{request.ItemDataCompressed.Length}å­—èŠ‚";
                            UnityEngine.Debug.Log($"[LocalPlayer] âœ… å·²ä¸Šä¼ æ­¦å™¨: {slotName} = {weaponItem.DisplayName} (æ•°æ®={dataInfo})");
                        }
                    }
                }

                UnityEngine.Debug.Log($"[LocalPlayer] ğŸ”« æ­¦å™¨æ•°æ®ä¸Šä¼ å®Œæˆ: {uploadedCount} ä»¶æ­¦å™¨");

                // ğŸ”¥ ä¸Šä¼ å½“å‰æ‰‹æŒçš„æ­¦å™¨æ§½ä½
                await UploadCurrentWeaponSlot(characterMainControl);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] âŒ ä¸Šä¼ æ­¦å™¨æ•°æ®å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// ä¸Šä¼ å½“å‰æ‰‹æŒçš„æ­¦å™¨æ§½ä½
        /// </summary>
        private async System.Threading.Tasks.Task UploadCurrentWeaponSlot(CharacterMainControl characterMainControl)
        {
            try
            {
                if (characterMainControl == null || characterMainControl.CurrentHoldItemAgent == null)
                {
                    UnityEngine.Debug.Log("[LocalPlayer] å½“å‰æ²¡æœ‰æ‰‹æŒæ­¦å™¨ï¼Œè·³è¿‡æ§½ä½åŒæ­¥");
                    return;
                }

                var currentWeapon = characterMainControl.CurrentHoldItemAgent.Item;
                if (currentWeapon == null)
                {
                    return;
                }

                // ç¡®å®šå½“å‰æ­¦å™¨åœ¨å“ªä¸ªæ§½ä½
                Shared.Data.WeaponSlotType? slotType = null;

                if (characterMainControl.PrimWeaponSlot()?.Content == currentWeapon)
                    slotType = Shared.Data.WeaponSlotType.PrimaryWeapon;
                else if (characterMainControl.SecWeaponSlot()?.Content == currentWeapon)
                    slotType = Shared.Data.WeaponSlotType.SecondaryWeapon;
                else if (characterMainControl.MeleeWeaponSlot()?.Content == currentWeapon)
                    slotType = Shared.Data.WeaponSlotType.MeleeWeapon;

                if (!slotType.HasValue)
                {
                    UnityEngine.Debug.LogWarning($"[LocalPlayer] æ— æ³•ç¡®å®šå½“å‰æ­¦å™¨çš„æ§½ä½: {currentWeapon.DisplayName}");
                    return;
                }

                if (_serverContext == null)
                {
                    UnityEngine.Debug.LogWarning("[LocalPlayer] âŒ RPCä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œæ— æ³•ä¸Šä¼ æ­¦å™¨æ§½ä½");
                    return;
                }

                var weaponService = new Shared.Services.Generated.WeaponSyncServiceClientProxy(_serverContext);
                var request = new Shared.Data.WeaponSwitchRequest
                {
                    CurrentWeaponSlot = slotType.Value
                };

                bool success = await weaponService.SwitchWeaponSlotAsync(request);
                if (success)
                {
                    UnityEngine.Debug.Log($"[LocalPlayer] âœ… å·²ä¸Šä¼ å½“å‰æ­¦å™¨æ§½ä½: {slotType} ({currentWeapon.DisplayName})");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LocalPlayer] âŒ ä¸Šä¼ å½“å‰æ­¦å™¨æ§½ä½å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        public override void Dispose()
        {
            StopMainThreadSync();
            _eventSubscriber?.Dispose();

            if (AvatarTexture != null)
            {
                UnityEngine.Object.Destroy(AvatarTexture);
                AvatarTexture = null;
            }

            // è°ƒç”¨åŸºç±» Dispose é”€æ¯è§’è‰²å¯¹è±¡
            base.Dispose();
        }
    }
}


```

`Client\Core\Players\PlayerManager.cs`:

```cs
using System;
using UnityEngine;
using static UnityEngine.Debug;
using Steamworks;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;
using System.Collections.Generic;

namespace DuckyNet.Client.Core.Players
{
    public class PlayerManager : IDisposable
    {
        // ä½¿ç”¨ Dictionary æ›¿ä»£ List - O(1) æŸ¥æ‰¾
        private readonly Dictionary<string, RemotePlayer> _remotePlayers = new Dictionary<string, RemotePlayer>();
        
        /// <summary>
        /// è·å–æ‰€æœ‰è¿œç¨‹ç©å®¶ï¼ˆåªè¯»ï¼‰
        /// </summary>
        public IEnumerable<RemotePlayer> RemotePlayers => _remotePlayers.Values;

        /// <summary>
        /// è·å–æ‰€æœ‰è¿œç¨‹ç©å®¶çš„ä½ç½®ï¼ˆç”¨äºçƒ­åŒºè®¡ç®—ï¼‰
        /// </summary>
        public List<Vector3> GetRemotePlayerPositions()
        {
            var positions = new List<Vector3>();
            
            foreach (var player in _remotePlayers.Values)
            {
                if (player.CharacterObject != null)
                {
                    positions.Add(player.CharacterObject.transform.position);
                }
            }
            
            return positions;
        }
        
        public LocalPlayer LocalPlayer { get; private set; }
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        
        // ğŸ¯ æ–°å¢ï¼šè¿œç¨‹åŠ¨ç”»åŒæ­¥ç®¡ç†å™¨
        private readonly RemoteAnimatorSyncManager _remoteAnimatorSync = new RemoteAnimatorSyncManager();
        public PlayerManager()
        {
            LocalPlayer = new LocalPlayer(new PlayerInfo());
            _eventSubscriber.EnsureInitializedAndSubscribe();
            
            // ğŸ”¥ æ­£ç¡®æ¶æ„ï¼š
            // - æˆ¿é—´äº‹ä»¶ï¼šåˆ›å»º/åˆ é™¤ RemotePlayer
            // - åœºæ™¯äº‹ä»¶ï¼šåˆ›å»º/åˆ é™¤è§’è‰²
            _eventSubscriber.Subscribe<PlayerJoinedRoomEvent>(OnPlayerJoinedRoom);
            _eventSubscriber.Subscribe<PlayerLeftRoomEvent>(OnPlayerLeftRoom);
            _eventSubscriber.Subscribe<PlayerEnteredSceneEvent>(OnPlayerEnteredScene);
            _eventSubscriber.Subscribe<PlayerLeftSceneEvent>(OnPlayerLeftScene);
            _eventSubscriber.Subscribe<PlayerLeftEvent>(OnPlayerDisconnected);
            _eventSubscriber.Subscribe<NetworkDisconnectedEvent>(OnNetworkDisconnected);
            
            // ğŸ¯ è®¢é˜…è§’è‰²åˆ›å»ºäº‹ä»¶ï¼ˆç”¨äºåŠ¨ç”»åŒæ­¥æ³¨å†Œï¼‰
            _eventSubscriber.Subscribe<RemoteCharacterCreatedEvent>(OnRemoteCharacterCreated);
            
            // ğŸ¯ è®¢é˜…åŠ¨ç”»åŒæ­¥äº‹ä»¶
            _eventSubscriber.Subscribe<RemoteAnimatorUpdateEvent>(OnRemoteAnimatorUpdate);
            
            Log($"[PlayerManager] åˆå§‹åŒ–å®Œæˆ - æˆ¿é—´+åœºæ™¯åŒå±‚æ¶æ„ + åŠ¨ç”»åŒæ­¥");
        }

        /// <summary>
        /// ç©å®¶åŠ å…¥æˆ¿é—´ - åˆ›å»º RemotePlayer
        /// ğŸ“Œ å¯èƒ½åœ¨åœºæ™¯äº‹ä»¶ä¸­å·²ç»åˆ›å»ºï¼ˆå®¹é”™å¤„ç†ï¼‰ï¼Œéœ€è¦æ£€æŸ¥é‡å¤
        /// </summary>
        private void OnPlayerJoinedRoom(PlayerJoinedRoomEvent @event)
        {
            Log($"[PlayerManager] ========== æ”¶åˆ° PlayerJoinedRoomEvent ==========");
            Log($"[PlayerManager] ç©å®¶: {@event.Player.SteamName} ({@event.Player.SteamId})");
            Log($"[PlayerManager] æˆ¿é—´: {@event.Room.RoomName} ({@event.Room.RoomId})");
            
            // æ’é™¤æœ¬åœ°ç©å®¶
            if (@event.Player.SteamId == LocalPlayer.Info.SteamId)
            {
                Log($"[PlayerManager] âš ï¸ è·³è¿‡æœ¬åœ°ç©å®¶");
                return;
            }
            
            // ğŸ”¥ åˆ›å»º RemotePlayerï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!_remotePlayers.ContainsKey(@event.Player.SteamId))
            {
                var remotePlayer = new RemotePlayer(@event.Player);
                _remotePlayers[@event.Player.SteamId] = remotePlayer;
                Log($"[PlayerManager] âœ… åˆ›å»º RemotePlayer: {@event.Player.SteamName}");
            }
            else
            {
                // å¯èƒ½åœ¨åœºæ™¯äº‹ä»¶ä¸­å·²ç»åˆ›å»ºï¼ˆå®¹é”™å¤„ç†ï¼‰
                Log($"[PlayerManager] RemotePlayer å·²å­˜åœ¨ï¼ˆå¯èƒ½æ˜¯åœºæ™¯äº‹ä»¶å…ˆåˆ°è¾¾ï¼‰: {@event.Player.SteamName}");
            }
            
            Log($"[PlayerManager] ========== å¤„ç†å®Œæˆ ==========");
        }

        /// <summary>
        /// ç©å®¶ç¦»å¼€æˆ¿é—´ - åˆ é™¤ RemotePlayer
        /// </summary>
        private void OnPlayerLeftRoom(PlayerLeftRoomEvent @event)
        {
            Log($"[PlayerManager] ç©å®¶ç¦»å¼€æˆ¿é—´: {@event.Player.SteamName}");
            
            // æ’é™¤æœ¬åœ°ç©å®¶
            if (@event.Player.SteamId == LocalPlayer.Info.SteamId)
            {
                return;
            }
            
            // ğŸ”¥ é”€æ¯ RemotePlayerï¼ˆä¼šè‡ªåŠ¨é”€æ¯è§’è‰²ï¼‰
            if (_remotePlayers.TryGetValue(@event.Player.SteamId, out var player))
            {
                player.Dispose();
                _remotePlayers.Remove(@event.Player.SteamId);
                Log($"[PlayerManager] é”€æ¯ RemotePlayer: {@event.Player.SteamName}");
            }
        }

        /// <summary>
        /// ç©å®¶è¿›å…¥åœºæ™¯ - ç¡®ä¿ RemotePlayer å­˜åœ¨ï¼ˆå®¹é”™å¤„ç†ï¼‰
        /// ğŸ“Œ åœºæ™¯è¿›å…¥äº‹ä»¶å¯èƒ½æ¯”æˆ¿é—´åŠ å…¥äº‹ä»¶å…ˆåˆ°è¾¾ï¼Œéœ€è¦å®¹é”™å¤„ç†
        /// ğŸ“Œ RemotePlayer ä¼šè‡ªå·±è®¢é˜… PlayerEnteredSceneEvent å¹¶åˆ›å»ºè§’è‰²
        /// </summary>
        private void OnPlayerEnteredScene(PlayerEnteredSceneEvent @event)
        {
            Log($"[PlayerManager] ========== PlayerEnteredSceneEvent æ¥æ”¶ ==========");
            Log($"[PlayerManager] ç©å®¶: {@event.PlayerInfo.SteamName} ({@event.PlayerInfo.SteamId})");
            Log($"[PlayerManager] åœºæ™¯: {@event.ScenelData.SceneName}/{@event.ScenelData.SubSceneName}");
            
            // æ’é™¤æœ¬åœ°ç©å®¶
            if (@event.PlayerInfo.SteamId == LocalPlayer.Info.SteamId)
            {
                Log($"[PlayerManager] âš ï¸ è·³è¿‡æœ¬åœ°ç©å®¶çš„åœºæ™¯äº‹ä»¶");
                return;
            }

            // ğŸ”¥ å®¹é”™å¤„ç†ï¼šå¦‚æœ RemotePlayer ä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»ºå®ƒ
            if (!_remotePlayers.ContainsKey(@event.PlayerInfo.SteamId))
            {
                Log($"[PlayerManager] âš ï¸ RemotePlayer ä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»ºï¼ˆå¯èƒ½æ˜¯åœºæ™¯äº‹ä»¶å…ˆäºæˆ¿é—´äº‹ä»¶åˆ°è¾¾ï¼‰: {@event.PlayerInfo.SteamName}");
                
                var remotePlayer = new RemotePlayer(@event.PlayerInfo);
                _remotePlayers[@event.PlayerInfo.SteamId] = remotePlayer;
                
                Log($"[PlayerManager] âœ… å®¹é”™åˆ›å»º RemotePlayer: {@event.PlayerInfo.SteamName}");
            }
            else
            {
                Log($"[PlayerManager] RemotePlayer å·²å­˜åœ¨: {@event.PlayerInfo.SteamName}");
            }
            
            // RemotePlayer ä¼šè‡ªå·±å¤„ç†åœºæ™¯è¿›å…¥äº‹ä»¶ï¼ˆè®¢é˜…äº† PlayerEnteredSceneEventï¼‰
            // è¿™é‡Œä¸éœ€è¦é¢å¤–æ“ä½œ
            Log($"[PlayerManager] ========== PlayerEnteredSceneEvent å¤„ç†å®Œæˆ ==========");
        }

        /// <summary>
        /// ç©å®¶ç¦»å¼€åœºæ™¯ - åªé”€æ¯è§’è‰²ï¼Œä¸é”€æ¯ RemotePlayer
        /// </summary>
        private void OnPlayerLeftScene(PlayerLeftSceneEvent @event)
        {
            // æ’é™¤æœ¬åœ°ç©å®¶
            if (@event.PlayerInfo.SteamId == LocalPlayer.Info.SteamId)
            {
                return;
            }
            
            Log($"[PlayerManager] ç©å®¶ç¦»å¼€åœºæ™¯: {@event.PlayerInfo.SteamName}");
            
            // ğŸ”¥ åªé”€æ¯è§’è‰²ï¼ŒRemotePlayer ä¿ç•™ï¼ˆç©å®¶è¿˜åœ¨æˆ¿é—´ä¸­ï¼‰
            if (_remotePlayers.TryGetValue(@event.PlayerInfo.SteamId, out var player))
            {
                // ğŸ¯ å…ˆæ³¨é”€åŠ¨ç”»åŒæ­¥
                _remoteAnimatorSync.UnregisterRemotePlayer(@event.PlayerInfo.SteamId);
                
                player.DestroyCharacter();
                Log($"[PlayerManager] é”€æ¯è§’è‰²ï¼ˆä¿ç•™ RemotePlayerï¼‰: {@event.PlayerInfo.SteamName}");
            }
        }

        /// <summary>
        /// è¿œç¨‹è§’è‰²åˆ›å»ºå®Œæˆ - æ³¨å†Œæˆ–æ›´æ–°åŠ¨ç”»åŒæ­¥ç³»ç»Ÿ
        /// </summary>
        private void OnRemoteCharacterCreated(RemoteCharacterCreatedEvent @event)
        {
            if (@event.Character == null)
            {
                LogWarning($"[PlayerManager] âš ï¸ è§’è‰²åˆ›å»ºäº‹ä»¶çš„ Character ä¸ºç©º: {@event.PlayerId}");
                return;
            }
            
            // ğŸ”¥ æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ(åœºæ™¯åˆ‡æ¢åè§’è‰²é‡æ–°åˆ›å»º)
            if (_remoteAnimatorSync != null)
            {
                // å°è¯•æ›´æ–° GameObject (å¦‚æœå·²æ³¨å†Œ)
                _remoteAnimatorSync.UpdatePlayerGameObject(@event.PlayerId, @event.Character);
                
                // å¦‚æœæ˜¯é¦–æ¬¡åˆ›å»º,åˆ™æ³¨å†Œ
                _remoteAnimatorSync.RegisterRemotePlayer(@event.PlayerId, @event.Character);
                
                Log($"[PlayerManager] âœ… åŠ¨ç”»åŒæ­¥å·²å°±ç»ª: {@event.PlayerId}");
            }
        }

        /// <summary>
        /// ç©å®¶æ–­å¼€è¿æ¥ - é”€æ¯ RemotePlayer
        /// </summary>
        private void OnPlayerDisconnected(PlayerLeftEvent @event)
        {
            // æ’é™¤æœ¬åœ°ç©å®¶
            if (@event.Player.SteamId == LocalPlayer.Info.SteamId)
            {
                return;
            }
            
            Log($"[PlayerManager] ç©å®¶æ–­å¼€è¿æ¥: {@event.Player.SteamName}");
            
            // é”€æ¯ RemotePlayer
            if (_remotePlayers.TryGetValue(@event.Player.SteamId, out var player))
            {
                player.Dispose();
                _remotePlayers.Remove(@event.Player.SteamId);
                Log($"[PlayerManager] é”€æ¯ RemotePlayer: {@event.Player.SteamName}");
            }
        }

        /// <summary>
        /// ç½‘ç»œæ–­å¼€è¿æ¥ - æ¸…ç†æ‰€æœ‰è¿œç¨‹ç©å®¶
        /// </summary>
        private void OnNetworkDisconnected(NetworkDisconnectedEvent @event)
        {
            Log($"[PlayerManager] ğŸ”¥ ç½‘ç»œæ–­å¼€è¿æ¥ï¼Œæ¸…ç†æ‰€æœ‰è¿œç¨‹ç©å®¶: {@event.Reason}");
            
            // é”€æ¯æ‰€æœ‰ RemotePlayer
            foreach (var kvp in _remotePlayers)
            {
                kvp.Value.Dispose();
                Log($"[PlayerManager] é”€æ¯ RemotePlayer: {kvp.Value.Info.SteamName}");
            }
            
            _remotePlayers.Clear();
            _remoteAnimatorSync?.Dispose();
            
            Log($"[PlayerManager] âœ… æ‰€æœ‰è¿œç¨‹ç©å®¶å·²æ¸…ç†");
        }

        /// <summary>
        /// æ£€æŸ¥è¿œç¨‹ç©å®¶æ˜¯å¦åœ¨åŒä¸€åœºæ™¯
        /// </summary>
        private bool IsInSameScene(ScenelData remoteSceneData)
        {
            // ğŸ”¥ ç›´æ¥æ¯”è¾ƒåœºæ™¯æ•°æ®
            bool sameScene = remoteSceneData.SceneName == LocalPlayer.Info.CurrentScenelData.SceneName &&
                   remoteSceneData.SubSceneName == LocalPlayer.Info.CurrentScenelData.SubSceneName;
            
            Log($"[PlayerManager] åœºæ™¯åŒ¹é…æ£€æŸ¥: è¿œç¨‹({remoteSceneData.SceneName}/{remoteSceneData.SubSceneName}) vs æœ¬åœ°({LocalPlayer.Info.CurrentScenelData.SceneName}/{LocalPlayer.Info.CurrentScenelData.SubSceneName}) = {sameScene}");
            
            return sameScene;
        }
        
        /// <summary>
        /// ğŸ¯ å¤„ç†è¿œç¨‹åŠ¨ç”»æ›´æ–°äº‹ä»¶
        /// </summary>
        private void OnRemoteAnimatorUpdate(RemoteAnimatorUpdateEvent @event)
        {
            // Debug.Log($"[PlayerManager] ğŸ“¬ æ¥æ”¶åˆ°åŠ¨ç”»äº‹ä»¶ - PlayerId:{@event.PlayerId}, State:{@event.AnimatorData.StateHash}");
            _remoteAnimatorSync.ReceiveAnimatorUpdate(@event.PlayerId, @event.AnimatorData);
        }

        /// <summary>
        /// è·å–è¿œç¨‹ç©å®¶
        /// </summary>
        public RemotePlayer? GetRemotePlayer(string steamId)
        {
            if (_remotePlayers.TryGetValue(steamId, out var player))
            {
                return player;
            }
            return null;
        }

        public void Dispose()
        {
            LocalPlayer.Dispose();
            _remoteAnimatorSync.Dispose();
            foreach (var kvp in _remotePlayers)
            {
                kvp.Value.Dispose();
            }
            _remotePlayers.Clear();
        }

        /// <summary>
        /// æ›´æ–°æœ¬åœ°ç©å®¶å’Œè¿œç¨‹ç©å®¶ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        public void Update()
        {
            LocalPlayer?.LateUpdate();
            
            // æ›´æ–°æ‰€æœ‰è¿œç¨‹ç©å®¶ä½ç½®ï¼ˆå¹³æ»‘åŒæ­¥ï¼‰
            foreach (var kvp in _remotePlayers)
            {
                kvp.Value?.UpdatePosition();
            }
        }
        
        /// <summary>
        /// ğŸ¯ LateUpdate - æ›´æ–°è¿œç¨‹åŠ¨ç”»
        /// </summary>
        public void LateUpdate()
        {
            _remoteAnimatorSync.UpdateAll();
        }
    }
}
```

`Client\Core\Players\RemoteAnimatorSyncManager.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Client.Core.Utils;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.Players
{
    /// <summary>
    /// è¿œç¨‹ç©å®¶åŠ¨ç”»åŒæ­¥ç®¡ç†å™¨
    /// æ•´åˆæ‰¹é‡å†™å…¥ã€å»¶è¿Ÿæ’­æ”¾ã€è¶‹åŠ¿å¤–æ¨ä¸‰å¤§ç³»ç»Ÿ
    /// ä¸ºæ¯ä¸ªè¿œç¨‹ç©å®¶æä¾›å¹³æ»‘çš„åŠ¨ç”»åŒæ­¥
    /// </summary>
    public class RemoteAnimatorSyncManager : IDisposable
    {
        // è¿œç¨‹ç©å®¶çŠ¶æ€æ˜ å°„è¡¨
        private readonly Dictionary<string, RemotePlayerAnimationState> _playerStates = new Dictionary<string, RemotePlayerAnimationState>();
        
        // é…ç½®å‚æ•°
        public int PlaybackDelayMs { get; set; } = 120; // æ’­æ”¾å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
        public bool EnableExtrapolation { get; set; } = true; // å¯ç”¨è¶‹åŠ¿å¤–æ¨
        public float SmoothTime { get; set; } = 0.12f; // å¹³æ»‘æ—¶é—´
        
        /// <summary>
        /// è¿œç¨‹ç©å®¶åŠ¨ç”»çŠ¶æ€
        /// </summary>
        private class RemotePlayerAnimationState : IDisposable
        {
            public string PlayerId { get; }
            public GameObject? GameObject { get; private set; } // å¯å˜,æ”¯æŒåœºæ™¯åˆ‡æ¢æ—¶æ›´æ–°
            public Animator? Animator { get; private set; }
            
            // æ ¸å¿ƒç³»ç»Ÿç»„ä»¶
            public AnimationFrameRingBuffer FrameBuffer { get; }
            public AnimationBatchWriter BatchWriter { get; }
            public KalmanMotionPredictor KalmanPredictor { get; private set; } // å¡å°”æ›¼æ»¤æ³¢é¢„æµ‹å™¨
            
            // çŠ¶æ€æ ‡å¿—
            public bool IsActive { get; private set; }
            public double LastFrameTime { get; private set; }
            
            // å‚æ•°å“ˆå¸Œç¼“å­˜
            private readonly Dictionary<int, int> _floatParamHashes;
            private readonly Dictionary<int, int> _boolParamHashes;
            
            // å‚æ•°åç§°æ˜ å°„ï¼ˆä¸ AnimatorSyncManager ä¿æŒä¸€è‡´ï¼‰
            private static readonly string[] FloatParamNames = new string[]
            {
                "MoveSpeed",   // 0
                "MoveDirX",    // 1
                "MoveDirY",    // 2
                "HandState",   // 3 (ä½œä¸º float ä¼ è¾“çš„ int)
                "",            // 4-7 é¢„ç•™
                "",
                "",
                ""
            };
            
            private static readonly string[] BoolParamNames = new string[]
            {
                "Dashing",      // 0
                "RightHandOut", // 1
                "Attack",       // 2
                "GunReady",     // 3
            };
            
            public RemotePlayerAnimationState(string playerId, GameObject gameObject)
            {
                PlayerId = playerId;
                GameObject = gameObject;
                
                // åˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶
                FrameBuffer = new AnimationFrameRingBuffer(32);
                BatchWriter = new AnimationBatchWriter();
                KalmanPredictor = new KalmanMotionPredictor();
                
                // åˆå§‹åŒ–å‚æ•°å“ˆå¸Œç¼“å­˜
                _floatParamHashes = new Dictionary<int, int>();
                _boolParamHashes = new Dictionary<int, int>();
                
                // ç¼“å­˜å‚æ•°å“ˆå¸Œ
                for (int i = 0; i < FloatParamNames.Length; i++)
                {
                    if (!string.IsNullOrEmpty(FloatParamNames[i]))
                    {
                        _floatParamHashes[i] = Animator.StringToHash(FloatParamNames[i]);
                    }
                }
                
                for (int i = 0; i < BoolParamNames.Length; i++)
                {
                    if (!string.IsNullOrEmpty(BoolParamNames[i]))
                    {
                        _boolParamHashes[i] = Animator.StringToHash(BoolParamNames[i]);
                    }
                }
                
                // æŸ¥æ‰¾ Animator
                TryLinkAnimator();
            }
            
            /// <summary>
            /// æ›´æ–° GameObject å¼•ç”¨(åœºæ™¯åˆ‡æ¢åè§’è‰²é‡æ–°åˆ›å»ºæ—¶è°ƒç”¨)
            /// </summary>
            public void UpdateGameObject(GameObject newGameObject)
            {
                GameObject = newGameObject;
                Animator = null; // æ¸…ç©ºæ—§çš„ Animator
                IsActive = false;
                
                UnityEngine.Debug.Log($"[RemoteAnimatorSync] ğŸ”„ æ›´æ–° GameObject å¼•ç”¨: {PlayerId}");
                
                // é‡æ–°ç»‘å®š Animator
                TryLinkAnimator();
            }
            
            private void TryLinkAnimator()
            {
                // æ£€æŸ¥ GameObject æ˜¯å¦æœ‰æ•ˆ
                if (GameObject == null || !GameObject)
                {
                    UnityEngine.Debug.LogWarning($"[RemoteAnimatorSync] GameObject æ— æ•ˆæˆ–å·²é”€æ¯: {PlayerId}");
                    IsActive = false;
                    return;
                }
                
                try
                {
                    // æ–¹å¼1: é€šè¿‡ CharacterMainControl
                    var charControlType = HarmonyLib.AccessTools.TypeByName("CharacterMainControl");
                    if (charControlType != null)
                    {
                        var charControl = GameObject.GetComponent(charControlType);
                        if (charControl != null)
                        {
                            var modelField = HarmonyLib.AccessTools.Field(charControlType, "characterModel");
                            var model = modelField?.GetValue(charControl) as GameObject;
                            if (model != null)
                            {
                                Animator = model.GetComponentInChildren<Animator>(true);
                            }
                        }
                    }
                    
                    // æ–¹å¼2: ç›´æ¥æŸ¥æ‰¾
                    if (Animator == null)
                    {
                        Animator = GameObject.GetComponentInChildren<Animator>(true);
                    }
                    
                    if (Animator != null)
                    {
                        Animator.applyRootMotion = false;
                        IsActive = true;
                        UnityEngine.Debug.Log($"[RemoteAnimatorSync] âœ… Animator ç»‘å®šæˆåŠŸ: {PlayerId}");
                        
                        // ğŸ”¥ ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬,é˜²æ­¢æœ¬åœ°é€»è¾‘è¦†ç›–ç½‘ç»œåŒæ­¥çš„åŠ¨ç”»å‚æ•°
                        DisableAnimationControl();
                    }
                    else
                    {
                        UnityEngine.Debug.LogWarning($"[RemoteAnimatorSync] âš ï¸ æœªæ‰¾åˆ° Animator: {PlayerId}");
                    }
                }
                catch (Exception ex)
                {
                    UnityEngine.Debug.LogError($"[RemoteAnimatorSync] é“¾æ¥ Animator å¤±è´¥: {ex.Message}");
                }
            }
            
            /// <summary>
            /// ç¦ç”¨æ¸¸æˆåŸæœ¬çš„åŠ¨ç”»æ§åˆ¶è„šæœ¬,é˜²æ­¢è¦†ç›–ç½‘ç»œåŒæ­¥çš„å‚æ•°
            /// </summary>
            private void DisableAnimationControl()
            {
                try
                {
                    if (GameObject == null) return;
                    
                    // ç¦ç”¨ CharacterAnimationControl
                    var animControlType = HarmonyLib.AccessTools.TypeByName("CharacterAnimationControl");
                    if (animControlType != null)
                    {
                        var animControl = GameObject.GetComponentInChildren(animControlType) as MonoBehaviour;
                        if (animControl != null)
                        {
                            animControl.enabled = false;
                            UnityEngine.Debug.Log($"[RemoteAnimatorSync] âœ… å·²ç¦ç”¨ CharacterAnimationControl: {PlayerId}");
                        }
                    }
                    
                    // ç¦ç”¨ CharacterAnimationControl_MagicBlend
                    var magicBlendType = HarmonyLib.AccessTools.TypeByName("CharacterAnimationControl_MagicBlend");
                    if (magicBlendType != null)
                    {
                        var magicBlend = GameObject.GetComponentInChildren(magicBlendType) as MonoBehaviour;
                        if (magicBlend != null)
                        {
                            magicBlend.enabled = false;
                            UnityEngine.Debug.Log($"[RemoteAnimatorSync] âœ… å·²ç¦ç”¨ CharacterAnimationControl_MagicBlend: {PlayerId}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    UnityEngine.Debug.LogWarning($"[RemoteAnimatorSync] ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬å¤±è´¥: {ex.Message}");
                }
            }
            
            /// <summary>
            /// æ¥æ”¶è¿œç¨‹åŠ¨ç”»æ•°æ®
            /// </summary>
            public void ReceiveAnimatorData(AnimatorSyncData syncData)
            {
                // è½¬æ¢ä¸º AnimationFrame
                var frame = new AnimationFrame
                {
                    Timestamp = Time.unscaledTimeAsDouble,
                    MoveSpeed = syncData.GetFloatParam(0),
                    MoveDirX = syncData.GetFloatParam(1),
                    MoveDirY = syncData.GetFloatParam(2),
                    IsDashing = syncData.GetBoolParam(0),
                    IsGunReady = syncData.GetBoolParam(3),
                    IsReloading = false, // å¦‚æœéœ€è¦ï¼Œå¯ä»¥æ‰©å±•
                    IsDead = false,
                    HandState = (int)syncData.GetFloatParam(3), // HandState ä½œä¸º int
                    AttackIndex = 0,
                    StateHash = syncData.StateHash,
                    NormalizedTime = syncData.GetNormalizedTime()
                };
                
                // æ£€æŸ¥æ—¶é—´åˆæ³•æ€§
                if (FrameBuffer.Count > 0)
                {
                    var lastFrame = FrameBuffer.GetLatest();
                    double deltaTime = frame.Timestamp - lastFrame.Timestamp;
                    
                    // æ—¶é—´å¼‚å¸¸ï¼Œæ¸…ç©ºç¼“å†²
                    if (deltaTime < -0.05 || deltaTime > 2.0)
                    {
                        UnityEngine.Debug.LogWarning($"[RemoteAnimatorSync] æ—¶é—´å¼‚å¸¸ï¼Œæ¸…ç©ºç¼“å†²: {PlayerId}, dt={deltaTime:F3}s");
                        FrameBuffer.Clear();
                        KalmanPredictor.Reset();
                    }
                }
                
                // æ¨å…¥å¸§
                FrameBuffer.Push(frame);
                LastFrameTime = frame.Timestamp;
                
                // æ›´æ–°å¡å°”æ›¼æ»¤æ³¢å™¨
                KalmanPredictor.Update(frame.MoveSpeed, frame.MoveDirX, frame.MoveDirY, frame.Timestamp);
            }
            
            /// <summary>
            /// æ›´æ–°åŠ¨ç”»ï¼ˆåœ¨ LateUpdate ä¸­è°ƒç”¨ï¼‰
            /// </summary>
            public void UpdateAnimation(float deltaTime, int playbackDelayMs, bool enableExtrapolation)
            {
                // æ£€æŸ¥ GameObject æ˜¯å¦è¢«é”€æ¯
                if (GameObject == null || !GameObject)
                {
                    IsActive = false;
                    return;
                }
                
                if (!IsActive || Animator == null || FrameBuffer.Count == 0)
                {
                    return;
                }
                
                // ğŸ”¥ ç®€åŒ–é€»è¾‘ï¼šç›´æ¥ä½¿ç”¨æœ€æ–°å¸§ï¼Œä¸åšå¤æ‚é¢„æµ‹
                // åŸå› ï¼š20Hz åŒæ­¥é¢‘ç‡å·²ç»è¶³å¤Ÿæµç•…ï¼Œé¢„æµ‹åè€Œå¼•å…¥æŠ–åŠ¨
                var targetFrame = FrameBuffer.GetLatest();
                
                // åº”ç”¨åˆ°æ‰¹å†™å…¥å™¨
                ApplyFrameToBatchWriter(targetFrame);
                
                // æäº¤åˆ° Animatorï¼ˆç§»é™¤è°ƒè¯•æ—¥å¿—ï¼Œæé«˜æ€§èƒ½ï¼‰
                BatchWriter.Commit(Animator, deltaTime);
            }
            
            private void ApplyFrameToBatchWriter(AnimationFrame frame)
            {
                // ğŸ”¥ ç§»é™¤æ‰€æœ‰æ—¥å¿—ï¼Œæé«˜æ€§èƒ½ï¼ˆæ¯å¸§è°ƒç”¨ï¼Œæ—¥å¿—ä¼šä¸¥é‡æ‹–æ…¢æ¸¸æˆï¼‰
                
                // Float å‚æ•°
                if (_floatParamHashes.TryGetValue(0, out int moveSpeedHash))
                    BatchWriter.SetFloat(moveSpeedHash, frame.MoveSpeed);
                
                if (_floatParamHashes.TryGetValue(1, out int moveDirXHash))
                    BatchWriter.SetFloat(moveDirXHash, frame.MoveDirX);
                
                if (_floatParamHashes.TryGetValue(2, out int moveDirYHash))
                    BatchWriter.SetFloat(moveDirYHash, frame.MoveDirY);
                
                if (_floatParamHashes.TryGetValue(3, out int handStateHash))
                    BatchWriter.SetInt(handStateHash, frame.HandState);
                
                // Bool å‚æ•°
                if (_boolParamHashes.TryGetValue(0, out int dashingHash))
                    BatchWriter.SetBool(dashingHash, frame.IsDashing);
                
                if (_boolParamHashes.TryGetValue(3, out int gunReadyHash))
                    BatchWriter.SetBool(gunReadyHash, frame.IsGunReady);
            }
            
            public void Dispose()
            {
                BatchWriter?.Clear();
                FrameBuffer?.Clear();
                KalmanPredictor?.Reset();
            }
        }
        
        /// <summary>
        /// æ³¨å†Œè¿œç¨‹ç©å®¶(æ”¯æŒå¹‚ç­‰æ€§,å¦‚æœå·²å­˜åœ¨åˆ™è·³è¿‡)
        /// </summary>
        public void RegisterRemotePlayer(string playerId, GameObject playerObject)
        {
            if (_playerStates.ContainsKey(playerId))
            {
                // å·²å­˜åœ¨,è·³è¿‡(ä¸è¾“å‡ºè­¦å‘Š,å› ä¸ºå¯èƒ½æ˜¯åœºæ™¯åˆ‡æ¢åæ›´æ–°)
                return;
            }
            
            var state = new RemotePlayerAnimationState(playerId, playerObject);
            state.BatchWriter.SetSmoothTime(SmoothTime);
            
            _playerStates[playerId] = state;
            UnityEngine.Debug.Log($"[RemoteAnimatorSync] æ³¨å†Œè¿œç¨‹ç©å®¶: {playerId}");
        }
        
        /// <summary>
        /// æ³¨é”€è¿œç¨‹ç©å®¶
        /// </summary>
        public void UnregisterRemotePlayer(string playerId)
        {
            if (_playerStates.TryGetValue(playerId, out var state))
            {
                state.Dispose();
                _playerStates.Remove(playerId);
                UnityEngine.Debug.Log($"[RemoteAnimatorSync] æ³¨é”€è¿œç¨‹ç©å®¶: {playerId}");
            }
        }
        
        /// <summary>
        /// æ›´æ–°è¿œç¨‹ç©å®¶çš„ GameObject (åœºæ™¯åˆ‡æ¢åè§’è‰²é‡æ–°åˆ›å»ºæ—¶è°ƒç”¨)
        /// </summary>
        public void UpdatePlayerGameObject(string playerId, GameObject newGameObject)
        {
            if (_playerStates.TryGetValue(playerId, out var state))
            {
                state.UpdateGameObject(newGameObject);
                UnityEngine.Debug.Log($"[RemoteAnimatorSync] ğŸ”„ æ›´æ–°ç©å®¶ GameObject: {playerId}");
            }
            else
            {
                UnityEngine.Debug.LogWarning($"[RemoteAnimatorSync] æœªæ‰¾åˆ°ç©å®¶çŠ¶æ€,æ— æ³•æ›´æ–° GameObject: {playerId}");
            }
        }
        
        /// <summary>
        /// æ¥æ”¶è¿œç¨‹ç©å®¶çš„åŠ¨ç”»æ•°æ®
        /// </summary>
        public void ReceiveAnimatorUpdate(string playerId, AnimatorSyncData syncData)
        {
            // ğŸ”¥ ç§»é™¤æ—¥å¿—ï¼Œæé«˜æ€§èƒ½ï¼ˆæ¯å¸§è°ƒç”¨å¤šæ¬¡ï¼‰
            if (_playerStates.TryGetValue(playerId, out var state))
            {
                state.ReceiveAnimatorData(syncData);
            }
            // é™é»˜å¤±è´¥ï¼Œé¿å…åˆ·å±
        }
        
        /// <summary>
        /// æ›´æ–°æ‰€æœ‰è¿œç¨‹ç©å®¶åŠ¨ç”»ï¼ˆåœ¨ LateUpdate ä¸­è°ƒç”¨ï¼‰
        /// </summary>
        public void UpdateAll()
        {
            float deltaTime = Time.unscaledDeltaTime;
            
            foreach (var state in _playerStates.Values)
            {
                state.UpdateAnimation(deltaTime, PlaybackDelayMs, EnableExtrapolation);
            }
        }
        
        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public string GetStats()
        {
            return $"è¿œç¨‹ç©å®¶: {_playerStates.Count}, " +
                   $"å»¶è¿Ÿ: {PlaybackDelayMs}ms, " +
                   $"å¤–æ¨: {(EnableExtrapolation ? "å¯ç”¨" : "ç¦ç”¨")}";
        }
        
        public void Dispose()
        {
            foreach (var state in _playerStates.Values)
            {
                state.Dispose();
            }
            _playerStates.Clear();
        }
    }
}

```

`Client\Core\Players\RemotePlayer.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using static UnityEngine.Debug;
using Steamworks;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.Utils;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;
using ItemStatsSystem;
using Duckov.Utilities;
using CharacterAppearanceReceivedEvent = DuckyNet.Client.Services.CharacterAppearanceReceivedEvent;

namespace DuckyNet.Client.Core.Players
{
    /// <summary>
    /// è¿œç¨‹ç©å®¶ - è¡¨ç¤ºç½‘ç»œä¸­çš„å…¶ä»–ç©å®¶
    /// ğŸ”¥ æ­£ç¡®æ¶æ„ï¼šåŒå±‚ç”Ÿå‘½å‘¨æœŸ
    /// 
    /// RemotePlayer ç”Ÿå‘½å‘¨æœŸï¼ˆæˆ¿é—´å±‚ï¼‰ï¼š
    /// - PlayerJoinedRoomEvent â†’ åˆ›å»º RemotePlayerï¼ˆè®¢é˜…ä½ç½®åŒæ­¥äº‹ä»¶ï¼‰
    /// - PlayerLeftRoomEvent â†’ é”€æ¯ RemotePlayer
    /// 
    /// Character ç”Ÿå‘½å‘¨æœŸï¼ˆåœºæ™¯å±‚ï¼‰ï¼š
    /// - PlayerEnteredSceneEvent â†’ æ ‡è®°ç©å®¶è¿›å…¥åœºæ™¯
    /// - æ”¶åˆ°ä½ç½®åŒæ­¥æ•°æ® â†’ åˆ›å»ºè§’è‰²ï¼ˆå¦‚æœåœ¨åŒä¸€åœºæ™¯ï¼‰
    /// - PlayerLeftSceneEvent â†’ é”€æ¯è§’è‰²ï¼ˆä¿ç•™ RemotePlayerï¼‰
    /// 
    /// æ€§èƒ½ä¼˜åŒ–ï¼š
    /// - ç¼“å­˜ Transform å¼•ç”¨ï¼Œå‡å°‘ GetComponent è°ƒç”¨
    /// </summary>
    public class RemotePlayer : BasePlayer
    {
        #region å¸¸é‡å®šä¹‰

        /// <summary>ç­‰å¾…è§’è‰²åˆå§‹åŒ–çš„å¸§æ•°</summary>
        private const int CHARACTER_INIT_WAIT_FRAMES = 2;

        /// <summary>é»˜è®¤ç”Ÿæˆä½ç½®</summary>
        private static readonly Vector3 DEFAULT_SPAWN_POSITION = Vector3.zero;

        #endregion

        #region ç¼“å­˜å­—æ®µ

        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        private SmoothSyncManager? _smoothSyncManager;
        private Transform? _characterTransform; // ç¼“å­˜ Transform å¼•ç”¨
        private CharacterAppearanceData? _cachedAppearanceData; // ç¼“å­˜å¤–è§‚æ•°æ®
        private PlayerEquipmentData? _equipmentData; // ç¼“å­˜è£…å¤‡æ•°æ®
        private PlayerWeaponData? _weaponData; // ç¼“å­˜æ­¦å™¨æ•°æ®
        
        // è¡€é‡åŒæ­¥ç¼“å­˜
        private object? _cachedHealth; // ç¼“å­˜ Health ç»„ä»¶
        private System.Reflection.MethodInfo? _cachedSetHealthMethod; // ç¼“å­˜ SetHealth æ–¹æ³•

        /// <summary>è£…å¤‡æ§½ä½Hashæ˜ å°„ç¼“å­˜</summary>
        private static readonly Dictionary<EquipmentSlotType, int> _equipmentSlotHashCache = new Dictionary<EquipmentSlotType, int>()
        {
            { EquipmentSlotType.Armor, CharacterEquipmentController.armorHash },
            { EquipmentSlotType.Helmet, CharacterEquipmentController.helmatHash },
            { EquipmentSlotType.FaceMask, CharacterEquipmentController.faceMaskHash },
            { EquipmentSlotType.Backpack, CharacterEquipmentController.backpackHash },
            { EquipmentSlotType.Headset, CharacterEquipmentController.headsetHash }
        };

        /// <summary>æ­¦å™¨æ§½ä½Hashæ˜ å°„ç¼“å­˜</summary>
        private static readonly Dictionary<WeaponSlotType, int> _weaponSlotHashCache = new Dictionary<WeaponSlotType, int>()
        {
            { WeaponSlotType.PrimaryWeapon, "PrimaryWeapon".GetHashCode() },
            { WeaponSlotType.SecondaryWeapon, "SecondaryWeapon".GetHashCode() },
            { WeaponSlotType.MeleeWeapon, "MeleeWeapon".GetHashCode() }
        };

        #endregion

        /// <summary>
        /// è¿œç¨‹ç©å®¶å½“å‰æ‰€åœ¨çš„åœºæ™¯åç§°
        /// </summary>
        public string? CurrentSceneName { get; private set; }

        public RemotePlayer(PlayerInfo info) : base(info)
        {
            Log($"[RemotePlayer] è¿œç¨‹ç©å®¶åˆ›å»ºï¼ˆæˆ¿é—´å±‚ï¼‰: {info.SteamName} ({info.SteamId})");

            InitializeSceneName(info);
            SubscribeToEvents();
            RequestAppearanceData();

            Log($"[RemotePlayer] ğŸ¨ è¿œç¨‹ç©å®¶åˆ›å»ºå®Œæˆ: {info.SteamName}");
        }

        /// <summary>
        /// åˆå§‹åŒ–åœºæ™¯åç§°
        /// </summary>
        private void InitializeSceneName(PlayerInfo info)
        {
            if (info.CurrentScenelData != null && !string.IsNullOrEmpty(info.CurrentScenelData.SceneName))
            {
                CurrentSceneName = info.CurrentScenelData.SceneName;
                Log($"[RemotePlayer] åˆå§‹åœºæ™¯: {CurrentSceneName}");
            }
            else
            {
                Log($"[RemotePlayer] ç©å®¶ {info.SteamName} åˆå§‹åœºæ™¯æœªè®¾ç½®");
            }
        }

        /// <summary>
        /// è®¢é˜…æ‰€æœ‰äº‹ä»¶
        /// </summary>
        private void SubscribeToEvents()
        {
            _eventSubscriber.EnsureInitializedAndSubscribe();

            // è®¢é˜…ä½ç½®åŒæ­¥äº‹ä»¶
            _eventSubscriber.Subscribe<PlayerUnitySyncEvent>(OnPlayerUnitySyncReceived);

            // è®¢é˜…åœºæ™¯äº‹ä»¶ï¼ˆè¿œç¨‹ç©å®¶è¿›å…¥/ç¦»å¼€åœºæ™¯ï¼‰
            _eventSubscriber.Subscribe<PlayerEnteredSceneEvent>(OnPlayerEnteredScene);
            _eventSubscriber.Subscribe<PlayerLeftSceneEvent>(OnPlayerLeftScene);

            // è®¢é˜…å¤–è§‚æ¥æ”¶äº‹ä»¶
            _eventSubscriber.Subscribe<CharacterAppearanceReceivedEvent>(OnAppearanceReceived);
            _eventSubscriber.Subscribe<BeforeDamageAppliedEvent>(OnBeforeDamageApplied);

            // è®¢é˜…è¡€é‡åŒæ­¥äº‹ä»¶
            _eventSubscriber.Subscribe<RemotePlayerHealthSyncEvent>(OnHealthSyncReceived);

        }


        /// <summary>
        /// å¤„ç†è¡€é‡åŒæ­¥äº‹ä»¶
        /// </summary>
        private void OnHealthSyncReceived(RemotePlayerHealthSyncEvent @event)
        {
            try
            {
                // åªå¤„ç†è‡ªå·±çš„è¡€é‡åŒæ­¥æ•°æ®
                if (@event.HealthData.SteamId != Info.SteamId)
                {
                    return;
                }

                // æ£€æŸ¥è§’è‰²æ˜¯å¦å·²åˆ›å»º
                if (CharacterObject == null)
                {
                    Log($"[RemotePlayer] âš ï¸ è§’è‰²å°šæœªåˆ›å»ºï¼Œæ— æ³•åŒæ­¥è¡€é‡");
                    return;
                }

                // å¦‚æœç¼“å­˜å¤±æ•ˆï¼Œé‡æ–°è·å– Health ç»„ä»¶
                if (_cachedHealth == null || _cachedSetHealthMethod == null)
                {
                    Log($"[RemotePlayer] ğŸ”§ Health ç¼“å­˜æœªåˆå§‹åŒ–ï¼Œæ­£åœ¨åˆå§‹åŒ–...");
                    if (!InitializeHealthCache())
                    {
                        LogError($"[RemotePlayer] âŒ Health ç¼“å­˜åˆå§‹åŒ–å¤±è´¥ï¼Œè·³è¿‡è¡€é‡åŒæ­¥");
                        return;
                    }
                }

                // è¯»å–å½“å‰è¡€é‡ï¼ˆè°ƒç”¨å‰ï¼‰
                var healthType = _cachedHealth!.GetType();
                var currentHealthProp = HarmonyLib.AccessTools.Property(healthType, "CurrentHealth");
                float beforeHealth = currentHealthProp != null ? (float)(currentHealthProp.GetValue(_cachedHealth) ?? 0f) : 0f;

                // ä½¿ç”¨ç¼“å­˜çš„ SetHealth æ–¹æ³•è®¾ç½®å½“å‰è¡€é‡
                _cachedSetHealthMethod!.Invoke(_cachedHealth, new object[] { @event.HealthData.CurrentHealth });

                // è¯»å–å½“å‰è¡€é‡ï¼ˆè°ƒç”¨åï¼ŒéªŒè¯æ˜¯å¦è®¾ç½®æˆåŠŸï¼‰
                float afterHealth = currentHealthProp != null ? (float)(currentHealthProp.GetValue(_cachedHealth) ?? 0f) : 0f;

                Log($"[RemotePlayer] ğŸ’š åŒæ­¥è¡€é‡: {beforeHealth:F0} â†’ {afterHealth:F0} (ç›®æ ‡:{@event.HealthData.CurrentHealth:F0}/{@event.HealthData.MaxHealth:F0})");

                // éªŒè¯æ˜¯å¦è®¾ç½®æˆåŠŸ
                if (Math.Abs(afterHealth - @event.HealthData.CurrentHealth) > 0.1f)
                {
                    LogWarning($"[RemotePlayer] âš ï¸ è¡€é‡è®¾ç½®ä¸å‡†ç¡®ï¼æœŸæœ›:{@event.HealthData.CurrentHealth:F0}, å®é™…:{afterHealth:F0}");
                }

                // ğŸ”¥ æ‰‹åŠ¨è§¦å‘ HealthBar åˆ·æ–°ï¼ˆç¡®ä¿ UI æ›´æ–°ï¼‰
                RefreshHealthBar();
            }
            catch (Exception ex)
            {
                // ç¼“å­˜å¯èƒ½å¤±æ•ˆï¼Œæ¸…ç©ºç¼“å­˜
                _cachedHealth = null;
                _cachedSetHealthMethod = null;
                LogError($"[RemotePlayer] å¤„ç†è¡€é‡åŒæ­¥å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// åˆå§‹åŒ– Health ç¼“å­˜
        /// </summary>
        private bool InitializeHealthCache()
        {
            try
            {
                // è·å– CharacterMainControl ç»„ä»¶
                var characterMainControlType = HarmonyLib.AccessTools.TypeByName("CharacterMainControl");
                if (characterMainControlType == null)
                {
                    LogError("[RemotePlayer] æ‰¾ä¸åˆ° CharacterMainControl ç±»å‹");
                    return false;
                }

                var characterMainControl = CharacterObject!.GetComponent(characterMainControlType);
                if (characterMainControl == null)
                {
                    LogError("[RemotePlayer] CharacterObject ä¸Šæ²¡æœ‰ CharacterMainControl ç»„ä»¶");
                    return false;
                }

                // è·å– Health å±æ€§
                var healthProperty = HarmonyLib.AccessTools.Property(characterMainControlType, "Health");
                if (healthProperty == null)
                {
                    LogError("[RemotePlayer] æ‰¾ä¸åˆ° Health å±æ€§");
                    return false;
                }

                _cachedHealth = healthProperty.GetValue(characterMainControl);
                if (_cachedHealth == null)
                {
                    LogError("[RemotePlayer] Health ç»„ä»¶ä¸ºç©º");
                    return false;
                }

                // ç¼“å­˜ SetHealth æ–¹æ³•
                var healthType = _cachedHealth.GetType();
                _cachedSetHealthMethod = HarmonyLib.AccessTools.Method(healthType, "SetHealth");
                if (_cachedSetHealthMethod == null)
                {
                    LogError("[RemotePlayer] æ‰¾ä¸åˆ° SetHealth æ–¹æ³•");
                    _cachedHealth = null;
                    return false;
                }

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šè°ƒç”¨ SetItemAndCharacter ç»‘å®š item
                // Health.MaxHealth éœ€è¦ä» item.GetStatValue() è¯»å–ï¼Œå¦‚æœ item ä¸º nullï¼ŒMaxHealth å°±æ˜¯ 0
                Log($"[RemotePlayer] ğŸ” æ­£åœ¨è·å– CharacterItem...");
                var characterItemProp = HarmonyLib.AccessTools.Property(characterMainControlType, "CharacterItem");
                if (characterItemProp == null)
                {
                    LogError("[RemotePlayer] æ‰¾ä¸åˆ° CharacterItem å±æ€§");
                }
                else
                {
                    var characterItem = characterItemProp.GetValue(characterMainControl);
                    Log($"[RemotePlayer] CharacterItem: {(characterItem != null ? characterItem.GetType().Name : "null")}");
                    
                    if (characterItem != null)
                    {
                        Log($"[RemotePlayer] ğŸ” æ­£åœ¨æŸ¥æ‰¾ SetItemAndCharacter æ–¹æ³•...");
                        var setItemAndCharacterMethod = HarmonyLib.AccessTools.Method(healthType, "SetItemAndCharacter");
                        if (setItemAndCharacterMethod != null)
                        {
                            Log($"[RemotePlayer] ğŸ”§ æ­£åœ¨è°ƒç”¨ Health.SetItemAndCharacter()...");
                            setItemAndCharacterMethod.Invoke(_cachedHealth, new object[] { characterItem, characterMainControl });
                            Log($"[RemotePlayer] âœ… å·²è°ƒç”¨ Health.SetItemAndCharacter()");
                            
                            // éªŒè¯ item å­—æ®µæ˜¯å¦è®¾ç½®æˆåŠŸ
                            var itemField = HarmonyLib.AccessTools.Field(healthType, "item");
                            var itemValue = itemField?.GetValue(_cachedHealth);
                            Log($"[RemotePlayer] éªŒè¯ Health.item: {(itemValue != null ? "å·²è®¾ç½®" : "null")}");
                        }
                        else
                        {
                            LogError("[RemotePlayer] âŒ æ‰¾ä¸åˆ° SetItemAndCharacter æ–¹æ³•");
                        }
                    }
                    else
                    {
                        LogError("[RemotePlayer] âŒ CharacterItem ä¸º nullï¼Œæ— æ³•ç»‘å®šåˆ° Health");
                    }
                }

                // ğŸ”¥ ç¡®ä¿ showHealthBar = true
                var showHealthBarProp = HarmonyLib.AccessTools.Property(healthType, "showHealthBar");
                if (showHealthBarProp != null && showHealthBarProp.CanWrite)
                {
                    showHealthBarProp.SetValue(_cachedHealth, true);
                }

                // éªŒè¯ MaxHealth æ˜¯å¦æ­£ç¡®
                var maxHealthProp = HarmonyLib.AccessTools.Property(healthType, "MaxHealth");
                float maxHealth = maxHealthProp != null ? (float)(maxHealthProp.GetValue(_cachedHealth) ?? 0f) : 0f;
                Log($"[RemotePlayer] âœ… Health ç¼“å­˜åˆå§‹åŒ–æˆåŠŸï¼ŒMaxHealth={maxHealth:F0}");
                
                return true;
            }
            catch (Exception ex)
            {
                LogError($"[RemotePlayer] åˆå§‹åŒ– Health ç¼“å­˜å¤±è´¥: {ex.Message}");
                _cachedHealth = null;
                _cachedSetHealthMethod = null;
                return false;
            }
        }


        /// <summary>
        /// åˆ·æ–°è¡€æ¡æ˜¾ç¤ºï¼ˆåŒæ—¶åˆ·æ–°åå­—ï¼‰
        /// </summary>
        private void RefreshHealthBar()
        {
            try
            {
                if (_cachedHealth == null) return;

                // è°ƒç”¨ RequestHealthBar æ–¹æ³•å¼ºåˆ¶åˆ·æ–°
                var requestHealthBarMethod = HarmonyLib.AccessTools.Method(_cachedHealth.GetType(), "RequestHealthBar");
                if (requestHealthBarMethod != null)
                {
                    requestHealthBarMethod.Invoke(_cachedHealth, null);
                }

                // ğŸ”¥ è¡€é‡åŒæ­¥æ—¶ä¹Ÿåˆ·æ–°åå­—ï¼ˆé˜²æ­¢è¢« RefreshCharacterIcon è¦†ç›–ï¼‰
                RefreshHealthBarName();

                Log($"[RemotePlayer] ğŸ”„ å·²è§¦å‘ HealthBar åˆ·æ–°");
            }
            catch (Exception ex)
            {
                LogWarning($"[RemotePlayer] åˆ·æ–° HealthBar å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åˆ·æ–°è¡€æ¡åå­—æ˜¾ç¤º
        /// </summary>
        private void RefreshHealthBarName()
        {
            try
            {
                if (_cachedHealth == null) return;

                // è·å– HealthBarManager
                var healthBarManagerType = HarmonyLib.AccessTools.TypeByName("Duckov.UI.HealthBarManager");
                if (healthBarManagerType == null) return;

                var instanceProp = HarmonyLib.AccessTools.Property(healthBarManagerType, "Instance");
                var healthBarManager = instanceProp?.GetValue(null);
                if (healthBarManager == null) return;

                // è·å–å½“å‰ Health å¯¹åº”çš„ HealthBar
                var getActiveHealthBarMethod = HarmonyLib.AccessTools.Method(healthBarManagerType, "GetActiveHealthBar");
                if (getActiveHealthBarMethod == null) return;

                var healthBar = getActiveHealthBarMethod.Invoke(healthBarManager, new object[] { _cachedHealth });
                if (healthBar == null) return;

                // å¼ºåˆ¶åˆ·æ–°å›¾æ ‡ï¼ˆä¼šé‡æ–°è¯»å– characterPreset.showNameï¼‰
                var refreshIconMethod = HarmonyLib.AccessTools.Method(healthBar.GetType(), "RefreshCharacterIcon");
                if (refreshIconMethod != null)
                {
                    refreshIconMethod.Invoke(healthBar, null);
                }

                // ç›´æ¥è®¾ç½®åå­—æ–‡æœ¬ï¼ˆåŒé‡ä¿é™©ï¼‰
                var nameTextField = HarmonyLib.AccessTools.Field(healthBar.GetType(), "nameText");
                var nameText = nameTextField?.GetValue(healthBar);
                
                if (nameText != null)
                {
                    var textProp = HarmonyLib.AccessTools.Property(nameText.GetType(), "text");
                    if (textProp != null && textProp.CanWrite)
                    {
                        textProp.SetValue(nameText, Info.SteamName);
                    }
                    
                    // å¼ºåˆ¶æ¿€æ´»åå­—æ˜¾ç¤º
                    var gameObjectProp = HarmonyLib.AccessTools.Property(nameText.GetType(), "gameObject");
                    var gameObject = gameObjectProp?.GetValue(nameText);
                    if (gameObject != null)
                    {
                        var setActiveMethod = HarmonyLib.AccessTools.Method(gameObject.GetType(), "SetActive");
                        setActiveMethod?.Invoke(gameObject, new object[] { true });
                    }
                }
            }
            catch (Exception ex)
            {
                // é™é»˜å¤±è´¥ï¼Œä¸å½±å“è¡€é‡åŒæ­¥
                LogWarning($"[RemotePlayer] åˆ·æ–°è¡€æ¡åå­—å¤±è´¥: {ex.Message}");
            }
        }

        private void OnBeforeDamageApplied(BeforeDamageAppliedEvent @event)
        {
            // åˆ¤æ–­å—ä¼¤çš„æ˜¯å¦æ˜¯å½“å‰ LocalPlayer å®ä¾‹çš„è§’è‰²
            if (@event.TargetGameObject == null || CharacterObject == null)
            {
                return;
            }

            // é€šè¿‡ GameObject å¼•ç”¨åˆ¤æ–­æ˜¯å¦æ˜¯å½“å‰å•ä½
            if (@event.TargetGameObject != CharacterObject)
            {
                return;
            }

            // å°†å½“å‰å•ä½æ‰€æœ‰ä¼¤å®³è®¾ç½®ä¸º 0ï¼ˆæ— æ•Œæ¨¡å¼ï¼‰
            @event.DamageValue = 0;
        }

        #region åœºæ™¯äº‹ä»¶å¤„ç†

        /// <summary>
        /// è¿œç¨‹ç©å®¶è¿›å…¥åœºæ™¯ - é”€æ¯æ—§è§’è‰²å¹¶åˆ›å»ºæ–°è§’è‰²
        /// </summary>
        private void OnPlayerEnteredScene(PlayerEnteredSceneEvent @event)
        {
            Log($"[RemotePlayer] ========== PlayerEnteredSceneEvent æ¥æ”¶ ==========");
            Log($"[RemotePlayer] äº‹ä»¶ç©å®¶: {@event.PlayerInfo.SteamName} ({@event.PlayerInfo.SteamId})");
            Log($"[RemotePlayer] å½“å‰å¯¹è±¡: {Info.SteamName} ({Info.SteamId})");
            Log($"[RemotePlayer] æ˜¯å¦åŒ¹é…: {@event.PlayerInfo.SteamId == Info.SteamId}");
            
            // åªå¤„ç†è‡ªå·±çš„åœºæ™¯äº‹ä»¶
            if (@event.PlayerInfo.SteamId != Info.SteamId)
            {
                Log($"[RemotePlayer] âš ï¸ SteamId ä¸åŒ¹é…ï¼Œè·³è¿‡");
                return;
            }

            // å…ˆé”€æ¯æ—§è§’è‰²
            if (CharacterObject != null)
            {
                Log($"[RemotePlayer] é”€æ¯æ—§è§’è‰²å¯¹è±¡");
                UnityEngine.Object.Destroy(CharacterObject);
                CharacterObject = null;
                _characterTransform = null;
            }

            // æ›´æ–°åœºæ™¯ä¿¡æ¯
            CurrentSceneName = @event.ScenelData.SceneName;
            Info.CurrentScenelData = @event.ScenelData;

            Log($"[RemotePlayer] ğŸ¯ ç©å®¶ {Info.SteamName} è¿›å…¥åœºæ™¯: {CurrentSceneName}");
            Log($"[RemotePlayer] ğŸ¯ æ­£åœ¨åˆ›å»ºè§’è‰²å¯¹è±¡...");

            // åˆ›å»ºæ–°è§’è‰²
            CreateCharacter(DEFAULT_SPAWN_POSITION, Info.SteamName);
            
            Log($"[RemotePlayer] ========== è§’è‰²åˆ›å»ºå®Œæˆ ==========");
        }

        /// <summary>
        /// ç©å®¶ç¦»å¼€åœºæ™¯ - é”€æ¯è§’è‰²
        /// </summary>
        private void OnPlayerLeftScene(PlayerLeftSceneEvent @event)
        {
            // åªå¤„ç†è‡ªå·±çš„åœºæ™¯äº‹ä»¶
            if (@event.PlayerInfo.SteamId != Info.SteamId) return;

            Log($"[RemotePlayer] ç©å®¶ {Info.SteamName} ç¦»å¼€åœºæ™¯: {CurrentSceneName}");

            // æ¸…ç©ºåœºæ™¯ä¿¡æ¯
            CurrentSceneName = null;
            Info.CurrentScenelData = new ScenelData("", "");

            // é”€æ¯è§’è‰²ï¼Œä½†ä¿ç•™ RemotePlayer
            DestroyCharacter();
        }

        #endregion

        #region ä½ç½®åŒæ­¥

        /// <summary>
        /// æ¥æ”¶ä½ç½®åŒæ­¥æ•°æ®
        /// </summary>
        private void OnPlayerUnitySyncReceived(PlayerUnitySyncEvent @event)
        {
            // å¿«é€Ÿè¿‡æ»¤ï¼šæ£€æŸ¥åŒæ­¥æ•°æ®æ˜¯å¦æ˜¯å½“å‰ç©å®¶çš„
            if (@event.SteamID != Info.SteamId) return;

            // å¦‚æœå¹³æ»‘ç®¡ç†å™¨ä¸å­˜åœ¨ï¼Œåˆå§‹åŒ–å®ƒ
            if (_smoothSyncManager == null)
            {
                InitializeSmoothSyncManager(@event.SyncData);
            }

            // æ¥æ”¶æ–°çš„åŒæ­¥æ•°æ®
            _smoothSyncManager?.ReceiveSyncData(@event.SyncData);
        }

        /// <summary>
        /// åˆå§‹åŒ–å¹³æ»‘åŒæ­¥ç®¡ç†å™¨
        /// </summary>
        private void InitializeSmoothSyncManager(UnitySyncData syncData)
        {
            var position = syncData.GetPosition();
            var rotation = syncData.GetRotation();

            _smoothSyncManager = new SmoothSyncManager(
                new Vector3(position.Item1, position.Item2, position.Item3),
                new Quaternion(rotation.Item1, rotation.Item2, rotation.Item3, rotation.Item4)
            );

            Log($"[RemotePlayer] åˆå§‹åŒ–å¹³æ»‘åŒæ­¥ç®¡ç†å™¨: {Info.SteamName}");
        }

        /// <summary>
        /// æ›´æ–°è¿œç¨‹ç©å®¶ä½ç½®ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ Transform å¼•ç”¨ï¼Œé¿å…æ¯å¸§ GetComponent
        /// </summary>
        public void UpdatePosition()
        {
            if (_smoothSyncManager == null || CharacterObject == null) return;

            // ç¼“å­˜ Transform å¼•ç”¨
            if (_characterTransform == null)
            {
                _characterTransform = CharacterObject.transform;
                if (_characterTransform == null) return;
            }

            // æ›´æ–°å¹³æ»‘å€¼å¹¶åº”ç”¨åˆ°è§’è‰²å¯¹è±¡
            _smoothSyncManager.Update();
            _smoothSyncManager.ApplyToTransform(_characterTransform, _characterTransform);
            
            // ğŸ”¥ æ¯å¸§å¼ºåˆ¶æ¿€æ´»åå­—æ˜¾ç¤ºï¼ˆé˜²æ­¢è¢« RefreshCharacterIcon éšè—ï¼‰
            ForceShowHealthBarName();
        }
        
        private int _nameRefreshFrameCounter = 0;
        
        /// <summary>
        /// å¼ºåˆ¶æ¿€æ´»è¡€æ¡åå­—æ˜¾ç¤ºï¼ˆæ¯å¸§è°ƒç”¨ï¼Œä½†é™åˆ¶é¢‘ç‡ï¼‰
        /// </summary>
        private void ForceShowHealthBarName()
        {
            // æ¯ 30 å¸§åˆ·æ–°ä¸€æ¬¡ï¼ˆçº¦ 0.5 ç§’ï¼‰é¿å…æ€§èƒ½é—®é¢˜
            _nameRefreshFrameCounter++;
            if (_nameRefreshFrameCounter < 30) return;
            _nameRefreshFrameCounter = 0;
            
            try
            {
                if (_cachedHealth == null) return;

                // è·å– HealthBarManager
                var healthBarManagerType = HarmonyLib.AccessTools.TypeByName("Duckov.UI.HealthBarManager");
                if (healthBarManagerType == null) return;

                var instanceProp = HarmonyLib.AccessTools.Property(healthBarManagerType, "Instance");
                var healthBarManager = instanceProp?.GetValue(null);
                if (healthBarManager == null) return;

                // è·å–å½“å‰ Health å¯¹åº”çš„ HealthBar
                var getActiveHealthBarMethod = HarmonyLib.AccessTools.Method(healthBarManagerType, "GetActiveHealthBar");
                if (getActiveHealthBarMethod == null) return;

                var healthBar = getActiveHealthBarMethod.Invoke(healthBarManager, new object[] { _cachedHealth });
                if (healthBar == null) return;

                // ç›´æ¥æ¿€æ´»åå­—æ˜¾ç¤ºï¼ˆä¸è°ƒç”¨ RefreshCharacterIconï¼Œé¿å…è¢«è¦†ç›–ï¼‰
                var nameTextField = HarmonyLib.AccessTools.Field(healthBar.GetType(), "nameText");
                var nameText = nameTextField?.GetValue(healthBar);
                
                if (nameText != null)
                {
                    // å¼ºåˆ¶æ¿€æ´»åå­—çš„ GameObject
                    var gameObjectProp = HarmonyLib.AccessTools.Property(nameText.GetType(), "gameObject");
                    var gameObject = gameObjectProp?.GetValue(nameText);
                    if (gameObject != null)
                    {
                        var setActiveMethod = HarmonyLib.AccessTools.Method(gameObject.GetType(), "SetActive");
                        setActiveMethod?.Invoke(gameObject, new object[] { true });
                    }
                    
                    // ç¡®ä¿æ–‡æœ¬æ­£ç¡®
                    var textProp = HarmonyLib.AccessTools.Property(nameText.GetType(), "text");
                    if (textProp != null && textProp.CanWrite)
                    {
                        string currentText = textProp.GetValue(nameText)?.ToString() ?? "";
                        if (currentText != Info.SteamName)
                        {
                            textProp.SetValue(nameText, Info.SteamName);
                        }
                    }
                }
            }
            catch
            {
                // é™é»˜å¤±è´¥ï¼Œä¸å½±å“ä½ç½®åŒæ­¥
            }
        }

        #endregion

        #region è§’è‰²åˆ›å»º

        /// <summary>
        /// åˆ›å»ºè§’è‰²å¯¹è±¡ï¼ˆä¸»å…¥å£ï¼‰
        /// </summary>
        /// <param name="position">ç”Ÿæˆä½ç½®</param>
        /// <param name="displayName">æ˜¾ç¤ºåç§°ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨ Info.SteamNameï¼‰</param>
        /// <returns>åˆ›å»ºæˆåŠŸè¿”å›true</returns>
        public bool CreateCharacter(Vector3 position, string? displayName = null)
        {
            displayName ??= Info.SteamName;

            // å¦‚æœå·²ç»æœ‰è§’è‰²å¯¹è±¡,å…ˆé”€æ¯
            if (CharacterObject != null)
            {
                DestroyCharacter();
            }

            try
            {
                // 1. åˆ›å»ºè§’è‰²æ¨¡å‹
                var newCharacter = CreateCharacterModel(position, displayName);
                if (newCharacter == null)
                {
                    return false;
                }

                // 2. é…ç½®è§’è‰²ç»„ä»¶
                if (!ConfigureCharacterComponents(newCharacter, displayName))
                {
                    return false;
                }

                // 3. åˆå§‹åŒ–ç³»ç»Ÿ
                InitializeCharacterSystems();

                // 4. åº”ç”¨æ•°æ®ï¼ˆå¤–è§‚ã€è£…å¤‡ã€æ­¦å™¨ï¼‰
                ApplyCharacterDataDelayed(displayName);

                // 5. å‘å¸ƒäº‹ä»¶å’Œæ—¥å¿—
                PublishCharacterCreatedEvent();
                LogCharacterCreationSuccess(displayName, position);

                return true;
            }
            catch (Exception ex)
            {
                LogError($"[RemotePlayer] âŒ åˆ›å»ºè§’è‰²æ—¶å‘ç”Ÿå¼‚å¸¸: {displayName}, é”™è¯¯: {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }

        /// <summary>
        /// åˆ›å»ºè§’è‰²æ¨¡å‹
        /// </summary>
        private object? CreateCharacterModel(Vector3 position, string displayName)
        {
            // åˆ›å»ºè§’è‰²æ•°æ®é¡¹
            var characterItem = CharacterCreationUtils.CreateCharacterItem();
            if (characterItem == null)
            {
                LogWarning($"[RemotePlayer] âš ï¸ åˆ›å»ºè§’è‰²æ•°æ®é¡¹å¤±è´¥: {displayName}");
                return null;
            }

            // è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“
            var modelPrefab = CharacterCreationUtils.GetCharacterModelPrefab();
            if (modelPrefab == null)
            {
                LogWarning($"[RemotePlayer] âš ï¸ è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“å¤±è´¥ï¼ˆå¯èƒ½æ˜¯åœºæ™¯åˆ‡æ¢ä¸­ LevelManager æœªå°±ç»ªï¼‰: {displayName}");
                return null;
            }

            // å®ä¾‹åŒ–è§’è‰²
            var newCharacter = CharacterCreationUtils.CreateCharacterInstance(
                characterItem, modelPrefab, position, Quaternion.identity
            );

            if (newCharacter == null)
            {
                LogWarning($"[RemotePlayer] âš ï¸ å®ä¾‹åŒ–è§’è‰²å¤±è´¥: {displayName}");
            }

            return newCharacter;
        }

        /// <summary>
        /// é…ç½®è§’è‰²ç»„ä»¶å’Œå±æ€§
        /// </summary>
        private bool ConfigureCharacterComponents(object newCharacter, string displayName)
        {
            // é…ç½®è§’è‰²åŸºæœ¬å±æ€§
            CharacterCreationUtils.ConfigureCharacter(newCharacter, $"Character_{Info.SteamName}", DEFAULT_SPAWN_POSITION, team: 0);
            CharacterCreationUtils.ConfigureCharacterPreset(newCharacter, displayName, showName: true);

            // æ ‡è®°ä¸ºè¿œç¨‹ç©å®¶
            CharacterCreationUtils.MarkAsRemotePlayer(newCharacter);

            // ä»è·ç¦»ç®¡ç†ç³»ç»Ÿä¸­ç§»é™¤
            CharacterCreationUtils.UnregisterFromDistanceSystem(newCharacter);

            // è¯·æ±‚è¡€æ¡
            var customIcon = GetCustomIcon();
            CharacterCreationUtils.RequestHealthBar(newCharacter, displayName, customIcon);

            // ä¿å­˜ GameObject å¼•ç”¨
            if (newCharacter is Component characterComponent)
            {
                CharacterObject = characterComponent.gameObject;
                _characterTransform = CharacterObject.transform;

                // ç¡®ä¿ GameObject æ¿€æ´»
                if (!CharacterObject.activeSelf)
                {
                    LogWarning($"[RemotePlayer] âš ï¸ GameObject æœªæ¿€æ´»ï¼Œå¼ºåˆ¶æ¿€æ´»");
                    CharacterObject.SetActive(true);
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// åˆå§‹åŒ–è§’è‰²ç³»ç»Ÿï¼ˆåŒæ­¥ç®¡ç†å™¨ç­‰ï¼‰
        /// </summary>
        private void InitializeCharacterSystems()
        {
            if (_characterTransform == null) return;

            // åˆå§‹åŒ–å¹³æ»‘åŒæ­¥ç®¡ç†å™¨ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (_smoothSyncManager == null)
            {
                _smoothSyncManager = new SmoothSyncManager(
                    _characterTransform.position,
                    _characterTransform.rotation
                );
                Log($"[RemotePlayer] åˆ›å»ºå¹³æ»‘åŒæ­¥ç®¡ç†å™¨: ä½ç½® {_characterTransform.position}");
            }
        }

        /// <summary>
        /// å»¶è¿Ÿåº”ç”¨è§’è‰²æ•°æ®ï¼ˆå¤–è§‚ã€è£…å¤‡ã€æ­¦å™¨ï¼‰
        /// </summary>
        private void ApplyCharacterDataDelayed(string displayName)
        {
            if (ModBehaviour.Instance != null)
            {
                // ä½¿ç”¨åç¨‹å»¶è¿Ÿåº”ç”¨
                ModBehaviour.Instance.StartCoroutine(ApplyAllDataDelayed());
            }
            else
            {
                // ç›´æ¥åº”ç”¨ï¼ˆå¯èƒ½å¤±è´¥ï¼‰
                LogWarning($"[RemotePlayer] âš ï¸ ModBehaviour ä¸å¯ç”¨ï¼Œç«‹å³åº”ç”¨æ•°æ®ï¼ˆå¯èƒ½å¤±è´¥ï¼‰");
                ApplyCachedAppearance();
                ApplyCachedEquipment();
                ApplyCachedWeapons();
            }
        }

        /// <summary>
        /// å‘å¸ƒè§’è‰²åˆ›å»ºäº‹ä»¶
        /// </summary>
        private void PublishCharacterCreatedEvent()
        {
            if (GameContext.IsInitialized && GameContext.Instance.EventBus != null && CharacterObject != null)
            {
                GameContext.Instance.EventBus.Publish(
                    new RemoteCharacterCreatedEvent(Info.SteamId, CharacterObject)
                );
            }
        }

        /// <summary>
        /// è®°å½•è§’è‰²åˆ›å»ºæˆåŠŸæ—¥å¿—
        /// </summary>
        private void LogCharacterCreationSuccess(string displayName, Vector3 position)
        {
            if (_characterTransform == null || CharacterObject == null) return;

            Log($"[RemotePlayer] âœ… è§’è‰²åˆ›å»ºæˆåŠŸ: {displayName}, ä½ç½®: {_characterTransform.position}");

            // éªŒè¯åœºæ™¯
            var activeScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();
            Log($"[RemotePlayer] åœºæ™¯: {CharacterObject.scene.name} (æ´»åŠ¨: {activeScene.name})");
        }

        /// <summary>
        /// è·å–è‡ªå®šä¹‰å›¾æ ‡ - ä½¿ç”¨ Steam å¤´åƒ
        /// </summary>
        private UnityEngine.Sprite? GetCustomIcon()
        {
            // å¦‚æœæœ‰ Steam å¤´åƒ,å°†å…¶è½¬æ¢ä¸º Sprite
            if (AvatarTexture != null)
            {
                return UnityEngine.Sprite.Create(
                    AvatarTexture,
                    new UnityEngine.Rect(0, 0, AvatarTexture.width, AvatarTexture.height),
                    new UnityEngine.Vector2(0.5f, 0.5f)
                );
            }
            return null;
        }

        /// <summary>
        /// è¯·æ±‚è¯¥ç©å®¶çš„å¤–è§‚æ•°æ®
        /// </summary>
        private void RequestAppearanceData()
        {
            if (GameContext.IsInitialized && GameContext.Instance.RpcClient != null)
            {
                Log($"[RemotePlayer] ğŸ“¤ æ­£åœ¨è¯·æ±‚ç©å®¶å¤–è§‚æ•°æ®: {Info.SteamName} ({Info.SteamId})");
                GameContext.Instance.RpcClient.InvokeServer<Shared.Services.ICharacterAppearanceService>(
                    nameof(Shared.Services.ICharacterAppearanceService.RequestAppearance),
                    Info.SteamId
                );
                Log($"[RemotePlayer] âœ… å¤–è§‚æ•°æ®è¯·æ±‚å·²å‘é€");
            }
            else
            {
                LogWarning($"[RemotePlayer] âŒ RpcClientæœªåˆå§‹åŒ–ï¼Œæ— æ³•è¯·æ±‚å¤–è§‚æ•°æ®: {Info.SteamName}");
            }
        }

        /// <summary>
        /// æ¥æ”¶åˆ°å¤–è§‚æ•°æ®äº‹ä»¶
        /// </summary>
        private void OnAppearanceReceived(Services.CharacterAppearanceReceivedEvent @event)
        {
            // åªå¤„ç†è‡ªå·±çš„å¤–è§‚æ•°æ®
            if (@event.SteamId != Info.SteamId)
            {
                Log($"[RemotePlayer] ğŸ” æ”¶åˆ°å…¶ä»–ç©å®¶çš„å¤–è§‚æ•°æ®ï¼Œå¿½ç•¥: {@event.SteamId} (å½“å‰: {Info.SteamId})");
                return;
            }

            Log($"[RemotePlayer] ğŸ“¦ æ”¶åˆ°ç©å®¶å¤–è§‚æ•°æ®: {Info.SteamName} ({Info.SteamId})");
            Log($"[RemotePlayer] å¤–è§‚æ•°æ®è¯¦æƒ… - HeadScale: {@event.AppearanceData.HeadSetting.ScaleX}, Parts: {@event.AppearanceData.Parts.Length}");

            // ç¼“å­˜å¤–è§‚æ•°æ®
            _cachedAppearanceData = @event.AppearanceData;

            // å¦‚æœè§’è‰²å·²åˆ›å»º,ç«‹å³åº”ç”¨å¤–è§‚
            if (CharacterObject != null)
            {
                Log($"[RemotePlayer] âœ… è§’è‰²å¯¹è±¡å·²å­˜åœ¨ï¼Œç«‹å³åº”ç”¨å¤–è§‚: {Info.SteamName}");
                ApplyCachedAppearance();
            }
            else
            {
                Log($"[RemotePlayer] ğŸ’¾ è§’è‰²å¯¹è±¡å°šæœªåˆ›å»ºï¼Œå¤–è§‚æ•°æ®å·²ç¼“å­˜ï¼Œå°†åœ¨è§’è‰²åˆ›å»ºååº”ç”¨: {Info.SteamName}");
            }
        }

        /// <summary>
        /// åº”ç”¨ç¼“å­˜çš„å¤–è§‚æ•°æ®
        /// </summary>
        private void ApplyCachedAppearance()
        {
            if (_cachedAppearanceData == null)
            {
                LogWarning($"[RemotePlayer] âš ï¸ æ²¡æœ‰ç¼“å­˜çš„å¤–è§‚æ•°æ®: {Info.SteamName}");
                return;
            }

            if (CharacterObject == null)
            {
                LogWarning($"[RemotePlayer] âš ï¸ è§’è‰²å¯¹è±¡ä¸å­˜åœ¨ï¼Œæ— æ³•åº”ç”¨å¤–è§‚: {Info.SteamName}");
                return;
            }

            try
            {
                Log($"[RemotePlayer] ğŸ¨ å¼€å§‹åº”ç”¨ç¼“å­˜çš„å¤–è§‚æ•°æ®: {Info.SteamName}");
                Utils.AppearanceConverter.ApplyAppearanceToCharacter(CharacterObject, _cachedAppearanceData);
                Log($"[RemotePlayer] âœ… æˆåŠŸåº”ç”¨å¤–è§‚åˆ°è§’è‰²: {Info.SteamName}");
            }
            catch (Exception ex)
            {
                LogError($"[RemotePlayer] âŒ åº”ç”¨å¤–è§‚å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// é€šç”¨å»¶è¿Ÿåç¨‹ - ç­‰å¾…è§’è‰²åˆå§‹åŒ–åæ‰§è¡Œæ“ä½œ
        /// </summary>
        private System.Collections.IEnumerator WaitAndExecute(System.Action action, string description)
        {
            Log($"[RemotePlayer] â³ ç­‰å¾…è§’è‰²åˆå§‹åŒ–å®Œæˆ ({description})...");

            // ç­‰å¾…æŒ‡å®šå¸§æ•°ï¼Œç¡®ä¿ characterModel å·²åˆå§‹åŒ–
            for (int i = 0; i < CHARACTER_INIT_WAIT_FRAMES; i++)
            {
                yield return null;
            }

            action?.Invoke();
        }

        /// <summary>
        /// å»¶è¿Ÿåº”ç”¨æ‰€æœ‰æ•°æ®ï¼ˆå¤–è§‚ã€è£…å¤‡ã€æ­¦å™¨ï¼‰
        /// </summary>
        private System.Collections.IEnumerator ApplyAllDataDelayed()
        {
            Log($"[RemotePlayer] â³ ç­‰å¾…è§’è‰²åˆå§‹åŒ–å®Œæˆ (æ‰€æœ‰æ•°æ®)...");

            // ç­‰å¾…æŒ‡å®šå¸§æ•°
            for (int i = 0; i < CHARACTER_INIT_WAIT_FRAMES; i++)
            {
                yield return null;
            }

            ApplyCachedAppearance();
            ApplyCachedEquipment();
            ApplyCachedWeapons();
        }

        #endregion

        #region Steam å¤´åƒ

        /// <summary>
        /// è®¾ç½® Steam å¤´åƒçº¹ç†
        /// </summary>
        public override void SetAvatarTexture(Texture2D texture)
        {
            AvatarTexture = texture;
            Log($"[RemotePlayer] Steam å¤´åƒå·²è®¾ç½®: {Info.SteamId}");

            // å¦‚æœè§’è‰²å·²åˆ›å»º,å¯ä»¥æ›´æ–°è¡€æ¡å›¾æ ‡
            // TODO: å®ç°è¿è¡Œæ—¶æ›´æ–°è¡€æ¡å›¾æ ‡çš„é€»è¾‘
        }

        #endregion

        #region è£…å¤‡æ•°æ®ç®¡ç†

        /// <summary>
        /// è®¾ç½®å®Œæ•´çš„è£…å¤‡æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶æ‰¹é‡è®¾ç½®ï¼‰
        /// </summary>
        public void SetEquipmentData(PlayerEquipmentData equipmentData)
        {
            if (equipmentData == null)
            {
                LogWarning($"[RemotePlayer] è£…å¤‡æ•°æ®ä¸ºç©º");
                return;
            }

            _equipmentData = equipmentData.Clone(); // å…‹éš†ä¸€ä»½é¿å…å¼•ç”¨å…±äº«
            Log($"[RemotePlayer] è£…å¤‡æ•°æ®å·²è®¾ç½®: {Info.SteamName}, {_equipmentData.GetEquippedCount()} ä»¶è£…å¤‡");
        }

        /// <summary>
        /// æ›´æ–°å•ä¸ªè£…å¤‡æ§½ä½ï¼ˆå®æ—¶æ›´æ–°ï¼‰
        /// </summary>
        public void UpdateEquipmentSlot(EquipmentSlotType slotType, int? itemTypeId)
        {
            if (_equipmentData == null)
            {
                _equipmentData = new PlayerEquipmentData();
            }

            _equipmentData.SetEquipment(slotType, itemTypeId);

            string action = itemTypeId.HasValue && itemTypeId.Value > 0 ? "è£…å¤‡" : "å¸ä¸‹";
            Log($"[RemotePlayer] è£…å¤‡æ›´æ–°: {Info.SteamName} {action} {slotType} (TypeID={itemTypeId})");
        }

        /// <summary>
        /// è·å–è£…å¤‡æ•°æ®
        /// </summary>
        public PlayerEquipmentData? GetEquipmentData()
        {
            return _equipmentData;
        }

        /// <summary>
        /// è·å–æŒ‡å®šæ§½ä½çš„è£…å¤‡TypeID
        /// </summary>
        public int? GetEquipmentTypeId(EquipmentSlotType slotType)
        {
            return _equipmentData?.GetEquipment(slotType);
        }

        /// <summary>
        /// åº”ç”¨ç¼“å­˜çš„è£…å¤‡æ•°æ®åˆ°è§’è‰²ï¼ˆè§’è‰²åˆ›å»ºæ—¶è°ƒç”¨ï¼‰
        /// </summary>
        private void ApplyCachedEquipment()
        {
            if (_equipmentData == null || _equipmentData.GetEquippedCount() == 0)
            {
                Log($"[RemotePlayer] æ²¡æœ‰ç¼“å­˜çš„è£…å¤‡æ•°æ®éœ€è¦åº”ç”¨");
                return;
            }

            if (CharacterObject == null)
            {
                LogWarning($"[RemotePlayer] è§’è‰²å¯¹è±¡ä¸ºç©ºï¼Œæ— æ³•åº”ç”¨è£…å¤‡");
                return;
            }

            var characterMainControl = CharacterObject.GetComponent<CharacterMainControl>();
            if (characterMainControl == null || characterMainControl.CharacterItem == null)
            {
                LogWarning($"[RemotePlayer] è§’è‰²ç»„ä»¶æ— æ•ˆï¼Œæ— æ³•åº”ç”¨è£…å¤‡");
                return;
            }

            Log($"[RemotePlayer] ğŸ½ å¼€å§‹åº”ç”¨ç¼“å­˜çš„è£…å¤‡: {_equipmentData.GetEquippedCount()} ä»¶");

            int successCount = 0;
            foreach (var kvp in _equipmentData.Equipment)
            {
                EquipmentSlotType slotType = kvp.Key;
                int itemTypeId = kvp.Value;

                if (itemTypeId > 0)
                {
                    int slotHash = GetSlotHash(slotType);
                    var slot = characterMainControl.CharacterItem.Slots.GetSlot(slotHash);

                    if (slot != null)
                    {
                        bool success = Core.Utils.EquipmentTools.CreateAndEquip(
                            itemTypeId,
                            slot,
                            HandleUnpluggedEquipment
                        );

                        if (success)
                        {
                            successCount++;
                            Log($"[RemotePlayer] âœ… å·²åº”ç”¨è£…å¤‡: {slotType} = TypeID {itemTypeId}");
                        }
                    }
                }
            }

            Log($"[RemotePlayer] ğŸ½ è£…å¤‡åº”ç”¨å®Œæˆ: {successCount}/{_equipmentData.GetEquippedCount()}");
        }

        /// <summary>
        /// è·å–æ§½ä½Hashå€¼ï¼ˆä½¿ç”¨ç¼“å­˜å­—å…¸ï¼‰
        /// </summary>
        private int GetSlotHash(EquipmentSlotType slotType)
        {
            return _equipmentSlotHashCache.TryGetValue(slotType, out int hash) ? hash : 0;
        }

        /// <summary>
        /// å¤„ç†è¢«æ›¿æ¢çš„è£…å¤‡ï¼ˆé”€æ¯ï¼‰
        /// </summary>
        private void HandleUnpluggedEquipment(Item item)
        {
            if (item != null)
            {
                item.DestroyTree();
            }
        }

        #endregion

        #region æ­¦å™¨æ•°æ®ç®¡ç†

        /// <summary>
        /// è®¾ç½®æ­¦å™¨æ•°æ®ï¼ˆæ‰¹é‡æ›´æ–°ï¼ŒåŠ å…¥æˆ¿é—´æ—¶ï¼‰
        /// </summary>
        public void SetWeaponData(PlayerWeaponData weaponData)
        {
            if (weaponData == null)
            {
                LogWarning($"[RemotePlayer] æ­¦å™¨æ•°æ®ä¸ºç©º");
                return;
            }

            _weaponData = weaponData; // ç›´æ¥ä½¿ç”¨ï¼ˆæœåŠ¡å™¨å·²ç»æ˜¯æ–°å®ä¾‹ï¼‰
            Log($"[RemotePlayer] æ­¦å™¨æ•°æ®å·²è®¾ç½®: {Info.SteamName}, {_weaponData.GetEquippedCount()} ä»¶æ­¦å™¨");
        }

        /// <summary>
        /// æ›´æ–°å•ä¸ªæ­¦å™¨æ§½ä½ï¼ˆå¢é‡æ›´æ–°ï¼‰
        /// </summary>
        public void UpdateWeaponSlot(WeaponSlotType slotType, WeaponItemData? weaponData)
        {
            if (_weaponData == null)
            {
                _weaponData = new PlayerWeaponData();
            }

            _weaponData.SetWeapon(slotType, weaponData);

            string action = weaponData != null ? "è£…å¤‡" : "å¸ä¸‹";
            string weaponName = weaponData?.ItemName ?? "æ— ";
            Log($"[RemotePlayer] æ­¦å™¨æ›´æ–°: {Info.SteamName} {action} {slotType} ({weaponName})");
        }

        /// <summary>
        /// è·å–æ­¦å™¨æ•°æ®
        /// </summary>
        public PlayerWeaponData? GetWeaponData()
        {
            return _weaponData;
        }

        /// <summary>
        /// è·å–æŒ‡å®šæ§½ä½çš„æ­¦å™¨æ•°æ®
        /// </summary>
        public WeaponItemData? GetWeaponItemData(WeaponSlotType slotType)
        {
            return _weaponData?.GetWeapon(slotType);
        }

        /// <summary>
        /// åº”ç”¨ç¼“å­˜çš„æ­¦å™¨ï¼ˆè§’è‰²åˆ›å»ºåè°ƒç”¨ï¼‰
        /// </summary>
        private void ApplyCachedWeapons()
        {
            if (_weaponData == null || _weaponData.GetEquippedCount() == 0)
            {
                Log($"[RemotePlayer] æ²¡æœ‰ç¼“å­˜çš„æ­¦å™¨æ•°æ®éœ€è¦åº”ç”¨");
                return;
            }

            if (CharacterObject == null)
            {
                LogWarning($"[RemotePlayer] è§’è‰²å¯¹è±¡ä¸ºç©ºï¼Œæ— æ³•åº”ç”¨æ­¦å™¨");
                return;
            }

            var characterMainControl = CharacterObject.GetComponent<CharacterMainControl>();
            if (characterMainControl == null || characterMainControl.CharacterItem == null)
            {
                LogWarning($"[RemotePlayer] è§’è‰²ç»„ä»¶æ— æ•ˆï¼Œæ— æ³•åº”ç”¨æ­¦å™¨");
                return;
            }

            Log($"[RemotePlayer] ğŸ”« å¼€å§‹åº”ç”¨ç¼“å­˜çš„æ­¦å™¨: {_weaponData.GetEquippedCount()} ä»¶");

            int successCount = 0;
            var weaponSlots = new[]
            {
                (WeaponSlotType.PrimaryWeapon, _weaponData.PrimaryWeapon),
                (WeaponSlotType.SecondaryWeapon, _weaponData.SecondaryWeapon),
                (WeaponSlotType.MeleeWeapon, _weaponData.MeleeWeapon)
            };

            foreach (var (slotType, weaponData) in weaponSlots)
            {
                if (weaponData != null && weaponData.ItemTypeId > 0)
                {
                    int slotHash = GetWeaponSlotHash(slotType);
                    var slot = characterMainControl.CharacterItem.Slots.GetSlot(slotHash);

                    if (slot != null)
                    {
                        // ååºåˆ—åŒ–æ­¦å™¨æ•°æ®å¹¶è£…å¤‡
                        Item? weaponItem = Services.WeaponSyncHelper.DeserializeItem(
                            weaponData.ItemDataCompressed,
                            weaponData.ItemTypeId
                        );

                        if (weaponItem != null)
                        {
                            bool success = slot.Plug(weaponItem, out Item unpluggedItem);
                            if (success)
                            {
                                successCount++;
                                Log($"[RemotePlayer] âœ… æ­¦å™¨å·²åº”ç”¨: {slotType} = {weaponData.ItemName}");

                                // å¤„ç†è¢«æ›¿æ¢çš„æ­¦å™¨
                                if (unpluggedItem != null)
                                {
                                    unpluggedItem.DestroyTree();
                                }
                            }
                            else
                            {
                                LogWarning($"[RemotePlayer] âš ï¸ æ­¦å™¨è£…å¤‡å¤±è´¥: {slotType}");
                                weaponItem.DestroyTree();
                            }
                        }
                        else
                        {
                            LogWarning($"[RemotePlayer] âš ï¸ æ­¦å™¨ååºåˆ—åŒ–å¤±è´¥: {slotType}");
                        }
                    }
                }
            }

            Log($"[RemotePlayer] ğŸ”« æ­¦å™¨åº”ç”¨å®Œæˆ: {successCount}/{_weaponData.GetEquippedCount()}");
        }

        /// <summary>
        /// è·å–æ­¦å™¨æ§½ä½Hashå€¼ï¼ˆä½¿ç”¨ç¼“å­˜å­—å…¸ï¼‰
        /// </summary>
        private int GetWeaponSlotHash(WeaponSlotType slotType)
        {
            return _weaponSlotHashCache.TryGetValue(slotType, out int hash) ? hash : 0;
        }

        /// <summary>
        /// åˆ‡æ¢æ­¦å™¨æ§½ä½ï¼ˆæ˜¾ç¤ºå¯¹åº”çš„æ­¦å™¨ï¼‰
        /// </summary>
        public void SwitchWeaponSlot(WeaponSlotType slotType)
        {
            try
            {
                Log($"[RemotePlayer] ğŸ”« åˆ‡æ¢æ­¦å™¨æ§½ä½: {Info.SteamName} â†’ {slotType}");

                if (CharacterObject == null)
                {
                    LogWarning($"[RemotePlayer] è§’è‰²å¯¹è±¡ä¸ºç©ºï¼Œæ— æ³•åˆ‡æ¢æ­¦å™¨");
                    return;
                }

                var characterMainControl = CharacterObject.GetComponent<CharacterMainControl>();
                if (characterMainControl == null || characterMainControl.CharacterItem == null)
                {
                    LogWarning($"[RemotePlayer] è§’è‰²ç»„ä»¶æ— æ•ˆï¼Œæ— æ³•åˆ‡æ¢æ­¦å™¨");
                    return;
                }

                // æ›´æ–°å½“å‰æ­¦å™¨æ§½ä½
                if (_weaponData != null)
                {
                    _weaponData.CurrentWeaponSlot = slotType;
                }

                // è·å–å¯¹åº”æ§½ä½çš„æ­¦å™¨æ•°æ®
                var weaponData = _weaponData?.GetWeapon(slotType);
                if (weaponData == null || weaponData.ItemTypeId == 0)
                {
                    Log($"[RemotePlayer] æ§½ä½ {slotType} æ²¡æœ‰æ­¦å™¨ï¼Œæ¸…é™¤æ‰‹æŒæ­¦å™¨");
                    characterMainControl.ChangeHoldItem(null);
                    return;
                }

                // ä»è§’è‰²çš„æ§½ä½ä¸­è·å–æ­¦å™¨Item
                int slotHash = GetWeaponSlotHash(slotType);
                var slot = characterMainControl.CharacterItem.Slots.GetSlot(slotHash);

                if (slot == null || slot.Content == null)
                {
                    LogWarning($"[RemotePlayer] æ§½ä½ {slotType} ä¸­æ²¡æœ‰æ­¦å™¨Item");
                    return;
                }

                // è°ƒç”¨ ChangeHoldItem æ˜¾ç¤ºæ­¦å™¨
                try
                {
                    characterMainControl.ChangeHoldItem(slot.Content);
                    Log($"[RemotePlayer] âœ… å·²åˆ‡æ¢åˆ°æ­¦å™¨: {slotType} ({weaponData.ItemName})");
                }
                catch (Exception ex)
                {
                    LogWarning($"[RemotePlayer] ChangeHoldItem å¤±è´¥: {ex.Message}");
                }
            }
            catch (Exception ex)
            {
                LogWarning($"[RemotePlayer] åˆ‡æ¢æ­¦å™¨æ§½ä½å¤±è´¥: {ex.Message}");
            }
        }

        #endregion

        /// <summary>
        /// é”€æ¯è§’è‰²ï¼ˆè¦†ç›–åŸºç±»æ–¹æ³•ä»¥æ¸…ç†ç¼“å­˜ï¼‰
        /// </summary>
        public override void DestroyCharacter()
        {
            // æ¸…é™¤æ‰€æœ‰è§’è‰²ç›¸å…³çš„ç¼“å­˜
            _characterTransform = null;
            _smoothSyncManager = null;
            _cachedHealth = null;
            _cachedSetHealthMethod = null;
            
            // è°ƒç”¨åŸºç±»æ–¹æ³•é”€æ¯è§’è‰²å¯¹è±¡
            base.DestroyCharacter();
        }

        /// <summary>
        /// é‡Šæ”¾èµ„æºï¼ˆç¦»å¼€æˆ¿é—´æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public override void Dispose()
        {
            Log($"[RemotePlayer] è¿œç¨‹ç©å®¶é”€æ¯ï¼ˆæˆ¿é—´å±‚ï¼‰: {Info.SteamId}");
            _characterTransform = null; // æ¸…é™¤ Transform ç¼“å­˜
            _smoothSyncManager = null;  // æ¸…é™¤åŒæ­¥ç®¡ç†å™¨
            _cachedHealth = null;       // æ¸…é™¤ Health ç¼“å­˜
            _cachedSetHealthMethod = null; // æ¸…é™¤ SetHealth æ–¹æ³•ç¼“å­˜
            _eventSubscriber.Dispose();  // å–æ¶ˆäº‹ä»¶è®¢é˜…
            base.Dispose(); // ä¼šè‡ªåŠ¨é”€æ¯è§’è‰²å¯¹è±¡
        }
    }
}
```

`Client\Core\Players\SmoothSyncManager.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.Players
{
    /// <summary>
    /// é«˜æ€§èƒ½å¹³æ»‘åŒæ­¥ç®¡ç†å™¨ (ä¼˜åŒ–ç‰ˆ)
    /// ä½¿ç”¨é¢„æµ‹æ€§æ’å€¼ï¼ˆExtrapolationï¼‰+ ç¼“å†²å¿«ç…§ç³»ç»Ÿ
    /// ç®—æ³•å‚è€ƒï¼šSource Engine çš„ç½‘ç»œæ’å€¼å®ç°
    /// 
    /// é‡è¦ï¼šæ—¶é—´æˆ³ä½¿ç”¨æœ¬åœ°æ¥æ”¶æ—¶é—´ï¼Œè€Œéä¼ è¾“çš„åºåˆ—å·
    /// è¿™æ ·å¯ä»¥é¿å…å®¢æˆ·ç«¯/æœåŠ¡å™¨æ—¶é’Ÿä¸åŒæ­¥çš„é—®é¢˜
    /// </summary>
    public class SmoothSyncManager
    {
        // ========== å¸¸é‡é…ç½® ==========
        private const float MIN_INTERPOLATION_DELAY = 0.02f;      // æœ€å°å»¶è¿Ÿ 20ms
        private const float DEFAULT_INTERPOLATION_DELAY = 0.05f;  // é»˜è®¤å»¶è¿Ÿ 50ms
        private const float DEFAULT_EXTRAPOLATION_LIMIT = 0.5f;   // é»˜è®¤å¤–æ¨é™åˆ¶ 500ms
        private const float DEFAULT_SNAP_DISTANCE = 5f;           // é»˜è®¤ç¬ç§»è·ç¦»
        private const float DEFAULT_ROTATION_SNAP_ANGLE = 180f;   // é»˜è®¤æ—‹è½¬ç¬ç§»è§’åº¦
        private const float DEFAULT_POSITION_SMOOTH_SPEED = 15f;  // é»˜è®¤ä½ç½®å¹³æ»‘é€Ÿåº¦
        private const float DEFAULT_ROTATION_SMOOTH_SPEED = 10f;  // é»˜è®¤æ—‹è½¬å¹³æ»‘é€Ÿåº¦
        private const float SMALL_ANGLE_THRESHOLD = 10f;          // å°è§’åº¦é˜ˆå€¼ï¼ˆç”¨ Lerpï¼‰
        private const uint SEQUENCE_HALF = 0x80000000;            // åºåˆ—å·ä¸­ç‚¹ï¼ˆç”¨äºæº¢å‡ºåˆ¤æ–­ï¼‰
        
        // ========== å¿«ç…§ç¼“å†² ==========
        private struct Snapshot
        {
            public Vector3 Position;
            public Quaternion Rotation;
            public Vector3 Velocity;
            public float LocalReceiveTime;  // æœ¬åœ°æ¥æ”¶æ—¶é—´ï¼ˆTime.timeï¼‰
            public uint SequenceNumber;     // åºåˆ—å·ï¼ˆç”¨äºæ£€æµ‹ä¹±åº/é‡å¤ï¼‰
        }
        
        private Snapshot _fromSnapshot;      // èµ·å§‹å¿«ç…§
        private Snapshot _toSnapshot;        // ç›®æ ‡å¿«ç…§
        private Snapshot _currentSnapshot;   // å½“å‰æ’å€¼ç»“æœ
        
        // ========== é…ç½®å‚æ•° ==========
        private float _interpolationDelay = DEFAULT_INTERPOLATION_DELAY;
        private float _extrapolationLimit = DEFAULT_EXTRAPOLATION_LIMIT;
        private float _snapDistance = DEFAULT_SNAP_DISTANCE;
        private float _rotationSnapAngle = DEFAULT_ROTATION_SNAP_ANGLE;
        private float _positionSmoothSpeed = DEFAULT_POSITION_SMOOTH_SPEED;
        private float _rotationSmoothSpeed = DEFAULT_ROTATION_SMOOTH_SPEED;
        
        // ========== è¿è¡Œæ—¶æ•°æ® ==========
        private bool _hasReceivedData = false;
        
        // ğŸ”¥ ä¼˜åŒ–ï¼šç¼“å­˜è®¡ç®—ç»“æœï¼Œå‡å°‘é‡å¤è®¡ç®—
        private float _cachedTimeDiff;
        private float _cachedInterpolationT;
        
        /// <summary>
        /// åˆå§‹åŒ–å¹³æ»‘åŒæ­¥ç®¡ç†å™¨
        /// </summary>
        public SmoothSyncManager(Vector3 initialPosition, Quaternion initialRotation)
        {
            float currentTime = Time.time;
            
            _fromSnapshot = new Snapshot
            {
                Position = initialPosition,
                Rotation = initialRotation,
                Velocity = Vector3.zero,
                LocalReceiveTime = currentTime,
                SequenceNumber = 0
            };
            
            _toSnapshot = _fromSnapshot;
            _currentSnapshot = _fromSnapshot;
        }
        
        /// <summary>
        /// æ¥æ”¶æ–°çš„åŒæ­¥æ•°æ® - O(1) å¤æ‚åº¦
        /// é‡è¦ï¼šä½¿ç”¨æœ¬åœ°æ¥æ”¶æ—¶é—´ï¼Œè€Œéä¼ è¾“çš„åºåˆ—å·ä½œä¸ºæ—¶é—´æˆ³
        /// </summary>
        public void ReceiveSyncData(UnitySyncData syncData)
        {
            var (posX, posY, posZ) = syncData.GetPosition();
            var (rotX, rotY, rotZ, rotW) = syncData.GetRotation();
            var (velX, velY, velZ) = syncData.GetVelocity();
            
            Vector3 newPosition = new Vector3(posX, posY, posZ);
            Quaternion newRotation = new Quaternion(rotX, rotY, rotZ, rotW);
            Vector3 newVelocity = new Vector3(velX, velY, velZ);
            
            // æ£€æµ‹ä¹±åºåŒ…ï¼ˆåºåˆ—å·å€’é€€ï¼‰
            if (_hasReceivedData && IsSequenceOlder(syncData.SequenceNumber, _toSnapshot.SequenceNumber))
            {
                // ä¸¢å¼ƒä¹±åºçš„æ—§åŒ…
                return;
            }
            
            // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ sqrMagnitude é¿å…å¹³æ–¹æ ¹è®¡ç®—ï¼ˆ~30% æ€§èƒ½æå‡ï¼‰
            float sqrDistance = (_toSnapshot.Position - newPosition).sqrMagnitude;
            float sqrSnapDistance = _snapDistance * _snapDistance;
            
            if (sqrDistance > sqrSnapDistance)
            {
                // ç¬ç§»ï¼šç›´æ¥è®¾ç½®ä½ç½®
                float currentTime = Time.time;
                _fromSnapshot = new Snapshot
                {
                    Position = newPosition,
                    Rotation = newRotation,
                    Velocity = newVelocity,
                    LocalReceiveTime = currentTime,
                    SequenceNumber = syncData.SequenceNumber
                };
                _toSnapshot = _fromSnapshot;
                _currentSnapshot = _fromSnapshot;
                _hasReceivedData = true;
                return;
            }
            
            // æ­£å¸¸æ›´æ–°ï¼šè®¾ç½®æ–°çš„ç›®æ ‡å¿«ç…§ï¼ˆä½¿ç”¨æœ¬åœ°æ¥æ”¶æ—¶é—´ï¼‰
            float receiveTime = Time.time;
            _fromSnapshot = _toSnapshot;
            _toSnapshot = new Snapshot
            {
                Position = newPosition,
                Rotation = newRotation,
                Velocity = newVelocity,
                LocalReceiveTime = receiveTime,
                SequenceNumber = syncData.SequenceNumber
            };
            
            _hasReceivedData = true;
        }
        
        /// <summary>
        /// ğŸ”¥ ä¼˜åŒ–ï¼šæ”¹è¿›åºåˆ—å·åˆ¤æ–­é€»è¾‘ï¼ˆRFC 1982 Serial Number Arithmeticï¼‰
        /// åˆ¤æ–­ seq1 æ˜¯å¦æ¯” seq2 æ—§
        /// </summary>
        private static bool IsSequenceOlder(uint seq1, uint seq2)
        {
            // å¦‚æœ seq1 æ¯” seq2 æ—§ï¼Œè¿”å› true
            return seq1 != seq2 && ((seq2 - seq1) & SEQUENCE_HALF) == 0;
        }
        
        /// <summary>
        /// ğŸ”¥ ä¼˜åŒ–ï¼šæ”¹è¿›æ’å€¼ç®—æ³•ï¼Œç¼“å­˜è®¡ç®—ç»“æœ
        /// ä½¿ç”¨çº¿æ€§æ’å€¼ + é€Ÿåº¦é¢„æµ‹ + æ—¶é—´æˆ³åŒæ­¥
        /// </summary>
        public void Update()
        {
            if (!_hasReceivedData) return;
            
            // ç¼“å­˜ Time.timeï¼Œé¿å…å¤šæ¬¡è°ƒç”¨
            float currentTime = Time.time;
            float renderTime = currentTime - _interpolationDelay;
            
            // ========== æƒ…å†µ1: æ’å€¼ (Interpolation) ==========
            if (renderTime >= _fromSnapshot.LocalReceiveTime && renderTime <= _toSnapshot.LocalReceiveTime)
            {
                // ğŸ”¥ ç¼“å­˜è®¡ç®—ç»“æœï¼Œå‡å°‘é‡å¤è®¡ç®—
                _cachedTimeDiff = _toSnapshot.LocalReceiveTime - _fromSnapshot.LocalReceiveTime;
                _cachedInterpolationT = _cachedTimeDiff > 0 
                    ? (renderTime - _fromSnapshot.LocalReceiveTime) / _cachedTimeDiff 
                    : 0f;
                
                // ä½ç½®æ’å€¼ï¼ˆçº¿æ€§ï¼‰
                _currentSnapshot.Position = Vector3.Lerp(
                    _fromSnapshot.Position, 
                    _toSnapshot.Position, 
                    _cachedInterpolationT
                );
                
                // æ—‹è½¬æ’å€¼ï¼ˆä¼˜åŒ–ç‰ˆï¼‰- å°è§’åº¦ç”¨ Lerpï¼Œå¤§è§’åº¦ç”¨ Slerp
                float angle = Quaternion.Angle(_fromSnapshot.Rotation, _toSnapshot.Rotation);
                _currentSnapshot.Rotation = angle < SMALL_ANGLE_THRESHOLD
                    ? Quaternion.Lerp(_fromSnapshot.Rotation, _toSnapshot.Rotation, _cachedInterpolationT)
                    : Quaternion.Slerp(_fromSnapshot.Rotation, _toSnapshot.Rotation, _cachedInterpolationT);
                
                // é€Ÿåº¦æ’å€¼
                _currentSnapshot.Velocity = Vector3.Lerp(
                    _fromSnapshot.Velocity, 
                    _toSnapshot.Velocity, 
                    _cachedInterpolationT
                );
            }
            // ========== æƒ…å†µ2: å¤–æ¨ (Extrapolation) ==========
            else if (renderTime > _toSnapshot.LocalReceiveTime)
            {
                // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ Mathf.Min ç®€åŒ–é€»è¾‘
                float extrapolationTime = Mathf.Min(
                    renderTime - _toSnapshot.LocalReceiveTime, 
                    _extrapolationLimit
                );
                
                // ä½¿ç”¨é€Ÿåº¦é¢„æµ‹ä½ç½® - Dead Reckoning
                _currentSnapshot.Position = _toSnapshot.Position + _toSnapshot.Velocity * extrapolationTime;
                _currentSnapshot.Rotation = _toSnapshot.Rotation;
                _currentSnapshot.Velocity = _toSnapshot.Velocity;
            }
            // ========== æƒ…å†µ3: è¿‡æ—¶æ•°æ® ==========
            else
            {
                // æ¸²æŸ“æ—¶é—´æ—©äºèµ·å§‹å¿«ç…§ï¼Œä½¿ç”¨èµ·å§‹å¿«ç…§
                _currentSnapshot = _fromSnapshot;
            }
        }
        
        /// <summary>
        /// ğŸ”¥ ä¼˜åŒ–ï¼šä¿®å¤å¹³æ»‘æ’å€¼ç®—æ³•ï¼Œä½¿ç”¨æ­£ç¡®çš„æŒ‡æ•°è¡°å‡
        /// åº”ç”¨åˆ° Transform - O(1)
        /// </summary>
        /// <param name="targetTransform">ç›®æ ‡Transformï¼ˆç”¨äºä½ç½®ï¼‰</param>
        /// <param name="rotationTransform">æ—‹è½¬ç›®æ ‡Transformï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸targetTransformç›¸åŒï¼‰</param>
        public void ApplyToTransform(Transform targetTransform, Transform? rotationTransform = null)
        {
            if (targetTransform == null || !_hasReceivedData) return;
            
            float deltaTime = Time.deltaTime;
            
            // ğŸ”¥ æ­£ç¡®çš„å¹³æ»‘å…¬å¼ï¼št = 1 - exp(-speed * deltaTime) çš„è¿‘ä¼¼
            // ä½¿ç”¨ Clamp01 ç¡®ä¿ t åœ¨ [0, 1] èŒƒå›´å†…ï¼Œé¿å… deltaTime è¿‡å¤§æ—¶è¶…è°ƒ
            float positionSmoothT = Mathf.Clamp01(_positionSmoothSpeed * deltaTime);
            float rotationSmoothT = Mathf.Clamp01(_rotationSmoothSpeed * deltaTime);
            
            // ä½ç½®å¹³æ»‘ï¼ˆæŒ‡æ•°è¡°å‡ï¼‰
            targetTransform.position = Vector3.Lerp(
                targetTransform.position, 
                _currentSnapshot.Position, 
                positionSmoothT
            );
            
            // æ—‹è½¬å¹³æ»‘ï¼ˆçƒé¢çº¿æ€§æ’å€¼ï¼‰
            Transform rotTarget = rotationTransform != null ? rotationTransform : targetTransform;
            rotTarget.rotation = Quaternion.Slerp(
                rotTarget.rotation, 
                _currentSnapshot.Rotation, 
                rotationSmoothT
            );
        }
        
        // ========== Getter æ–¹æ³• ==========
        public Vector3 GetPosition() => _currentSnapshot.Position;
        public Quaternion GetRotation() => _currentSnapshot.Rotation;
        public Vector3 GetVelocity() => _currentSnapshot.Velocity;
        public Vector3 GetTargetPosition() => _toSnapshot.Position;
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦å·²æ¥æ”¶æ•°æ®
        /// </summary>
        public bool HasReceivedData() => _hasReceivedData;
        
        // ========== é…ç½®æ–¹æ³• ==========
        
        /// <summary>
        /// è®¾ç½®æ’å€¼å»¶è¿Ÿï¼ˆé»˜è®¤ 50msï¼‰
        /// å»¶è¿Ÿè¶Šå¤§è¶Šå¹³æ»‘ï¼Œä½†å“åº”è¶Šæ…¢
        /// </summary>
        public void SetInterpolationDelay(float delay)
        {
            _interpolationDelay = Mathf.Max(MIN_INTERPOLATION_DELAY, delay);
        }
        
        /// <summary>
        /// è®¾ç½®å¤–æ¨é™åˆ¶ï¼ˆé»˜è®¤ 500msï¼‰
        /// è¶…è¿‡æ­¤æ—¶é—´å°†åœæ­¢é¢„æµ‹ï¼Œç­‰å¾…æ–°æ•°æ®
        /// </summary>
        public void SetExtrapolationLimit(float limit)
        {
            _extrapolationLimit = Mathf.Max(0f, limit);
        }
        
        /// <summary>
        /// è®¾ç½®ç¬ç§»è·ç¦»é˜ˆå€¼ï¼ˆé»˜è®¤ 5mï¼‰
        /// </summary>
        public void SetSnapDistance(float distance)
        {
            _snapDistance = Mathf.Max(0f, distance);
        }
        
        /// <summary>
        /// è®¾ç½®æ—‹è½¬ç¬ç§»è§’åº¦é˜ˆå€¼ï¼ˆé»˜è®¤ 180åº¦ï¼‰
        /// </summary>
        public void SetRotationSnapAngle(float angle)
        {
            _rotationSnapAngle = Mathf.Clamp(angle, 0f, 180f);
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šè®¾ç½®ä½ç½®å¹³æ»‘é€Ÿåº¦ï¼ˆé»˜è®¤ 15ï¼‰
        /// é€Ÿåº¦è¶Šå¤§ï¼Œå¹³æ»‘æ•ˆæœè¶Šå¼±ï¼Œè·Ÿéšè¶Šå¿«
        /// </summary>
        public void SetPositionSmoothSpeed(float speed)
        {
            _positionSmoothSpeed = Mathf.Max(0f, speed);
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šè®¾ç½®æ—‹è½¬å¹³æ»‘é€Ÿåº¦ï¼ˆé»˜è®¤ 10ï¼‰
        /// é€Ÿåº¦è¶Šå¤§ï¼Œå¹³æ»‘æ•ˆæœè¶Šå¼±ï¼Œè·Ÿéšè¶Šå¿«
        /// </summary>
        public void SetRotationSmoothSpeed(float speed)
        {
            _rotationSmoothSpeed = Mathf.Max(0f, speed);
        }
        
        /// <summary>
        /// ç›´æ¥è®¾ç½®ä½ç½®ï¼ˆç¬ç§»ï¼‰
        /// </summary>
        public void SetPositionDirect(Vector3 position)
        {
            _fromSnapshot.Position = position;
            _toSnapshot.Position = position;
            _currentSnapshot.Position = position;
        }
        
        /// <summary>
        /// ç›´æ¥è®¾ç½®æ—‹è½¬ï¼ˆç¬ç§»ï¼‰
        /// </summary>
        public void SetRotationDirect(Quaternion rotation)
        {
            _fromSnapshot.Rotation = rotation;
            _toSnapshot.Rotation = rotation;
            _currentSnapshot.Rotation = rotation;
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šé‡ç½®çŠ¶æ€ï¼ˆç”¨äºåœºæ™¯åˆ‡æ¢ç­‰ï¼‰
        /// </summary>
        public void Reset()
        {
            _hasReceivedData = false;
            _cachedTimeDiff = 0f;
            _cachedInterpolationT = 0f;
        }
    }
}

```

`Client\Core\RoomManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using DuckyNet.Client.UI;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Services;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services.Generated;
using System.Threading.Tasks;
using DuckyNet.Client.Core.EventBus;

namespace DuckyNet.Client.Core
{

    public class RoomManager : IDisposable
    {
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        private RoomServiceClientProxy _roomServiceClient;
        public RoomInfo? CurrentRoom { get; private set; }

        public List<PlayerInfo> RoomPlayers { get; private set; } = new List<PlayerInfo>();

        public RoomManager()
        {
            Debug.Log("[RoomManager] æ„é€ å‡½æ•°å¼€å§‹");
            _eventSubscriber.EnsureInitializedAndSubscribe();
            _eventSubscriber.Subscribe<RoomJoinedEvent>(OnRoomJoined);
            _eventSubscriber.Subscribe<RoomLeftEvent>(OnRoomLeft);
            _eventSubscriber.Subscribe<NetworkDisconnectedEvent>(OnNetworkDisconnected);
            Debug.Log("[RoomManager] æ„é€ å‡½æ•°å®Œæˆ (äº‹ä»¶å·²è®¢é˜…)");
            var serverContext = new ClientServerContext(GameContext.Instance.RpcClient);
            _roomServiceClient = new RoomServiceClientProxy(serverContext);
        }




        public IReadOnlyList<PlayerInfo> GetRoomPlayers() => RoomPlayers;

        public void SetCurrentRoom(RoomInfo room)
        {
            CurrentRoom = room;
            RefreshPlayerListAsync();
            if (GameContext.IsInitialized)
            {
                GameContext.Instance.EventBus.Publish(new RoomJoinedEvent(GameContext.Instance.PlayerManager.LocalPlayer.Info, room));
            }
        }

        public async void RefreshPlayerListAsync()
        {
            if (CurrentRoom == null) return;
            try
            {
                var oldPlayers = RoomPlayers.ToList(); // ä¿å­˜æ—§åˆ—è¡¨
                var players = await _roomServiceClient.GetRoomPlayersAsync(CurrentRoom.RoomId);
                RoomPlayers = new List<PlayerInfo>(players);
                
                // è¯¦æƒ…æ‰“å° RoomPlayers
                foreach (var player in RoomPlayers)
                {
                    Debug.Log($"[RoomManager] ç©å®¶: {player.SteamName}, åœºæ™¯: {player.CurrentScenelData.SceneName}, å­åœºæ™¯: {player.CurrentScenelData.SubSceneName}");
                }
                Debug.Log($"[RoomManager] åˆ·æ–°æˆ¿é—´ç©å®¶: {RoomPlayers.Count}");
                
                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¯¹æ¯”æ–°æ—§åˆ—è¡¨ï¼Œä¸ºæ–°å¢ç©å®¶å‘å¸ƒ PlayerJoinedRoomEvent
                if (GameContext.IsInitialized && CurrentRoom != null)
                {
                    var localSteamId = GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId;
                    
                    foreach (var newPlayer in RoomPlayers)
                    {
                        // è·³è¿‡è‡ªå·±
                        if (newPlayer.SteamId == localSteamId)
                            continue;
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°ç©å®¶ï¼ˆä¸åœ¨æ—§åˆ—è¡¨ä¸­ï¼‰
                        bool isNewPlayer = !oldPlayers.Any(p => p.SteamId == newPlayer.SteamId);
                        
                        if (isNewPlayer)
                        {
                            Debug.Log($"[RoomManager] ğŸ”¥ æ£€æµ‹åˆ°æ–°ç©å®¶ï¼Œå‘å¸ƒ PlayerJoinedRoomEvent: {newPlayer.SteamName}");
                            GameContext.Instance.EventBus.Publish(new PlayerJoinedRoomEvent(newPlayer, CurrentRoom));
                        }
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[RoomManager] åˆ·æ–°ç©å®¶åˆ—è¡¨å¤±è´¥: {ex.Message}");
            }
        }

        public async Task<bool> LeaveRoomAsync()
        {

            try
            {
                var success = await _roomServiceClient.LeaveRoomAsync();
                if (success)
                {
                    var leftRoom = CurrentRoom;
                    CurrentRoom = null;
                    RoomPlayers.Clear();
                    if (GameContext.IsInitialized)
                    {
                        GameContext.Instance.EventBus.Publish(new RoomLeftEvent(GameContext.Instance.PlayerManager.LocalPlayer.Info, leftRoom ?? new RoomInfo()));
                    }
                }
                return success;
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[RoomManager] ç¦»å¼€æˆ¿é—´å¤±è´¥: {ex.Message}");
                return false;
            }
        }

        private async void OnRoomJoined(RoomJoinedEvent evt)
        {

            if (evt.Player.SteamId == GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId)
            {
                Debug.Log($"[RoomManager] è‡ªå·±è¿›å…¥æˆ¿é—´: {evt.Room.RoomId}");
                CurrentRoom = evt.Room;
                try
                {
                    var players = await _roomServiceClient.GetRoomPlayersAsync(evt.Room.RoomId);
                    RoomPlayers = new List<PlayerInfo>(players);
                    Debug.Log($"[RoomManager] æˆ¿é—´ç©å®¶: {string.Join(", ", RoomPlayers.Select(p => p.SteamName))}");
                    
                    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä¸ºæˆ¿é—´å†…å…¶ä»–ç©å®¶å‘å¸ƒ PlayerJoinedRoomEvent
                    var localSteamId = GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId;
                    Debug.Log($"[RoomManager] ğŸ”¥ å‡†å¤‡ä¸ºæˆ¿é—´å†…ç©å®¶å‘å¸ƒäº‹ä»¶ï¼Œæ€»ç©å®¶æ•°: {RoomPlayers.Count}ï¼Œæœ¬åœ°ç©å®¶ID: {localSteamId}");
                    
                    int publishedCount = 0;
                    foreach (var otherPlayer in RoomPlayers)
                    {
                        // è·³è¿‡è‡ªå·±
                        if (otherPlayer.SteamId == localSteamId)
                        {
                            Debug.Log($"[RoomManager] è·³è¿‡æœ¬åœ°ç©å®¶: {otherPlayer.SteamName}");
                            continue;
                        }
                        
                        Debug.Log($"[RoomManager] ğŸ”¥ ä¸ºå·²åœ¨æˆ¿é—´çš„ç©å®¶å‘å¸ƒ PlayerJoinedRoomEvent: {otherPlayer.SteamName} (AvatarUrl: {otherPlayer.AvatarUrl ?? "(null)"})");
                        GameContext.Instance.EventBus.Publish(new PlayerJoinedRoomEvent(otherPlayer, evt.Room));
                        publishedCount++;
                    }
                    
                    Debug.Log($"[RoomManager] âœ… å…±å‘å¸ƒäº† {publishedCount} ä¸ª PlayerJoinedRoomEvent äº‹ä»¶");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[RoomManager] è·å–æˆ¿é—´ç©å®¶å¤±è´¥: {ex.Message}");
                }
            }
            else
            {

                Debug.Log($"[RoomManager] âœ… ç©å®¶åŠ å…¥æˆ¿é—´: {evt.Player.SteamName} â†’ è‡ªåŠ¨æ›´æ–°åˆ—è¡¨");
                var idx = RoomPlayers.FindIndex(p => p.SteamId == evt.Player.SteamId);
                if (idx >= 0)
                {
                    RoomPlayers[idx] = evt.Player;
                    Debug.Log($"[RoomManager] æ›´æ–°ç°æœ‰ç©å®¶ä¿¡æ¯: {evt.Player.SteamName}");
                }
                else
                {
                    RoomPlayers.Add(evt.Player);
                    Debug.Log($"[RoomManager] æ·»åŠ æ–°ç©å®¶: {evt.Player.SteamName}, å½“å‰æ€»æ•°: {RoomPlayers.Count}");
                }

                // ğŸ”¥ é¢„åŠ è½½ç©å®¶å¤´åƒ
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.AvatarManager.PreloadAvatar(evt.Player.SteamId);
                }
            }



        }

        private void OnRoomLeft(RoomLeftEvent evt)
        {
            if (evt.Player.SteamId == GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId)
            {

                Debug.Log($"[RoomManager] è‡ªå·±ç¦»å¼€æˆ¿é—´: {evt.Room.RoomId}");
                CurrentRoom = null;
                RoomPlayers.Clear();
            }
            else
            {
                Debug.Log($"[RoomManager] âŒ ç©å®¶ç¦»å¼€æˆ¿é—´: {evt.Player.SteamName} â†’ è‡ªåŠ¨æ›´æ–°åˆ—è¡¨");
                var idx = RoomPlayers.FindIndex(p => p.SteamId == evt.Player.SteamId);
                if (idx >= 0)
                {
                    RoomPlayers.RemoveAt(idx);
                    Debug.Log($"[RoomManager] ç§»é™¤ç©å®¶: {evt.Player.SteamName}, å½“å‰æ€»æ•°: {RoomPlayers.Count}");
                }
                else
                {
                    Debug.LogWarning($"[RoomManager] âš ï¸ å°è¯•ç§»é™¤ä¸å­˜åœ¨çš„ç©å®¶: {evt.Player.SteamName}");
                }
            }
        }

        private void OnNetworkDisconnected(NetworkDisconnectedEvent evt)
        {
            Debug.Log($"[RoomManager] ğŸ”¥ ç½‘ç»œæ–­å¼€è¿æ¥ï¼Œæ¸…ç†æˆ¿é—´çŠ¶æ€: {evt.Reason}");
            CurrentRoom = null;
            RoomPlayers.Clear();
            Debug.Log($"[RoomManager] âœ… æˆ¿é—´çŠ¶æ€å·²æ¸…ç†");
        }

        public void Dispose()
        {
            _eventSubscriber.Dispose();
        }
    }
}
```

`Client\Core\SceneClientManager.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Client.UI;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Services;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services.Generated;
using DuckyNet.Client.Core.EventBus;

namespace DuckyNet.Client.Core
{

    public class SceneClientManager : IDisposable
    {
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        private SceneServiceClientProxy _sceneServiceClient;
        public ScenelData _scenelDataList = new ScenelData("", "");
        public SceneClientManager()
        {
            Debug.Log("[SceneClientManager] æ„é€ å‡½æ•°å¼€å§‹");
            _eventSubscriber.EnsureInitializedAndSubscribe();
            
            // ğŸ”¥ è®¢é˜…æœ¬åœ°åœºæ™¯äº‹ä»¶ï¼ˆUnityåœºæ™¯ç³»ç»Ÿè§¦å‘ï¼‰
            _eventSubscriber.Subscribe<SceneLoadedDetailEvent>(OnSceneLoaded);
            _eventSubscriber.Subscribe<SceneUnloadingDetailEvent>(OnSceneUnloading);

            // âŒ ç§»é™¤ï¼šæœåŠ¡å™¨ä¸å†å‘é€è¿™äº›äº‹ä»¶ï¼Œæ”¹ç”¨ä½ç½®åŒæ­¥è§¦å‘è§’è‰²åˆ›å»º
            // _eventSubscriber.Subscribe<PlayerEnteredSceneEvent>(OnPlayerEnteredScene);
            // _eventSubscriber.Subscribe<PlayerLeftSceneEvent>(OnPlayerLeftScene);

            Debug.Log("[SceneClientManager] æ„é€ å‡½æ•°å®Œæˆ (äº‹ä»¶å·²è®¢é˜…)");
            var serverContext = new ClientServerContext(GameContext.Instance.RpcClient);
            _sceneServiceClient = new SceneServiceClientProxy(serverContext);
        }

        // âŒ å·²ç§»é™¤ï¼šæœåŠ¡å™¨ä¸å†å‘é€è¿™äº›äº‹ä»¶
        // è§’è‰²åˆ›å»º/é”€æ¯æ”¹ç”± RemotePlayer ç›‘å¬ä½ç½®åŒæ­¥äº‹ä»¶è‡ªåŠ¨å¤„ç†

        private void OnSceneLoaded(SceneLoadedDetailEvent evt)
        {
            Debug.Log($"[SceneClientManager] åœºæ™¯åŠ è½½: {evt.ScenelData.SceneName} {evt.ScenelData.SubSceneName}");
            _scenelDataList = evt.ScenelData;
            Debug.Log($"[SceneClientManager] ğŸ”¥ å‘é€åœºæ™¯è¿›å…¥è¯·æ±‚: {_scenelDataList.SceneName}");
            _sceneServiceClient.EnterSceneAsync(_scenelDataList);
            
            // ğŸ”¥ åœºæ™¯åŠ è½½å®Œæˆå,åˆ·æ–°æˆ¿é—´ç©å®¶åˆ—è¡¨,è·å–å…¶ä»–ç©å®¶ä½ç½®
            // è¿™æ ·å¯ä»¥åœ¨æ–°åœºæ™¯ä¸­é‡æ–°åˆ›å»ºå…¶ä»–ç©å®¶çš„è§’è‰²
            if (GameContext.IsInitialized && GameContext.Instance.RoomManager?.CurrentRoom != null)
            {
                Debug.Log($"[SceneClientManager] åœºæ™¯åŠ è½½å®Œæˆ,åˆ·æ–°æˆ¿é—´ç©å®¶åˆ—è¡¨");
                GameContext.Instance.RoomManager.RefreshPlayerListAsync();
            }
        }

        private void OnSceneUnloading(SceneUnloadingDetailEvent evt)
        {
            Debug.Log($"[SceneClientManager] åœºæ™¯å¸è½½: {evt.ScenelData.SceneName} {evt.ScenelData.SubSceneName}");
            
            // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨äº‹ä»¶ä¸­çš„åœºæ™¯æ•°æ®ï¼ˆå³å°†å¸è½½çš„åœºæ™¯ï¼‰ï¼Œè€Œä¸æ˜¯ _scenelDataList
            // å› ä¸º _scenelDataList å¯èƒ½å·²ç»è¢«æ–°åœºæ™¯æ›´æ–°äº†ï¼ˆOnSceneLoadedå…ˆæ‰§è¡Œï¼‰
            _sceneServiceClient.LeaveSceneAsync(evt.ScenelData);
            
            Debug.Log($"[SceneClientManager] âœ… å·²å‘é€ç¦»å¼€åœºæ™¯è¯·æ±‚: {evt.ScenelData.SceneName}");
            
            // åªæœ‰åœ¨ç¦»å¼€ä¸»åœºæ™¯æ—¶æ‰æ¸…ç©ºï¼ˆå­åœºæ™¯åˆ‡æ¢ä¸æ¸…ç©ºï¼‰
            // ğŸ”¥ ä¿®å¤ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯ä¸»åœºæ™¯å¸è½½
            if (evt.ScenelData.SceneName == _scenelDataList.SceneName)
            {
                Debug.Log($"[SceneClientManager] ä¸»åœºæ™¯å¸è½½ï¼Œæ¸…ç©ºåœºæ™¯æ•°æ®");
                _scenelDataList = new ScenelData("", "");
            }
        }

        public void Dispose()
        {
            _scenelDataList = new ScenelData("", "");
            _eventSubscriber.Dispose();
        }
    }
}
```

`Client\Core\ShadowNpcFactory.cs`:

```cs
using System;
using UnityEngine;
using HarmonyLib;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core.Utils;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// å½±å­ NPC å·¥å‚ - åˆ›å»ºæ—  AI çš„è¿œç¨‹ NPC
    /// 
    /// è®¾è®¡ç†å¿µï¼š
    /// 1. ä½¿ç”¨ä¸è¿œç¨‹ç©å®¶ç›¸åŒçš„åˆ›å»ºæ–¹å¼ï¼ˆCharacterCreationUtilsï¼‰
    /// 2. ç¦ç”¨æ‰€æœ‰ AI ç»„ä»¶ï¼ˆCharacterAIã€NavMeshAgentï¼‰
    /// 3. ç½‘ç»œæ§åˆ¶ä½ç½®å’Œæ—‹è½¬
    /// 4. ä¸å‚ä¸æ¸¸æˆé€»è¾‘ï¼ˆè®¾ç½®ä¸ºä¸­ç«‹é˜Ÿä¼ï¼‰
    /// </summary>
    public static class ShadowNpcFactory
    {
        private static Type? _characterMainControlType;
        private static Type? _characterAIType;
        private static Type? _navMeshAgentType;
        private static bool _initialized = false;

        /// <summary>
        /// åˆå§‹åŒ–åå°„
        /// </summary>
        public static void Initialize()
        {
            if (_initialized) return;

            _characterMainControlType = AccessTools.TypeByName("CharacterMainControl");
            _characterAIType = AccessTools.TypeByName("CharacterAI");
            _navMeshAgentType = Type.GetType("UnityEngine.AI.NavMeshAgent, UnityEngine.AIModule");

            _initialized = true;
            Debug.Log("[ShadowNpcFactory] å½±å­ NPC å·¥å‚å·²åˆå§‹åŒ–");
        }

        /// <summary>
        /// åˆ›å»ºå½±å­ NPCï¼ˆä½¿ç”¨ä¸è¿œç¨‹ç©å®¶ç›¸åŒçš„æ–¹å¼ï¼‰
        /// </summary>
        public static object? CreateShadowNpc(NpcSpawnData data)
        {
            try
            {
                if (!_initialized) Initialize();

                Debug.Log($"[ShadowNpcFactory] å¼€å§‹åˆ›å»ºå½±å­ NPC: {data.NpcType}");

                // 1. åˆ›å»ºè§’è‰²ç‰©å“ï¼ˆCharacterItemï¼‰
                var characterItem = CharacterCreationUtils.CreateCharacterItem();
                if (characterItem == null)
                {
                    Debug.LogError("[ShadowNpcFactory] åˆ›å»ºè§’è‰²ç‰©å“å¤±è´¥");
                    return null;
                }

                // 2. è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“
                var modelPrefab = CharacterCreationUtils.GetCharacterModelPrefab();
                if (modelPrefab == null)
                {
                    Debug.LogError("[ShadowNpcFactory] è·å–æ¨¡å‹é¢„åˆ¶ä½“å¤±è´¥");
                    return null;
                }

                // 3. åˆ›å»ºè§’è‰²å®ä¾‹
                Vector3 position = new Vector3(data.PositionX, data.PositionY, data.PositionZ);
                Quaternion rotation = Quaternion.Euler(0, data.RotationY, 0);
                
                var character = CharacterCreationUtils.CreateCharacterInstance(
                    characterItem, 
                    modelPrefab, 
                    position, 
                    rotation
                );

                if (character == null)
                {
                    Debug.LogError("[ShadowNpcFactory] åˆ›å»ºè§’è‰²å®ä¾‹å¤±è´¥");
                    return null;
                }

                // 4. é…ç½®è§’è‰²ï¼ˆåç§°ã€ä½ç½®ã€é˜Ÿä¼=ä¸­ç«‹ï¼‰
                CharacterCreationUtils.ConfigureCharacter(
                    character, 
                    $"RemoteNPC_{data.NpcType}", 
                    position, 
                    2 // team=2 (middle/ä¸­ç«‹)
                );

                // 5. ç¦ç”¨ AI ç»„ä»¶
                if (character is Component component)
                {
                    DisableAIComponents(component.gameObject);
                    
                    // æ·»åŠ æ ‡è®°ç»„ä»¶
                    var marker = component.gameObject.AddComponent<ShadowNpcMarker>();
                    marker.NpcId = data.NpcId;
                    marker.NpcType = data.NpcType;
                    marker.SceneName = data.SceneName;
                    marker.SubSceneName = data.SubSceneName;
                }

                Debug.Log($"[ShadowNpcFactory] âœ… å½±å­ NPC å·²åˆ›å»º: {data.NpcType} (ID: {data.NpcId})");

                return character;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ShadowNpcFactory] åˆ›å»ºå½±å­ NPC å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
                return null;
            }
        }

        /// <summary>
        /// æ›´æ–°å½±å­ NPC çš„ä½ç½®å’Œæ—‹è½¬
        /// </summary>
        public static void UpdateShadowNpcTransform(GameObject shadowNpc, Vector3 position, float rotationY)
        {
            if (shadowNpc == null) return;

            shadowNpc.transform.position = position;
            shadowNpc.transform.rotation = Quaternion.Euler(0, rotationY, 0);
        }

        /// <summary>
        /// é”€æ¯å½±å­ NPC
        /// </summary>
        public static void DestroyShadowNpc(GameObject shadowNpc)
        {
            if (shadowNpc != null)
            {
                UnityEngine.Object.Destroy(shadowNpc);
                Debug.Log($"[ShadowNpcFactory] å½±å­ NPC å·²é”€æ¯: {shadowNpc.name}");
            }
        }

        /// <summary>
        /// ç¦ç”¨ AI ç»„ä»¶
        /// </summary>
        private static void DisableAIComponents(GameObject npc)
        {
            try
            {
                int disabledCount = 0;

                // ç¦ç”¨ CharacterAI
                if (_characterAIType != null)
                {
                    var ai = npc.GetComponentInChildren(_characterAIType) as MonoBehaviour;
                    if (ai != null)
                    {
                        ai.enabled = false;
                        disabledCount++;
                        Debug.Log($"[ShadowNpcFactory] âœ… å·²ç¦ç”¨ CharacterAI");
                    }
                }

                // ç¦ç”¨ NavMeshAgent
                if (_navMeshAgentType != null)
                {
                    var agent = npc.GetComponent(_navMeshAgentType) as MonoBehaviour;
                    if (agent != null)
                    {
                        agent.enabled = false;
                        disabledCount++;
                        Debug.Log($"[ShadowNpcFactory] âœ… å·²ç¦ç”¨ NavMeshAgent");
                    }
                }

                // ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬ï¼ˆé¿å…æœ¬åœ°åŠ¨ç”»é€»è¾‘ï¼‰
                var animControlType = AccessTools.TypeByName("CharacterAnimationControl");
                if (animControlType != null)
                {
                    var animControl = npc.GetComponentInChildren(animControlType) as MonoBehaviour;
                    if (animControl != null)
                    {
                        animControl.enabled = false;
                        disabledCount++;
                    }
                }

                Debug.Log($"[ShadowNpcFactory] AI ç»„ä»¶å·²ç¦ç”¨: {npc.name}, å…± {disabledCount} ä¸ªç»„ä»¶");
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[ShadowNpcFactory] ç¦ç”¨ AI ç»„ä»¶å¤±è´¥: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// å½±å­ NPC æ ‡è®°ç»„ä»¶ - ç”¨äºè¯†åˆ«å’ŒæŸ¥æ‰¾å½±å­ NPC
    /// </summary>
    public class ShadowNpcMarker : MonoBehaviour
    {
        public string NpcId { get; set; } = "";
        public string NpcType { get; set; } = "";
        public string SceneName { get; set; } = "";
        public string SubSceneName { get; set; } = "";
    }
}


```

`Client\Core\ShadowNpcPool.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// å½±å­ NPC å¯¹è±¡æ± 
    /// 
    /// åŠŸèƒ½ï¼š
    /// 1. å¤ç”¨ GameObjectï¼Œé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯
    /// 2. å‡å°‘ GC å‹åŠ›
    /// 3. æé«˜æ€§èƒ½
    /// 
    /// ç­–ç•¥ï¼š
    /// - æŒ‰ NPC ç±»å‹åˆ†æ± ï¼ˆä¸åŒç±»å‹ä¸å…±ç”¨ï¼‰
    /// - é¢„çƒ­ï¼šå¯åŠ¨æ—¶é¢„åˆ›å»ºå¸¸ç”¨ NPC
    /// - åŠ¨æ€æ‰©å®¹ï¼šä¸å¤Ÿæ—¶è‡ªåŠ¨åˆ›å»ºæ–°çš„
    /// - è‡ªåŠ¨å›æ”¶ï¼šé•¿æ—¶é—´æœªä½¿ç”¨çš„å¯¹è±¡é”€æ¯
    /// </summary>
    public class ShadowNpcPool : IDisposable
    {
        // æŒ‰ NPC ç±»å‹åˆ†æ± 
        private readonly Dictionary<string, Queue<PooledNpc>> _pools = new Dictionary<string, Queue<PooledNpc>>();
        
        // æ­£åœ¨ä½¿ç”¨çš„ NPCï¼ˆç”¨äºè¿½è¸ªï¼‰
        private readonly Dictionary<string, PooledNpc> _activeNpcs = new Dictionary<string, PooledNpc>();

        // é…ç½®
        public int DefaultPoolSize { get; set; } = 10; // æ¯ä¸ªç±»å‹çš„é»˜è®¤æ± å¤§å°
        public int MaxPoolSize { get; set; } = 50; // æ¯ä¸ªç±»å‹çš„æœ€å¤§æ± å¤§å°
        public float AutoRecycleTime { get; set; } = 60f; // 60ç§’æœªä½¿ç”¨è‡ªåŠ¨å›æ”¶

        // ç»Ÿè®¡
        private int _totalCreated = 0;
        private int _totalReused = 0;
        private int _totalRecycled = 0;

        /// <summary>
        /// é¢„çƒ­å¯¹è±¡æ± ï¼ˆåœºæ™¯åŠ è½½æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public void WarmUp(string npcType, int count)
        {
            if (!_pools.ContainsKey(npcType))
            {
                _pools[npcType] = new Queue<PooledNpc>();
            }

            for (int i = 0; i < count; i++)
            {
                var npcData = new NpcSpawnData
                {
                    NpcId = Guid.NewGuid().ToString(),
                    NpcType = npcType,
                    PositionX = 0,
                    PositionY = -1000, // æ”¾åˆ°åœ°ä¸‹
                    PositionZ = 0,
                    RotationY = 0
                };

                var npc = CreateNewNpc(npcData);
                if (npc != null && npc.GameObject != null)
                {
                    npc.GameObject.SetActive(false); // ç¦ç”¨
                    _pools[npcType].Enqueue(npc);
                }
            }

            Debug.Log($"[ShadowNpcPool] é¢„çƒ­å®Œæˆ: {npcType} Ã— {count}");
        }

        /// <summary>
        /// ä»æ± ä¸­è·å–æˆ–åˆ›å»º NPC
        /// </summary>
        public (object? characterMainControl, GameObject? gameObject) Get(NpcSpawnData data)
        {
            var npcType = data.NpcType;

            if (!_pools.ContainsKey(npcType))
            {
                _pools[npcType] = new Queue<PooledNpc>();
            }

            PooledNpc? pooledNpc = null;

            // å°è¯•ä»æ± ä¸­è·å–
            if (_pools[npcType].Count > 0)
            {
                pooledNpc = _pools[npcType].Dequeue();
                _totalReused++;
                Debug.Log($"[ShadowNpcPool] â™»ï¸ å¤ç”¨ NPC: {npcType} (æ± å‰©ä½™: {_pools[npcType].Count})");
            }
            else
            {
                // æ± ä¸ºç©ºï¼Œåˆ›å»ºæ–°çš„
                pooledNpc = CreateNewNpc(data);
                _totalCreated++;
                Debug.Log($"[ShadowNpcPool] ğŸ†• åˆ›å»ºæ–° NPC: {npcType} (æ€»åˆ›å»º: {_totalCreated})");
            }

            if (pooledNpc == null)
                return (null, null);

            // é‡ç½®çŠ¶æ€
            ResetNpc(pooledNpc, data);

            // æ¿€æ´»å¹¶è®°å½•
            if (pooledNpc.GameObject != null)
            {
                pooledNpc.GameObject.SetActive(true);
            }
            pooledNpc.LastUsedTime = Time.time;
            _activeNpcs[data.NpcId] = pooledNpc;

            return (pooledNpc.CharacterMainControl, pooledNpc.GameObject);
        }

        /// <summary>
        /// å›æ”¶ NPC åˆ°æ± 
        /// </summary>
        public void Recycle(string npcId)
        {
            if (!_activeNpcs.TryGetValue(npcId, out var pooledNpc))
            {
                Debug.LogWarning($"[ShadowNpcPool] NPC ä¸åœ¨æ´»åŠ¨åˆ—è¡¨ä¸­: {npcId}");
                return;
            }

            _activeNpcs.Remove(npcId);

            var npcType = pooledNpc.NpcType;
            if (!_pools.ContainsKey(npcType))
            {
                _pools[npcType] = new Queue<PooledNpc>();
            }

            // æ£€æŸ¥æ± æ˜¯å¦å·²æ»¡
            if (_pools[npcType].Count >= MaxPoolSize)
            {
                // æ± æ»¡äº†ï¼Œç›´æ¥é”€æ¯
                if (pooledNpc.GameObject != null)
                {
                    UnityEngine.Object.Destroy(pooledNpc.GameObject);
                }
                Debug.Log($"[ShadowNpcPool] æ± å·²æ»¡ï¼Œé”€æ¯ NPC: {npcType}");
                return;
            }

            // ç¦ç”¨å¹¶å›æ”¶
            if (pooledNpc.GameObject != null)
            {
                pooledNpc.GameObject.SetActive(false);
                pooledNpc.GameObject.transform.position = new Vector3(0, -1000, 0); // ç§»åˆ°åœ°ä¸‹
            }

            pooledNpc.LastUsedTime = Time.time;
            _pools[npcType].Enqueue(pooledNpc);
            _totalRecycled++;

            Debug.Log($"[ShadowNpcPool] â™»ï¸ å›æ”¶ NPC: {npcType} (æ± æ•°é‡: {_pools[npcType].Count})");
        }

        /// <summary>
        /// åˆ›å»ºæ–°çš„ NPC
        /// </summary>
        private PooledNpc? CreateNewNpc(NpcSpawnData data)
        {
            var character = ShadowNpcFactory.CreateShadowNpc(data);
            if (character == null) return null;

            GameObject? gameObject = (character is Component comp) ? comp.gameObject : null;
            if (gameObject == null) return null;

            return new PooledNpc
            {
                NpcType = data.NpcType,
                CharacterMainControl = character,
                GameObject = gameObject,
                CreatedTime = Time.time,
                LastUsedTime = Time.time
            };
        }

        /// <summary>
        /// é‡ç½® NPC çŠ¶æ€
        /// </summary>
        private void ResetNpc(PooledNpc npc, NpcSpawnData data)
        {
            if (npc.GameObject == null) return;

            // é‡ç½®ä½ç½®å’Œæ—‹è½¬
            npc.GameObject.transform.position = new Vector3(data.PositionX, data.PositionY, data.PositionZ);
            npc.GameObject.transform.rotation = Quaternion.Euler(0, data.RotationY, 0);

            // é‡ç½®åç§°
            npc.GameObject.name = $"RemoteNPC_{data.NpcType}";

            // æ›´æ–°æ ‡è®°ç»„ä»¶
            var marker = npc.GameObject.GetComponent<ShadowNpcMarker>();
            if (marker != null)
            {
                marker.NpcId = data.NpcId;
                marker.NpcType = data.NpcType;
                marker.SceneName = data.SceneName;
                marker.SubSceneName = data.SubSceneName;
            }
        }

        /// <summary>
        /// æ¸…ç†é•¿æ—¶é—´æœªä½¿ç”¨çš„ NPCï¼ˆå®šæœŸè°ƒç”¨ï¼Œå¦‚æ¯åˆ†é’Ÿï¼‰
        /// </summary>
        public void CleanupUnused()
        {
            int cleaned = 0;
            foreach (var kvp in _pools)
            {
                var npcType = kvp.Key;
                var pool = kvp.Value;

                // ä¸´æ—¶åˆ—è¡¨
                var toKeep = new Queue<PooledNpc>();

                while (pool.Count > 0)
                {
                    var npc = pool.Dequeue();
                    
                    // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
                    if (Time.time - npc.LastUsedTime > AutoRecycleTime)
                    {
                        // é”€æ¯
                        if (npc.GameObject != null)
                        {
                            UnityEngine.Object.Destroy(npc.GameObject);
                        }
                        cleaned++;
                    }
                    else
                    {
                        // ä¿ç•™
                        toKeep.Enqueue(npc);
                    }
                }

                // é‡å»ºé˜Ÿåˆ—
                _pools[npcType] = toKeep;
            }

            if (cleaned > 0)
            {
                Debug.Log($"[ShadowNpcPool] ğŸ§¹ æ¸…ç†æœªä½¿ç”¨çš„ NPC: {cleaned} ä¸ª");
            }
        }

        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public PoolStats GetStats()
        {
            int totalPooled = 0;
            foreach (var pool in _pools.Values)
            {
                totalPooled += pool.Count;
            }

            return new PoolStats
            {
                TotalCreated = _totalCreated,
                TotalReused = _totalReused,
                TotalRecycled = _totalRecycled,
                ActiveNpcs = _activeNpcs.Count,
                PooledNpcs = totalPooled,
                PoolTypes = _pools.Count,
                ReuseRate = _totalCreated > 0 ? (_totalReused / (float)(_totalCreated + _totalReused)) * 100f : 0f
            };
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰æ± 
        /// </summary>
        public void Dispose()
        {
            // é”€æ¯æ‰€æœ‰æ´»åŠ¨ NPC
            foreach (var npc in _activeNpcs.Values)
            {
                if (npc.GameObject != null)
                {
                    UnityEngine.Object.Destroy(npc.GameObject);
                }
            }
            _activeNpcs.Clear();

            // é”€æ¯æ‰€æœ‰æ± ä¸­çš„ NPC
            foreach (var pool in _pools.Values)
            {
                while (pool.Count > 0)
                {
                    var npc = pool.Dequeue();
                    if (npc.GameObject != null)
                    {
                        UnityEngine.Object.Destroy(npc.GameObject);
                    }
                }
            }
            _pools.Clear();

            Debug.Log($"[ShadowNpcPool] å¯¹è±¡æ± å·²æ¸…ç†ï¼ˆå¤ç”¨ç‡: {GetStats().ReuseRate:F1}%ï¼‰");
        }
    }

    /// <summary>
    /// æ± åŒ–çš„ NPC
    /// </summary>
    internal class PooledNpc
    {
        public string NpcType { get; set; } = "";
        public object? CharacterMainControl { get; set; }
        public GameObject? GameObject { get; set; }
        public float CreatedTime { get; set; }
        public float LastUsedTime { get; set; }
    }

    /// <summary>
    /// å¯¹è±¡æ± ç»Ÿè®¡
    /// </summary>
    public struct PoolStats
    {
        public int TotalCreated;      // æ€»åˆ›å»ºæ•°
        public int TotalReused;       // æ€»å¤ç”¨æ•°
        public int TotalRecycled;     // æ€»å›æ”¶æ•°
        public int ActiveNpcs;        // å½“å‰æ´»åŠ¨æ•°
        public int PooledNpcs;        // å½“å‰æ± ä¸­æ•°
        public int PoolTypes;         // æ± ç±»å‹æ•°
        public float ReuseRate;       // å¤ç”¨ç‡ï¼ˆ%ï¼‰
    }
}


```

`Client\Core\UIManager.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Client.UI;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Services;
using DuckyNet.Shared.Services;
using System.Diagnostics.Tracing;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Core
{
    /// <summary>
    /// UI ç®¡ç†å™¨
    /// è´Ÿè´£ç®¡ç†æ‰€æœ‰ UI çª—å£çš„ç”Ÿå‘½å‘¨æœŸã€æ˜¾ç¤ºå’Œéšè—
    /// </summary>
    public class UIManager : IDisposable
    {
        private readonly RpcClient _rpcClient;
        private readonly Dictionary<string, IUIWindow> _windows;
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();
        // UI çª—å£
        private MainMenuWindow? _mainMenuWindow;
        private ChatWindow? _chatWindow;
        private PlayerListWindow? _playerListWindow;
        private DebugWindow? _debugWindow;

        // æœåŠ¡å®ç°
        private PlayerClientServiceImpl? _playerClientService;
        private RoomClientServiceImpl? _roomClientService;

        public UIManager(RpcClient rpcClient)
        {
            _rpcClient = rpcClient ?? throw new ArgumentNullException(nameof(rpcClient));
            _windows = new Dictionary<string, IUIWindow>();
        }

        /// <summary>
        /// åˆå§‹åŒ–æ‰€æœ‰ UI çª—å£
        /// </summary>
        public void Initialize()
        {
            try
            {
                UnityEngine.Debug.Log("[UIManager] å¼€å§‹åˆå§‹åŒ– UI ç³»ç»Ÿ...");

                // æ³¨å†Œå®¢æˆ·ç«¯æœåŠ¡
                RegisterClientServices();
                _eventSubscriber.EnsureInitializedAndSubscribe();
                // åˆ›å»ºèŠå¤©çª—å£
                _chatWindow = new ChatWindow(_rpcClient);
                RegisterWindow("Chat", _chatWindow);

                // è®¢é˜…èŠå¤©æ¶ˆæ¯äº‹ä»¶ï¼ˆé€šè¿‡å…¨å±€ EventBusï¼‰
                _eventSubscriber.Subscribe<ChatMessageReceivedEvent>(OnChatMessageReceived);
                // åˆ›å»ºç©å®¶åˆ—è¡¨çª—å£
                _playerListWindow = new PlayerListWindow(_rpcClient);
                RegisterWindow("PlayerList", _playerListWindow);

                // åˆ›å»ºä¸»èœå•çª—å£
                _mainMenuWindow = new MainMenuWindow(_rpcClient, _chatWindow);
                RegisterWindow("MainMenu", _mainMenuWindow);

                // åˆ›å»ºè°ƒè¯•çª—å£ï¼ˆåŒ…å«æ‰€æœ‰è°ƒè¯•æ¨¡å—ï¼‰
                _debugWindow = new DebugWindow(_rpcClient);
                RegisterWindow("Debug", _debugWindow);

                UnityEngine.Debug.Log($"[UIManager] UI ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œå…±æ³¨å†Œ {_windows.Count} ä¸ªçª—å£");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[UIManager] UI ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
                throw;
            }
        }

        /// <summary>
        /// æ³¨å†Œå®¢æˆ·ç«¯ RPC æœåŠ¡
        /// </summary>
        private void RegisterClientServices()
        {
            _playerClientService = new PlayerClientServiceImpl();
            _rpcClient.RegisterClientService<IPlayerClientService>(_playerClientService);

            _roomClientService = new RoomClientServiceImpl();
            _rpcClient.RegisterClientService<IRoomClientService>(_roomClientService);

            UnityEngine.Debug.Log("[UIManager] å®¢æˆ·ç«¯æœåŠ¡å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œçª—å£åˆ°ç®¡ç†å™¨
        /// </summary>
        private void RegisterWindow(string name, IUIWindow window)
        {
            if (_windows.ContainsKey(name))
            {
                UnityEngine.Debug.LogWarning($"[UIManager] çª—å£ '{name}' å·²å­˜åœ¨ï¼Œå°†è¢«è¦†ç›–");
            }
            _windows[name] = window;
            UnityEngine.Debug.Log($"[UIManager] çª—å£ '{name}' å·²æ³¨å†Œ");
        }

        /// <summary>
        /// è·å–çª—å£
        /// </summary>
        public T? GetWindow<T>(string name) where T : class, IUIWindow
        {
            if (_windows.TryGetValue(name, out var window))
            {
                return window as T;
            }
            return null;
        }

        /// <summary>
        /// æ˜¾ç¤ºçª—å£
        /// </summary>
        public void ShowWindow(string name)
        {
            if (_windows.TryGetValue(name, out var window))
            {
                window.Show();
                UnityEngine.Debug.Log($"[UIManager] çª—å£ '{name}' å·²æ˜¾ç¤º");
            }
            else
            {
                UnityEngine.Debug.LogWarning($"[UIManager] çª—å£ '{name}' ä¸å­˜åœ¨");
            }
        }

        /// <summary>
        /// éšè—çª—å£
        /// </summary>
        public void HideWindow(string name)
        {
            if (_windows.TryGetValue(name, out var window))
            {
                window.Hide();
                UnityEngine.Debug.Log($"[UIManager] çª—å£ '{name}' å·²éšè—");
            }
            else
            {
                UnityEngine.Debug.LogWarning($"[UIManager] çª—å£ '{name}' ä¸å­˜åœ¨");
            }
        }

        /// <summary>
        /// åˆ‡æ¢çª—å£æ˜¾ç¤ºçŠ¶æ€
        /// </summary>
        public void ToggleWindow(string name)
        {
            if (_windows.TryGetValue(name, out var window))
            {
                UnityEngine.Debug.Log($"[UIManager] åˆ‡æ¢çª—å£: {name}");
                window.Toggle();
            }
            else
            {
                UnityEngine.Debug.LogWarning($"[UIManager] çª—å£ '{name}' ä¸å­˜åœ¨ï¼Œå·²æ³¨å†Œçª—å£: {string.Join(", ", _windows.Keys)}");
            }
        }

        /// <summary>
        /// éšè—æ‰€æœ‰çª—å£
        /// </summary>
        public void HideAllWindows()
        {
            foreach (var window in _windows.Values)
            {
                window.Hide();
            }
            UnityEngine.Debug.Log("[UIManager] æ‰€æœ‰çª—å£å·²éšè—");
        }

        /// <summary>
        /// æ›´æ–°æ‰€æœ‰çª—å£ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
        /// </summary>
        public void Update()
        {
            try
            {
                // æ›´æ–°è°ƒè¯•çª—å£ï¼ˆæ¨¡å—éœ€è¦ Updateï¼‰
                _debugWindow?.Update();
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[UIManager] æ›´æ–°çª—å£æ—¶å‡ºé”™: {ex.Message}");
            }
        }

        /// <summary>
        /// æ¸²æŸ“æ‰€æœ‰çª—å£
        /// </summary>
        public void OnGUI()
        {
            try
            {
                foreach (var window in _windows.Values)
                {
                    window.OnGUI();
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[UIManager] æ¸²æŸ“çª—å£æ—¶å‡ºé”™: {ex.Message}");
            }
        }

        /// <summary>
        /// èŠå¤©æ¶ˆæ¯æ¥æ”¶äº‹ä»¶å¤„ç†å™¨
        /// </summary>
        private void OnChatMessageReceived(ChatMessageReceivedEvent evt)
        {
            UnityEngine.Debug.Log($"[UIManager] æ”¶åˆ° ChatMessageReceivedEvent: {evt.Sender.SteamName}: {evt.Message}");
            if (_chatWindow != null)
            {
                _chatWindow.AddMessage(evt.Sender, evt.Message);
                UnityEngine.Debug.Log($"[UIManager] å·²æ·»åŠ æ¶ˆæ¯åˆ° ChatWindow");
            }
            else
            {
                UnityEngine.Debug.LogError("[UIManager] ChatWindow ä¸º nullï¼");
            }
        }

        /// <summary>
        /// æ¸…ç†èµ„æº
        /// </summary>
        public void Dispose()
        {
            try
            {
                // å–æ¶ˆ EventBus äº‹ä»¶è®¢é˜…ï¼ˆç”± EventSubscriberHelper è‡ªåŠ¨ç®¡ç†ï¼‰
                _eventSubscriber?.Dispose();

                // æ¸…ç†æ‰€æœ‰çª—å£
                foreach (var kvp in _windows)
                {
                    try
                    {
                        kvp.Value.Dispose();
                    }
                    catch (Exception ex)
                    {
                        UnityEngine.Debug.LogError($"[UIManager] æ¸…ç†çª—å£ '{kvp.Key}' å¤±è´¥: {ex.Message}");
                    }
                }

                _windows.Clear();

                _mainMenuWindow = null;
                _chatWindow = null;
                _playerListWindow = null;
                _debugWindow = null;
                _playerClientService = null;
                _roomClientService = null;

                UnityEngine.Debug.Log("[UIManager] UI ç®¡ç†å™¨å·²æ¸…ç†");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[UIManager] æ¸…ç†å¤±è´¥: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// UI çª—å£æ¥å£
    /// </summary>
    public interface IUIWindow : IDisposable
    {
        bool IsVisible { get; }
        void Show();
        void Hide();
        void Toggle();
        void OnGUI();
    }
}


```

`Client\Core\Utils\AnimationBatchWriter.cs`:

```cs
using System.Collections.Generic;
using UnityEngine;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// æ‰¹é‡åŠ¨ç”»å‚æ•°å†™å…¥å™¨ - æ”¶é›†ä¸€å¸§å†…æ‰€æœ‰å‚æ•°å˜åŒ–ï¼Œç»Ÿä¸€å¹³æ»‘å¹¶æäº¤
    /// ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å®ç°è‡ªé€‚åº”å¹³æ»‘,è‡ªåŠ¨å¤„ç†ç½‘ç»œæŠ–åŠ¨
    /// </summary>
    public class AnimationBatchWriter
    {
        // å‚æ•°ç¼“å­˜
        private readonly Dictionary<int, float> _floatTargets = new Dictionary<int, float>();
        private readonly Dictionary<int, bool> _boolValues = new Dictionary<int, bool>();
        private readonly Dictionary<int, int> _intValues = new Dictionary<int, int>();
        private readonly HashSet<int> _triggerHashes = new HashSet<int>();
        
        // æ¯ä¸ª Float å‚æ•°ç‹¬ç«‹çš„å¡å°”æ›¼æ»¤æ³¢å™¨
        private readonly Dictionary<int, KalmanFilter1D> _floatFilters = new Dictionary<int, KalmanFilter1D>();

        // æ»¤æ³¢é…ç½®
        private float _processNoise = 0.01f;     // è¿‡ç¨‹å™ªå£°(è¿åŠ¨å¹³æ»‘åº¦)
        private float _measurementNoise = 0.05f; // æµ‹é‡å™ªå£°(ç½‘ç»œæŠ–åŠ¨)

        /// <summary>
        /// è®¾ç½®å¹³æ»‘å‚æ•°
        /// </summary>
        public void SetSmoothTime(float smoothTime)
        {
            // æ ¹æ®å¹³æ»‘æ—¶é—´è°ƒæ•´è¿‡ç¨‹å™ªå£°(å¹³æ»‘æ—¶é—´è¶Šå¤§,è¿‡ç¨‹å™ªå£°è¶Šå°)
            _processNoise = Mathf.Max(0.001f, 0.1f / smoothTime);
        }

        /// <summary>
        /// è®¾ç½® Float å‚æ•°ç›®æ ‡å€¼ï¼ˆä¼šåœ¨ Commit æ—¶å¹³æ»‘æ’å€¼ï¼‰
        /// </summary>
        public void SetFloat(int hash, float value)
        {
            _floatTargets[hash] = value;
        }

        /// <summary>
        /// è®¾ç½® Bool å‚æ•°å€¼ï¼ˆç«‹å³ç”Ÿæ•ˆï¼‰
        /// </summary>
        public void SetBool(int hash, bool value)
        {
            _boolValues[hash] = value;
        }

        /// <summary>
        /// è®¾ç½® Int å‚æ•°å€¼ï¼ˆç«‹å³ç”Ÿæ•ˆï¼‰
        /// </summary>
        public void SetInt(int hash, int value)
        {
            _intValues[hash] = value;
        }

        /// <summary>
        /// è§¦å‘ Triggerï¼ˆä¼šåœ¨ Commit æ—¶è§¦å‘ï¼‰
        /// </summary>
        public void FireTrigger(int hash)
        {
            _triggerHashes.Add(hash);
        }

        /// <summary>
        /// æäº¤æ‰€æœ‰å‚æ•°åˆ° Animator
        /// </summary>
        /// <param name="animator">ç›®æ ‡ Animator</param>
        /// <param name="deltaTime">å¸§æ—¶é—´</param>
        public void Commit(Animator animator, float deltaTime)
        {
            if (animator == null) 
            {
                UnityEngine.Debug.LogWarning("[AnimationBatchWriter] Animator ä¸ºç©ºï¼Œæ— æ³•æäº¤å‚æ•°");
                return;
            }

            // Float å‚æ•° - ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å¹³æ»‘
            foreach (var kv in _floatTargets)
            {
                int hash = kv.Key;
                float target = kv.Value;
                
                // ä¸ºæ¯ä¸ªå‚æ•°åˆ›å»ºç‹¬ç«‹çš„å¡å°”æ›¼æ»¤æ³¢å™¨
                if (!_floatFilters.ContainsKey(hash))
                {
                    _floatFilters[hash] = new KalmanFilter1D(_processNoise, _measurementNoise);
                    // åˆå§‹åŒ–ä¸ºå½“å‰å€¼
                    float current = animator.GetFloat(hash);
                    _floatFilters[hash].Initialize(current);
                }
                
                // æ›´æ–°å¡å°”æ›¼æ»¤æ³¢å™¨
                var filter = _floatFilters[hash];
                filter.Update(target);
                float smoothed = filter.GetEstimate();
                
                // åº”ç”¨åˆ° Animator
                animator.SetFloat(hash, smoothed);
            }

            // Bool å‚æ•° - ç›´æ¥å†™å…¥
            foreach (var kv in _boolValues)
            {
                animator.SetBool(kv.Key, kv.Value);
            }

            // Int å‚æ•° - ç›´æ¥å†™å…¥
            foreach (var kv in _intValues)
            {
                animator.SetInteger(kv.Key, kv.Value);
            }

            // Trigger - ç»Ÿä¸€è§¦å‘
            foreach (var hash in _triggerHashes)
            {
                animator.SetTrigger(hash);
            }

            // æ¸…ç† Triggerï¼ˆFloat/Bool/Int ä¿ç•™ç”¨äºä¸‹ä¸€å¸§ï¼‰
            _triggerHashes.Clear();
        }

        /// <summary>
        /// æ¸…ç©ºæ‰€æœ‰ç¼“å­˜å‚æ•°
        /// </summary>
        public void Clear()
        {
            _floatTargets.Clear();
            _boolValues.Clear();
            _intValues.Clear();
            _triggerHashes.Clear();
            _floatFilters.Clear(); // æ¸…ç©ºæ»¤æ³¢å™¨
        }

        /// <summary>
        /// è·å–å½“å‰ç¼“å­˜çš„å‚æ•°æ•°é‡
        /// </summary>
        public int GetCachedParamCount()
        {
            return _floatTargets.Count + _boolValues.Count + _intValues.Count + _triggerHashes.Count;
        }
    }
}

```

`Client\Core\Utils\AnimationFrameBuffer.cs`:

```cs
using System;
using UnityEngine;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// åŠ¨ç”»å¸§æ•°æ® - å­˜å‚¨å•å¸§åŠ¨ç”»å‚æ•°
    /// </summary>
    [Serializable]
    public struct AnimationFrame
    {
        // æ—¶é—´æˆ³
        public double Timestamp;

        // åŸºç¡€è¿åŠ¨å‚æ•°
        public float MoveSpeed;
        public float MoveDirX;
        public float MoveDirY;

        // çŠ¶æ€æ ‡å¿—
        public bool IsDashing;
        public bool IsGunReady;
        public bool IsReloading;
        public bool IsDead;

        // å§¿æ€å‚æ•°
        public int HandState;
        public int AttackIndex;

        // åŠ¨ç”»çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
        public int StateHash;
        public float NormalizedTime;

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆå¸§
        /// </summary>
        public bool IsValid => Timestamp > 0;

        /// <summary>
        /// åˆ›å»ºç©ºå¸§
        /// </summary>
        public static AnimationFrame Empty => new AnimationFrame { Timestamp = 0 };
    }

    /// <summary>
    /// åŠ¨ç”»å¸§ç¯å½¢ç¼“å†²åŒº - ä½¿ç”¨å›ºå®šå¤§å°æ•°ç»„ï¼Œé›¶GC
    /// </summary>
    public class AnimationFrameRingBuffer
    {
        private readonly AnimationFrame[] _frames;
        private int _writePos;
        private int _frameCount;

        public int Capacity { get; }
        public int Count => _frameCount;

        /// <summary>
        /// åˆ›å»ºç¯å½¢ç¼“å†²åŒº
        /// </summary>
        /// <param name="capacity">å®¹é‡ï¼ˆå»ºè®® 16-64ï¼‰</param>
        public AnimationFrameRingBuffer(int capacity = 32)
        {
            Capacity = capacity;
            _frames = new AnimationFrame[capacity];
            _writePos = 0;
            _frameCount = 0;
        }

        /// <summary>
        /// æ¨å…¥æ–°å¸§
        /// </summary>
        public void Push(AnimationFrame frame)
        {
            _frames[_writePos] = frame;
            _writePos = (_writePos + 1) % Capacity;

            if (_frameCount < Capacity)
            {
                _frameCount++;
            }
        }

        /// <summary>
        /// è·å–æŒ‡å®šç´¢å¼•çš„å¸§ï¼ˆ0 = æœ€æ—§ï¼ŒCount-1 = æœ€æ–°ï¼‰
        /// </summary>
        public AnimationFrame Get(int index)
        {
            if (index < 0 || index >= _frameCount)
            {
                return AnimationFrame.Empty;
            }

            int pos = (_writePos - _frameCount + index + Capacity) % Capacity;
            return _frames[pos];
        }

        /// <summary>
        /// è·å–æœ€æ–°çš„å¸§
        /// </summary>
        public AnimationFrame GetLatest()
        {
            if (_frameCount == 0)
            {
                return AnimationFrame.Empty;
            }

            return Get(_frameCount - 1);
        }

        /// <summary>
        /// è·å–æœ€æ—§çš„å¸§
        /// </summary>
        public AnimationFrame GetOldest()
        {
            if (_frameCount == 0)
            {
                return AnimationFrame.Empty;
            }

            return Get(0);
        }

        /// <summary>
        /// æŸ¥æ‰¾æŒ‡å®šæ—¶é—´çš„å¸§ï¼ˆä½¿ç”¨çº¿æ€§æ’å€¼ï¼‰
        /// </summary>
        /// <param name="targetTime">ç›®æ ‡æ—¶é—´æˆ³</param>
        /// <returns>æ’å€¼åçš„å¸§</returns>
        public AnimationFrame FindFrameAtTime(double targetTime)
        {
            if (_frameCount == 0)
            {
                return AnimationFrame.Empty;
            }

            // å¦‚æœåªæœ‰ä¸€å¸§ï¼Œç›´æ¥è¿”å›
            if (_frameCount == 1)
            {
                return Get(0);
            }

            // æŸ¥æ‰¾ç›®æ ‡æ—¶é—´æ‰€åœ¨çš„ä¸¤å¸§
            AnimationFrame frameBefore = AnimationFrame.Empty;
            AnimationFrame frameAfter = AnimationFrame.Empty;

            for (int i = 0; i < _frameCount - 1; i++)
            {
                var current = Get(i);
                var next = Get(i + 1);

                if (current.Timestamp <= targetTime && targetTime <= next.Timestamp)
                {
                    frameBefore = current;
                    frameAfter = next;
                    break;
                }
            }

            // å¦‚æœç›®æ ‡æ—¶é—´åœ¨æœ€æ–°å¸§ä¹‹åï¼Œè¿”å›æœ€æ–°å¸§
            if (!frameBefore.IsValid)
            {
                return GetLatest();
            }

            // å¦‚æœç›®æ ‡æ—¶é—´åœ¨æœ€æ—§å¸§ä¹‹å‰ï¼Œè¿”å›æœ€æ—§å¸§
            if (!frameAfter.IsValid)
            {
                return GetOldest();
            }

            // çº¿æ€§æ’å€¼
            return InterpolateFrames(frameBefore, frameAfter, targetTime);
        }

        /// <summary>
        /// çº¿æ€§æ’å€¼ä¸¤å¸§
        /// </summary>
        private AnimationFrame InterpolateFrames(AnimationFrame a, AnimationFrame b, double targetTime)
        {
            double duration = b.Timestamp - a.Timestamp;
            if (duration <= 0)
            {
                return b;
            }

            float t = (float)((targetTime - a.Timestamp) / duration);
            t = Mathf.Clamp01(t);

            return new AnimationFrame
            {
                Timestamp = targetTime,
                MoveSpeed = Mathf.Lerp(a.MoveSpeed, b.MoveSpeed, t),
                MoveDirX = Mathf.Lerp(a.MoveDirX, b.MoveDirX, t),
                MoveDirY = Mathf.Lerp(a.MoveDirY, b.MoveDirY, t),
                IsDashing = t < 0.5f ? a.IsDashing : b.IsDashing,
                IsGunReady = t < 0.5f ? a.IsGunReady : b.IsGunReady,
                IsReloading = t < 0.5f ? a.IsReloading : b.IsReloading,
                IsDead = t < 0.5f ? a.IsDead : b.IsDead,
                HandState = t < 0.5f ? a.HandState : b.HandState,
                AttackIndex = t < 0.5f ? a.AttackIndex : b.AttackIndex,
                StateHash = t < 0.5f ? a.StateHash : b.StateHash,
                NormalizedTime = Mathf.Lerp(a.NormalizedTime, b.NormalizedTime, t)
            };
        }

        /// <summary>
        /// æ¸…ç©ºç¼“å†²åŒº
        /// </summary>
        public void Clear()
        {
            _frameCount = 0;
            _writePos = 0;
        }

        /// <summary>
        /// ç§»é™¤æ—©äºæŒ‡å®šæ—¶é—´çš„å¸§
        /// </summary>
        public void RemoveOlderThan(double timestamp)
        {
            int removeCount = 0;
            for (int i = 0; i < _frameCount; i++)
            {
                if (Get(i).Timestamp < timestamp)
                {
                    removeCount++;
                }
                else
                {
                    break;
                }
            }

            if (removeCount > 0)
            {
                _frameCount -= removeCount;
            }
        }
    }
}

```

`Client\Core\Utils\AppearanceConverter.cs`:

```cs
using System;
using HarmonyLib;
using UnityEngine;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// è§’è‰²å¤–è§‚æ•°æ®è½¬æ¢å·¥å…·
    /// ç”¨äºå°†æ¸¸æˆå†…çš„ CustomFaceSettingData è½¬æ¢ä¸ºç½‘ç»œä¼ è¾“æ ¼å¼ CharacterAppearanceData
    /// </summary>
    public static class AppearanceConverter
    {
        /// <summary>
        /// ä»æ¸¸æˆçš„ CustomFaceSettingData è½¬æ¢ä¸ºç½‘ç»œä¼ è¾“æ ¼å¼
        /// </summary>
        /// <param name="customFaceData">æ¸¸æˆå†…çš„å¤–è§‚æ•°æ®å¯¹è±¡</param>
        /// <returns>ç½‘ç»œä¼ è¾“æ ¼å¼çš„å¤–è§‚æ•°æ®ï¼Œå¤±è´¥è¿”å› null</returns>
        public static CharacterAppearanceData? ConvertToNetworkFormat(object? customFaceData)
        {
            if (customFaceData == null)
            {
                Debug.LogWarning("[AppearanceConverter] customFaceData ä¸ºç©º");
                return null;
            }

            try
            {
                var result = new CharacterAppearanceData();
                var type = customFaceData.GetType();

                // ============ è§£æå¤´éƒ¨è®¾ç½® ============
                var headSettingField = AccessTools.Field(type, "headSetting");
                if (headSettingField != null)
                {
                    var headSetting = headSettingField.GetValue(customFaceData);
                    if (headSetting != null)
                    {
                        ParseHeadSetting(headSetting, result);
                    }
                }

                // ============ è§£æå„ä¸ªéƒ¨ä½ ============
                ParsePart(customFaceData, "hair", result, PartType.Hair);
                ParsePart(customFaceData, "eye", result, PartType.Eye);
                ParsePart(customFaceData, "eyebrow", result, PartType.Eyebrow);
                ParsePart(customFaceData, "mouth", result, PartType.Mouth);
                ParsePart(customFaceData, "tail", result, PartType.Tail);
                ParsePart(customFaceData, "foot", result, PartType.Foot);
                ParsePart(customFaceData, "wing", result, PartType.Wing);

                Debug.Log($"[AppearanceConverter] æˆåŠŸè½¬æ¢å¤–è§‚æ•°æ®");
                return result;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AppearanceConverter] è½¬æ¢å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return null;
            }
        }

        /// <summary>
        /// ä» CustomFaceManager åŠ è½½ä¸»è§’å¤–è§‚æ•°æ®å¹¶è½¬æ¢
        /// </summary>
        public static CharacterAppearanceData? LoadMainCharacterAppearance()
        {
            try
            {
                var customFaceManagerType = AccessTools.TypeByName("CustomFaceManager");
                var levelManagerType = AccessTools.TypeByName("LevelManager");

                if (customFaceManagerType == null || levelManagerType == null)
                {
                    Debug.LogWarning("[AppearanceConverter] æ— æ³•æ‰¾åˆ° CustomFaceManager æˆ– LevelManager ç±»å‹");
                    return null;
                }

                var instanceProp = AccessTools.Property(levelManagerType, "Instance");
                var levelManager = instanceProp?.GetValue(null);

                if (levelManager == null)
                {
                    Debug.LogWarning("[AppearanceConverter] LevelManager.Instance ä¸ºç©º");
                    return null;
                }

                var customFaceManagerProp = AccessTools.Property(levelManagerType, "CustomFaceManager");
                var customFaceManager = customFaceManagerProp?.GetValue(levelManager);

                if (customFaceManager == null)
                {
                    Debug.LogWarning("[AppearanceConverter] CustomFaceManager ä¸ºç©º");
                    return null;
                }

                var loadMethod = AccessTools.Method(customFaceManagerType, "LoadMainCharacterSetting");
                object? faceData = loadMethod?.Invoke(customFaceManager, null);

                return ConvertToNetworkFormat(faceData);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AppearanceConverter] LoadMainCharacterAppearance å¤±è´¥: {ex}");
                return null;
            }
        }

        /// <summary>
        /// ä»è§’è‰²å®ä¾‹è·å–å¤–è§‚æ•°æ®å¹¶è½¬æ¢
        /// </summary>
        public static CharacterAppearanceData? GetCharacterAppearance(CharacterMainControl character)
        {
            try
            {
                // è·å– CharacterModel (ä½¿ç”¨ Field è€Œä¸æ˜¯ Property)
                var characterModelField = AccessTools.Field(character.GetType(), "characterModel");
                var characterModel = characterModelField?.GetValue(character);

                if (characterModel == null)
                {
                    Debug.LogWarning("[AppearanceConverter] CharacterModel ä¸ºç©º");
                    return null;
                }

                // è·å– CustomFace
                var customFaceProp = AccessTools.Property(characterModel.GetType(), "CustomFace");
                var customFaceInstance = customFaceProp?.GetValue(characterModel);

                if (customFaceInstance == null)
                {
                    Debug.LogWarning("[AppearanceConverter] CustomFace å®ä¾‹ä¸ºç©º");
                    return null;
                }

                // è½¬æ¢ä¸ºä¿å­˜æ•°æ®
                var convertMethod = AccessTools.Method(customFaceInstance.GetType(), "ConvertToSaveData");
                object? faceData = convertMethod?.Invoke(customFaceInstance, null);

                return ConvertToNetworkFormat(faceData);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AppearanceConverter] GetCharacterAppearance å¤±è´¥: {ex}");
                return null;
            }
        }

        /// <summary>
        /// åº”ç”¨å¤–è§‚æ•°æ®åˆ°è§’è‰²
        /// ä½¿ç”¨ CharacterModel.SetFaceFromData() æ–¹æ³•
        /// </summary>
        /// <param name="character">ç›®æ ‡è§’è‰²ï¼ˆCharacterMainControl æˆ– GameObjectï¼‰</param>
        /// <param name="appearanceData">ç½‘ç»œä¼ è¾“æ ¼å¼çš„å¤–è§‚æ•°æ®</param>
        /// <returns>æˆåŠŸè¿”å› true</returns>
        public static bool ApplyAppearanceToCharacter(object character, CharacterAppearanceData appearanceData)
        {
            try
            {
                Debug.Log($"[AppearanceConverter] ğŸ¨ å¼€å§‹åº”ç”¨å¤–è§‚æ•°æ®åˆ°è§’è‰²");
                if (character == null)
                {
                    Debug.LogWarning("[AppearanceConverter] âŒ è§’è‰²ä¸ºç©º");
                    return false;
                }
                if (appearanceData == null)
                {
                    Debug.LogWarning("[AppearanceConverter] âŒ å¤–è§‚æ•°æ®ä¸ºç©º");
                    return false;
                }
                // å¦‚æœä¼ å…¥çš„æ˜¯ GameObjectï¼Œè·å– CharacterMainControl ç»„ä»¶
                object characterComponent = character;
                if (character is GameObject gameObject)
                {
                    Debug.Log($"[AppearanceConverter] æ£€æµ‹åˆ° GameObjectï¼Œå°è¯•è·å– CharacterMainControl ç»„ä»¶");
                    var characterMainControlType = AccessTools.TypeByName("CharacterMainControl");
                    if (characterMainControlType != null)
                    {
                        var getComponentMethod = typeof(GameObject).GetMethod("GetComponent", new[] { typeof(System.Type) });
                        if (getComponentMethod != null)
                        {
                            characterComponent = getComponentMethod.Invoke(gameObject, new object[] { characterMainControlType })!;
                        }

                        if (characterComponent == null)
                        {
                            Debug.LogError("[AppearanceConverter] âŒ GameObject ä¸Šæœªæ‰¾åˆ° CharacterMainControl ç»„ä»¶");
                            return false;
                        }
                        Debug.Log($"[AppearanceConverter] âœ… æˆåŠŸè·å– CharacterMainControl ç»„ä»¶");
                    }
                    else
                    {
                        Debug.LogError("[AppearanceConverter] âŒ æ— æ³•æ‰¾åˆ° CharacterMainControl ç±»å‹");
                        return false;
                    }
                }
                Debug.Log($"[AppearanceConverter] ğŸ“¦ å¤–è§‚æ•°æ®è¯¦æƒ… - HeadScale: {appearanceData.HeadSetting.ScaleX}, Parts: {appearanceData.Parts.Length}");
                // è½¬æ¢ä¸ºæ¸¸æˆå†…æ ¼å¼
                Debug.Log($"[AppearanceConverter] ğŸ”„ æ­£åœ¨è½¬æ¢ç½‘ç»œæ ¼å¼åˆ°æ¸¸æˆæ ¼å¼...");
                var customFaceData = ConvertFromNetworkFormat(appearanceData);
                if (customFaceData == null)
                {
                    Debug.LogError("[AppearanceConverter] âŒ è½¬æ¢å¤–è§‚æ•°æ®å¤±è´¥");
                    return false;
                }

                Debug.Log($"[AppearanceConverter] âœ… å¤–è§‚æ•°æ®è½¬æ¢æˆåŠŸ");

                // ä½¿ç”¨ CharacterCreationUtils åº”ç”¨å¤–è§‚
                Debug.Log($"[AppearanceConverter] ğŸ¯ æ­£åœ¨åº”ç”¨å¤–è§‚åˆ°è§’è‰²...");
                bool success = CharacterCreationUtils.ApplyCustomFace(characterComponent, customFaceData);

                if (success)
                {
                    Debug.Log($"[AppearanceConverter] âœ… å¤–è§‚åº”ç”¨æˆåŠŸï¼");
                }
                else
                {
                    Debug.LogError($"[AppearanceConverter] âŒ å¤–è§‚åº”ç”¨å¤±è´¥");
                }

                return success;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AppearanceConverter] âŒ åº”ç”¨å¤–è§‚æ•°æ®å¼‚å¸¸: {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }

        /// <summary>
        /// ä»ç½‘ç»œæ ¼å¼è½¬æ¢å›æ¸¸æˆå†…æ ¼å¼ï¼ˆCustomFaceSettingDataï¼‰
        /// </summary>
        /// <param name="appearanceData">ç½‘ç»œä¼ è¾“æ ¼å¼</param>
        /// <returns>æ¸¸æˆå†…æ ¼å¼çš„ CustomFaceSettingData</returns>
        public static object? ConvertFromNetworkFormat(CharacterAppearanceData appearanceData)
        {
            try
            {
                var customFaceDataType = AccessTools.TypeByName("CustomFaceSettingData");
                if (customFaceDataType == null)
                {
                    Debug.LogError("[AppearanceConverter] æ— æ³•æ‰¾åˆ° CustomFaceSettingData ç±»å‹");
                    return null;
                }

                // åˆ›å»º CustomFaceSettingData å®ä¾‹
                var customFaceData = Activator.CreateInstance(customFaceDataType);
                if (customFaceData == null)
                {
                    Debug.LogError("[AppearanceConverter] æ— æ³•åˆ›å»º CustomFaceSettingData å®ä¾‹");
                    return null;
                }

                // ============ åº”ç”¨å¤´éƒ¨è®¾ç½® ============
                ApplyHeadSetting(customFaceData, appearanceData.HeadSetting);

                // ============ åº”ç”¨å„ä¸ªéƒ¨ä½ ============
                foreach (var part in appearanceData.Parts)
                {
                    ApplyPart(customFaceData, part);
                }

                Debug.Log($"[AppearanceConverter] æˆåŠŸè½¬æ¢ä¸ºæ¸¸æˆå†…æ ¼å¼ (CustomFaceSettingData)");
                return customFaceData;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AppearanceConverter] è½¬æ¢å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return null;
            }
        }

        // ============ ç§æœ‰è¾…åŠ©æ–¹æ³• ============

        private enum PartType
        {
            Hair, Eye, Eyebrow, Mouth, Tail, Foot, Wing
        }

        /// <summary>
        /// è§£æå¤´éƒ¨è®¾ç½®
        /// </summary>
        private static void ParseHeadSetting(object headSetting, CharacterAppearanceData result)
        {
            var headSettingData = new HeadSettingData();
            var type = headSetting.GetType();

            // å¤´éƒ¨ç¼©æ”¾åç§»é‡ -> Scale (æ­£ç¡®çš„å­—æ®µå: headScaleOffset)
            var headScaleOffsetField = AccessTools.Field(type, "headScaleOffset");
            if (headScaleOffsetField != null)
            {
                float headScaleOffset = Convert.ToSingle(headScaleOffsetField.GetValue(headSetting));
                var (x, y, z) = FloatCompression.CompressVector3(headScaleOffset, headScaleOffset, headScaleOffset);
                headSettingData.ScaleX = x;
                headSettingData.ScaleY = y;
                headSettingData.ScaleZ = z;
            }

            // å‰é¢é«˜åº¦å’Œåœ†åº¦ -> Offset (æ­£ç¡®çš„å­—æ®µå: foreheadHeight, foreheadRound)
            var foreheadHeightField = AccessTools.Field(type, "foreheadHeight");
            var foreheadRoundField = AccessTools.Field(type, "foreheadRound");
            if (foreheadHeightField != null && foreheadRoundField != null)
            {
                float foreheadHeight = Convert.ToSingle(foreheadHeightField.GetValue(headSetting));
                float foreheadRound = Convert.ToSingle(foreheadRoundField.GetValue(headSetting));
                var (x, y, z) = FloatCompression.CompressVector3(0, foreheadHeight, foreheadRound);
                headSettingData.OffsetX = x;
                headSettingData.OffsetY = y;
                headSettingData.OffsetZ = z;
            }

            // çš®è‚¤é¢œè‰² -> å­˜å‚¨åœ¨ Rotation å­—æ®µä¸­ (å¤ç”¨å­—æ®µ)
            var skinColorField = AccessTools.Field(type, "skinColor");
            if (skinColorField != null)
            {
                var skinColor = skinColorField.GetValue(headSetting);
                if (skinColor is Color color)
                {
                    // ä¿®æ­£: ç›´æ¥ä½¿ç”¨ FloatCompression.Compress å°† 0-1 é¢œè‰²å€¼æ˜ å°„åˆ° 0-100
                    headSettingData.RotationX = FloatCompression.Compress(color.r);
                    headSettingData.RotationY = FloatCompression.Compress(color.g);
                    headSettingData.RotationZ = FloatCompression.Compress(color.b);
                }
            }

            // ä¸»é¢œè‰²ï¼ˆèº«ä½“é¢œè‰²ï¼‰-> MainColor å­—æ®µ
            var mainColorField = AccessTools.Field(type, "mainColor");
            if (mainColorField != null)
            {
                var mainColor = mainColorField.GetValue(headSetting);
                if (mainColor is Color color)
                {
                    headSettingData.MainColorR = FloatCompression.Compress(color.r);
                    headSettingData.MainColorG = FloatCompression.Compress(color.g);
                    headSettingData.MainColorB = FloatCompression.Compress(color.b);
                }
            }

            result.HeadSetting = headSettingData;
        }

        /// <summary>
        /// è§£æéƒ¨ä½æ•°æ®
        /// </summary>
        private static void ParsePart(object customFaceData, string partName, CharacterAppearanceData result, PartType partType)
        {
            var type = customFaceData.GetType();

            // è·å– ID
            var idField = AccessTools.Field(type, $"{partName}ID");
            int partId = 0;
            if (idField != null)
            {
                partId = Convert.ToInt32(idField.GetValue(customFaceData));
            }

            // è·å– Info
            var infoField = AccessTools.Field(type, $"{partName}Info");
            if (infoField == null) return;

            var infoValue = infoField.GetValue(customFaceData);
            if (infoValue == null) return;

            var partData = new PartData
            {
                PartType = (byte)partType,
                PartId = (ushort)partId
            };

            var infoType = infoValue.GetType();

            // Scale å­—æ®µ: å­˜å‚¨ scale (size)
            var scaleField = AccessTools.Field(infoType, "scale");
            if (scaleField != null)
            {
                float scale = Convert.ToSingle(scaleField.GetValue(infoValue));
                var (x, y, z) = FloatCompression.CompressVector3(scale, scale, scale);
                partData.ScaleX = x;
                partData.ScaleY = y;
                partData.ScaleZ = z;
            }

            // Offset å­—æ®µ: å­˜å‚¨ height, heightOffset, radius
            var heightField = AccessTools.Field(infoType, "height");
            var heightOffsetField = AccessTools.Field(infoType, "heightOffset");
            var radiusField = AccessTools.Field(infoType, "radius");

            float height = heightField != null ? Convert.ToSingle(heightField.GetValue(infoValue)) : 0f;
            float heightOffset = heightOffsetField != null ? Convert.ToSingle(heightOffsetField.GetValue(infoValue)) : 0f;
            float radius = radiusField != null ? Convert.ToSingle(radiusField.GetValue(infoValue)) : 0f;

            var (ox, oy, oz) = FloatCompression.CompressVector3(height, heightOffset, radius);
            partData.OffsetX = ox;
            partData.OffsetY = oy;
            partData.OffsetZ = oz;

            // Rotation å­—æ®µ: å­˜å‚¨ distanceAngle, leftRightAngle, twist
            var distanceAngleField = AccessTools.Field(infoType, "distanceAngle");
            var leftRightAngleField = AccessTools.Field(infoType, "leftRightAngle");
            var twistField = AccessTools.Field(infoType, "twist");

            float distanceAngle = distanceAngleField != null ? Convert.ToSingle(distanceAngleField.GetValue(infoValue)) : 0f;
            float leftRightAngle = leftRightAngleField != null ? Convert.ToSingle(leftRightAngleField.GetValue(infoValue)) : 0f;
            float twist = twistField != null ? Convert.ToSingle(twistField.GetValue(infoValue)) : 0f;

            var (rx, ry, rz) = FloatCompression.CompressVector3(distanceAngle, leftRightAngle, twist);
            partData.RotationX = rx;
            partData.RotationY = ry;
            partData.RotationZ = rz;

            // é¢œè‰²å­—æ®µ: å­˜å‚¨ RGB é¢œè‰²å€¼
            var colorField = AccessTools.Field(infoType, "color");
            if (colorField != null)
            {
                var color = colorField.GetValue(infoValue);
                if (color is Color c)
                {
                    partData.ColorR = FloatCompression.Compress(c.r);
                    partData.ColorG = FloatCompression.Compress(c.g);
                    partData.ColorB = FloatCompression.Compress(c.b);
                }
            }

            // æ·»åŠ åˆ°ç»“æœä¸­
            var parts = new System.Collections.Generic.List<PartData>(result.Parts);
            parts.Add(partData);
            result.Parts = parts.ToArray();
        }

        /// <summary>
        /// åº”ç”¨å¤´éƒ¨è®¾ç½®åˆ°æ¸¸æˆå†…æ ¼å¼
        /// </summary>
        private static void ApplyHeadSetting(object customFaceData, HeadSettingData headSettingData)
        {
            var type = customFaceData.GetType();

            // åˆ›å»ºæˆ–è·å– headSetting å¯¹è±¡
            var headSettingField = AccessTools.Field(type, "headSetting");
            if (headSettingField == null) return;

            var headSettingType = headSettingField.FieldType;
            var headSetting = Activator.CreateInstance(headSettingType);
            if (headSetting == null) return;

            var hsType = headSetting.GetType();

            // å¤´éƒ¨ç¼©æ”¾åç§»é‡ (ä» Scale è¿˜åŸï¼Œæ­£ç¡®çš„å­—æ®µå: headScaleOffset)
            var headScaleOffsetField = AccessTools.Field(hsType, "headScaleOffset");
            if (headScaleOffsetField != null)
            {
                var (x, y, z) = FloatCompression.DecompressVector3(
                    headSettingData.ScaleX,
                    headSettingData.ScaleY,
                    headSettingData.ScaleZ
                );
                headScaleOffsetField.SetValue(headSetting, x); // ä½¿ç”¨ X ä½œä¸ºåç§»é‡
            }

            // å‰é¢é«˜åº¦å’Œåœ†åº¦ (ä» Offset è¿˜åŸï¼Œæ­£ç¡®çš„å­—æ®µå: foreheadHeight, foreheadRound)
            var foreheadHeightField = AccessTools.Field(hsType, "foreheadHeight");
            var foreheadRoundField = AccessTools.Field(hsType, "foreheadRound");
            if (foreheadHeightField != null && foreheadRoundField != null)
            {
                var (x, y, z) = FloatCompression.DecompressVector3(
                    headSettingData.OffsetX,
                    headSettingData.OffsetY,
                    headSettingData.OffsetZ
                );
                foreheadHeightField.SetValue(headSetting, y); // Y æ˜¯å‰é¢é«˜åº¦
                foreheadRoundField.SetValue(headSetting, z);   // Z æ˜¯å‰é¢åœ†åº¦
            }

            // çš®è‚¤é¢œè‰² (ä» Rotation è¿˜åŸ)
            var skinColorField = AccessTools.Field(hsType, "skinColor");
            if (skinColorField != null)
            {
                // ä¿®æ­£: ä½¿ç”¨ FloatCompression.Decompress å°† 0-100 å€¼è¿˜åŸä¸º 0-1 é¢œè‰²å€¼
                float r = FloatCompression.Decompress(headSettingData.RotationX);
                float g = FloatCompression.Decompress(headSettingData.RotationY);
                float b = FloatCompression.Decompress(headSettingData.RotationZ);

                var color = new Color(
                    Mathf.Clamp01(r),
                    Mathf.Clamp01(g),
                    Mathf.Clamp01(b),
                    1f
                );
                skinColorField.SetValue(headSetting, color);
            }

            // ä¸»é¢œè‰²ï¼ˆèº«ä½“é¢œè‰²ï¼‰(ä» MainColor è¿˜åŸ)
            var mainColorField = AccessTools.Field(hsType, "mainColor");
            if (mainColorField != null)
            {
                float r = FloatCompression.Decompress(headSettingData.MainColorR);
                float g = FloatCompression.Decompress(headSettingData.MainColorG);
                float b = FloatCompression.Decompress(headSettingData.MainColorB);

                var color = new Color(
                    Mathf.Clamp01(r),
                    Mathf.Clamp01(g),
                    Mathf.Clamp01(b),
                    1f
                );
                mainColorField.SetValue(headSetting, color);
            }

            // è®¾ç½®åˆ° customFaceData
            headSettingField.SetValue(customFaceData, headSetting);
        }

        /// <summary>
        /// åº”ç”¨éƒ¨ä½æ•°æ®åˆ°æ¸¸æˆå†…æ ¼å¼
        /// </summary>
        private static void ApplyPart(object customFaceData, PartData partData)
        {
            var type = customFaceData.GetType();

            // æ ¹æ® PartType ç¡®å®šéƒ¨ä½åç§°
            string partName = ((PartType)partData.PartType) switch
            {
                PartType.Hair => "hair",
                PartType.Eye => "eye",
                PartType.Eyebrow => "eyebrow",
                PartType.Mouth => "mouth",
                PartType.Tail => "tail",
                PartType.Foot => "foot",
                PartType.Wing => "wing",
                _ => ""
            };

            if (string.IsNullOrEmpty(partName)) return;

            // è®¾ç½® ID
            var idField = AccessTools.Field(type, $"{partName}ID");
            if (idField != null)
            {
                idField.SetValue(customFaceData, (int)partData.PartId);
            }

            // è®¾ç½® Info
            var infoField = AccessTools.Field(type, $"{partName}Info");
            if (infoField == null) return;

            // åˆ›å»º Info å¯¹è±¡
            var infoType = infoField.FieldType;
            var infoInstance = Activator.CreateInstance(infoType);
            if (infoInstance == null) return;

            // è¿˜åŸ scale
            var scaleField = AccessTools.Field(infoType, "scale");
            if (scaleField != null)
            {
                var (x, y, z) = FloatCompression.DecompressVector3(partData.ScaleX, partData.ScaleY, partData.ScaleZ);
                scaleField.SetValue(infoInstance, x);
            }

            // è¿˜åŸ height, heightOffset, radius
            var (height, heightOffset, radius) = FloatCompression.DecompressVector3(
                partData.OffsetX, partData.OffsetY, partData.OffsetZ);

            var heightField = AccessTools.Field(infoType, "height");
            if (heightField != null) heightField.SetValue(infoInstance, height);

            var heightOffsetField = AccessTools.Field(infoType, "heightOffset");
            if (heightOffsetField != null) heightOffsetField.SetValue(infoInstance, heightOffset);

            var radiusField = AccessTools.Field(infoType, "radius");
            if (radiusField != null) radiusField.SetValue(infoInstance, radius);

            // è¿˜åŸ distanceAngle, leftRightAngle, twist
            var (distanceAngle, leftRightAngle, twist) = FloatCompression.DecompressVector3(
                partData.RotationX, partData.RotationY, partData.RotationZ);

            var distanceAngleField = AccessTools.Field(infoType, "distanceAngle");
            if (distanceAngleField != null) distanceAngleField.SetValue(infoInstance, distanceAngle);

            var leftRightAngleField = AccessTools.Field(infoType, "leftRightAngle");
            if (leftRightAngleField != null) leftRightAngleField.SetValue(infoInstance, leftRightAngle);

            var twistField = AccessTools.Field(infoType, "twist");
            if (twistField != null) twistField.SetValue(infoInstance, twist);

            // è¿˜åŸé¢œè‰²
            var colorField = AccessTools.Field(infoType, "color");
            if (colorField != null)
            {
                float r = FloatCompression.Decompress(partData.ColorR);
                float g = FloatCompression.Decompress(partData.ColorG);
                float b = FloatCompression.Decompress(partData.ColorB);

                var color = new Color(
                    Mathf.Clamp01(r),
                    Mathf.Clamp01(g),
                    Mathf.Clamp01(b),
                    1f
                );
                colorField.SetValue(infoInstance, color);
            }

            // è®¾ç½®åˆ° customFaceData
            infoField.SetValue(customFaceData, infoInstance);
        }
    }
}

```

`Client\Core\Utils\CharacterCreationUtils.cs`:

```cs
using System;
using System.Reflection;
using UnityEngine;
using HarmonyLib;

namespace DuckyNet.Client.Core.Utils
{
    public static class CharacterCreationUtils
    {
        /// <summary>
        /// ç¼“å­˜åå°„ç±»å‹å’Œæˆå‘˜ï¼Œé¿å…é‡å¤æŸ¥æ‰¾
        /// </summary>
        private static class CachedReflection
        {
            // ç±»å‹ç¼“å­˜
            public static readonly Type? LevelManagerType = AccessTools.TypeByName("LevelManager");
            public static readonly Type? CharacterCreatorType = AccessTools.TypeByName("CharacterCreator");
            public static readonly Type? CharacterRandomPresetType = AccessTools.TypeByName("CharacterRandomPreset");
            public static readonly Type? ItemAssetsCollectionType = AccessTools.TypeByName("ItemStatsSystem.ItemAssetsCollection");
            public static readonly Type? GameplayDataSettingsType = AccessTools.TypeByName("Duckov.Utilities.GameplayDataSettings");
            public static readonly Type? TeamsType = AccessTools.TypeByName("Teams");
            public static readonly Type? CharacterIconTypesType = AccessTools.TypeByName("CharacterIconTypes");
            public static readonly Type? MovementType = AccessTools.TypeByName("Movement");
            public static readonly Type? SetActiveByPlayerDistanceType = AccessTools.TypeByName("Duckov.Utilities.SetActiveByPlayerDistance");
            public static readonly Type? HealthBarManagerType = AccessTools.TypeByName("Duckov.UI.HealthBarManager");

            // å±æ€§ç¼“å­˜
            public static readonly PropertyInfo? LevelManagerInstance = AccessTools.Property(LevelManagerType, "Instance");
            public static readonly PropertyInfo? MainCharacter = AccessTools.Property(LevelManagerType, "MainCharacter");
            public static readonly PropertyInfo? CharacterCreatorProp = AccessTools.Property(LevelManagerType, "CharacterCreator");
            public static readonly PropertyInfo? ItemAssets = AccessTools.Property(GameplayDataSettingsType, "ItemAssets");
            public static readonly PropertyInfo? HealthBarManagerInstance = AccessTools.Property(HealthBarManagerType, "Instance");

            // å­—æ®µç¼“å­˜
            public static readonly FieldInfo? CharacterModelField = AccessTools.Field(LevelManagerType, "characterModel");

            // æ–¹æ³•ç¼“å­˜
            public static readonly MethodInfo? InstantiateAsyncMethod = AccessTools.Method(ItemAssetsCollectionType, "InstantiateAsync", new[] { typeof(int) });
            public static readonly MethodInfo? CreateCharacterMethod = AccessTools.Method(CharacterCreatorType, "CreateCharacter");
            public static readonly MethodInfo? UnregisterMethod = SetActiveByPlayerDistanceType != null 
                ? AccessTools.Method(SetActiveByPlayerDistanceType, "Unregister", new[] { typeof(GameObject), typeof(int) }) 
                : null;
            public static readonly MethodInfo? GetActiveHealthBarMethod = AccessTools.Method(HealthBarManagerType, "GetActiveHealthBar");
        }

        public static object? CreateCharacterItem()
        {
            if (CachedReflection.ItemAssets == null || CachedReflection.InstantiateAsyncMethod == null)
            {
                UnityEngine.Debug.LogWarning("[CharacterCreationUtils] ç¼ºå°‘å¿…è¦çš„åå°„æˆå‘˜");
                return null;
            }

            object? itemAssets = CachedReflection.ItemAssets.GetValue(null);
            var defaultItemTypeProp = AccessTools.Property(itemAssets?.GetType(), "DefaultCharacterItemTypeID");
            int itemTypeID = (int)(defaultItemTypeProp?.GetValue(itemAssets) ?? 0);

            object? instantiateTask = CachedReflection.InstantiateAsyncMethod.Invoke(null, new object[] { itemTypeID });

            return instantiateTask != null ? UniTaskHelper.WaitForUniTaskSync(instantiateTask) : null;
        }

        public static object? GetCharacterModelPrefab()
        {
            if (CachedReflection.LevelManagerInstance == null || CachedReflection.CharacterModelField == null)
            {
                UnityEngine.Debug.LogWarning("[CharacterCreationUtils] ç¼ºå°‘å¿…è¦çš„åå°„æˆå‘˜");
                return null;
            }

            var levelManager = CachedReflection.LevelManagerInstance.GetValue(null);
            if (levelManager == null)
            {
                UnityEngine.Debug.LogWarning("[CharacterCreationUtils] LevelManager.Instance ä¸º nullï¼Œæ— æ³•è·å–è§’è‰²æ¨¡å‹é¢„åˆ¶ä½“");
                return null;
            }

            return CachedReflection.CharacterModelField.GetValue(levelManager);
        }

        public static object? CreateCharacterInstance(object characterItem, object modelPrefab, Vector3 position, Quaternion rotation)
        {
            if (CachedReflection.LevelManagerInstance == null || 
                CachedReflection.CharacterCreatorProp == null || 
                CachedReflection.CreateCharacterMethod == null)
            {
                UnityEngine.Debug.LogWarning("[CharacterCreationUtils] ç¼ºå°‘å¿…è¦çš„åå°„æˆå‘˜");
                return null;
            }

            var levelManager = CachedReflection.LevelManagerInstance.GetValue(null);
            if (levelManager == null)
            {
                UnityEngine.Debug.LogWarning("[CharacterCreationUtils] LevelManager.Instance ä¸º nullï¼Œæ— æ³•åˆ›å»ºè§’è‰²å®ä¾‹");
                return null;
            }

            var characterCreator = CachedReflection.CharacterCreatorProp.GetValue(levelManager);
            object? createTask = CachedReflection.CreateCharacterMethod.Invoke(characterCreator, new object[] { 
                characterItem, modelPrefab, position, rotation 
            });

            return createTask != null ? UniTaskHelper.WaitForUniTaskSync(createTask) : null;
        }

        public static void ConfigureCharacter(object character, string name, Vector3 position, int team)
        {
            Component? characterComponent = character as Component;
            if (characterComponent == null) return;

            characterComponent.gameObject.name = name;
            characterComponent.transform.position = position;

            // è®¾ç½®é˜Ÿä¼
            if (CachedReflection.TeamsType != null && team >= 0 && team <= 2)
            {
                string[] teamEnumNames = { "player", "scav", "middle" };
                object teamValue = Enum.Parse(CachedReflection.TeamsType, teamEnumNames[team]);
                var setTeamMethod = AccessTools.Method(character.GetType(), "SetTeam");
                setTeamMethod?.Invoke(character, new object[] { teamValue });
            }

            // åˆå§‹åŒ–è¡€é‡
            var healthProp = AccessTools.Property(character.GetType(), "Health");
            object? health = healthProp?.GetValue(character);
            if (health != null)
            {
                var initMethod = AccessTools.Method(health.GetType(), "Init", Type.EmptyTypes);
                initMethod?.Invoke(health, null);
            }
        }

        public static void ConfigureCharacterPreset(object character, string displayName, bool showName = true)
        {
            var charType = character.GetType();
            var characterPresetProp = AccessTools.Property(charType, "characterPreset");
            object? currentPreset = characterPresetProp?.GetValue(character);

            // å¦‚æœé¢„è®¾ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°çš„
            if (currentPreset == null && CachedReflection.CharacterRandomPresetType != null)
            {
                currentPreset = UnityEngine.ScriptableObject.CreateInstance(CachedReflection.CharacterRandomPresetType);
                characterPresetProp?.SetValue(character, currentPreset);
            }

            if (currentPreset == null) return;

            var presetType = currentPreset.GetType();
            
            // ä¸€æ¬¡æ€§è®¾ç½®æ‰€æœ‰å­—æ®µï¼ˆæ— éœ€é‡å¤éªŒè¯ï¼‰
            AccessTools.Field(presetType, "showHealthBar")?.SetValue(currentPreset, true);
            AccessTools.Field(presetType, "showName")?.SetValue(currentPreset, showName);
            AccessTools.Field(presetType, "nameKey")?.SetValue(currentPreset, displayName);
            
            // è®¾ç½®å›¾æ ‡ç±»å‹
            if (CachedReflection.CharacterIconTypesType != null)
            {
                AccessTools.Field(presetType, "characterIconType")?.SetValue(
                    currentPreset, 
                    Enum.Parse(CachedReflection.CharacterIconTypesType, "pmc")
                );
            }
        }

        /// <summary>
        /// æ ‡è®°è§’è‰²ä¸ºè¿œç¨‹ç©å®¶ - é€šè¿‡åç§°åç¼€è®© Movement è¡¥ä¸è¯†åˆ«å¹¶è·³è¿‡æ›´æ–°
        /// </summary>
        public static void MarkAsRemotePlayer(object character)
        {
            Component? characterComponent = character as Component;
            if (characterComponent == null)
            {
                UnityEngine.Debug.LogWarning("[CharacterCreationUtils] æ— æ³•æ ‡è®°è¿œç¨‹ç©å®¶: character ä¸æ˜¯ Component");
                return;
            }

            try
            {
                // ä½¿ç”¨åç§°åç¼€æ ‡è®°ï¼ˆé¿å… Tag æœªå®šä¹‰çš„é”™è¯¯ï¼‰
                if (!characterComponent.gameObject.name.Contains("[RemotePlayer]"))
                {
                    characterComponent.gameObject.name += " [RemotePlayer]";
                }
                UnityEngine.Debug.Log($"[CharacterCreationUtils] âœ… å·²æ ‡è®°ä¸ºè¿œç¨‹ç©å®¶: {characterComponent.gameObject.name}");
            }
            catch (System.Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCreationUtils] æ ‡è®°å¤±è´¥: {ex.Message}");
            }
        }


        /// <summary>
        /// ä»è·ç¦»ç®¡ç†ç³»ç»Ÿä¸­ç§»é™¤è§’è‰²ï¼ˆé˜²æ­¢è¿œç¨‹ç©å®¶è¢«è‡ªåŠ¨ç¦ç”¨ï¼‰
        /// </summary>
        public static void UnregisterFromDistanceSystem(object character)
        {
            Component? characterComponent = character as Component;
            if (characterComponent == null) return;

            if (CachedReflection.UnregisterMethod != null)
            {
                try
                {
                    int sceneBuildIndex = characterComponent.gameObject.scene.buildIndex;
                    CachedReflection.UnregisterMethod.Invoke(null, new object[] { characterComponent.gameObject, sceneBuildIndex });
                }
                catch (Exception ex)
                {
                    UnityEngine.Debug.LogError($"[CharacterCreationUtils] ä»è·ç¦»ç³»ç»Ÿç§»é™¤å¤±è´¥: {ex.Message}");
                }
            }
        }

        public static void RequestHealthBar(object character, string displayName, UnityEngine.Sprite? customIcon = null)
        {
            // å…ˆé…ç½®é¢„è®¾ï¼ˆHealthBar ä¼šä»é¢„è®¾ä¸­è¯»å–åç§°ï¼‰
            ConfigureCharacterPreset(character, displayName, showName: true);

            var healthProp = AccessTools.Property(character.GetType(), "Health");
            object? health = healthProp?.GetValue(character);
            
            if (health != null)
            {
                var showHealthBarProp = AccessTools.Property(health.GetType(), "showHealthBar");
                showHealthBarProp?.SetValue(health, true);

                var requestMethod = AccessTools.Method(health.GetType(), "RequestHealthBar", Type.EmptyTypes);
                requestMethod?.Invoke(health, null);
                
                // å¦‚æœéœ€è¦è‡ªå®šä¹‰å›¾æ ‡ï¼Œå»¶è¿Ÿè®¾ç½®ï¼ˆç­‰å¾… HealthBar åˆ›å»ºï¼‰
                if (customIcon != null && health is UnityEngine.MonoBehaviour mb)
                {
                    mb.StartCoroutine(SetHealthBarIconDelayed(health, customIcon));
                }
            }
        }

        private static System.Collections.IEnumerator SetHealthBarIconDelayed(object health, UnityEngine.Sprite customIcon)
        {
            yield return null; // ç­‰å¾…ä¸€å¸§ï¼Œè®© HealthBar åˆ›å»ºå®Œæˆ
            
            if (CachedReflection.HealthBarManagerInstance == null || CachedReflection.GetActiveHealthBarMethod == null)
            {
                yield break;
            }
            
            object? healthBarManager = CachedReflection.HealthBarManagerInstance.GetValue(null);
            if (healthBarManager == null) yield break;
            
            object? healthBar = CachedReflection.GetActiveHealthBarMethod.Invoke(healthBarManager, new object[] { health });
            if (healthBar != null)
            {
                SetHealthBarIcon(healthBar, customIcon);
            }
        }

        private static void SetHealthBarIcon(object healthBar, UnityEngine.Sprite? customIcon)
        {
            var levelIconField = AccessTools.Field(healthBar.GetType(), "levelIcon");
            object? levelIcon = levelIconField?.GetValue(healthBar);
            
            if (levelIcon == null) return;
            
            // å¦‚æœæœ‰è‡ªå®šä¹‰å›¾æ ‡ï¼Œä½¿ç”¨è‡ªå®šä¹‰å›¾æ ‡
            if (customIcon != null)
            {
                var spriteProp = AccessTools.Property(levelIcon.GetType(), "sprite");
                if (spriteProp != null && spriteProp.CanWrite)
                {
                    spriteProp.SetValue(levelIcon, customIcon);
                    UnityEngine.Debug.Log("[CharacterCreationUtils] è®¾ç½®è‡ªå®šä¹‰å›¾æ ‡");
                }
                
                var iconGameObjectProp = AccessTools.Property(levelIcon.GetType(), "gameObject");
                object? iconGameObject = iconGameObjectProp?.GetValue(levelIcon);
                if (iconGameObject != null)
                {
                    var setActiveMethod = AccessTools.Method(iconGameObject.GetType(), "SetActive");
                    setActiveMethod?.Invoke(iconGameObject, new object[] { true });
                    UnityEngine.Debug.Log("[CharacterCreationUtils] æ¿€æ´» HealthBar.levelIcon");
                }
            }
            else
            {
                // æ²¡æœ‰è‡ªå®šä¹‰å›¾æ ‡ï¼Œéšè—å›¾æ ‡
                var iconGameObjectProp = AccessTools.Property(levelIcon.GetType(), "gameObject");
                object? iconGameObject = iconGameObjectProp?.GetValue(levelIcon);
                if (iconGameObject != null)
                {
                    var setActiveMethod = AccessTools.Method(iconGameObject.GetType(), "SetActive");
                    setActiveMethod?.Invoke(iconGameObject, new object[] { false });
                    UnityEngine.Debug.Log("[CharacterCreationUtils] éšè— HealthBar.levelIcon (æ— è‡ªå®šä¹‰å›¾æ ‡)");
                }
            }
        }

        public static UnityEngine.Sprite? GetLocalPlayerIcon()
        {
            try
            {
                // å°è¯•ä» GameContext è·å–æœ¬åœ°ç©å®¶çš„ Steam å¤´åƒ
                if (GameContext.IsInitialized)
                {
                    var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                    if (localPlayer?.AvatarTexture != null)
                    {
                        var texture = localPlayer.AvatarTexture;
                        return UnityEngine.Sprite.Create(
                            texture,
                            new UnityEngine.Rect(0, 0, texture.width, texture.height),
                            new UnityEngine.Vector2(0.5f, 0.5f)
                        );
                    }
                }
                
                // å¤‡é€‰ï¼šä½¿ç”¨æœ¬åœ°ç©å®¶çš„è§’è‰²é¢„è®¾å›¾æ ‡
                if (CachedReflection.LevelManagerInstance != null && CachedReflection.MainCharacter != null)
                {
                    var levelManager = CachedReflection.LevelManagerInstance.GetValue(null);
                    if (levelManager != null)
                    {
                        var mainChar = CachedReflection.MainCharacter.GetValue(levelManager);
                        if (mainChar != null)
                        {
                            var preset = AccessTools.Property(mainChar.GetType(), "characterPreset")?.GetValue(mainChar);
                            if (preset != null)
                            {
                                return AccessTools.Method(preset.GetType(), "GetCharacterIcon")?.Invoke(preset, null) as UnityEngine.Sprite;
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogWarning($"[CharacterCreationUtils] è·å–å›¾æ ‡å¤±è´¥: {ex.Message}");
            }
            
            return null;
        }

        /// <summary>
        /// ç»Ÿä¸€çš„è§’è‰²åˆ›å»ºå’Œé…ç½®æ–¹æ³•
        /// </summary>
        public static object? CreateAndConfigureCharacter(
            Vector3 position, 
            Quaternion rotation, 
            string displayName, 
            int team = 0,
            bool isRemotePlayer = true)
        {
            var characterItem = CreateCharacterItem();
            if (characterItem == null)
            {
                UnityEngine.Debug.LogError("[CharacterCreationUtils] åˆ›å»ºè§’è‰²ç‰©å“å¤±è´¥");
                return null;
            }

            var modelPrefab = GetCharacterModelPrefab();
            if (modelPrefab == null)
            {
                UnityEngine.Debug.LogError("[CharacterCreationUtils] è·å–è§’è‰²æ¨¡å‹å¤±è´¥");
                return null;
            }

            var character = CreateCharacterInstance(characterItem, modelPrefab, position, rotation);
            if (character == null)
            {
                UnityEngine.Debug.LogError("[CharacterCreationUtils] åˆ›å»ºè§’è‰²å®ä¾‹å¤±è´¥");
                return null;
            }

            // æŒ‰æ­£ç¡®é¡ºåºé…ç½®
            ConfigureCharacterPreset(character, displayName, showName: true);
            ConfigureCharacter(character, displayName, position, team);
            
            if (isRemotePlayer)
            {
                MarkAsRemotePlayer(character);
                UnregisterFromDistanceSystem(character);
            }
            
            RequestHealthBar(character, displayName);

            return character;
        }

        /// <summary>
        /// åº”ç”¨è‡ªå®šä¹‰å¤–è§‚æ•°æ®åˆ°è§’è‰²
        /// </summary>
        /// <param name="character">è§’è‰²å¯¹è±¡ï¼ˆCharacterMainControl æˆ–ç±»ä¼¼ç±»å‹ï¼‰</param>
        /// <param name="faceData">CustomFaceSettingData å¤–è§‚æ•°æ®</param>
        /// <returns>æˆåŠŸè¿”å› true</returns>
        public static bool ApplyCustomFace(object character, object faceData)
        {
            try
            {
                if (character == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCreationUtils] character ä¸ºç©º");
                    return false;
                }

                if (faceData == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCreationUtils] faceData ä¸ºç©º");
                    return false;
                }

                // é€šè¿‡å­—æ®µè·å– CharacterModelï¼ˆå­—æ®µæ˜¯æ­£ç¡®çš„æ–¹å¼ï¼‰
                var characterModelField = AccessTools.Field(character.GetType(), "characterModel");
                var characterModel = characterModelField?.GetValue(character);
                
                if (characterModel == null)
                {
                    UnityEngine.Debug.LogWarning("[CharacterCreationUtils] CharacterModel ä¸ºç©º");
                    return false;
                }

                // è°ƒç”¨ SetFaceFromData æ–¹æ³•åº”ç”¨å¤–è§‚
                var setFaceMethod = AccessTools.Method(characterModel.GetType(), "SetFaceFromData");
                if (setFaceMethod != null)
                {
                    setFaceMethod.Invoke(characterModel, new object[] { faceData });
                    UnityEngine.Debug.Log("[CharacterCreationUtils] æˆåŠŸåº”ç”¨å¤–è§‚æ•°æ®");
                    return true;
                }
                else
                {
                    UnityEngine.Debug.LogWarning("[CharacterCreationUtils] æœªæ‰¾åˆ° SetFaceFromData æ–¹æ³•");
                    return false;
                }
            }
            catch (System.Exception ex)
            {
                UnityEngine.Debug.LogError($"[CharacterCreationUtils] åº”ç”¨å¤–è§‚å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }
    }
}
```

`Client\Core\Utils\EquipmentTools.cs`:

```cs
using System;
using System.Collections;
using ItemStatsSystem;
using ItemStatsSystem.Items;
using UnityEngine;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// è£…å¤‡å·¥å…·ç±» - æä¾›åˆ›å»ºå’Œè£…å¤‡ç‰©å“çš„ä¾¿æ·æ–¹æ³•
    /// </summary>
    public static class EquipmentTools
    {
        /// <summary>
        /// åˆ›å»ºç‰©å“å¹¶è£…å¤‡åˆ°æŒ‡å®šæ§½ä½ï¼ˆåŒæ­¥ç‰ˆæœ¬ - ä½¿ç”¨ InstantiateSyncï¼‰
        /// </summary>
        /// <param name="itemTypeId">ç‰©å“ç±»å‹ID</param>
        /// <param name="targetSlot">ç›®æ ‡æ§½ä½</param>
        /// <param name="handleUnplugged">å¦‚ä½•å¤„ç†è¢«æ›¿æ¢çš„ç‰©å“ï¼ˆnull=é”€æ¯ï¼Œå¦åˆ™è°ƒç”¨å›è°ƒï¼‰</param>
        /// <returns>æ˜¯å¦æˆåŠŸè£…å¤‡</returns>
        public static bool CreateAndEquip(
            int itemTypeId, 
            Slot targetSlot, 
            Action<Item>? handleUnplugged = null)
        {
            if (targetSlot == null)
            {
                Debug.LogError("[EquipmentTools] ç›®æ ‡æ§½ä½ä¸ºç©º");
                return false;
            }

            try
            {
                // 1. åˆ›å»ºç‰©å“å®ä¾‹ï¼ˆåŒæ­¥ï¼‰
                Item newItem = ItemAssetsCollection.InstantiateSync(itemTypeId);
                if (newItem == null)
                {
                    Debug.LogError($"[EquipmentTools] åˆ›å»ºç‰©å“å¤±è´¥ - TypeID={itemTypeId}");
                    return false;
                }

                // 2. æ’å…¥æ§½ä½
                bool success = targetSlot.Plug(newItem, out Item unpluggedItem);

                if (success)
                {
                    Debug.Log($"[EquipmentTools] âœ… æˆåŠŸè£…å¤‡ç‰©å“: {newItem.DisplayName} åˆ°æ§½ä½ {targetSlot.Key}");

                    // å¤„ç†è¢«æ›¿æ¢çš„ç‰©å“
                    if (unpluggedItem != null)
                    {
                        Debug.Log($"[EquipmentTools] æ§½ä½ä¸­åŸæœ‰ç‰©å“è¢«æ›¿æ¢: {unpluggedItem.DisplayName}");
                        
                        if (handleUnplugged != null)
                        {
                            handleUnplugged(unpluggedItem);
                        }
                        else
                        {
                            // é»˜è®¤ï¼šé”€æ¯è¢«æ›¿æ¢çš„ç‰©å“
                            unpluggedItem.DestroyTree();
                        }
                    }

                    return true;
                }
                else
                {
                    Debug.LogError($"[EquipmentTools] âŒ è£…å¤‡ç‰©å“å¤±è´¥ - å¯èƒ½ä¸ç¬¦åˆæ§½ä½è¦æ±‚");
                    newItem.DestroyTree();
                    return false;
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentTools] è£…å¤‡ç‰©å“æ—¶å‘ç”Ÿå¼‚å¸¸: {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }

        /// <summary>
        /// ä¸ºè§’è‰²è£…å¤‡ç‰©å“åˆ°æŒ‡å®šæ§½ä½ï¼ˆé€šè¿‡æ§½ä½Keyï¼‰
        /// </summary>
        public static bool EquipToCharacter(
            int itemTypeId,
            Item characterItem,
            string slotKey,
            Action<Item>? handleUnplugged = null)
        {
            if (characterItem == null)
            {
                Debug.LogError("[EquipmentTools] è§’è‰²ç‰©å“ä¸ºç©º");
                return false;
            }

            Slot targetSlot = characterItem.Slots[slotKey];
            if (targetSlot == null)
            {
                Debug.LogError($"[EquipmentTools] æ§½ä½ä¸å­˜åœ¨: {slotKey}");
                return false;
            }

            return CreateAndEquip(itemTypeId, targetSlot, handleUnplugged);
        }

        /// <summary>
        /// ä¸ºè§’è‰²è£…å¤‡ç‰©å“åˆ°æŒ‡å®šæ§½ä½ï¼ˆé€šè¿‡æ§½ä½Hashï¼‰
        /// </summary>
        public static bool EquipToCharacter(
            int itemTypeId,
            Item characterItem,
            int slotHash,
            Action<Item>? handleUnplugged = null)
        {
            if (characterItem == null)
            {
                Debug.LogError("[EquipmentTools] è§’è‰²ç‰©å“ä¸ºç©º");
                return false;
            }

            Slot targetSlot = characterItem.Slots.GetSlot(slotHash);
            if (targetSlot == null)
            {
                Debug.LogError($"[EquipmentTools] æ§½ä½ä¸å­˜åœ¨: Hash={slotHash}");
                return false;
            }

            return CreateAndEquip(itemTypeId, targetSlot, handleUnplugged);
        }

        /// <summary>
        /// å¤åˆ¶æ§½ä½å†…å®¹åˆ°å¦ä¸€ä¸ªæ§½ä½
        /// </summary>
        public static bool CopySlotContent(Slot sourceSlot, Slot targetSlot)
        {
            if (sourceSlot == null || targetSlot == null)
            {
                Debug.LogError("[EquipmentTools] æºæ§½ä½æˆ–ç›®æ ‡æ§½ä½ä¸ºç©º");
                return false;
            }

            if (sourceSlot.Content == null)
            {
                Debug.Log("[EquipmentTools] æºæ§½ä½ä¸ºç©ºï¼Œæ— éœ€å¤åˆ¶");
                return true;
            }

            // è·å–æºç‰©å“çš„ TypeID
            int itemTypeId = sourceSlot.Content.TypeID;
            
            // åˆ›å»ºç›¸åŒç±»å‹çš„æ–°ç‰©å“å¹¶è£…å¤‡
            return CreateAndEquip(itemTypeId, targetSlot);
        }

        /// <summary>
        /// å¤åˆ¶è§’è‰²çš„æ‰€æœ‰è£…å¤‡æ§½ä½åˆ°å¦ä¸€ä¸ªè§’è‰²
        /// </summary>
        public static int CopyAllEquipment(
            Item sourceCharacter, 
            Item targetCharacter,
            bool includeArmor = true,
            bool includeHelmet = true,
            bool includeFaceMask = true,
            bool includeBackpack = true,
            bool includeHeadset = true)
        {
            if (sourceCharacter == null || targetCharacter == null)
            {
                Debug.LogError("[EquipmentTools] æºè§’è‰²æˆ–ç›®æ ‡è§’è‰²ä¸ºç©º");
                return 0;
            }

            int successCount = 0;

            try
            {
                // æŠ¤ç”²
                if (includeArmor)
                {
                    var sourceSlot = sourceCharacter.Slots.GetSlot(CharacterEquipmentController.armorHash);
                    var targetSlot = targetCharacter.Slots.GetSlot(CharacterEquipmentController.armorHash);
                    if (CopySlotContent(sourceSlot, targetSlot))
                    {
                        successCount++;
                    }
                }

                // å¤´ç›”
                if (includeHelmet)
                {
                    var sourceSlot = sourceCharacter.Slots.GetSlot(CharacterEquipmentController.helmatHash);
                    var targetSlot = targetCharacter.Slots.GetSlot(CharacterEquipmentController.helmatHash);
                    if (CopySlotContent(sourceSlot, targetSlot))
                    {
                        successCount++;
                    }
                }

                // é¢ç½©
                if (includeFaceMask)
                {
                    var sourceSlot = sourceCharacter.Slots.GetSlot(CharacterEquipmentController.faceMaskHash);
                    var targetSlot = targetCharacter.Slots.GetSlot(CharacterEquipmentController.faceMaskHash);
                    if (CopySlotContent(sourceSlot, targetSlot))
                    {
                        successCount++;
                    }
                }

                // èƒŒåŒ…
                if (includeBackpack)
                {
                    var sourceSlot = sourceCharacter.Slots.GetSlot(CharacterEquipmentController.backpackHash);
                    var targetSlot = targetCharacter.Slots.GetSlot(CharacterEquipmentController.backpackHash);
                    if (CopySlotContent(sourceSlot, targetSlot))
                    {
                        successCount++;
                    }
                }

                // è€³æœº
                if (includeHeadset)
                {
                    var sourceSlot = sourceCharacter.Slots.GetSlot(CharacterEquipmentController.headsetHash);
                    var targetSlot = targetCharacter.Slots.GetSlot(CharacterEquipmentController.headsetHash);
                    if (CopySlotContent(sourceSlot, targetSlot))
                    {
                        successCount++;
                    }
                }

                Debug.Log($"[EquipmentTools] âœ… è£…å¤‡å¤åˆ¶å®Œæˆ: {successCount} ä¸ªæ§½ä½");
                return successCount;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentTools] å¤åˆ¶è£…å¤‡æ—¶å‘ç”Ÿå¼‚å¸¸: {ex.Message}\n{ex.StackTrace}");
                return successCount;
            }
        }

        /// <summary>
        /// è·å–è§’è‰²æŒ‡å®šæ§½ä½çš„ç‰©å“TypeID
        /// </summary>
        public static int? GetEquipmentTypeId(Item characterItem, int slotHash)
        {
            if (characterItem == null) return null;

            var slot = characterItem.Slots.GetSlot(slotHash);
            return slot?.Content?.TypeID;
        }

        /// <summary>
        /// æ£€æŸ¥æ§½ä½æ˜¯å¦ä¸ºç©º
        /// </summary>
        public static bool IsSlotEmpty(Item characterItem, int slotHash)
        {
            if (characterItem == null) return true;

            var slot = characterItem.Slots.GetSlot(slotHash);
            return slot?.Content == null;
        }

        /// <summary>
        /// å¸ä¸‹è£…å¤‡ï¼ˆç§»é™¤æ§½ä½ä¸­çš„ç‰©å“ï¼‰
        /// ä½¿ç”¨ Slot.Unplug() æ–¹æ³•æ­£ç¡®ç§»é™¤è£…å¤‡
        /// </summary>
        /// <param name="characterItem">è§’è‰²ç‰©å“</param>
        /// <param name="slotHash">æ§½ä½Hash</param>
        /// <returns>è¢«ç§»é™¤çš„ç‰©å“ï¼ˆå¦‚æœæ§½ä½ä¸ºç©ºåˆ™è¿”å›nullï¼‰</returns>
        public static Item? UnequipSlot(Item characterItem, int slotHash)
        {
            if (characterItem == null) return null;

            var slot = characterItem.Slots.GetSlot(slotHash);
            if (slot == null)
            {
                Debug.LogWarning($"[EquipmentTools] æ§½ä½ä¸å­˜åœ¨: Hash={slotHash}");
                return null;
            }

            if (slot.Content == null)
            {
                Debug.Log($"[EquipmentTools] æ§½ä½å·²ç»ä¸ºç©º: {slot.Key}");
                return null;
            }

            // ä½¿ç”¨ Unplug() æ–¹æ³•ç§»é™¤è£…å¤‡
            // è¿™ä¼šè§¦å‘ onSlotContentChanged äº‹ä»¶ï¼Œæ‚¨çš„è¡¥ä¸ä¼šæ•è·åˆ°
            Item removedItem = slot.Unplug();
            
            if (removedItem != null)
            {
                Debug.Log($"[EquipmentTools] âœ… å¸ä¸‹è£…å¤‡: {removedItem.DisplayName} (ä»æ§½ä½ {slot.Key})");
            }
            
            return removedItem;
        }

        /// <summary>
        /// å¸ä¸‹è£…å¤‡å¹¶é”€æ¯
        /// </summary>
        public static bool UnequipAndDestroy(Item characterItem, int slotHash)
        {
            var removedItem = UnequipSlot(characterItem, slotHash);
            if (removedItem != null)
            {
                removedItem.DestroyTree();
                Debug.Log($"[EquipmentTools] è£…å¤‡å·²é”€æ¯: {removedItem.DisplayName}");
                return true;
            }
            return false;
        }

        /// <summary>
        /// æ¸…ç©ºæ‰€æœ‰è£…å¤‡æ§½ä½
        /// </summary>
        public static int ClearAllEquipment(Item characterItem, bool destroyItems = true)
        {
            if (characterItem == null) return 0;

            int count = 0;
            int[] slotHashes = new[]
            {
                CharacterEquipmentController.armorHash,
                CharacterEquipmentController.helmatHash,
                CharacterEquipmentController.faceMaskHash,
                CharacterEquipmentController.backpackHash,
                CharacterEquipmentController.headsetHash
            };

            foreach (var hash in slotHashes)
            {
                var item = UnequipSlot(characterItem, hash);
                if (item != null)
                {
                    if (destroyItems)
                    {
                        item.DestroyTree();
                    }
                    count++;
                }
            }

            Debug.Log($"[EquipmentTools] æ¸…ç©ºè£…å¤‡å®Œæˆ: {count} ä¸ªæ§½ä½");
            return count;
        }
    }
}


```

`Client\Core\Utils\KalmanMotionPredictor.cs`:

```cs
using System;
using UnityEngine;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// å¡å°”æ›¼æ»¤æ³¢è¿åŠ¨é¢„æµ‹å™¨ - æ€§èƒ½ä¼˜å¼‚çš„AIé¢„æµ‹ç®—æ³•
    /// 
    /// ä¼˜åŠ¿:
    /// 1. è®¡ç®—é‡æä½ (ä»…çŸ©é˜µè¿ç®—,æ— éœ€è®­ç»ƒ)
    /// 2. è‡ªé€‚åº”å™ªå£°(è‡ªåŠ¨é€‚åº”ç½‘ç»œæŠ–åŠ¨)
    /// 3. å¹³æ»‘æ•ˆæœå¥½(æ¯”çº¿æ€§æ’å€¼æ›´è‡ªç„¶)
    /// 4. å®æ—¶æ€§å¼º(å•å¸§é¢„æµ‹ < 0.1ms)
    /// </summary>
    public class KalmanMotionPredictor
    {
        // å¡å°”æ›¼æ»¤æ³¢å™¨ - 3ä¸ªç‹¬ç«‹æ»¤æ³¢å™¨(é€Ÿåº¦, Xæ–¹å‘, Yæ–¹å‘)
        private KalmanFilter1D _velocityFilter;
        private KalmanFilter1D _dirXFilter;
        private KalmanFilter1D _dirYFilter;
        
        // å†å²åŠ é€Ÿåº¦(ç”¨äºäºŒé˜¶é¢„æµ‹)
        private float _lastVelocity;
        private float _lastDirX;
        private float _lastDirY;
        private double _lastTimestamp;
        
        // é…ç½®å‚æ•°
        public float ProcessNoise { get; set; } = 0.01f;  // è¿‡ç¨‹å™ªå£°(è¿åŠ¨æ¨¡å‹ä¸ç¡®å®šæ€§)
        public float MeasurementNoise { get; set; } = 0.1f; // æµ‹é‡å™ªå£°(ç½‘ç»œæŠ–åŠ¨)
        public float MaxPredictionTime { get; set; } = 0.3f;
        
        public KalmanMotionPredictor()
        {
            _velocityFilter = new KalmanFilter1D(ProcessNoise, MeasurementNoise);
            _dirXFilter = new KalmanFilter1D(ProcessNoise, MeasurementNoise);
            _dirYFilter = new KalmanFilter1D(ProcessNoise, MeasurementNoise);
        }
        
        /// <summary>
        /// æ›´æ–°æ»¤æ³¢å™¨(æ¯æ¬¡æ”¶åˆ°æ–°æ•°æ®æ—¶è°ƒç”¨)
        /// </summary>
        public void Update(float velocity, float dirX, float dirY, double timestamp)
        {
            // æ›´æ–°å¡å°”æ›¼æ»¤æ³¢å™¨
            _velocityFilter.Update(velocity);
            _dirXFilter.Update(dirX);
            _dirYFilter.Update(dirY);
            
            // è®°å½•å†å²(ç”¨äºè®¡ç®—åŠ é€Ÿåº¦)
            _lastVelocity = velocity;
            _lastDirX = dirX;
            _lastDirY = dirY;
            _lastTimestamp = timestamp;
        }
        
        /// <summary>
        /// é¢„æµ‹æœªæ¥çŠ¶æ€(å¸¦åŠ é€Ÿåº¦è¡¥å¿)
        /// </summary>
        public AnimationFrame Predict(AnimationFrame lastFrame, float deltaTime)
        {
            // é™åˆ¶é¢„æµ‹æ—¶é—´
            deltaTime = Mathf.Min(deltaTime, MaxPredictionTime);
            
            // è·å–æ»¤æ³¢åçš„å½“å‰çŠ¶æ€
            float filteredVel = _velocityFilter.GetEstimate();
            float filteredX = _dirXFilter.GetEstimate();
            float filteredY = _dirYFilter.GetEstimate();
            
            // ä¼°ç®—åŠ é€Ÿåº¦(ä¸€é˜¶å¯¼æ•°)
            float velAccel = _velocityFilter.GetVelocity();
            float xAccel = _dirXFilter.GetVelocity();
            float yAccel = _dirYFilter.GetVelocity();
            
            // äºŒé˜¶é¢„æµ‹: position = current + velocity*dt + 0.5*accel*dt^2
            float predictedVel = filteredVel + velAccel * deltaTime;
            float predictedX = filteredX + xAccel * deltaTime;
            float predictedY = filteredY + yAccel * deltaTime;
            
            // åº”ç”¨é˜»å°¼(æ¨¡æ‹Ÿæ‘©æ“¦åŠ›)
            float dampingFactor = Mathf.Exp(-deltaTime * 2f);
            predictedVel *= dampingFactor;
            
            // å½’ä¸€åŒ–æ–¹å‘å‘é‡
            float dirMagnitude = Mathf.Sqrt(predictedX * predictedX + predictedY * predictedY);
            if (dirMagnitude > 0.01f)
            {
                predictedX /= dirMagnitude;
                predictedY /= dirMagnitude;
            }
            
            return new AnimationFrame
            {
                Timestamp = lastFrame.Timestamp + deltaTime,
                MoveSpeed = Mathf.Max(0, predictedVel),
                MoveDirX = Mathf.Clamp(predictedX, -1f, 1f),
                MoveDirY = Mathf.Clamp(predictedY, -1f, 1f),
                IsDashing = lastFrame.IsDashing,
                IsGunReady = lastFrame.IsGunReady,
                IsReloading = lastFrame.IsReloading,
                IsDead = lastFrame.IsDead,
                HandState = lastFrame.HandState,
                AttackIndex = lastFrame.AttackIndex,
                StateHash = lastFrame.StateHash,
                NormalizedTime = lastFrame.NormalizedTime
            };
        }
        
        /// <summary>
        /// è·å–é¢„æµ‹ç½®ä¿¡åº¦(0-1)
        /// </summary>
        public float GetConfidence()
        {
            // åŸºäºä¼°è®¡åæ–¹å·®(è¶Šå°è¶Šå¯ä¿¡)
            float avgUncertainty = (_velocityFilter.GetUncertainty() + 
                                   _dirXFilter.GetUncertainty() + 
                                   _dirYFilter.GetUncertainty()) / 3f;
            
            return 1f / (1f + avgUncertainty * 10f);
        }
        
        public void Reset()
        {
            _velocityFilter.Reset();
            _dirXFilter.Reset();
            _dirYFilter.Reset();
            _lastVelocity = 0;
            _lastDirX = 0;
            _lastDirY = 0;
            _lastTimestamp = 0;
        }
    }
    
    /// <summary>
    /// ä¸€ç»´å¡å°”æ›¼æ»¤æ³¢å™¨
    /// </summary>
    internal class KalmanFilter1D
    {
        // çŠ¶æ€å˜é‡
        private float _estimate;      // çŠ¶æ€ä¼°è®¡å€¼ (xÌ‚)
        private float _velocity;      // é€Ÿåº¦ä¼°è®¡ (vÌ‚)
        private float _errorCovariance; // ä¼°è®¡è¯¯å·®åæ–¹å·® (P)
        
        // å™ªå£°å‚æ•°
        private readonly float _processNoise;     // Q - è¿‡ç¨‹å™ªå£°
        private readonly float _measurementNoise; // R - æµ‹é‡å™ªå£°
        
        public KalmanFilter1D(float processNoise, float measurementNoise)
        {
            _processNoise = processNoise;
            _measurementNoise = measurementNoise;
            _errorCovariance = 1f; // åˆå§‹ä¸ç¡®å®šæ€§
        }
        
        /// <summary>
        /// åˆå§‹åŒ–æ»¤æ³¢å™¨çŠ¶æ€
        /// </summary>
        public void Initialize(float initialValue)
        {
            _estimate = initialValue;
            _velocity = 0;
            _errorCovariance = 0.1f; // è¾ƒä½çš„åˆå§‹ä¸ç¡®å®šæ€§
        }
        
        /// <summary>
        /// æ›´æ–°æ»¤æ³¢å™¨(æ”¶åˆ°æ–°æµ‹é‡å€¼æ—¶è°ƒç”¨)
        /// </summary>
        public void Update(float measurement)
        {
            // é¢„æµ‹æ­¥éª¤
            float predictedEstimate = _estimate + _velocity * Time.deltaTime;
            float predictedCovariance = _errorCovariance + _processNoise;
            
            // æ›´æ–°æ­¥éª¤(å¡å°”æ›¼å¢ç›Š)
            float kalmanGain = predictedCovariance / (predictedCovariance + _measurementNoise);
            
            // ä¿®æ­£ä¼°è®¡
            _estimate = predictedEstimate + kalmanGain * (measurement - predictedEstimate);
            _errorCovariance = (1 - kalmanGain) * predictedCovariance;
            
            // æ›´æ–°é€Ÿåº¦(ä¸€é˜¶å¯¼æ•°)
            _velocity = (measurement - predictedEstimate) / Mathf.Max(Time.deltaTime, 0.001f);
        }
        
        public float GetEstimate() => _estimate;
        public float GetVelocity() => _velocity;
        public float GetUncertainty() => _errorCovariance;
        
        public void Reset()
        {
            _estimate = 0;
            _velocity = 0;
            _errorCovariance = 1f;
        }
    }
}

```

`Client\Core\Utils\UniTaskHelper.cs`:

```cs
using System;
using System.Reflection;
using UnityEngine;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// UniTask è¾…åŠ©å·¥å…· - å¤„ç† UniTask å¼‚æ­¥ä»»åŠ¡çš„ç­‰å¾…
    /// </summary>
    public static class UniTaskHelper
    {
        /// <summary>
        /// ç­‰å¾… UniTask å®Œæˆ
        /// </summary>
        public static async System.Threading.Tasks.Task WaitForUniTask(object uniTask)
        {
            try
            {
                var resultType = uniTask.GetType();

                // è·å– GetAwaiter() æ–¹æ³•
                var getAwaiterMethod = resultType.GetMethod("GetAwaiter", BindingFlags.Public | BindingFlags.Instance);
                if (getAwaiterMethod == null)
                {
                    UnityEngine.Debug.LogError("[UniTaskHelper] æ‰¾ä¸åˆ° GetAwaiter() æ–¹æ³•");
                    return;
                }

                var awaiter = getAwaiterMethod.Invoke(uniTask, null);
                if (awaiter == null)
                {
                    UnityEngine.Debug.LogError("[UniTaskHelper] GetAwaiter() è¿”å› null");
                    return;
                }

                var awaiterType = awaiter.GetType();

                // è·å– IsCompleted å±æ€§å’Œ GetResult æ–¹æ³•
                var isCompletedProp = awaiterType.GetProperty("IsCompleted");
                var getResultMethod = awaiterType.GetMethod("GetResult");

                if (isCompletedProp == null || getResultMethod == null)
                {
                    UnityEngine.Debug.LogError("[UniTaskHelper] æ‰¾ä¸åˆ° IsCompleted æˆ– GetResult");
                    return;
                }

                // è½®è¯¢ç­‰å¾…å®Œæˆ
                int maxWaitMs = 30000; // æœ€å¤šç­‰å¾…30ç§’
                int elapsedMs = 0;
                int pollIntervalMs = 50;

                while (!(bool)isCompletedProp.GetValue(awaiter))
                {
                    await System.Threading.Tasks.Task.Delay(pollIntervalMs);
                    elapsedMs += pollIntervalMs;

                    if (elapsedMs >= maxWaitMs)
                    {
                        UnityEngine.Debug.LogError("[UniTaskHelper] ç­‰å¾… UniTask å®Œæˆè¶…æ—¶");
                        return;
                    }
                }

                // è°ƒç”¨ GetResult() ç¡®ä¿ä»»åŠ¡å®Œæˆï¼ˆå³ä½¿æ— è¿”å›å€¼ï¼‰
                getResultMethod.Invoke(awaiter, null);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[UniTaskHelper] WaitForUniTask å¼‚å¸¸: {ex.Message}");
                UnityEngine.Debug.LogException(ex);
            }
        }

        /// <summary>
        /// åŒæ­¥ç­‰å¾… UniTaskï¼ˆé˜»å¡è°ƒç”¨ï¼‰
        /// </summary>
        public static object? WaitForUniTaskSync(object uniTask)
        {
            try
            {
                var resultType = uniTask.GetType();
                var getAwaiterMethod = resultType.GetMethod("GetAwaiter", BindingFlags.Public | BindingFlags.Instance);
                if (getAwaiterMethod == null) return null;

                var awaiter = getAwaiterMethod.Invoke(uniTask, null);
                if (awaiter == null) return null;

                var awaiterType = awaiter.GetType();
                var isCompletedProp = awaiterType.GetProperty("IsCompleted");
                var getResultMethod = awaiterType.GetMethod("GetResult");

                if (isCompletedProp == null || getResultMethod == null) return null;

                // å¦‚æœå·²å®Œæˆï¼Œç›´æ¥è¿”å›ç»“æœ
                if ((bool)isCompletedProp.GetValue(awaiter))
                {
                    return getResultMethod.Invoke(awaiter, null);
                }

                // å¦‚æœæœªå®Œæˆï¼Œè½®è¯¢ç­‰å¾…ï¼ˆé˜»å¡ï¼‰
                while (!(bool)isCompletedProp.GetValue(awaiter))
                {
                    System.Threading.Thread.Sleep(50);
                }

                return getResultMethod.Invoke(awaiter, null);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[UniTaskHelper] WaitForUniTaskSync å¼‚å¸¸: {ex.Message}");
                return null;
            }
        }
    }
}


```

`Client\Core\Utils\WeaponEffectsCore.cs`:

```cs
using System;
using System.Reflection;
using UnityEngine;
using HarmonyLib;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// æ­¦å™¨ç‰¹æ•ˆæ ¸å¿ƒç±» - æä¾›å…±äº«çš„åå°„ç¼“å­˜å’Œé€šç”¨ç‰¹æ•ˆæ’­æ”¾é€»è¾‘
    /// é¿å… WeaponEffectsPlayer å’Œ WeaponFireEffectsPlayer çš„ä»£ç é‡å¤
    /// </summary>
    public static class WeaponEffectsCore
    {
        #region åå°„ç±»å‹ç¼“å­˜
        
        private static Type? _characterMainControlType;
        private static Type? _itemAgentGunType;
        private static Type? _itemSettingGunType;
        private static Type? _levelManagerType;
        private static Type? _audioManagerType;
        private static Type? _gameplayDataSettingsType;

        private static PropertyInfo? _gunItemSettingProperty;
        private static PropertyInfo? _muzzleProperty;
        private static PropertyInfo? _silencedProperty;
        private static PropertyInfo? _bulletSpeedProperty;
        private static PropertyInfo? _bulletDistanceProperty;
        
        private static FieldInfo? _muzzleFxPfbField;
        private static FieldInfo? _shellParticleField;
        private static FieldInfo? _shootKeyField;
        private static FieldInfo? _bulletPfbField;
        
        private static PropertyInfo? _prefabsProperty;
        private static FieldInfo? _defaultBulletField;
        
        private static MethodInfo? _audioManagerPostMethod;

        private static bool _initialized = false;

        #endregion

        /// <summary>
        /// åˆå§‹åŒ–åå°„ç¼“å­˜
        /// </summary>
        public static void Initialize()
        {
            if (_initialized) return;

            try
            {
                // ç¼“å­˜ç±»å‹
                _characterMainControlType = AccessTools.TypeByName("CharacterMainControl");
                _itemAgentGunType = AccessTools.TypeByName("ItemAgent_Gun");
                _itemSettingGunType = AccessTools.TypeByName("ItemSetting_Gun");
                _levelManagerType = AccessTools.TypeByName("LevelManager");
                _audioManagerType = AccessTools.TypeByName("AudioManager");
                _gameplayDataSettingsType = AccessTools.TypeByName("Duckov.Utilities.GameplayDataSettings");

                // ç¼“å­˜ ItemAgent_Gun çš„å±æ€§å’Œå­—æ®µ
                if (_itemAgentGunType != null)
                {
                    _gunItemSettingProperty = AccessTools.Property(_itemAgentGunType, "GunItemSetting");
                    _muzzleProperty = AccessTools.Property(_itemAgentGunType, "muzzle");
                    _silencedProperty = AccessTools.Property(_itemAgentGunType, "Silenced");
                    _bulletSpeedProperty = AccessTools.Property(_itemAgentGunType, "BulletSpeed");
                    _bulletDistanceProperty = AccessTools.Property(_itemAgentGunType, "BulletDistance");
                    _shellParticleField = AccessTools.Field(_itemAgentGunType, "shellParticle");
                }

                // ç¼“å­˜ ItemSetting_Gun çš„å­—æ®µ
                if (_itemSettingGunType != null)
                {
                    _muzzleFxPfbField = AccessTools.Field(_itemSettingGunType, "muzzleFxPfb");
                    _shootKeyField = AccessTools.Field(_itemSettingGunType, "shootKey");
                    _bulletPfbField = AccessTools.Field(_itemSettingGunType, "bulletPfb");
                }

                // ç¼“å­˜é»˜è®¤å­å¼¹
                if (_gameplayDataSettingsType != null)
                {
                    _prefabsProperty = AccessTools.Property(_gameplayDataSettingsType, "Prefabs");
                    if (_prefabsProperty != null)
                    {
                        object? prefabs = _prefabsProperty.GetValue(null);
                        if (prefabs != null)
                        {
                            _defaultBulletField = AccessTools.Field(prefabs.GetType(), "DefaultBullet");
                        }
                    }
                }

                // ç¼“å­˜ AudioManager.Post æ–¹æ³•
                if (_audioManagerType != null)
                {
                    _audioManagerPostMethod = AccessTools.Method(_audioManagerType, "Post", 
                        new[] { typeof(string), typeof(Vector3) });
                }

                _initialized = true;
                Debug.Log("[WeaponEffectsCore] âœ… åˆå§‹åŒ–å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponEffectsCore] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        #region é€šç”¨ç‰¹æ•ˆæ’­æ”¾æ–¹æ³•

        /// <summary>
        /// æ’­æ”¾æªå£ç«ç„°ç‰¹æ•ˆ
        /// </summary>
        public static void PlayMuzzleFlash(object gunAgent)
        {
            try
            {
                EnsureInitialized();
                
                object? gunItemSetting = _gunItemSettingProperty?.GetValue(gunAgent);
                if (gunItemSetting == null) return;

                GameObject? muzzleFxPfb = _muzzleFxPfbField?.GetValue(gunItemSetting) as GameObject;
                Transform? muzzle = _muzzleProperty?.GetValue(gunAgent) as Transform;

                if (muzzleFxPfb != null && muzzle != null)
                {
                    GameObject.Instantiate(muzzleFxPfb, muzzle.position, muzzle.rotation);
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[WeaponEffectsCore] æ’­æ”¾æªå£ç«ç„°å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ’­æ”¾å¼¹å£³æŠ›å‡ºç‰¹æ•ˆ
        /// </summary>
        public static void PlayShellEjection(object gunAgent)
        {
            try
            {
                EnsureInitialized();
                
                ParticleSystem? shellParticle = _shellParticleField?.GetValue(gunAgent) as ParticleSystem;
                shellParticle?.Emit(1);
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[WeaponEffectsCore] æ’­æ”¾å¼¹å£³å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ’­æ”¾å¼€æªéŸ³æ•ˆï¼ˆ3Dç©ºé—´éŸ³æ•ˆï¼‰
        /// </summary>
        public static void PlayShootSound(object gunAgent, Vector3 position, bool? isSilencedOverride = null)
        {
            try
            {
                EnsureInitialized();
                
                object? gunItemSetting = _gunItemSettingProperty?.GetValue(gunAgent);
                if (gunItemSetting == null) return;

                string? shootKey = _shootKeyField?.GetValue(gunItemSetting) as string;
                if (string.IsNullOrEmpty(shootKey)) return;

                // æ„å»ºéŸ³æ•ˆè·¯å¾„
                string soundPath = $"SFX/Combat/Gun/Shoot/{shootKey}";
                
                // æ£€æŸ¥æ¶ˆéŸ³å™¨ï¼ˆå¯ä»¥è¢«å¤–éƒ¨å‚æ•°è¦†ç›–ï¼‰
                bool isSilenced = isSilencedOverride ?? (bool)(_silencedProperty?.GetValue(gunAgent) ?? false);
                if (isSilenced)
                {
                    soundPath += "_mute";
                }

                // æ’­æ”¾ 3D ç©ºé—´éŸ³æ•ˆ
                _audioManagerPostMethod?.Invoke(null, new object[] { soundPath, position });
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[WeaponEffectsCore] æ’­æ”¾éŸ³æ•ˆå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åˆ›å»ºå­å¼¹ï¼ˆä»å¯¹è±¡æ± è·å–ï¼‰
        /// </summary>
        public static void CreateBullet(object gunAgent, Vector3 muzzlePosition, Vector3 direction, 
            object? sourceCharacter = null, float damageMultiplier = 1.0f)
        {
            try
            {
                EnsureInitialized();
                
                object? gunItemSetting = _gunItemSettingProperty?.GetValue(gunAgent);
                if (gunItemSetting == null) return;

                // è·å–å­å¼¹é¢„åˆ¶ä½“
                object? bulletPfb = GetBulletPrefab(gunItemSetting);
                if (bulletPfb == null) return;

                Transform? muzzle = _muzzleProperty?.GetValue(gunAgent) as Transform;
                if (muzzle == null) return;

                // ä»å¯¹è±¡æ± è·å–å­å¼¹
                object? bullet = GetBulletFromPool(bulletPfb);
                if (bullet is Component bulletComponent)
                {
                    bulletComponent.transform.position = muzzlePosition;
                    bulletComponent.transform.rotation = Quaternion.LookRotation(direction, Vector3.up);
                    
                    // åˆå§‹åŒ–å­å¼¹
                    InitializeBullet(bullet, gunAgent, muzzlePosition, direction, sourceCharacter, damageMultiplier);
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[WeaponEffectsCore] åˆ›å»ºå­å¼¹å¤±è´¥: {ex.Message}");
            }
        }

        #endregion

        #region è¾…åŠ©æ–¹æ³•

        /// <summary>
        /// è·å–å­å¼¹é¢„åˆ¶ä½“ï¼ˆä¼˜å…ˆä½¿ç”¨è‡ªå®šä¹‰ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤ï¼‰
        /// </summary>
        private static object? GetBulletPrefab(object gunItemSetting)
        {
            object? bulletPfb = _bulletPfbField?.GetValue(gunItemSetting);
            
            // å¦‚æœæ²¡æœ‰è‡ªå®šä¹‰å­å¼¹ï¼Œä½¿ç”¨é»˜è®¤å­å¼¹
            if (bulletPfb == null && _prefabsProperty != null)
            {
                object? prefabs = _prefabsProperty.GetValue(null);
                if (prefabs != null && _defaultBulletField != null)
                {
                    bulletPfb = _defaultBulletField.GetValue(prefabs);
                }
            }
            
            return bulletPfb;
        }

        /// <summary>
        /// ä»å¯¹è±¡æ± è·å–å­å¼¹
        /// </summary>
        private static object? GetBulletFromPool(object bulletPfb)
        {
            if (_levelManagerType == null) return null;

            var instanceProperty = AccessTools.Property(_levelManagerType, "Instance");
            object? levelManager = instanceProperty?.GetValue(null);
            if (levelManager == null) return null;

            var bulletPoolProperty = AccessTools.Property(_levelManagerType, "BulletPool");
            object? bulletPool = bulletPoolProperty?.GetValue(levelManager);
            if (bulletPool == null) return null;

            var getABulletMethod = AccessTools.Method(bulletPool.GetType(), "GetABullet");
            return getABulletMethod?.Invoke(bulletPool, new object[] { bulletPfb });
        }

        /// <summary>
        /// åˆå§‹åŒ–å­å¼¹çš„ ProjectileContext
        /// </summary>
        private static bool InitializeBullet(object bullet, object gunAgent, Vector3 muzzlePosition, 
            Vector3 direction, object? sourceCharacter, float damageMultiplier)
        {
            try
            {
                var projectileContextType = AccessTools.TypeByName("ProjectileContext");
                if (projectileContextType == null) return false;

                object? context = Activator.CreateInstance(projectileContextType);
                if (context == null) return false;

                // è·å–å­å¼¹å‚æ•°ï¼ˆå·²åŒ…å«è§’è‰²åŠ æˆï¼‰
                float bulletSpeed = GetBulletSpeed(gunAgent);
                float bulletDistance = GetBulletDistance(gunAgent);

                // è®¾ç½®åŸºç¡€å‚æ•°
                AccessTools.Field(projectileContextType, "direction")?.SetValue(context, direction);
                AccessTools.Field(projectileContextType, "speed")?.SetValue(context, bulletSpeed);
                AccessTools.Field(projectileContextType, "distance")?.SetValue(context, bulletDistance + 0.4f);
                AccessTools.Field(projectileContextType, "damage")?.SetValue(context, 25f * damageMultiplier);

                // è®¾ç½®ç¬¬ä¸€å¸§æ£€æµ‹
                AccessTools.Field(projectileContextType, "firstFrameCheck")?.SetValue(context, true);
                AccessTools.Field(projectileContextType, "firstFrameCheckStartPoint")?.SetValue(context, muzzlePosition);

                // è®¾ç½®ä¼¤å®³å‚æ•°
                AccessTools.Field(projectileContextType, "halfDamageDistance")?.SetValue(context, 50f);
                AccessTools.Field(projectileContextType, "critRate")?.SetValue(context, 0.1f * damageMultiplier);
                AccessTools.Field(projectileContextType, "critDamageFactor")?.SetValue(context, 2.0f);
                AccessTools.Field(projectileContextType, "armorPiercing")?.SetValue(context, 0f);
                AccessTools.Field(projectileContextType, "armorBreak")?.SetValue(context, 0f);
                AccessTools.Field(projectileContextType, "penetrate")?.SetValue(context, 0);

                // è®¾ç½®æ¥æºè§’è‰²å’Œé˜Ÿä¼
                if (sourceCharacter != null)
                {
                    AccessTools.Field(projectileContextType, "fromCharacter")?.SetValue(context, sourceCharacter);
                    
                    if (_characterMainControlType != null)
                    {
                        var teamProperty = AccessTools.Property(_characterMainControlType, "Team");
                        object? team = teamProperty?.GetValue(sourceCharacter);
                        if (team != null)
                        {
                            AccessTools.Field(projectileContextType, "team")?.SetValue(context, team);
                        }
                    }
                }

                // è°ƒç”¨ Projectile.Init() æ–¹æ³•
                var initMethod = AccessTools.Method(bullet.GetType(), "Init", new Type[] { projectileContextType });
                if (initMethod != null)
                {
                    initMethod.Invoke(bullet, new object[] { context });
                    return true;
                }
                
                return false;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponEffectsCore] åˆå§‹åŒ–å­å¼¹å¤±è´¥: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// è·å–å­å¼¹é€Ÿåº¦ï¼ˆå«è§’è‰²åŠ æˆï¼‰
        /// </summary>
        private static float GetBulletSpeed(object gunAgent)
        {
            if (_bulletSpeedProperty != null)
            {
                object? speedValue = _bulletSpeedProperty.GetValue(gunAgent);
                if (speedValue is float speed)
                {
                    return speed;
                }
            }
            return 100f; // é»˜è®¤å€¼
        }

        /// <summary>
        /// è·å–å­å¼¹é£è¡Œè·ç¦»ï¼ˆå«è§’è‰²åŠ æˆï¼‰
        /// </summary>
        private static float GetBulletDistance(object gunAgent)
        {
            if (_bulletDistanceProperty != null)
            {
                object? distanceValue = _bulletDistanceProperty.GetValue(gunAgent);
                if (distanceValue is float distance)
                {
                    return distance;
                }
            }
            return 200f; // é»˜è®¤å€¼
        }

        /// <summary>
        /// ç¡®ä¿å·²åˆå§‹åŒ–
        /// </summary>
        private static void EnsureInitialized()
        {
            if (!_initialized) Initialize();
        }

        #endregion

        #region å…¬å¼€å±æ€§ï¼ˆä¾›å¤–éƒ¨æŸ¥è¯¢ï¼‰

        public static Type? CharacterMainControlType => _characterMainControlType;
        public static Type? ItemAgentGunType => _itemAgentGunType;
        public static bool IsInitialized => _initialized;

        #endregion
    }
}


```

`Client\Core\Utils\WeaponEffectsPlayer.cs`:

```cs
using System;
using System.Reflection;
using UnityEngine;
using HarmonyLib;

namespace DuckyNet.Client.Core.Utils
{
    /// <summary>
    /// æ­¦å™¨ç‰¹æ•ˆæ’­æ”¾å™¨ - æœ¬åœ°ç©å®¶ä¸“ç”¨
    /// ä½¿ç”¨ WeaponEffectsCore æä¾›çš„å…±äº«é€»è¾‘
    /// </summary>
    public static class WeaponEffectsPlayer
    {
        // æœ¬åœ°ç©å®¶ä¸“ç”¨çš„åå°„æˆå‘˜
        private static PropertyInfo? _mainProperty;
        private static MethodInfo? _getGunMethod;
        private static bool _initialized = false;

        /// <summary>
        /// åˆå§‹åŒ–åå°„ï¼ˆæœ¬åœ°ç©å®¶ä¸“ç”¨ï¼‰
        /// </summary>
        public static void Initialize()
        {
            if (_initialized) return;

            try
            {
                // åˆå§‹åŒ–å…±äº«æ ¸å¿ƒ
                WeaponEffectsCore.Initialize();

                // åˆå§‹åŒ–æœ¬åœ°ç©å®¶ä¸“ç”¨æˆå‘˜
                var characterMainControlType = WeaponEffectsCore.CharacterMainControlType;
                if (characterMainControlType != null)
                {
                    _mainProperty = AccessTools.Property(characterMainControlType, "Main");
                    _getGunMethod = AccessTools.Method(characterMainControlType, "GetGun");
                }

                _initialized = true;
                Debug.Log("[WeaponEffectsPlayer] åˆå§‹åŒ–å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponEffectsPlayer] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ’­æ”¾å®Œæ•´çš„å¼€ç«ç‰¹æ•ˆï¼ˆæªå£ç«ç„° + å¼¹å£³ + éŸ³æ•ˆ + å­å¼¹ï¼‰
        /// </summary>
        /// <param name="includeBullet">æ˜¯å¦åŒ…å«å­å¼¹åˆ›å»ºï¼ˆé»˜è®¤ä¸º trueï¼Œâš ï¸ ä¼šé€ æˆçœŸå®ä¼¤å®³ï¼‰</param>
        public static void PlayFullFireEffects(bool includeBullet = true)
        {
            try
            {
                if (!_initialized) Initialize();

                var gun = GetCurrentGun();
                if (gun == null)
                {
                    Debug.LogWarning("[WeaponEffectsPlayer] å½“å‰æœªæŒæœ‰æªæ¢°");
                    return;
                }

                // ä½¿ç”¨å…±äº«æ ¸å¿ƒçš„æ–¹æ³•
                var muzzle = GetMuzzleTransform(gun);
                if (muzzle != null)
                {
                    WeaponEffectsCore.PlayMuzzleFlash(gun);
                    WeaponEffectsCore.PlayShellEjection(gun);
                    WeaponEffectsCore.PlayShootSound(gun, muzzle.position);
                    
                    if (includeBullet)
                    {
                        // è·å–ä¸»è§’ä½œä¸ºæ¥æºè§’è‰²
                        object? mainCharacter = _mainProperty?.GetValue(null);
                        WeaponEffectsCore.CreateBullet(gun, muzzle.position, muzzle.forward, mainCharacter, 1.0f);
                        Debug.Log("[WeaponEffectsPlayer] âœ… å·²æ’­æ”¾å®Œæ•´å¼€ç«ç‰¹æ•ˆï¼ˆå«å­å¼¹ï¼‰");
                    }
                    else
                    {
                        Debug.Log("[WeaponEffectsPlayer] âœ… å·²æ’­æ”¾å®Œæ•´å¼€ç«ç‰¹æ•ˆï¼ˆä¸å«å­å¼¹ï¼‰");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponEffectsPlayer] æ’­æ”¾ç‰¹æ•ˆå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ’­æ”¾æªå£ç«ç„°ç‰¹æ•ˆï¼ˆå‘åå…¼å®¹ APIï¼‰
        /// </summary>
        public static void PlayMuzzleFlash(object? gun = null)
        {
            if (!_initialized) Initialize();
            
            gun ??= GetCurrentGun();
            if (gun == null) return;

            WeaponEffectsCore.PlayMuzzleFlash(gun);
        }

        /// <summary>
        /// æ’­æ”¾å¼¹å£³æŠ›å‡ºç‰¹æ•ˆï¼ˆå‘åå…¼å®¹ APIï¼‰
        /// </summary>
        public static void PlayShellEjection(object? gun = null)
        {
            if (!_initialized) Initialize();
            
            gun ??= GetCurrentGun();
            if (gun == null) return;

            WeaponEffectsCore.PlayShellEjection(gun);
        }

        /// <summary>
        /// æ’­æ”¾å¼€æªéŸ³æ•ˆï¼ˆå‘åå…¼å®¹ APIï¼‰
        /// </summary>
        public static void PlayShootSound(object? gun = null)
        {
            if (!_initialized) Initialize();
            
            gun ??= GetCurrentGun();
            if (gun == null) return;

            var muzzle = GetMuzzleTransform(gun);
            if (muzzle != null)
            {
                WeaponEffectsCore.PlayShootSound(gun, muzzle.position);
            }
        }

        /// <summary>
        /// åˆ›å»ºå­å¼¹ï¼ˆå‘åå…¼å®¹ APIï¼‰
        /// âš ï¸ è­¦å‘Šï¼šæ­¤æ–¹æ³•ä¼šåˆ›å»ºçœŸå®çš„å­å¼¹ï¼Œå¯èƒ½é€ æˆä¼¤å®³
        /// </summary>
        public static void CreateBullet(object? gun = null)
        {
            if (!_initialized) Initialize();
            
            gun ??= GetCurrentGun();
            if (gun == null) return;

            var muzzle = GetMuzzleTransform(gun);
            if (muzzle != null)
            {
                object? mainCharacter = _mainProperty?.GetValue(null);
                WeaponEffectsCore.CreateBullet(gun, muzzle.position, muzzle.forward, mainCharacter, 1.0f);
            }
        }

        /// <summary>
        /// è·å–æªå£ Transform
        /// </summary>
        private static Transform? GetMuzzleTransform(object gun)
        {
            var muzzleProperty = AccessTools.Property(WeaponEffectsCore.ItemAgentGunType, "muzzle");
            return muzzleProperty?.GetValue(gun) as Transform;
        }

        /// <summary>
        /// è·å–å½“å‰æ‰‹æŒçš„æªæ¢°
        /// </summary>
        private static object? GetCurrentGun()
        {
            try
            {
                if (_mainProperty == null || _getGunMethod == null) return null;

                object? mainCharacter = _mainProperty.GetValue(null);
                if (mainCharacter == null) return null;

                return _getGunMethod.Invoke(mainCharacter, null);
            }
            catch
            {
                return null;
            }
        }
    }
}


```

`Client\DuckyNetClient.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <Nullable>enable</Nullable>
    <AssemblyName>DuckyNet.Client</AssemblyName>
    <DuckovPath>C:\Program Files (x86)\Steam\steamapps\common\Escape from Duckov</DuckovPath>
  </PropertyGroup>
  
  <ItemGroup>
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\TeamSoda.*" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\Unity*" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\com.rlabrecque.steamworks.net.dll" />
    <PackageReference Include="Lib.Harmony" Version="2.4.1" />
    <PackageReference Include="LiteNetLib" Version="1.2.0" />
    <PackageReference Include="NetSerializer" Version="4.1.1" />
    <PackageReference Include="Microsoft.CSharp" Version="4.7.0" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\ItemStatsSystem.dll" />
    <ProjectReference Include="..\Shared\DuckyNetShared.csproj" />
  </ItemGroup>

  <!-- å®šä¹‰ res ç›®å½• -->
  <PropertyGroup>
    <ResDir>$(MSBuildProjectDirectory)\res\</ResDir>
  </PropertyGroup>

  <!-- ç¼–è¯‘åå¤åˆ¶è¾“å‡ºæ–‡ä»¶åˆ° res ç›®å½• -->
  <Target Name="CopyOutputsToRes" AfterTargets="Build">
    <ItemGroup>
      <!-- DuckyNet.Client ä¸»è¾“å‡ºï¼ˆä½¿ç”¨ AssemblyNameï¼‰-->
      <OutputFiles Include="$(TargetPath)" />
      <OutputFiles Include="$(TargetDir)$(AssemblyName).pdb" Condition="Exists('$(TargetDir)$(AssemblyName).pdb')" />
      <OutputFiles Include="$(TargetDir)$(AssemblyName).xml" Condition="Exists('$(TargetDir)$(AssemblyName).xml')" />
      <!-- åŒ…å« DuckyNet.Shared.dll -->
      <OutputFiles Include="$(TargetDir)DuckyNet.Shared.dll" Condition="Exists('$(TargetDir)DuckyNet.Shared.dll')" />
      <OutputFiles Include="$(TargetDir)DuckyNet.Shared.pdb" Condition="Exists('$(TargetDir)DuckyNet.Shared.pdb')" />
      <!-- åŒ…å« LiteNetLib.dll -->
      <OutputFiles Include="$(TargetDir)LiteNetLib.dll" Condition="Exists('$(TargetDir)LiteNetLib.dll')" />
      <!-- åŒ…å« NetSerializer.dll -->
      <OutputFiles Include="$(TargetDir)NetSerializer.dll" Condition="Exists('$(TargetDir)NetSerializer.dll')" />
      <!-- åŒ…å« 0Harmony.dll (HarmonyLib) -->
      <OutputFiles Include="$(TargetDir)0Harmony.dll" Condition="Exists('$(TargetDir)0Harmony.dll')" />
    </ItemGroup>
    <Copy SourceFiles="@(OutputFiles)" DestinationFolder="$(ResDir)" SkipUnchangedFiles="false" />
    <Message Text="[DuckyNet] å·²å¤åˆ¶è¾“å‡ºæ–‡ä»¶åˆ° res ç›®å½•" Importance="high" />
  </Target>

  <!-- å®šä¹‰æ¸¸æˆ Mods ç›®å½• -->
  <PropertyGroup>
    <ModsDir>$(DuckovPath)\Duckov_Data\Mods\DuckyNet\</ModsDir>
  </PropertyGroup>

  <!-- å¤åˆ¶ res ç›®å½•åˆ°æ¸¸æˆ Mods ç›®å½• -->
  <Target Name="CopyResToMods" AfterTargets="Build" DependsOnTargets="CopyOutputsToRes">
    <MakeDir Directories="$(ModsDir)" />
    <ItemGroup>
      <ResFiles Include="$(ResDir)**\*.*" />
    </ItemGroup>
    <Copy SourceFiles="@(ResFiles)" DestinationFolder="$(ModsDir)\%(RecursiveDir)" SkipUnchangedFiles="false" />
    <Message Text="[DuckyNet] å·²å¤åˆ¶æ–‡ä»¶åˆ°æ¸¸æˆ Mods ç›®å½•: $(ModsDir)" Importance="high" />
  </Target>

</Project>

```

`Client\ModBehaviour.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus;
using HarmonyLib;

namespace DuckyNet.Client
{
    /// <summary>
    /// DuckyNet æ¨¡ç»„ä¸»è¡Œä¸ºç±»
    /// è´Ÿè´£æ¨¡ç»„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œä½œä¸º Unity å’Œæ¸¸æˆç³»ç»Ÿçš„æ¡¥æ¢
    /// </summary>
    public class ModBehaviour : Duckov.Modding.ModBehaviour
    {
        private readonly EventSubscriberHelper _eventSub = new EventSubscriberHelper();
        
        /// <summary>
        /// å…¨å±€å®ä¾‹
        /// </summary>
        public static ModBehaviour? Instance { get; private set; }

        /// <summary>
        /// Harmony å®ä¾‹
        /// </summary>
        private static Harmony? _harmony;
        

        
        /// <summary>
        /// æœ¬åœ°ç©å®¶å¼€æªäº‹ä»¶æ¡¥æ¥å™¨
        /// </summary>
        private Patches.LocalPlayerShootBridge? _localPlayerShootBridge;

        void Awake()
        {
            try
            {
                // è®¾ç½®å…¨å±€å®ä¾‹
                Instance = this;

                // è¾“å‡ºæ¨¡ç»„åŠ è½½ä¿¡æ¯
                LogModInfo();
                
                // åˆå§‹åŒ– Harmony å¹¶åº”ç”¨æ‰€æœ‰ Patch
                InitializeHarmony();

                // åˆå§‹åŒ–æ¸¸æˆä¸Šä¸‹æ–‡
                InitializeGameContext();

                Debug.Log("[DuckyNet] Mod Loaded!");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ModBehaviour] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// åˆå§‹åŒ–æ¸¸æˆä¸Šä¸‹æ–‡å’Œæ‰€æœ‰æœåŠ¡
        /// </summary>
        private void InitializeGameContext()
        {
            GameContext.Initialize();
            var context = GameContext.Instance;

            RegisterCoreServices(context);
            RegisterClientServices(context);
            InitializeManagers(context);
            RegisterInputKeys();
            InitializeBridges();
            InitializeNetworkLifecycle(context);

            Debug.Log("[ModBehaviour] æ¸¸æˆä¸Šä¸‹æ–‡åˆå§‹åŒ–å®Œæˆ");
        }

        /// <summary>
        /// æ³¨å†Œæ ¸å¿ƒæœåŠ¡
        /// </summary>
        private void RegisterCoreServices(GameContext context)
        {
            context.RegisterPlayerManager(new Core.Players.PlayerManager());
            context.RegisterRpcClient(new RPC.RpcClient());
            context.RegisterInputManager(new Core.InputManager());
            context.RegisterAvatarManager(new Core.AvatarManager());
            context.RegisterCharacterCustomizationManager(new Core.CharacterCustomizationManager());
            context.RegisterSceneClientManager(new Core.SceneClientManager());
            context.RegisterRoomManager(new Core.RoomManager());
            context.RegisterAnimatorSyncManager(new Core.AnimatorSyncManager());
            context.RegisterUIManager(new Core.UIManager(context.RpcClient));
            context.RegisterNpcManager(new Core.NpcManager());
            
            Debug.Log("[ModBehaviour] æ ¸å¿ƒæœåŠ¡å·²æ³¨å†Œ");
        }

        /// <summary>
        /// æ³¨å†Œå®¢æˆ·ç«¯ RPC æœåŠ¡
        /// </summary>
        private void RegisterClientServices(GameContext context)
        {
            var rpcClient = context.RpcClient;

            // æ³¨å†ŒåŸºç¡€å®¢æˆ·ç«¯æœåŠ¡
            rpcClient.RegisterClientService<Shared.Services.IPlayerClientService>(new Services.PlayerClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.IRoomClientService>(new Services.RoomClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.ISceneClientService>(new Services.SceneClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.ICharacterClientService>(new Services.CharacterClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.ICharacterAppearanceClientService>(new Services.CharacterAppearanceClientServiceImpl());
            
            // æ³¨å†ŒåŠ¨ç”»åŒæ­¥æœåŠ¡å¹¶ä¿å­˜å®ä¾‹
            var animatorSyncClientService = new Services.AnimatorSyncClientServiceImpl();
            rpcClient.RegisterClientService<Shared.Services.IAnimatorSyncClientService>(animatorSyncClientService);
            context.AnimatorSyncClientService = animatorSyncClientService;

            // æ³¨å†ŒåŒæ­¥æœåŠ¡
            rpcClient.RegisterClientService<Shared.Services.IItemSyncClientService>(new Services.ItemSyncClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.IEquipmentClientService>(new Services.EquipmentClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.IWeaponSyncClientService>(new Services.WeaponSyncClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.IHealthSyncClientService>(new Services.HealthSyncClientServiceImpl());
            rpcClient.RegisterClientService<Shared.Services.INpcSyncClientService>(new Services.NpcSyncClientServiceImpl());

            // åˆ›å»ºå¹¶æ³¨å†Œç‰©å“ç½‘ç»œåè°ƒå™¨
            var clientContext = new RPC.ClientServerContext(rpcClient);
            var itemSyncServiceProxy = new Shared.Services.Generated.ItemSyncServiceClientProxy(clientContext);
            var itemNetworkCoordinator = new Services.ItemNetworkCoordinator(itemSyncServiceProxy);
            context.RegisterItemNetworkCoordinator(itemNetworkCoordinator);

            Debug.Log("[ModBehaviour] å®¢æˆ·ç«¯æœåŠ¡å·²æ³¨å†Œ");
        }

        /// <summary>
        /// åˆå§‹åŒ–å„ä¸ªç®¡ç†å™¨
        /// </summary>
        private void InitializeManagers(GameContext context)
        {
            context.AnimatorSyncManager.Initialize();
            context.UIManager.Initialize();

            Debug.Log("[ModBehaviour] ç®¡ç†å™¨å·²åˆå§‹åŒ–");
        }

        /// <summary>
        /// åˆå§‹åŒ–å„ç§æ¡¥æ¥å™¨
        /// </summary>
        private void InitializeBridges()
        {
            // åœºæ™¯äº‹ä»¶æ¡¥æ¥å™¨
            var sceneBridge = new Patches.SceneEventBridge();
            sceneBridge.Initialize();
            Core.Helpers.SceneInfoProvider.Initialize(sceneBridge);


            // æœ¬åœ°ç©å®¶å¼€æªäº‹ä»¶æ¡¥æ¥å™¨
            _localPlayerShootBridge = new Patches.LocalPlayerShootBridge();
            _localPlayerShootBridge.Initialize();

            // æ­¦å™¨ç‰¹æ•ˆç³»ç»Ÿé¢„åˆå§‹åŒ–
            Core.Utils.WeaponEffectsPlayer.Initialize();
            Services.WeaponFireEffectsPlayer.Initialize();
            
            // å½±å­ NPC å·¥å‚é¢„åˆå§‹åŒ–
            Core.ShadowNpcFactory.Initialize();

            Debug.Log("[ModBehaviour] æ¡¥æ¥å™¨å·²åˆå§‹åŒ–");
        }

        /// <summary>
        /// åˆå§‹åŒ–ç½‘ç»œç”Ÿå‘½å‘¨æœŸ
        /// </summary>
        private void InitializeNetworkLifecycle(GameContext context)
        {
            var lifecycleManager = new Core.NetworkLifecycleManager(context);

            context.RpcClient.Connected += () => lifecycleManager.HandleConnected();
            context.RpcClient.Disconnected += lifecycleManager.HandleDisconnected;

            // å¯åŠ¨è§’è‰²å¤–è§‚è‡ªåŠ¨ä¸Šä¼ 
            CharacterAppearanceHelper.StartAutoUpload();

            Debug.Log("[ModBehaviour] ç½‘ç»œç”Ÿå‘½å‘¨æœŸå·²åˆå§‹åŒ–");
        }

        /// <summary>
        /// æ³¨å†Œæ‰€æœ‰è¾“å…¥æŒ‰é”®
        /// </summary>
        private void RegisterInputKeys()
        {
            var inputManager = GameContext.Instance.InputManager;
            var uiManager = GameContext.Instance.UIManager;

            inputManager.RegisterKey(KeyCode.F10, () =>
            {
                uiManager.ToggleWindow("MainMenu");
                var window = uiManager.GetWindow<UI.MainMenuWindow>("MainMenu");
                Debug.Log($"[ModBehaviour] ä¸»èœå• {(window?.IsVisible == true ? "å·²æ˜¾ç¤º" : "å·²éšè—")}");
            }, "åˆ‡æ¢ä¸»èœå•");

            inputManager.RegisterKey(KeyCode.F9, () =>
            {
                uiManager.ToggleWindow("Chat");
                var window = uiManager.GetWindow<UI.ChatWindow>("Chat");
                Debug.Log($"[ModBehaviour] èŠå¤©çª—å£ {(window?.IsVisible == true ? "å·²æ˜¾ç¤º" : "å·²éšè—")}");
            }, "åˆ‡æ¢èŠå¤©çª—å£");

            inputManager.RegisterKey(KeyCode.F6, () =>
            {
                uiManager.ToggleWindow("PlayerList");
                var window = uiManager.GetWindow<UI.PlayerListWindow>("PlayerList");
                Debug.Log($"[ModBehaviour] ç©å®¶åˆ—è¡¨ {(window?.IsVisible == true ? "å·²æ˜¾ç¤º" : "å·²éšè—")}");
            }, "åˆ‡æ¢ç©å®¶åˆ—è¡¨");

            inputManager.RegisterKey(KeyCode.F3, () =>
            {
                uiManager.ToggleWindow("Debug");
                var window = uiManager.GetWindow<UI.DebugWindow>("Debug");
                Debug.Log($"[ModBehaviour] è°ƒè¯•çª—å£ {(window?.IsVisible == true ? "å·²æ˜¾ç¤º" : "å·²éšè—")}");
            }, "åˆ‡æ¢è°ƒè¯•çª—å£ï¼ˆåŒ…å«æ‰€æœ‰è°ƒè¯•æ¨¡å—ï¼‰");

            Debug.Log("[ModBehaviour] è¾“å…¥æŒ‰é”®å·²æ³¨å†Œ");
        }


        /// <summary>
        /// è¾“å‡ºæ¨¡ç»„åŠ è½½ä¿¡æ¯
        /// </summary>
        private void LogModInfo()
        {
            Debug.Log("=== DuckyNet Mod åˆå§‹åŒ– ===");
            Debug.Log("[DuckyNet] æ¨¡ç»„ç‰ˆæœ¬: 1.0.0");
            Debug.Log($"[DuckyNet] Unityç‰ˆæœ¬: {Application.unityVersion}");
            Debug.Log($"[DuckyNet] åŠ è½½æ—¶é—´: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            Debug.Log("===========================");
        }

        /// <summary>
        /// åˆå§‹åŒ– Harmony å¹¶åº”ç”¨æ‰€æœ‰ Patch
        /// </summary>
        private void InitializeHarmony()
        {
            try
            {
                const string harmonyId = "com.duckynet.client";
                
                Debug.Log($"[ModBehaviour] åˆå§‹åŒ– Harmony (ID: {harmonyId})");
                
                // åˆ›å»º Harmony å®ä¾‹
                _harmony = new Harmony(harmonyId);
                
                // åº”ç”¨æ‰€æœ‰ Patchï¼ˆä¼šè‡ªåŠ¨æ‰«æå¸¦æœ‰ [HarmonyPatch] ç‰¹æ€§çš„ç±»ï¼‰
                _harmony.PatchAll(typeof(ModBehaviour).Assembly);
                
                Debug.Log("[ModBehaviour] âœ… Harmony Patch å·²å…¨éƒ¨åº”ç”¨");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ModBehaviour] Harmony åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        void Update()
        {
            try
            {
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.Update();
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ModBehaviour] Update æ–¹æ³•å‡ºé”™: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        void LateUpdate()
        {
            try
            {
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.LateUpdate();
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ModBehaviour] LateUpdate æ–¹æ³•å‡ºé”™: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        void OnGUI()
        {
            try
            {
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.OnGUI();
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ModBehaviour] OnGUI æ–¹æ³•å‡ºé”™: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        void OnDestroy()
        {
            try
            {
                Debug.Log("[ModBehaviour] Mod å¸è½½ä¸­...");

                // é‡Šæ”¾äº‹ä»¶è®¢é˜…
                _eventSub.Dispose();

                // å–æ¶ˆ Harmony Patch
                if (_harmony != null)
                {
                    _harmony.UnpatchAll("com.duckynet.client");
                    Debug.Log("[ModBehaviour] Harmony Patch å·²ç§»é™¤");
                }

    

                // æ¸…ç†æœ¬åœ°ç©å®¶å¼€æªäº‹ä»¶æ¡¥æ¥å™¨
                _localPlayerShootBridge?.Dispose();
                _localPlayerShootBridge = null;

                // æ¸…ç†ä¼¤å®³ä¿®æ”¹ç›‘å¬å™¨

                // æ³¨æ„ï¼šRPC å®¢æˆ·ç«¯ä¼šåœ¨ Disconnect æ—¶è‡ªåŠ¨æ¸…ç†äº‹ä»¶è®¢é˜…

                // æ¸…ç†æ¸¸æˆä¸Šä¸‹æ–‡ï¼ˆä¼šè‡ªåŠ¨æ¸…ç†æ‰€æœ‰æœåŠ¡ï¼‰
                GameContext.Cleanup();

                Debug.Log("[ModBehaviour] Mod å·²å¸è½½");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ModBehaviour] å¸è½½å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }
    }
}

```

`Client\Patches\CharacterLifecyclePatch.cs`:

```cs
using System;
using System.Collections.Generic;
using HarmonyLib;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// è§’è‰²ç”Ÿå‘½å‘¨æœŸè¡¥ä¸é›†åˆ - ç»Ÿä¸€ç®¡ç†è§’è‰²çš„åˆ›å»ºã€é”€æ¯ã€æ­»äº¡äº‹ä»¶
    /// </summary>
    public static class CharacterLifecyclePatch
    {
        #region å…±äº«åå°„ç¼“å­˜

        private static Type? _characterMainControlType;
        private static Type? _healthType;
        private static System.Reflection.MethodInfo? _tryGetCharacterMethod;
        private static System.Reflection.PropertyInfo? _isDeadProperty;
        private static System.Reflection.PropertyInfo? _isMainCharacterProperty;

        private static Type? CharacterMainControlType
        {
            get
            {
                if (_characterMainControlType == null)
                {
                    _characterMainControlType = AccessTools.TypeByName("CharacterMainControl");
                }
                return _characterMainControlType;
            }
        }

        #endregion

        #region è§’è‰² ID ç®¡ç†

        private static readonly Dictionary<object, string> _characterIds = new Dictionary<object, string>();

        /// <summary>
        /// ç”Ÿæˆå…¨å±€å”¯ä¸€çš„ NPC IDï¼ˆä½¿ç”¨ UUIDï¼‰
        /// </summary>
        private static string GenerateNpcId()
        {
            return Guid.NewGuid().ToString();
        }

        /// <summary>
        /// è·å–è§’è‰²çš„ ID
        /// </summary>
        public static string GetCharacterId(object characterMainControl)
        {
            if (characterMainControl != null && _characterIds.TryGetValue(characterMainControl, out string? id))
            {
                return id;
            }
            return "";
        }

        /// <summary>
        /// æ¸…ç†è§’è‰² ID æ˜ å°„
        /// </summary>
        private static void RemoveCharacterId(object characterMainControl)
        {
            _characterIds?.Remove(characterMainControl);
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰æ•°æ®
        /// </summary>
        public static void Clear()
        {
            _characterIds.Clear();
        }

        #endregion

        #region è§’è‰²åˆ›å»º Patch

        /// <summary>
        /// è§’è‰²åˆ›å»ºè¡¥ä¸ - æ‹¦æˆª CharacterSpawnerRoot.AddCreatedCharacter
        /// </summary>
        [HarmonyPatch]
        public static class CreationPatch
        {
            [HarmonyTargetMethod]
            static System.Reflection.MethodBase? TargetMethod()
            {
                var type = AccessTools.TypeByName("CharacterSpawnerRoot");
                if (type == null)
                {
                    Debug.LogWarning("[CharacterLifecycle] æ‰¾ä¸åˆ° CharacterSpawnerRoot ç±»å‹");
                    return null;
                }

                var method = AccessTools.Method(type, "AddCreatedCharacter");
                if (method == null)
                {
                    Debug.LogWarning("[CharacterLifecycle] æ‰¾ä¸åˆ° AddCreatedCharacter æ–¹æ³•");
                    return null;
                }

                return method;
            }

            [HarmonyPostfix]
            static void Postfix(object c)
            {
                try
                {
                    if (c == null || !GameContext.IsInitialized) return;

                    // ç”Ÿæˆå…¨å±€å”¯ä¸€ IDï¼ˆUUIDï¼‰
                    string characterId = GenerateNpcId();
                    _characterIds[c] = characterId;

                    // è·å– GameObject
                    GameObject? gameObject = (c is Component component) ? component.gameObject : null;

                    // å‘å¸ƒäº‹ä»¶
                    var evt = new CharacterSpawnedEvent(c, gameObject, characterId);
                    Debug.Log($"[CharacterLifecycle] è§’è‰²åˆ›å»º: {gameObject?.name} ID: {characterId}");
                    GameContext.Instance.EventBus.Publish(evt);
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[CharacterLifecycle] è§’è‰²åˆ›å»ºå¤±è´¥: {ex.Message}");
                }
            }
        }

        #endregion

        #region è§’è‰²é”€æ¯ Patch

        /// <summary>
        /// è§’è‰²é”€æ¯è¡¥ä¸ - æ‹¦æˆª CharacterMainControl.OnDestroy
        /// ä½¿ç”¨ Unity ç”Ÿå‘½å‘¨æœŸæ–¹æ³•æ›´å¯é ï¼Œæ— è®ºé€šè¿‡ä½•ç§æ–¹å¼é”€æ¯éƒ½ä¼šè§¦å‘
        /// </summary>
        [HarmonyPatch]
        public static class DestructionPatch
        {
            [HarmonyTargetMethod]
            static System.Reflection.MethodBase? TargetMethod()
            {
                var type = CharacterMainControlType;
                if (type == null)
                {
                    Debug.LogWarning("[CharacterLifecycle] æ‰¾ä¸åˆ° CharacterMainControl ç±»å‹");
                    return null;
                }

                var method = AccessTools.Method(type, "OnDestroy");
                if (method == null)
                {
                    Debug.LogWarning("[CharacterLifecycle] æ‰¾ä¸åˆ° OnDestroy æ–¹æ³•");
                    return null;
                }

                return method;
            }

            [HarmonyPrefix]
            static void Prefix(object __instance)
            {
                try
                {
                    if (__instance == null || !GameContext.IsInitialized) return;

                    // è·å– GameObject
                    GameObject? gameObject = (__instance is Component component) ? component.gameObject : null;

                    // è·å–è§’è‰² ID
                    string characterId = GetCharacterId(__instance);

                    // å‘å¸ƒé”€æ¯äº‹ä»¶
                    var evt = new CharacterDestroyedEvent(__instance, gameObject, characterId);
                    GameContext.Instance.EventBus.Publish(evt);
                    RemoveCharacterId(__instance);
                    
                    Debug.Log($"[CharacterLifecycle] è§’è‰²é”€æ¯: {gameObject?.name} ID: {characterId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[CharacterLifecycle] è§’è‰²é”€æ¯äº‹ä»¶å¤±è´¥: {ex.Message}");
                }
            }
        }

        #endregion

        #region è§’è‰²æ­»äº¡ Patch

        /// <summary>
        /// è§’è‰²æ­»äº¡è¡¥ä¸ - æ‹¦æˆª Health.Hurt æ–¹æ³•
        /// </summary>
        [HarmonyPatch]
        public static class DeathPatch
        {
            [HarmonyTargetMethod]
            static System.Reflection.MethodBase? TargetMethod()
            {
                _healthType = AccessTools.TypeByName("Health");
                if (_healthType == null)
                {
                    Debug.LogWarning("[CharacterLifecycle] æ‰¾ä¸åˆ° Health ç±»å‹");
                    return null;
                }

                var method = AccessTools.Method(_healthType, "Hurt");
                if (method == null)
                {
                    Debug.LogWarning("[CharacterLifecycle] æ‰¾ä¸åˆ° Hurt æ–¹æ³•");
                    return null;
                }

                // ç¼“å­˜åå°„æˆå‘˜
                _tryGetCharacterMethod = AccessTools.Method(_healthType, "TryGetCharacter");
                _isDeadProperty = AccessTools.Property(_healthType, "IsDead");

                if (CharacterMainControlType != null)
                {
                    _isMainCharacterProperty = AccessTools.Property(CharacterMainControlType, "IsMainCharacter");
                }

                return method;
            }

            [HarmonyPostfix]
            static void Postfix(object __instance, object damageInfo, bool __result)
            {
                try
                {
                    if (!__result || !GameContext.IsInitialized || _isDeadProperty == null) return;

                    // æ£€æŸ¥æ˜¯å¦æ­»äº¡
                    bool isDead = (bool)(_isDeadProperty.GetValue(__instance) ?? false);
                    if (!isDead) return;

                    // è·å–è§’è‰²ä¿¡æ¯
                    object? characterMainControl = _tryGetCharacterMethod?.Invoke(__instance, null);
                    if (characterMainControl == null) return;

                    // è¿‡æ»¤æ‰ç©å®¶è§’è‰²ï¼ˆåªç›‘å¬æ€ªç‰©/NPC æ­»äº¡ï¼‰
                    if (_isMainCharacterProperty != null)
                    {
                        try
                        {
                            var isMainCharacter = (bool)(_isMainCharacterProperty.GetValue(characterMainControl) ?? false);
                            if (isMainCharacter) return;
                        }
                        catch
                        {
                            // æ£€æŸ¥å¤±è´¥ï¼Œç»§ç»­å¤„ç†
                        }
                    }

                    // è·å– GameObject å’Œ ID
                    GameObject? gameObject = (characterMainControl is Component component) ? component.gameObject : null;
                    string characterId = GetCharacterId(characterMainControl);

                    // å‘å¸ƒæ­»äº¡äº‹ä»¶
                    var evt = new CharacterDeathEvent(__instance, damageInfo, characterMainControl, gameObject, characterId);
                    GameContext.Instance.EventBus.Publish(evt);
                }
                catch
                {
                    // é™é»˜å¤±è´¥ï¼Œé¿å…å¹²æ‰°æ¸¸æˆæµç¨‹
                }
            }
        }

        #endregion
    }
}


```

`Client\Patches\DamageModificationPatch.cs`:

```cs
using HarmonyLib;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// ä¼¤å®³ä¿®æ”¹è¡¥ä¸
    /// æ‹¦æˆª Health.Hurt() æ–¹æ³•ï¼Œåœ¨ä¼¤å®³åº”ç”¨å‰è§¦å‘äº‹ä»¶ï¼Œå…è®¸å¤–éƒ¨ä¿®æ”¹ä¼¤å®³å‚æ•°
    /// </summary>
    [HarmonyPatch]
    public static class DamageModificationPatch
    {
        /// <summary>
        /// åŠ¨æ€æŒ‡å®šè¦è¡¥ä¸çš„æ–¹æ³•
        /// </summary>
        [HarmonyTargetMethod]
        static System.Reflection.MethodBase? TargetMethod()
        {
            var healthType = AccessTools.TypeByName("Health");
            if (healthType == null)
            {
                Debug.LogWarning("[DamageModificationPatch] æ‰¾ä¸åˆ° Health ç±»å‹");
                return null;
            }

            var hurtMethod = AccessTools.Method(healthType, "Hurt");
            if (hurtMethod == null)
            {
                Debug.LogWarning("[DamageModificationPatch] æ‰¾ä¸åˆ° Health.Hurt æ–¹æ³•");
                return null;
            }

            Debug.Log("[DamageModificationPatch] âœ… æˆåŠŸå®šä½ Health.Hurt æ–¹æ³•");
            return hurtMethod;
        }

        /// <summary>
        /// å‰ç½®è¡¥ä¸ - åœ¨ä¼¤å®³è®¡ç®—å‰ä¿®æ”¹ DamageInfo
        /// </summary>
        [HarmonyPrefix]
        static bool Prefix(object __instance, ref object damageInfo, object[] __args)
        {
            try
            {
                // ===== 1. è·å–ç›®æ ‡è§’è‰²ä¿¡æ¯ =====
                var healthType = __instance.GetType();
                var tryGetCharacterMethod = AccessTools.Method(healthType, "TryGetCharacter");
                object? character = tryGetCharacterMethod?.Invoke(__instance, null);

                GameObject? targetGameObject = null;
                int? characterId = null;

                if (character != null && character is Component component)
                {
                    targetGameObject = component.gameObject;
                }

                // ===== 2. æå– DamageInfo å‚æ•° =====
                var damageInfoType = damageInfo.GetType();
                
                var damageValueField = AccessTools.Field(damageInfoType, "damageValue");
                var ignoreArmorField = AccessTools.Field(damageInfoType, "ignoreArmor");
                var ignoreDifficultyField = AccessTools.Field(damageInfoType, "ignoreDifficulty");
                var critRateField = AccessTools.Field(damageInfoType, "critRate");
                var critDamageFactorField = AccessTools.Field(damageInfoType, "critDamageFactor");
                var armorPiercingField = AccessTools.Field(damageInfoType, "armorPiercing");

                if (damageValueField == null)
                {
                    Debug.LogWarning("[DamageModificationPatch] æ— æ³•æ‰¾åˆ° damageValue å­—æ®µ");
                    return true; // ç»§ç»­æ‰§è¡ŒåŸæ–¹æ³•
                }

                float originalDamageValue = (float)damageValueField.GetValue(damageInfo);
                bool ignoreArmor = ignoreArmorField != null && (bool)ignoreArmorField.GetValue(damageInfo);
                bool ignoreDifficulty = ignoreDifficultyField != null && (bool)ignoreDifficultyField.GetValue(damageInfo);
                float critRate = critRateField != null ? (float)critRateField.GetValue(damageInfo) : 0f;
                float critDamageFactor = critDamageFactorField != null ? (float)critDamageFactorField.GetValue(damageInfo) : 1f;
                float armorPiercing = armorPiercingField != null ? (float)armorPiercingField.GetValue(damageInfo) : 0f;

                // ===== 3. åˆ›å»ºå¹¶å‘å¸ƒäº‹ä»¶ =====
                var damageEvent = new BeforeDamageAppliedEvent(
                    health: __instance,
                    originalDamageInfo: damageInfo,
                    targetGameObject: targetGameObject,
                    targetCharacter: character,
                    characterId: characterId,
                    damageValue: originalDamageValue,
                    ignoreArmor: ignoreArmor,
                    ignoreDifficulty: ignoreDifficulty,
                    critRate: critRate,
                    critDamageFactor: critDamageFactor,
                    armorPiercing: armorPiercing
                );
                
                // ğŸ”¥ ä½¿ç”¨ GameContext çš„ EventBus å®ä¾‹ï¼ˆè€Œä¸æ˜¯ EventBus.Instance å•ä¾‹ï¼‰
                if (!GameContext.IsInitialized)
                {
                    return true;
                }
                
                var eventBus = GameContext.Instance.EventBus;
                eventBus.Publish(damageEvent);

                // ===== 4. æ£€æŸ¥æ˜¯å¦å–æ¶ˆä¼¤å®³ =====
                if (damageEvent.CancelDamage)
                {
                    return false;
                }

                // ===== 5. åº”ç”¨ä¿®æ”¹åçš„å‚æ•° =====
                // ğŸ”¥ å¯¹äºç»“æ„ä½“ï¼Œéœ€è¦åˆ›å»ºæ–°å®ä¾‹å¹¶é‡æ–°è£…ç®±
                bool modified = false;
                
                // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿®æ”¹
                if (System.Math.Abs(damageEvent.DamageValue - originalDamageValue) > 0.001f)
                {
                    modified = true;
                }
                if (ignoreArmorField != null && damageEvent.IgnoreArmor != ignoreArmor)
                {
                    modified = true;
                }
                if (ignoreDifficultyField != null && damageEvent.IgnoreDifficulty != ignoreDifficulty)
                {
                    modified = true;
                }
                if (critRateField != null && System.Math.Abs(damageEvent.CritRate - critRate) > 0.001f)
                {
                    modified = true;
                }
                if (critDamageFactorField != null && System.Math.Abs(damageEvent.CritDamageFactor - critDamageFactor) > 0.001f)
                {
                    modified = true;
                }
                if (armorPiercingField != null && System.Math.Abs(damageEvent.ArmorPiercing - armorPiercing) > 0.001f)
                {
                    modified = true;
                }

                if (modified)
                {
                    // åˆ›å»ºæ–°çš„ç»“æ„ä½“å®ä¾‹ï¼ˆå¤åˆ¶æ‰€æœ‰å­—æ®µï¼‰
                    object newDamageInfo = System.Activator.CreateInstance(damageInfoType);
                    
                    // å¤åˆ¶æ‰€æœ‰å­—æ®µï¼ˆåŒ…æ‹¬ä¿®æ”¹å’Œæœªä¿®æ”¹çš„ï¼‰
                    foreach (var field in damageInfoType.GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance))
                    {
                        object? value = field.GetValue(damageInfo);
                        field.SetValue(newDamageInfo, value);
                    }
                    
                    // åº”ç”¨ä¿®æ”¹çš„å­—æ®µ
                    damageValueField.SetValue(newDamageInfo, damageEvent.DamageValue);
                    if (ignoreArmorField != null)
                        ignoreArmorField.SetValue(newDamageInfo, damageEvent.IgnoreArmor);
                    if (ignoreDifficultyField != null)
                        ignoreDifficultyField.SetValue(newDamageInfo, damageEvent.IgnoreDifficulty);
                    if (critRateField != null)
                        critRateField.SetValue(newDamageInfo, damageEvent.CritRate);
                    if (critDamageFactorField != null)
                        critDamageFactorField.SetValue(newDamageInfo, damageEvent.CritDamageFactor);
                    if (armorPiercingField != null)
                        armorPiercingField.SetValue(newDamageInfo, damageEvent.ArmorPiercing);
                    
                    // ğŸ”¥ åŒæ—¶ä¿®æ”¹ ref å‚æ•°å’Œ __args æ•°ç»„
                    damageInfo = newDamageInfo;
                    
                    // ğŸ”¥ å…³é”®ï¼šé€šè¿‡ __args ä¿®æ”¹å®é™…ä¼ é€’ç»™æ–¹æ³•çš„å‚æ•°
                    if (__args != null && __args.Length > 0)
                    {
                        // æ‰¾åˆ° DamageInfo å‚æ•°çš„ä½ç½®
                        for (int i = 0; i < __args.Length; i++)
                        {
                            if (__args[i] != null && __args[i].GetType() == damageInfoType)
                            {
                                __args[i] = newDamageInfo;
                                break;
                            }
                        }
                    }
                }

                return true; // ç»§ç»­æ‰§è¡ŒåŸæ–¹æ³•
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[DamageModificationPatch] å¤„ç†ä¼¤å®³ä¿®æ”¹å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
                return true; // å‘ç”Ÿé”™è¯¯æ—¶ç»§ç»­æ‰§è¡ŒåŸæ–¹æ³•ï¼Œé¿å…æ¸¸æˆå´©æºƒ
            }
        }

        /// <summary>
        /// åç½®è¡¥ä¸ - åœ¨ä¼¤å®³åº”ç”¨åè§¦å‘äº‹ä»¶
        /// </summary>
        [HarmonyPostfix]
        static void Postfix(object __instance, object damageInfo)
        {
            try
            {
                // ===== 1. è·å–ç›®æ ‡è§’è‰²ä¿¡æ¯ =====
                var healthType = __instance.GetType();
                var tryGetCharacterMethod = AccessTools.Method(healthType, "TryGetCharacter");
                object? character = tryGetCharacterMethod?.Invoke(__instance, null);

                GameObject? targetGameObject = null;
                int? characterId = null;
                bool isRemotePlayer = false;
                bool isLocalPlayer = false;

                if (character != null && character is Component component)
                {
                    targetGameObject = component.gameObject;
                    isRemotePlayer = targetGameObject.name.Contains("[RemotePlayer]");
                    isLocalPlayer = targetGameObject.name.Contains("[LocalPlayer]");
                }

                // ===== 2. è·å–ä¼¤å®³å€¼å’Œå‰©ä½™ç”Ÿå‘½ =====
                var damageInfoType = damageInfo.GetType();
                var damageValueField = AccessTools.Field(damageInfoType, "damageValue");
                float actualDamage = damageValueField != null ? (float)damageValueField.GetValue(damageInfo) : 0f;

                var currentHealthProp = AccessTools.Property(healthType, "CurrentHealth");
                var maxHealthProp = AccessTools.Property(healthType, "MaxHealth");
                
                float remainingHealth = currentHealthProp != null ? (float)currentHealthProp.GetValue(__instance) : 0f;
                bool causedDeath = remainingHealth <= 0f;

                // ===== 3. å‘å¸ƒä¼¤å®³åº”ç”¨åäº‹ä»¶ =====
                var afterEvent = new AfterDamageAppliedEvent(
                    health: __instance,
                    damageInfo: damageInfo,
                    targetGameObject: targetGameObject,
                    targetCharacter: character,
                    characterId: characterId,
                    isRemotePlayer: isRemotePlayer,
                    isLocalPlayer: isLocalPlayer,
                    actualDamage: actualDamage,
                    remainingHealth: remainingHealth,
                    causedDeath: causedDeath
                );

                // ğŸ”¥ ä½¿ç”¨ GameContext çš„ EventBus å®ä¾‹
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.EventBus.Publish(afterEvent);
                }
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[DamageModificationPatch] å‘å¸ƒä¼¤å®³åº”ç”¨åäº‹ä»¶å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }
    }
}


```

`Client\Patches\DropOperationBroadcaster.cs`:

```cs
using HarmonyLib;
using ItemStatsSystem;
using UnityEngine;
using DuckyNet.Client.Services;
using DuckyNet.Client.Core;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// ç‰©å“ä¸¢å¼ƒæ“ä½œå¹¿æ’­å™¨
    /// å½“ç©å®¶ä¸¢å¼ƒç‰©å“æ—¶ï¼Œå°†æ“ä½œå¹¿æ’­åˆ°ç½‘ç»œä¸­çš„å…¶ä»–ç©å®¶
    /// é‡‡ç”¨ Postfix æ¨¡å¼ç¡®ä¿æ¸¸æˆåŸç”Ÿé€»è¾‘å®Œæˆåå†è¿›è¡Œç½‘ç»œåŒæ­¥
    /// </summary>
    [HarmonyPatch(typeof(ItemExtensions), nameof(ItemExtensions.Drop), new Type[] { typeof(Item), typeof(Vector3), typeof(bool), typeof(Vector3), typeof(float) })]
    public static class DropOperationBroadcaster
    {
        /// <summary>
        /// Postfix é’©å­ï¼šåœ¨ç‰©å“æˆåŠŸä¸¢å¼ƒåæ‰§è¡Œç½‘ç»œå¹¿æ’­
        /// </summary>
        [HarmonyPostfix]
        static void BroadcastDropOperation(
            Item item,
            Vector3 pos,
            bool createRigidbody,
            Vector3 dropDirection,
            float randomAngle,
            DuckovItemAgent __result)
        {
            // æ—©æœŸé€€å‡ºæ£€æŸ¥ - å¿«é€ŸéªŒè¯å‰ç½®æ¡ä»¶
            if (!ValidateOperationContext(item, __result))
            {
                return;
            }

            // è·å–åŒæ­¥æœåŠ¡
            var coordinator = GetItemNetworkCoordinator();
            if (coordinator == null)
            {
                return;
            }

            // é˜²æ­¢å¾ªç¯å¹¿æ’­ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºè¿œç¨‹åˆ›å»ºçš„ç‰©å“
            if (coordinator.IsRemoteCreating(item))
            {
                Debug.Log($"[DropOperationBroadcaster] å¿½ç•¥è¿œç¨‹æ¥æºç‰©å“: {item.DisplayName}");
                return;
            }

            // å¯åŠ¨å¼‚æ­¥å¹¿æ’­ä»»åŠ¡ï¼ˆéé˜»å¡ï¼‰
            _ = ExecuteBroadcastAsync(coordinator, item, pos, createRigidbody, dropDirection, randomAngle, __result);
        }

        /// <summary>
        /// éªŒè¯æ“ä½œä¸Šä¸‹æ–‡çš„æœ‰æ•ˆæ€§
        /// </summary>
        private static bool ValidateOperationContext(Item item, DuckovItemAgent resultAgent)
        {
            // æ¸¸æˆä¸Šä¸‹æ–‡å¿…é¡»å·²åˆå§‹åŒ–
            if (!GameContext.IsInitialized)
            {
                return false;
            }

            // å¿…é¡»å­˜åœ¨æœ¬åœ°ä¸»è§’è‰²
            if (CharacterMainControl.Main == null)
            {
                return false;
            }

            // ç‰©å“å’Œç»“æœä»£ç†å¿…é¡»æœ‰æ•ˆ
            if (item == null || resultAgent == null)
            {
                Debug.LogWarning("[DropOperationBroadcaster] æ— æ•ˆçš„ç‰©å“æˆ–ä»£ç†å¯¹è±¡");
                return false;
            }

            return true;
        }

        /// <summary>
        /// è·å–ç‰©å“ç½‘ç»œåè°ƒå™¨
        /// </summary>
        private static ItemNetworkCoordinator? GetItemNetworkCoordinator()
        {
            if (!GameContext.IsInitialized)
            {
                return null;
            }

            var coordinator = GameContext.Instance.ItemNetworkCoordinator;
            if (coordinator == null)
            {
                Debug.LogWarning("[DropOperationBroadcaster] ç‰©å“åŒæ­¥æœåŠ¡æœªå°±ç»ª");
                return null;
            }

            return coordinator;
        }

        /// <summary>
        /// å¼‚æ­¥æ‰§è¡Œç½‘ç»œå¹¿æ’­æ“ä½œ
        /// </summary>
        private static async Task ExecuteBroadcastAsync(
            ItemNetworkCoordinator coordinator,
            Item item,
            Vector3 position,
            bool withRigidbody,
            Vector3 direction,
            float angleVariation,
            DuckovItemAgent agentReference)
        {
            try
            {
                // å‘æœåŠ¡å™¨æäº¤ä¸¢å¼ƒè¯·æ±‚å¹¶è·å–å…¨å±€å”¯ä¸€æ ‡è¯†ç¬¦
                var globalDropIdentifier = await coordinator.DropItemAsync(
                    item, position, withRigidbody, direction, angleVariation);

                // å¤„ç†æœåŠ¡å™¨å“åº”
                if (globalDropIdentifier.HasValue && globalDropIdentifier.Value > 0)
                {
                    // åœ¨æœ¬åœ°æ³¨å†Œè¯¥ç‰©å“ä¸æœåŠ¡å™¨IDçš„æ˜ å°„å…³ç³»ï¼ˆç½‘ç»œåŒæ­¥ç‰©å“ï¼‰
                    coordinator.RegisterLocalDrop(globalDropIdentifier.Value, agentReference);
                    Debug.Log($"[DropOperationBroadcaster] ç½‘ç»œåŒæ­¥å®Œæˆ â†’ ID={globalDropIdentifier}, ç‰©å“={item.DisplayName}");
                }
                else
                {
                    // ä¸åœ¨æˆ¿é—´ä¸­ï¼Œç‰©å“ä»…æœ¬åœ°å¯è§ï¼ˆæ­£å¸¸æƒ…å†µï¼‰
                    Debug.Log($"[DropOperationBroadcaster] æœ¬åœ°ä¸¢å¼ƒï¼ˆä»…è‡ªå·±å¯è§ï¼‰ - ç‰©å“={item.DisplayName}");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DropOperationBroadcaster] å¹¿æ’­å¤±è´¥ â†’ ç‰©å“={item?.DisplayName ?? "Unknown"}\n" +
                              $"é”™è¯¯: {ex.Message}\n{ex.StackTrace}");
            }
        }
    }
}


```

`Client\Patches\EquipmentSlotPatch.cs`:

```cs
using System;
using HarmonyLib;
using ItemStatsSystem;
using ItemStatsSystem.Items;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// è£…å¤‡æ§½ä½è¡¥ä¸ - ç›‘æ§æœ¬åœ°ç©å®¶çš„è£…å¤‡æ§½ä½è¿›å…¥/é€€å‡º
    /// æ‹¦æˆª CharacterEquipmentController çš„è£…å¤‡å˜æ›´æ–¹æ³•
    /// ä»…å¤„ç†ä¸»è§’è‰²ï¼ˆæœ¬åœ°ç©å®¶ï¼‰çš„è£…å¤‡å˜æ›´ï¼Œå¿½ç•¥å…¶ä»–ç©å®¶å’ŒNPC
    /// </summary>
    [HarmonyPatch]
    public static class EquipmentSlotPatch
    {
        // ==================== æŠ¤ç”²æ§½ä½ ====================
        
        /// <summary>
        /// æŠ¤ç”²æ§½ä½å˜æ›´è¡¥ä¸
        /// </summary>
        [HarmonyPatch(typeof(CharacterEquipmentController), "ChangeArmorModel")]
        [HarmonyPostfix]
        private static void Postfix_ChangeArmorModel(CharacterEquipmentController __instance, Slot slot)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
                if (!IsMainCharacter(__instance))
                {
                    return;
                }

                if (slot?.Content != null)
                {
                    Debug.Log($"[è£…å¤‡è¡¥ä¸] æŠ¤ç”²å·²è£…å¤‡: {slot.Content.name}");
                }
                else
                {
                    Debug.Log("[è£…å¤‡è¡¥ä¸] æŠ¤ç”²å·²å¸ä¸‹");
                }

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishEquipmentEvent(new ArmorSlotChangedEvent(slot, slot?.Content, __instance));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] æŠ¤ç”²æ§½ä½å¤„ç†å¤±è´¥: {ex.Message}");
            }
        }

        // ==================== å¤´ç›”æ§½ä½ ====================
        
        /// <summary>
        /// å¤´ç›”æ§½ä½å˜æ›´è¡¥ä¸
        /// </summary>
        [HarmonyPatch(typeof(CharacterEquipmentController), "ChangeHelmatModel")]
        [HarmonyPostfix]
        private static void Postfix_ChangeHelmatModel(CharacterEquipmentController __instance, Slot slot)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
                if (!IsMainCharacter(__instance))
                {
                    return;
                }

                if (slot?.Content != null)
                {
                    Debug.Log($"[è£…å¤‡è¡¥ä¸] å¤´ç›”å·²è£…å¤‡: {slot.Content.name}");
                }
                else
                {
                    Debug.Log("[è£…å¤‡è¡¥ä¸] å¤´ç›”å·²å¸ä¸‹");
                }

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishEquipmentEvent(new HelmetSlotChangedEvent(slot, slot?.Content, __instance));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] å¤´ç›”æ§½ä½å¤„ç†å¤±è´¥: {ex.Message}");
            }
        }

        // ==================== é¢ç½©æ§½ä½ ====================
        
        /// <summary>
        /// é¢ç½©æ§½ä½å˜æ›´è¡¥ä¸
        /// </summary>
        [HarmonyPatch(typeof(CharacterEquipmentController), "ChangeFaceMaskModel")]
        [HarmonyPostfix]
        private static void Postfix_ChangeFaceMaskModel(CharacterEquipmentController __instance, Slot slot)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
                if (!IsMainCharacter(__instance))
                {
                    return;
                }

                if (slot?.Content != null)
                {
                    Debug.Log($"[è£…å¤‡è¡¥ä¸] é¢ç½©å·²è£…å¤‡: {slot.Content.name}");
                }
                else
                {
                    Debug.Log("[è£…å¤‡è¡¥ä¸] é¢ç½©å·²å¸ä¸‹");
                }

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishEquipmentEvent(new FaceMaskSlotChangedEvent(slot, slot?.Content, __instance));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] é¢ç½©æ§½ä½å¤„ç†å¤±è´¥: {ex.Message}");
            }
        }

        // ==================== èƒŒåŒ…æ§½ä½ ====================
        
        /// <summary>
        /// èƒŒåŒ…æ§½ä½å˜æ›´è¡¥ä¸
        /// </summary>
        [HarmonyPatch(typeof(CharacterEquipmentController), "ChangeBackpackModel")]
        [HarmonyPostfix]
        private static void Postfix_ChangeBackpackModel(CharacterEquipmentController __instance, Slot slot)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
                if (!IsMainCharacter(__instance))
                {
                    return;
                }

                if (slot?.Content != null)
                {
                    Debug.Log($"[è£…å¤‡è¡¥ä¸] èƒŒåŒ…å·²è£…å¤‡: {slot.Content.name}");
                }
                else
                {
                    Debug.Log("[è£…å¤‡è¡¥ä¸] èƒŒåŒ…å·²å¸ä¸‹");
                }

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishEquipmentEvent(new BackpackSlotChangedEvent(slot, slot?.Content, __instance));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] èƒŒåŒ…æ§½ä½å¤„ç†å¤±è´¥: {ex.Message}");
            }
        }

        // ==================== è€³æœºæ§½ä½ ====================
        
        /// <summary>
        /// è€³æœºæ§½ä½å˜æ›´è¡¥ä¸
        /// </summary>
        [HarmonyPatch(typeof(CharacterEquipmentController), "ChangeHeadsetModel")]
        [HarmonyPostfix]
        private static void Postfix_ChangeHeadsetModel(CharacterEquipmentController __instance, Slot slot)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
                if (!IsMainCharacter(__instance))
                {
                    return;
                }

                if (slot?.Content != null)
                {
                    Debug.Log($"[è£…å¤‡è¡¥ä¸] è€³æœºå·²è£…å¤‡: {slot.Content.name}");
                }
                else
                {
                    Debug.Log("[è£…å¤‡è¡¥ä¸] è€³æœºå·²å¸ä¸‹");
                }

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishEquipmentEvent(new HeadsetSlotChangedEvent(slot, slot?.Content, __instance));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] è€³æœºæ§½ä½å¤„ç†å¤±è´¥: {ex.Message}");
            }
        }

        // ==================== è¾…åŠ©æ–¹æ³• ====================
        
        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶çš„è£…å¤‡æ§åˆ¶å™¨
        /// </summary>
        private static bool IsMainCharacter(CharacterEquipmentController equipmentController)
        {
            if (equipmentController == null)
            {
                return false;
            }

            // æ–¹æ³• 1: é€šè¿‡ CharacterMainControl ç»„ä»¶æ£€æŸ¥
            var characterMainControl = equipmentController.GetComponent<CharacterMainControl>();
            if (characterMainControl != null)
            {
                return characterMainControl.IsMainCharacter;
            }

            // æ–¹æ³• 2: é€šè¿‡ LevelManager æ¯”å¯¹
            if (LevelManager.Instance != null && LevelManager.Instance.MainCharacter != null)
            {
                var mainEquipmentController = LevelManager.Instance.MainCharacter.EquipmentController;
                return equipmentController == mainEquipmentController;
            }

            return false;
        }

        /// <summary>
        /// å‘å¸ƒè£…å¤‡äº‹ä»¶åˆ° EventBus å¹¶åŒæ­¥åˆ°æœåŠ¡å™¨
        /// </summary>
        private static void PublishEquipmentEvent<T>(T equipmentEvent) where T : EquipmentSlotChangedEvent
        {
            // å¤šå±‚ç©ºå€¼æ£€æŸ¥ï¼Œç¡®ä¿ EventBus å·²æ­£ç¡®åˆå§‹åŒ–
            if (!GameContext.IsInitialized || 
                GameContext.Instance == null || 
                GameContext.Instance.EventBus == null)
            {
                #if DEBUG || UNITY_EDITOR
                Debug.LogWarning("[è£…å¤‡è¡¥ä¸] EventBus æœªåˆå§‹åŒ–ï¼Œè·³è¿‡äº‹ä»¶å‘å¸ƒ");
                #endif
                return;
            }

            try
            {
                // 1. å‘å¸ƒæœ¬åœ°äº‹ä»¶åˆ° EventBus
                GameContext.Instance.EventBus.Publish(equipmentEvent);
                
                // 2. åŒæ­¥åˆ°æœåŠ¡å™¨ï¼ˆå¼‚æ­¥ï¼Œä¸ç­‰å¾…ï¼‰
                SendEquipmentUpdateToServerAsync(equipmentEvent).ConfigureAwait(false);
                
                #if DEBUG || UNITY_EDITOR
                LogEquipmentChange(equipmentEvent);
                #endif
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] äº‹ä»¶å‘å¸ƒå¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// å‘é€è£…å¤‡æ›´æ–°åˆ°æœåŠ¡å™¨
        /// </summary>
        private static async System.Threading.Tasks.Task SendEquipmentUpdateToServerAsync<T>(T equipmentEvent) 
            where T : EquipmentSlotChangedEvent
        {
            try
            {
                var rpcClient = GameContext.Instance?.RpcClient;
                if (rpcClient == null)
                {
                    Debug.LogWarning("[è£…å¤‡è¡¥ä¸] RPC å®¢æˆ·ç«¯æœªåˆå§‹åŒ–ï¼Œè·³è¿‡æœåŠ¡å™¨åŒæ­¥");
                    return;
                }

                // è·å–è£…å¤‡ TypeID
                int? itemTypeId = null;
                if (equipmentEvent.EquippedItem is ItemStatsSystem.Item item)
                {
                    itemTypeId = item.TypeID;
                }

                // åˆ›å»ºè¯·æ±‚
                var request = new Shared.Data.EquipmentSlotUpdateRequest
                {
                    SlotType = equipmentEvent.SlotType,
                    ItemTypeId = itemTypeId
                };

                // åˆ›å»ºæœåŠ¡ä»£ç†
                var clientContext = new RPC.ClientServerContext(rpcClient);
                var equipmentService = new Shared.Services.Generated.EquipmentServiceClientProxy(clientContext);

                // å‘é€åˆ°æœåŠ¡å™¨
                bool success = await equipmentService.UpdateEquipmentSlotAsync(request);
                
                if (success)
                {
                    Debug.Log($"[è£…å¤‡è¡¥ä¸] âœ… è£…å¤‡æ›´æ–°å·²åŒæ­¥åˆ°æœåŠ¡å™¨: {equipmentEvent.SlotType}");
                }
                else
                {
                    Debug.LogWarning($"[è£…å¤‡è¡¥ä¸] âš ï¸ æœåŠ¡å™¨æ‹’ç»è£…å¤‡æ›´æ–°");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[è£…å¤‡è¡¥ä¸] åŒæ­¥åˆ°æœåŠ¡å™¨å¤±è´¥: {ex.Message}");
            }
        }

        #if DEBUG || UNITY_EDITOR
        /// <summary>
        /// è®°å½•è£…å¤‡å˜æ›´æ—¥å¿—ï¼ˆä»…è°ƒè¯•æ¨¡å¼ï¼‰
        /// </summary>
        private static void LogEquipmentChange<T>(T equipmentEvent) where T : EquipmentSlotChangedEvent
        {
            try
            {
                string action = equipmentEvent.IsEquipped ? "è£…å¤‡" : "å¸ä¸‹";
                string itemName = "æ— ";
                
                // å®‰å…¨çš„ç±»å‹è½¬æ¢ - æ£€æŸ¥æ˜¯å¦ä¸º Unity Object
                if (equipmentEvent.EquippedItem != null)
                {
                    if (equipmentEvent.EquippedItem is UnityEngine.Object unityObj)
                    {
                        // Unity Object æœ‰ name å±æ€§ï¼Œå¯ä»¥å®‰å…¨è®¿é—®
                        itemName = !string.IsNullOrEmpty(unityObj.name) 
                            ? unityObj.name 
                            : unityObj.GetType().Name;
                    }
                    else
                    {
                        // é Unity Objectï¼Œä½¿ç”¨ç±»å‹å
                        itemName = equipmentEvent.EquippedItem.GetType().Name;
                    }
                }
                
                Debug.Log($"[è£…å¤‡è¡¥ä¸] äº‹ä»¶å·²å‘å¸ƒ: {equipmentEvent.SlotType} - {action} - {itemName}");
            }
            catch (Exception ex)
            {
                // æ—¥å¿—è®°å½•å¤±è´¥ä¸åº”å½±å“ä¸»é€»è¾‘
                Debug.LogWarning($"[è£…å¤‡è¡¥ä¸] æ—¥å¿—è®°å½•å¤±è´¥: {ex.Message}");
            }
        }
        #endif
    }
}


```

`Client\Patches\HealthEventBridge.cs`:

```cs
using System;
using HarmonyLib;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// è¡€é‡äº‹ä»¶æ¡¥æ¥ - ç›´æ¥ Patch Health æ–¹æ³•æ¥ç›‘å¬è¡€é‡å˜åŒ–
    /// </summary>
    public static class HealthEventBridge
    {
        private static Type? _healthType;
        private static Type? _characterMainControlType;
        private static System.Reflection.PropertyInfo? _currentHealthProperty;
        private static System.Reflection.PropertyInfo? _maxHealthProperty;
        private static System.Reflection.PropertyInfo? _isMainCharacterProperty;
        private static System.Reflection.PropertyInfo? _isDeadProperty;
        private static System.Reflection.MethodInfo? _tryGetCharacterMethod;

        /// <summary>
        /// åˆå§‹åŒ–åå°„ç¼“å­˜
        /// </summary>
        private static void InitializeReflectionCache()
        {
            if (_healthType != null) return;

            _healthType = AccessTools.TypeByName("Health");
            _characterMainControlType = AccessTools.TypeByName("CharacterMainControl");

            if (_healthType != null)
            {
                _currentHealthProperty = AccessTools.Property(_healthType, "CurrentHealth");
                _maxHealthProperty = AccessTools.Property(_healthType, "MaxHealth");
                _isDeadProperty = AccessTools.Property(_healthType, "IsDead");
                _tryGetCharacterMethod = AccessTools.Method(_healthType, "TryGetCharacter");
            }

            if (_characterMainControlType != null)
            {
                _isMainCharacterProperty = AccessTools.Property(_characterMainControlType, "IsMainCharacter");
            }
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°ç©å®¶
        /// </summary>
        private static bool IsLocalPlayer(object? characterMainControl)
        {
            if (characterMainControl == null || _isMainCharacterProperty == null)
                return false;

            try
            {
                return (bool)(_isMainCharacterProperty.GetValue(characterMainControl) ?? false);
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// è·å–è§’è‰²ä¿¡æ¯
        /// </summary>
        private static (GameObject?, object?) GetCharacterInfo(object healthInstance)
        {
            GameObject? gameObject = null;
            object? characterMainControl = null;

            if (_tryGetCharacterMethod != null)
            {
                characterMainControl = _tryGetCharacterMethod.Invoke(healthInstance, null);
                if (characterMainControl is Component component)
                {
                    gameObject = component.gameObject;
                }
            }

            return (gameObject, characterMainControl);
        }

        #region Health.CurrentHealth Setter Patch

        /// <summary>
        /// ç›‘å¬è¡€é‡å˜åŒ– - Patch CurrentHealth å±æ€§çš„ Setter
        /// </summary>
        [HarmonyPatch]
        public static class CurrentHealthPatch
        {
            [HarmonyTargetMethod]
            static System.Reflection.MethodBase? TargetMethod()
            {
                InitializeReflectionCache();

                if (_healthType == null)
                {
                    Debug.LogWarning("[HealthEventBridge] æ‰¾ä¸åˆ° Health ç±»å‹");
                    return null;
                }

                var property = AccessTools.Property(_healthType, "CurrentHealth");
                if (property == null)
                {
                    Debug.LogWarning("[HealthEventBridge] æ‰¾ä¸åˆ° Health.CurrentHealth å±æ€§");
                    return null;
                }

                return property.GetSetMethod();
            }

            [HarmonyPostfix]
            static void Postfix(object __instance)
            {
                try
                {
                    if (!GameContext.IsInitialized) return;

                    var (gameObject, character) = GetCharacterInfo(__instance);
                    bool isLocalPlayer = IsLocalPlayer(character);

                    float currentHealth = (float)(_currentHealthProperty?.GetValue(__instance) ?? 0f);
                    float maxHealth = (float)(_maxHealthProperty?.GetValue(__instance) ?? 0f);

                    var evt = new HealthChangedEvent(
                        __instance,
                        gameObject,
                        character,
                        isLocalPlayer,
                        currentHealth,
                        maxHealth);

                    GameContext.Instance.EventBus.Publish(evt);

                    #if DEBUG || UNITY_EDITOR
                    if (isLocalPlayer)
                    {
                        // Debug.Log($"[HealthEventBridge] ğŸ’š è¡€é‡å˜åŒ–: {currentHealth:F0}/{maxHealth:F0}");
                    }
                    #endif
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[HealthEventBridge] CurrentHealth Setter å¤±è´¥: {ex.Message}");
                }
            }
        }

        #endregion

        #region Health.MaxHealth Setter Patch

        /// <summary>
        /// ç›‘å¬æœ€å¤§è¡€é‡å˜åŒ– - Patch MaxHealth å±æ€§çš„ Setter
        /// </summary>
        [HarmonyPatch]
        public static class MaxHealthPatch
        {
            [HarmonyTargetMethod]
            static System.Reflection.MethodBase? TargetMethod()
            {
                InitializeReflectionCache();

                if (_healthType == null)
                {
                    Debug.LogWarning("[HealthEventBridge] æ‰¾ä¸åˆ° Health ç±»å‹");
                    return null;
                }

                var property = AccessTools.Property(_healthType, "MaxHealth");
                if (property == null)
                {
                    Debug.LogWarning("[HealthEventBridge] æ‰¾ä¸åˆ° Health.MaxHealth å±æ€§");
                    return null;
                }

                return property.GetSetMethod();
            }

            [HarmonyPostfix]
            static void Postfix(object __instance)
            {
                try
                {
                    if (!GameContext.IsInitialized) return;

                    var (gameObject, character) = GetCharacterInfo(__instance);
                    bool isLocalPlayer = IsLocalPlayer(character);

                    float maxHealth = (float)(_maxHealthProperty?.GetValue(__instance) ?? 0f);

                    var evt = new MaxHealthChangedEvent(
                        __instance,
                        gameObject,
                        character,
                        isLocalPlayer,
                        maxHealth);

                    GameContext.Instance.EventBus.Publish(evt);

                    #if DEBUG || UNITY_EDITOR
                    if (isLocalPlayer)
                    {
                        Debug.Log($"[HealthEventBridge] ğŸ’ª æœ€å¤§è¡€é‡å˜åŒ–: {maxHealth:F0}");
                    }
                    #endif
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[HealthEventBridge] MaxHealth Setter å¤±è´¥: {ex.Message}");
                }
            }
        }

        #endregion

        #region Health.Hurt Method Patch

        /// <summary>
        /// ç›‘å¬å—ä¼¤ - Patch Hurt æ–¹æ³•
        /// </summary>
        [HarmonyPatch]
        public static class HurtPatch
        {
            [HarmonyTargetMethod]
            static System.Reflection.MethodBase? TargetMethod()
            {
                InitializeReflectionCache();

                if (_healthType == null)
                {
                    Debug.LogWarning("[HealthEventBridge] æ‰¾ä¸åˆ° Health ç±»å‹");
                    return null;
                }

                var method = AccessTools.Method(_healthType, "Hurt");
                if (method == null)
                {
                    Debug.LogWarning("[HealthEventBridge] æ‰¾ä¸åˆ° Health.Hurt æ–¹æ³•");
                    return null;
                }

                return method;
            }

            [HarmonyPostfix]
            static void Postfix(object __instance, object damageInfo, bool __result)
            {
                try
                {
                    // å¦‚æœæ²¡æœ‰é€ æˆä¼¤å®³ï¼Œç›´æ¥è¿”å›
                    if (!__result || !GameContext.IsInitialized) return;

                    var (gameObject, character) = GetCharacterInfo(__instance);
                    bool isLocalPlayer = IsLocalPlayer(character);

                    float currentHealth = (float)(_currentHealthProperty?.GetValue(__instance) ?? 0f);
                    float maxHealth = (float)(_maxHealthProperty?.GetValue(__instance) ?? 0f);

                    // å‘å¸ƒå—ä¼¤äº‹ä»¶
                    var hurtEvt = new CharacterHurtEvent(
                        __instance,
                        damageInfo,
                        gameObject,
                        character,
                        isLocalPlayer,
                        currentHealth,
                        maxHealth);

                    GameContext.Instance.EventBus.Publish(hurtEvt);

                    #if DEBUG || UNITY_EDITOR
                    if (isLocalPlayer)
                    {
                        Debug.Log($"[HealthEventBridge] ğŸ©¸ è§’è‰²å—ä¼¤: å‰©ä½™è¡€é‡ {currentHealth:F0}/{maxHealth:F0}");
                    }
                    #endif

                    // æ£€æŸ¥æ˜¯å¦æ­»äº¡
                    bool isDead = (bool)(_isDeadProperty?.GetValue(__instance) ?? false);
                    if (isDead)
                    {
                        var deadEvt = new CharacterDeadEvent(
                            __instance,
                            damageInfo,
                            gameObject,
                            character,
                            isLocalPlayer);

                        GameContext.Instance.EventBus.Publish(deadEvt);

                        #if DEBUG || UNITY_EDITOR
                        if (isLocalPlayer)
                        {
                            Debug.Log($"[HealthEventBridge] ğŸ’€ æœ¬åœ°ç©å®¶æ­»äº¡");
                        }
                        #endif
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[HealthEventBridge] Hurt Postfix å¤±è´¥: {ex.Message}");
                }
            }
        }

        #endregion
    }
}


```

`Client\Patches\InputBlockingPatch.cs`:

```cs
using System;
using HarmonyLib;
using UnityEngine;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// å±è”½æ¸¸æˆè¾“å…¥çš„è¡¥ä¸
    /// å½“èŠå¤©çª—å£æ‰“å¼€è¾“å…¥æ¡†æ—¶ï¼ŒåŒæ—¶ç¦ç”¨ CharacterInputControl å’Œ UIInputManager
    /// </summary>
    [HarmonyPatch]
    public static class InputBlockingPatch
    {
        private static bool _shouldBlockGameInput = false;
        private static bool _wasCharacterInputEnabled = true;
        private static bool _wasUIInputManagerEnabled = true;
        private static bool _wasPlayerInputEnabled = true; // è®°å½• GameManager.MainPlayerInput çŠ¶æ€

        /// <summary>
        /// æ˜¯å¦åº”è¯¥å±è”½æ¸¸æˆè¾“å…¥
        /// </summary>
        public static bool ShouldBlockGameInput
        {
            get => _shouldBlockGameInput;
            set
            {
                if (_shouldBlockGameInput != value)
                {
                    _shouldBlockGameInput = value;
                    UpdateInputControlState();
                }
            }
        }

        /// <summary>
        /// æ›´æ–°æ‰€æœ‰è¾“å…¥æ§åˆ¶å™¨çš„å¯ç”¨çŠ¶æ€
        /// </summary>
        private static void UpdateInputControlState()
        {
            try
            {
                // 1. ç¦ç”¨ CharacterInputControlï¼ˆè§’è‰²æ§åˆ¶ï¼šWASDã€å°„å‡»ç­‰ï¼‰
                var characterInput = CharacterInputControl.Instance;
                if (characterInput != null)
                {
                    if (_shouldBlockGameInput)
                    {
                        _wasCharacterInputEnabled = characterInput.enabled;
                        characterInput.enabled = false;
                        Debug.Log($"[InputBlockingPatch] å·²ç¦ç”¨ CharacterInputControl (ä¹‹å‰: {_wasCharacterInputEnabled})");
                    }
                    else
                    {
                        characterInput.enabled = _wasCharacterInputEnabled;
                        Debug.Log($"[InputBlockingPatch] å·²æ¢å¤ CharacterInputControl (æ¢å¤åˆ°: {_wasCharacterInputEnabled})");
                    }
                }
                else
                {
                    Debug.LogWarning("[InputBlockingPatch] CharacterInputControl.Instance ä¸º null");
                }

                // 2. ç¦ç”¨ UIInputManagerï¼ˆUI æ§åˆ¶ï¼šIã€Oã€Pã€M ç­‰ï¼‰
                var uiInputManager = UIInputManager.Instance;
                if (uiInputManager != null)
                {
                    if (_shouldBlockGameInput)
                    {
                        _wasUIInputManagerEnabled = uiInputManager.enabled;
                        uiInputManager.enabled = false;
                        Debug.Log($"[InputBlockingPatch] å·²ç¦ç”¨ UIInputManager (ä¹‹å‰: {_wasUIInputManagerEnabled})");
                    }
                    else
                    {
                        uiInputManager.enabled = _wasUIInputManagerEnabled;
                        Debug.Log($"[InputBlockingPatch] å·²æ¢å¤ UIInputManager (æ¢å¤åˆ°: {_wasUIInputManagerEnabled})");
                    }
                }
                else
                {
                    Debug.LogWarning("[InputBlockingPatch] UIInputManager.Instance ä¸º null");
                }

                // 3. ç»Ÿä¸€ç¦ç”¨ PlayerInputï¼ˆæœ€åº•å±‚ InputAction èµ„äº§é©±åŠ¨ï¼Œè¦†ç›–ä»æœªæ•è·çš„ I/O/P/M ç­‰åŠ¨ä½œï¼‰
                try
                {
                    var playerInput = GameManager.MainPlayerInput; // PlayerInput æ˜¯ Unity è¾“å…¥ç³»ç»Ÿå…¥å£
                    if (playerInput != null)
                    {
                        if (_shouldBlockGameInput)
                        {
                            _wasPlayerInputEnabled = playerInput.enabled;
                            if (playerInput.enabled)
                            {
                                playerInput.enabled = false;
                                Debug.Log("[InputBlockingPatch] å·²ç¦ç”¨ PlayerInput (é˜»æ–­æ‰€æœ‰ InputAction äº‹ä»¶)");
                            }
                        }
                        else
                        {
                            playerInput.enabled = _wasPlayerInputEnabled;
                            Debug.Log($"[InputBlockingPatch] å·²æ¢å¤ PlayerInput (æ¢å¤åˆ°: {_wasPlayerInputEnabled})");
                        }
                    }
                    else
                    {
                        Debug.LogWarning("[InputBlockingPatch] GameManager.MainPlayerInput ä¸º null");
                    }
                }
                catch (Exception e)
                {
                    Debug.LogError($"[InputBlockingPatch] åˆ‡æ¢ PlayerInput å¤±è´¥: {e.Message}");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[InputBlockingPatch] æ›´æ–°è¾“å…¥çŠ¶æ€å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// Patch CharacterInputControl.Update æ–¹æ³•ï¼ˆé¢å¤–ä¿é™©ï¼‰
        /// </summary>
        [HarmonyPatch(typeof(CharacterInputControl), "Update")]
        [HarmonyPrefix]
        public static bool CharacterInputControl_Update_Prefix()
        {
            return !_shouldBlockGameInput;
        }

        /// <summary>
        /// Patch InputManager.InputActived å±æ€§ï¼ˆé¢å¤–ä¿é™©ï¼‰
        /// </summary>
        [HarmonyPatch(typeof(InputManager), "InputActived", MethodType.Getter)]
        [HarmonyPostfix]
        public static void InputActived_Postfix(ref bool __result)
        {
            if (_shouldBlockGameInput)
            {
                __result = false;
            }
        }
    }
}


```

`Client\Patches\LocalPlayerShootBridge.cs`:

```cs
using System;
using System.Collections.Generic;
using HarmonyLib;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// æœ¬åœ°ç©å®¶å¼€æªæ¡¥æ¥å™¨
    /// ğŸ”¥ æ–¹æ¡ˆä¸€ï¼ˆé˜Ÿåˆ—æ‰¹å¤„ç†ï¼‰ï¼šé¿å…éœ°å¼¹æª/è¿å‘æ­¦å™¨çš„ç½‘ç»œè¯·æ±‚çˆ†ç‚¸
    /// 
    /// æ¶æ„è¯´æ˜ï¼š
    /// 1. ShootOneBulletPatch æ•è·æ¯å‘å­å¼¹çš„æ•£å°„æ•°æ® â†’ å…¥é˜Ÿ
    /// 2. OnMainCharacterShootEvent è§¦å‘æ—¶ â†’ æ‰¹é‡å¤„ç†é˜Ÿåˆ—
    /// 3. éœ°å¼¹æª 8 å‘å¼¹ä¸¸ â†’ åªéœ€ 1 æ¬¡æ‰¹é‡ RPC è°ƒç”¨ âœ…
    /// </summary>
    public class LocalPlayerShootBridge : IDisposable
    {
        private Type? _itemAgentGunType;
        private System.Reflection.PropertyInfo? _muzzleProperty;
        private Delegate? _shootEventHandler;
        private bool _initialized = false;

        /// <summary>
        /// å­å¼¹å¼€ç«æ•°æ®ç»“æ„
        /// </summary>
        public struct BulletFireData
        {
            public Vector3 MuzzlePosition;
            public Vector3 ScatteredDirection;
        }

        // ğŸ”¥ ä½¿ç”¨é˜Ÿåˆ—å­˜å‚¨å¤šå‘å­å¼¹çš„æ•£å°„æ•°æ®
        private static Queue<BulletFireData> _pendingBullets = new Queue<BulletFireData>();
        private static object? _currentGunInstance = null;

        public void Initialize()
        {
            try
            {
                if (_initialized)
                {
                    Debug.LogWarning("[LocalPlayerShootBridge] å·²ç»åˆå§‹åŒ–,è·³è¿‡é‡å¤åˆå§‹åŒ–");
                    return;
                }

                _itemAgentGunType = AccessTools.TypeByName("ItemAgent_Gun");
                if (_itemAgentGunType == null)
                {
                    Debug.LogError("[LocalPlayerShootBridge] æ‰¾ä¸åˆ° ItemAgent_Gun ç±»å‹");
                    return;
                }

                _muzzleProperty = AccessTools.Property(_itemAgentGunType, "muzzle");

                var shootEvent = _itemAgentGunType.GetEvent("OnMainCharacterShootEvent");
                if (shootEvent == null)
                {
                    Debug.LogWarning("[LocalPlayerShootBridge] æ‰¾ä¸åˆ° OnMainCharacterShootEvent äº‹ä»¶");
                    return;
                }

                var handlerType = shootEvent.EventHandlerType;
                if (handlerType != null)
                {
                    var method = GetType().GetMethod(nameof(OnPlayerShoot),
                        System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

                    if (method != null)
                    {
                        _shootEventHandler = Delegate.CreateDelegate(handlerType, this, method);
                        shootEvent.AddEventHandler(null, _shootEventHandler);

                        _initialized = true;
                        Debug.Log("[LocalPlayerShootBridge] âœ… å·²è®¢é˜… ItemAgent_Gun.OnMainCharacterShootEventï¼ˆé˜Ÿåˆ—æ‰¹å¤„ç†æ¨¡å¼ï¼‰");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[LocalPlayerShootBridge] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// å¼€æªäº‹ä»¶å¤„ç†å™¨ - æ‰¹é‡å¤„ç†é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰å­å¼¹
        /// ğŸ¯ OnMainCharacterShootEvent åœ¨æ‰€æœ‰ ShootOneBullet() å®Œæˆåè§¦å‘
        /// </summary>
        private void OnPlayerShoot(object gun)
        {
            try
            {
                if (gun == null || !GameContext.IsInitialized) return;

                // ğŸ”¥ å¤„ç†é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰å­å¼¹æ•°æ®
                if (_currentGunInstance == gun && _pendingBullets.Count > 0)
                {
                    Transform? muzzle = _muzzleProperty?.GetValue(gun) as Transform;

                    // ğŸ¯ æ‰¹é‡å‘é€æ‰€æœ‰å­å¼¹ï¼ˆä¸€æ¬¡ RPC è°ƒç”¨ï¼‰
                    SendBulletBatchToServer(gun, _pendingBullets);

                    // ğŸ¯ é€ä¸ªå‘å¸ƒåˆ° EventBusï¼ˆä¾›å®¢æˆ·ç«¯å…¶ä»–ç³»ç»Ÿä½¿ç”¨ï¼‰
                    while (_pendingBullets.Count > 0)
                    {
                        var bulletData = _pendingBullets.Dequeue();
                        var evt = new LocalPlayerShootEvent(gun, bulletData.MuzzlePosition, bulletData.ScatteredDirection, muzzle);
                        GameContext.Instance.EventBus.Publish(evt);
                    }

                    _currentGunInstance = null;
                    Debug.Log($"[LocalPlayerShootBridge] âœ… å·²æ‰¹é‡å¤„ç†æ‰€æœ‰å­å¼¹");
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[LocalPlayerShootBridge] å¤„ç†å¼€æªäº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ‰¹é‡å‘é€å­å¼¹æ•°æ®åˆ°æœåŠ¡å™¨
        /// ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šéœ°å¼¹æª 8 å‘å¼¹ä¸¸åªéœ€ 1 æ¬¡ RPC è°ƒç”¨
        /// </summary>
        private void SendBulletBatchToServer(object gun, Queue<BulletFireData> bullets)
        {
            try
            {
                if (!GameContext.IsInitialized || GameContext.Instance?.RpcClient == null)
                {
                    return;
                }

                if (bullets.Count == 0)
                {
                    return;
                }

                // è·å–æ¶ˆéŸ³å™¨çŠ¶æ€
                bool isSilenced = false;
                if (_itemAgentGunType != null)
                {
                    var silencedProperty = AccessTools.Property(_itemAgentGunType, "Silenced");
                    if (silencedProperty != null)
                    {
                        isSilenced = (bool)(silencedProperty.GetValue(gun) ?? false);
                    }
                }

                int bulletCount = bullets.Count;

                // ğŸ”¥ åˆ›å»ºæ‰¹é‡æ•°æ®ç»“æ„ï¼ˆé¿å… RPC æ•°ç»„åºåˆ—åŒ–é—®é¢˜ï¼‰
                var batchData = new WeaponFireBatchData
                {
                    BulletCount = bulletCount,
                    IsSilenced = isSilenced,
                    WeaponTypeId = 0,
                    MuzzlePositionsX = new float[bulletCount],
                    MuzzlePositionsY = new float[bulletCount],
                    MuzzlePositionsZ = new float[bulletCount],
                    DirectionsX = new float[bulletCount],
                    DirectionsY = new float[bulletCount],
                    DirectionsZ = new float[bulletCount]
                };

                // å¡«å……æ‰¹é‡æ•°æ®
                int index = 0;
                foreach (var bulletData in bullets)
                {
                    batchData.MuzzlePositionsX[index] = bulletData.MuzzlePosition.x;
                    batchData.MuzzlePositionsY[index] = bulletData.MuzzlePosition.y;
                    batchData.MuzzlePositionsZ[index] = bulletData.MuzzlePosition.z;
                    batchData.DirectionsX[index] = bulletData.ScatteredDirection.x;
                    batchData.DirectionsY[index] = bulletData.ScatteredDirection.y;
                    batchData.DirectionsZ[index] = bulletData.ScatteredDirection.z;
                    index++;
                }

                // ğŸš€ æ‰¹é‡å‘é€ï¼ˆä¸€æ¬¡ RPC è°ƒç”¨ï¼‰
                var clientContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                var weaponService = new Shared.Services.Generated.WeaponSyncServiceClientProxy(clientContext);
                weaponService.NotifyWeaponFireBatch(batchData);

                Debug.Log($"[LocalPlayerShootBridge] ğŸš€ æ‰¹é‡å‘é€å®Œæˆ: {bulletCount} å‘å­å¼¹ (1 æ¬¡ RPC è°ƒç”¨)");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[LocalPlayerShootBridge] æ‰¹é‡å‘é€å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// ä» Harmony Patch æ¥æ”¶æ•£å°„åçš„æ–¹å‘ï¼ˆæ¯å‘å­å¼¹è°ƒç”¨ä¸€æ¬¡ï¼‰
        /// ğŸ”¥ éœ°å¼¹æª/è¿å‘æ­¦å™¨ä¼šå¤šæ¬¡è°ƒç”¨ï¼Œæ•°æ®æš‚å­˜åˆ°é˜Ÿåˆ—
        /// </summary>
        public static void OnBulletFired(object gunInstance, Vector3 muzzlePosition, Vector3 scatteredDirection)
        {
            _currentGunInstance = gunInstance;
            _pendingBullets.Enqueue(new BulletFireData
            {
                MuzzlePosition = muzzlePosition,
                ScatteredDirection = scatteredDirection
            });
        }

        public void Dispose()
        {
            try
            {
                if (!_initialized || _itemAgentGunType == null || _shootEventHandler == null) return;

                var shootEvent = _itemAgentGunType.GetEvent("OnMainCharacterShootEvent");
                if (shootEvent != null)
                {
                    shootEvent.RemoveEventHandler(null, _shootEventHandler);
                }

                _shootEventHandler = null;
                _initialized = false;
                _pendingBullets.Clear();
                Debug.Log("[LocalPlayerShootBridge] å·²å–æ¶ˆè®¢é˜…å¼€æªäº‹ä»¶");
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[LocalPlayerShootBridge] æ¸…ç†å¤±è´¥: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// ShootOneBullet Patch - æ•è·æ¯å‘å­å¼¹çš„æ•£å°„æ–¹å‘å¹¶å…¥é˜Ÿ
    /// ä¸ç«‹å³å‘é€ï¼Œè€Œæ˜¯æ”¶é›†åˆ°é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾… OnMainCharacterShootEvent è§¦å‘åæ‰¹é‡å¤„ç†
    /// </summary>
    [HarmonyPatch]
    public static class ShootOneBulletPatch
    {
        static System.Reflection.MethodBase TargetMethod()
        {
            var type = AccessTools.TypeByName("ItemAgent_Gun");
            return AccessTools.Method(type, "ShootOneBullet");
        }

        /// <summary>
        /// Postfix - åœ¨æ¯å‘å­å¼¹å‘å°„åæ•è·æ•£å°„æ•°æ®
        /// </summary>
        /// <param name="__instance">ItemAgent_Gun å®ä¾‹</param>
        /// <param name="_muzzlePoint">æªå£ä½ç½®</param>
        /// <param name="_shootDirection">æ•£å°„åçš„å°„å‡»æ–¹å‘</param>
        /// <param name="firstFrameCheckStartPoint">ç¬¬ä¸€å¸§æ£€æµ‹èµ·ç‚¹</param>
        static void Postfix(
            object __instance,
            Vector3 _muzzlePoint,
            Vector3 _shootDirection,
            Vector3 firstFrameCheckStartPoint)
        {
            try
            {
                var holderProperty = AccessTools.Property(__instance.GetType(), "Holder");
                if (holderProperty != null)
                {
                    object? holder = holderProperty.GetValue(__instance);
                    if (holder != null)
                    {
                        var isMainCharacterProperty = AccessTools.Property(holder.GetType(), "IsMainCharacter");
                        bool isMainCharacter = (bool)(isMainCharacterProperty?.GetValue(holder) ?? false);

                        if (isMainCharacter)
                        {
                            LocalPlayerShootBridge.OnBulletFired(__instance, _muzzlePoint, _shootDirection);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[ShootOneBulletPatch] å¤„ç†å¤±è´¥: {ex.Message}");
            }
        }
    }
}

```

`Client\Patches\MovementPatch.cs`:

```cs
using HarmonyLib;
using UnityEngine;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// Movement è¡¥ä¸ - é˜²æ­¢è¿œç¨‹ç©å®¶ç§»åŠ¨
    /// é€šè¿‡æ£€æŸ¥ GameObject åç§°è·³è¿‡è¿œç¨‹ç©å®¶çš„ç§»åŠ¨æ›´æ–°
    /// </summary>
    [HarmonyPatch]
    public static class MovementPatch
    {
        /// <summary>
        /// è¿œç¨‹ç©å®¶åç§°æ ‡è®°
        /// </summary>
        public const string REMOTE_PLAYER_MARKER = "[RemotePlayer]";

        /// <summary>
        /// è·å– Movement ç±»å‹
        /// </summary>
        private static System.Type? GetMovementType()
        {
            return AccessTools.TypeByName("Movement");
        }

        /// <summary>
        /// åŠ¨æ€æŒ‡å®šè¦è¡¥ä¸çš„æ–¹æ³•
        /// </summary>
        [HarmonyTargetMethod]
        static System.Reflection.MethodBase? TargetMethod()
        {
            var type = GetMovementType();
            if (type == null)
            {
                Debug.LogWarning("[MovementPatch] æ‰¾ä¸åˆ° Movement ç±»å‹");
                return null;
            }

            var updateMethod = AccessTools.Method(type, "UpdateMovement");
            if (updateMethod == null)
            {
                Debug.LogWarning("[MovementPatch] æ‰¾ä¸åˆ° Movement.UpdateMovement æ–¹æ³•");
                return null;
            }

            Debug.Log("[MovementPatch] âœ… æˆåŠŸå®šä½ Movement.UpdateMovement æ–¹æ³•");
            return updateMethod;
        }

        /// <summary>
        /// å‰ç½®è¡¥ä¸ - æ£€æŸ¥æ˜¯å¦ä¸ºè¿œç¨‹ç©å®¶
        /// </summary>
        [HarmonyPrefix]
        static bool Prefix(object __instance)
        {
            try
            {
                // å°† __instance è½¬æ¢ä¸º Component
                if (__instance is Component component)
                {
                    // ä½¿ç”¨åç§°æ£€æŸ¥ï¼ˆé¿å… Tag æœªå®šä¹‰çš„é—®é¢˜ï¼‰
                    if (component.gameObject.name.Contains(REMOTE_PLAYER_MARKER))
                    {
                        // è·³è¿‡è¿œç¨‹ç©å®¶çš„ç§»åŠ¨æ›´æ–°
                        return false;
                    }
                }

                // å¯¹äºæœ¬åœ°ç©å®¶å’Œå…¶ä»–è§’è‰²ï¼Œç»§ç»­æ‰§è¡ŒåŸæ–¹æ³•
                return true;
            }
            catch (System.Exception)
            {
                // é™é»˜å¤„ç†å¼‚å¸¸ï¼Œé¿å…æ¯å¸§éƒ½è¾“å‡ºé”™è¯¯æ—¥å¿—
                return true; // å‡ºé”™æ—¶ç»§ç»­æ‰§è¡ŒåŸæ–¹æ³•
            }
        }
    }
}

```

`Client\Patches\PickupActionForwarder.cs`:

```cs
using HarmonyLib;
using ItemStatsSystem;
using UnityEngine;
using DuckyNet.Client.Services;
using DuckyNet.Client.Core;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// æ‹¾å–åŠ¨ä½œè½¬å‘å™¨
    /// æ‹¦æˆªç©å®¶æ‹¾å–äº¤äº’ï¼Œå°†ç½‘ç»œåŒæ­¥ç‰©å“çš„æ‹¾å–åŠ¨ä½œè½¬å‘åˆ°æœåŠ¡å™¨
    /// é‡‡ç”¨ Prefix æ¨¡å¼åœ¨ä»£ç†é”€æ¯å‰æ•è·ç½‘ç»œæ ‡è®°ä¿¡æ¯
    /// </summary>
    [HarmonyPatch(typeof(InteractablePickup), "OnInteractStart")]
    public static class PickupActionForwarder
    {
        /// <summary>
        /// Prefix é’©å­ï¼šåœ¨æ‹¾å–äº¤äº’å¼€å§‹å‰è½¬å‘ç½‘ç»œåŒæ­¥è¯·æ±‚
        /// å¿…é¡»åœ¨æ­¤é˜¶æ®µæ‰§è¡Œï¼Œå› ä¸ºäº¤äº’å®Œæˆå ItemAgent ä¼šè¢«é”€æ¯
        /// </summary>
        [HarmonyPrefix]
        static void ForwardPickupAction(InteractablePickup __instance, CharacterMainControl character)
        {
            // å¿«é€ŸéªŒè¯ï¼šæ£€æŸ¥åŸºç¡€å‰ç½®æ¡ä»¶
            if (!ShouldProcessPickup(character))
            {
                return;
            }

            // æå–ç‰©å“ä»£ç†å’Œç½‘ç»œæ ‡è®°ä¿¡æ¯
            var pickupContext = ExtractPickupContext(__instance);
            if (!pickupContext.IsValid)
            {
                return;
            }

            // éªŒè¯æ˜¯å¦ä¸ºç½‘ç»œåŒæ­¥ç‰©å“
            if (!pickupContext.HasNetworkTag)
            {
                // æœ¬åœ°ç‰©å“ï¼Œæ— éœ€åŒæ­¥
                return;
            }

            Debug.Log($"[PickupActionForwarder] æ£€æµ‹åˆ°ç½‘ç»œç‰©å“äº¤äº’ â†’ ID={pickupContext.NetworkId}, åç§°={pickupContext.ItemName}");

            // è·å–åŒæ­¥æœåŠ¡å¹¶è½¬å‘è¯·æ±‚
            var coordinator = GetItemNetworkCoordinator();
            if (coordinator != null)
            {
                _ = ForwardToServerAsync(coordinator, pickupContext.NetworkId, pickupContext.ItemName);
            }
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦åº”è¯¥å¤„ç†æ­¤æ‹¾å–æ“ä½œ
        /// </summary>
        private static bool ShouldProcessPickup(CharacterMainControl character)
        {
            // æ¸¸æˆä¸Šä¸‹æ–‡å¿…é¡»å·²åˆå§‹åŒ–
            if (!GameContext.IsInitialized)
            {
                return false;
            }

            // å¿…é¡»æ˜¯æœ¬åœ°ç©å®¶æ‰§è¡Œçš„æ“ä½œ
            if (CharacterMainControl.Main == null || character != CharacterMainControl.Main)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// æ‹¾å–ä¸Šä¸‹æ–‡ä¿¡æ¯
        /// </summary>
        private struct PickupContext
        {
            public bool IsValid;
            public uint NetworkId;
            public string ItemName;
            public bool HasNetworkTag;
        }

        /// <summary>
        /// æå–æ‹¾å–æ“ä½œçš„ä¸Šä¸‹æ–‡ä¿¡æ¯
        /// </summary>
        private static PickupContext ExtractPickupContext(InteractablePickup interactable)
        {
            var context = new PickupContext { IsValid = false };

            if (interactable == null || interactable.ItemAgent == null)
            {
                return context;
            }

            var agent = interactable.ItemAgent;
            var item = agent.Item;

            if (item == null)
            {
                return context;
            }

            // å°è¯•è·å–ç½‘ç»œæ ‡è®°
            var networkTag = agent.GetComponent<NetworkDropTag>();
            if (networkTag != null)
            {
                context.IsValid = true;
                context.NetworkId = networkTag.DropId;
                context.ItemName = item.DisplayName;
                context.HasNetworkTag = true;
            }
            else
            {
                // æœ¬åœ°ç‰©å“ï¼ˆæ— ç½‘ç»œæ ‡è®°ï¼‰
                context.IsValid = true;
                context.ItemName = item.DisplayName;
                context.HasNetworkTag = false;
            }

            return context;
        }

        /// <summary>
        /// è·å–ç‰©å“ç½‘ç»œåè°ƒå™¨
        /// </summary>
        private static ItemNetworkCoordinator? GetItemNetworkCoordinator()
        {
            if (!GameContext.IsInitialized)
            {
                return null;
            }

            var coordinator = GameContext.Instance.ItemNetworkCoordinator;
            if (coordinator == null)
            {
                Debug.LogWarning("[PickupActionForwarder] åŒæ­¥æœåŠ¡ä¸å¯ç”¨");
                return null;
            }

            return coordinator;
        }

        /// <summary>
        /// å¼‚æ­¥è½¬å‘æ‹¾å–è¯·æ±‚åˆ°æœåŠ¡å™¨
        /// </summary>
        private static async Task ForwardToServerAsync(ItemNetworkCoordinator coordinator, uint networkId, string itemName)
        {
            try
            {
                bool operationSuccess = await coordinator.PickupItemAsync(networkId);

                if (operationSuccess)
                {
                    Debug.Log($"[PickupActionForwarder] è½¬å‘æˆåŠŸ â†’ ID={networkId}, ç‰©å“={itemName}");
                }
                else
                {
                    Debug.LogWarning($"[PickupActionForwarder] è½¬å‘å¤±è´¥ â†’ ID={networkId}");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[PickupActionForwarder] å¼‚æ­¥è½¬å‘å¼‚å¸¸ â†’ ID={networkId}\n" +
                              $"é”™è¯¯: {ex.Message}\n{ex.StackTrace}");
            }
        }
    }
}


```

`Client\Patches\SceneEventBridge.cs`:

```cs
using System;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;
using UnityEngine;
using Duckov.Scenes;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// åœºæ™¯äº‹ä»¶æ¡¥æ¥å™¨ï¼šä»…è´Ÿè´£è½¬å‘è¿›å…¥/ç¦»å¼€åœ°å›¾äº‹ä»¶åˆ°å…¨å±€ EventBusã€‚
    /// </summary>
    public class SceneEventBridge : IDisposable
    {
        public void Initialize()
        {
            try
            {
                MultiSceneCore.OnSubSceneWillBeUnloaded += OnSubSceneWillBeUnloaded;
                MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
                Debug.Log("[SceneEventBridge] å·²è®¢é˜…åœºæ™¯äº‹ä»¶");
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[SceneEventBridge] è®¢é˜…åœºæ™¯äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        public void Dispose()
        {
            try
            {
                MultiSceneCore.OnSubSceneWillBeUnloaded -= OnSubSceneWillBeUnloaded;
                MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
            }
            catch { }
        }

        private void OnSubSceneWillBeUnloaded(MultiSceneCore core, UnityEngine.SceneManagement.Scene scene)
        {
            try
            {
                if (!GameContext.IsInitialized) return;

                string mainSceneName = core.gameObject.scene.name;
                string subSceneName = scene.name;

                Debug.Log($"[SceneEventBridge] å­åœºæ™¯å³å°†å¸è½½: {subSceneName}");
                GameContext.Instance.EventBus.Publish(new SceneUnloadingDetailEvent(new ScenelData(mainSceneName, subSceneName)));
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[SceneEventBridge] OnSubSceneWillBeUnloaded å¤±è´¥: {ex.Message}");
            }
        }

        private void OnSubSceneLoaded(MultiSceneCore core, UnityEngine.SceneManagement.Scene scene)
        {
            try
            {
                if (!GameContext.IsInitialized) return;

                string mainSceneName = core.gameObject.scene.name;
                string subSceneName = scene.name;

                Debug.Log($"[SceneEventBridge] å­åœºæ™¯åŠ è½½å®Œæˆ: {subSceneName}");
                GameContext.Instance.EventBus.Publish(new SceneLoadedDetailEvent(new ScenelData(mainSceneName, subSceneName)));
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[SceneEventBridge] OnSubSceneLoaded å¤±è´¥: {ex.Message}");
            }
        }
    }
}





```

`Client\Patches\WeaponSlotPatch.cs`:

```cs
using System;
using HarmonyLib;
using ItemStatsSystem;
using ItemStatsSystem.Items;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// æ­¦å™¨æ§½ä½è¡¥ä¸ - ç›‘æ§æœ¬åœ°ç©å®¶çš„æ­¦å™¨æ§½ä½è¿›å…¥/é€€å‡º
    /// æ‹¦æˆª Slot.Plug å’Œ Slot.Unplug æ–¹æ³•
    /// ä»…å¤„ç†ä¸»è§’è‰²ï¼ˆæœ¬åœ°ç©å®¶ï¼‰çš„æ­¦å™¨å˜æ›´ï¼Œå¿½ç•¥å…¶ä»–ç©å®¶å’ŒNPC
    /// </summary>
    [HarmonyPatch]
    public static class WeaponSlotPatch
    {
        // æ­¦å™¨æ§½ä½çš„ Hash å€¼ï¼ˆä¸ CharacterMainControl ä¸­å®šä¹‰çš„ä¸€è‡´ï¼‰
        private static readonly int PrimWeaponSlotHash = "PrimaryWeapon".GetHashCode();
        private static readonly int SecWeaponSlotHash = "SecondaryWeapon".GetHashCode();
        private static readonly int MeleeWeaponSlotHash = "MeleeWeapon".GetHashCode();

        // ==================== æ‹¦æˆª Slot.Plug æ–¹æ³• ====================

        /// <summary>
        /// æ‹¦æˆªç‰©å“æ’å…¥æ§½ä½çš„æ“ä½œ
        /// </summary>
        [HarmonyPatch(typeof(Slot), "Plug")]
        [HarmonyPostfix]
        private static void Postfix_Plug(Slot __instance, Item otherItem, bool __result)
        {
            try
            {
                // åªå¤„ç†æˆåŠŸçš„æ’å…¥æ“ä½œ
                if (!__result || otherItem == null)
                    return;

                // æ£€æŸ¥æ˜¯å¦ä¸ºæ­¦å™¨æ§½ä½
                if (!IsWeaponSlot(__instance))
                    return;

                // æ£€æŸ¥æ˜¯å¦ä¸ºä¸»è§’è‰²
                if (!IsMainCharacterSlot(__instance))
                    return;

                var slotType = GetWeaponSlotType(__instance);
                var slotTypeName = GetWeaponSlotTypeName(__instance);
                
                Debug.Log($"[æ­¦å™¨è¡¥ä¸] {slotTypeName}å·²è£…å¤‡: {otherItem.name}");

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishWeaponSlotEvent(new WeaponSlotChangedEvent(
                    __instance,
                    otherItem,
                    slotType,
                    slotTypeName,
                    isEquipped: true
                ));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[æ­¦å™¨è¡¥ä¸] Plug å¤„ç†å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        // ==================== æ‹¦æˆª Slot.Unplug æ–¹æ³• ====================

        /// <summary>
        /// æ‹¦æˆªç‰©å“ä»æ§½ä½ç§»é™¤çš„æ“ä½œ
        /// </summary>
        [HarmonyPatch(typeof(Slot), "Unplug")]
        [HarmonyPrefix]
        private static void Prefix_Unplug(Slot __instance)
        {
            try
            {
                // æ£€æŸ¥æ§½ä½æ˜¯å¦æœ‰å†…å®¹
                if (__instance?.Content == null)
                    return;

                // æ£€æŸ¥æ˜¯å¦ä¸ºæ­¦å™¨æ§½ä½
                if (!IsWeaponSlot(__instance))
                    return;

                // æ£€æŸ¥æ˜¯å¦ä¸ºä¸»è§’è‰²
                if (!IsMainCharacterSlot(__instance))
                    return;

                var slotType = GetWeaponSlotType(__instance);
                var slotTypeName = GetWeaponSlotTypeName(__instance);
                Item removedItem = __instance.Content;

                Debug.Log($"[æ­¦å™¨è¡¥ä¸] {slotTypeName}å·²å¸ä¸‹: {removedItem.name}");

                // å‘å¸ƒäº‹ä»¶åˆ° EventBus
                PublishWeaponSlotEvent(new WeaponSlotChangedEvent(
                    __instance,
                    removedItem,
                    slotType,
                    slotTypeName,
                    isEquipped: false
                ));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[æ­¦å™¨è¡¥ä¸] Unplug å¤„ç†å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        // ==================== è¾…åŠ©æ–¹æ³• ====================

        /// <summary>
        /// æ£€æŸ¥æ§½ä½æ˜¯å¦ä¸ºæ­¦å™¨æ§½ä½
        /// </summary>
        private static bool IsWeaponSlot(Slot slot)
        {
            if (slot == null)
                return false;

            int slotHash = slot.Key.GetHashCode();
            return slotHash == PrimWeaponSlotHash ||
                   slotHash == SecWeaponSlotHash ||
                   slotHash == MeleeWeaponSlotHash;
        }

        /// <summary>
        /// è·å–æ­¦å™¨æ§½ä½ç±»å‹æšä¸¾
        /// </summary>
        private static Shared.Data.WeaponSlotType GetWeaponSlotType(Slot slot)
        {
            if (slot == null)
                return Shared.Data.WeaponSlotType.PrimaryWeapon;

            int slotHash = slot.Key.GetHashCode();

            if (slotHash == PrimWeaponSlotHash)
                return Shared.Data.WeaponSlotType.PrimaryWeapon;
            if (slotHash == SecWeaponSlotHash)
                return Shared.Data.WeaponSlotType.SecondaryWeapon;
            if (slotHash == MeleeWeaponSlotHash)
                return Shared.Data.WeaponSlotType.MeleeWeapon;

            return Shared.Data.WeaponSlotType.PrimaryWeapon;
        }

        /// <summary>
        /// è·å–æ­¦å™¨æ§½ä½ç±»å‹åç§°ï¼ˆä¸­æ–‡ï¼‰
        /// </summary>
        private static string GetWeaponSlotTypeName(Slot slot)
        {
            if (slot == null)
                return "æœªçŸ¥";

            int slotHash = slot.Key.GetHashCode();

            if (slotHash == PrimWeaponSlotHash)
                return "ä¸»æ­¦å™¨";
            if (slotHash == SecWeaponSlotHash)
                return "å‰¯æ­¦å™¨";
            if (slotHash == MeleeWeaponSlotHash)
                return "è¿‘æˆ˜æ­¦å™¨";

            return "æœªçŸ¥æ­¦å™¨æ§½ä½";
        }

        /// <summary>
        /// æ£€æŸ¥æ§½ä½æ˜¯å¦å±äºä¸»è§’è‰²
        /// </summary>
        private static bool IsMainCharacterSlot(Slot slot)
        {
            if (slot == null)
                return false;

            // é€šè¿‡æ§½ä½çš„ Masterï¼ˆæ‰€å± Itemï¼‰æ‰¾åˆ°è§’è‰²
            var characterItem = slot.Master;
            if (characterItem == null)
                return false;

            // æ£€æŸ¥æ˜¯å¦ä¸ºä¸»è§’è‰²çš„ç‰©å“
            var mainCharacter = LevelManager.Instance?.MainCharacter;
            if (mainCharacter == null)
                return false;

            return characterItem == mainCharacter.CharacterItem;
        }

        /// <summary>
        /// å‘å¸ƒæ­¦å™¨æ§½ä½äº‹ä»¶åˆ° EventBus å¹¶åŒæ­¥åˆ°æœåŠ¡å™¨
        /// </summary>
        private static void PublishWeaponSlotEvent(WeaponSlotChangedEvent weaponEvent)
        {
            if (!GameContext.IsInitialized ||
                GameContext.Instance == null ||
                GameContext.Instance.EventBus == null)
            {
                #if DEBUG || UNITY_EDITOR
                Debug.LogWarning("[æ­¦å™¨è¡¥ä¸] EventBus æœªåˆå§‹åŒ–ï¼Œè·³è¿‡äº‹ä»¶å‘å¸ƒ");
                #endif
                return;
            }

            try
            {
                // 1. å‘å¸ƒæœ¬åœ°äº‹ä»¶åˆ° EventBus
                GameContext.Instance.EventBus.Publish(weaponEvent);

                // 2. åŒæ­¥åˆ°æœåŠ¡å™¨ï¼ˆå¼‚æ­¥ï¼Œä¸ç­‰å¾…ï¼‰
                SendWeaponUpdateToServerAsync(weaponEvent).ConfigureAwait(false);

                #if DEBUG || UNITY_EDITOR
                string action = weaponEvent.IsEquipped ? "è£…å¤‡" : "å¸ä¸‹";
                string itemName = "æ— ";

                if (weaponEvent.Weapon != null && weaponEvent.Weapon is UnityEngine.Object unityObj)
                {
                    itemName = !string.IsNullOrEmpty(unityObj.name)
                        ? unityObj.name
                        : unityObj.GetType().Name;
                }

                Debug.Log($"[æ­¦å™¨è¡¥ä¸] äº‹ä»¶å·²å‘å¸ƒ: {weaponEvent.SlotTypeName} - {action} - {itemName}");
                #endif
            }
            catch (Exception ex)
            {
                Debug.LogError($"[æ­¦å™¨è¡¥ä¸] äº‹ä»¶å‘å¸ƒå¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// å‘é€æ­¦å™¨æ›´æ–°åˆ°æœåŠ¡å™¨
        /// </summary>
        private static async System.Threading.Tasks.Task SendWeaponUpdateToServerAsync(WeaponSlotChangedEvent weaponEvent)
        {
            try
            {
                var rpcClient = GameContext.Instance?.RpcClient;
                if (rpcClient == null)
                {
                    Debug.LogWarning("[æ­¦å™¨è¡¥ä¸] RPC å®¢æˆ·ç«¯æœªåˆå§‹åŒ–ï¼Œè·³è¿‡æœåŠ¡å™¨åŒæ­¥");
                    return;
                }

                var clientContext = new RPC.ClientServerContext(rpcClient);
                var weaponService = new Shared.Services.Generated.WeaponSyncServiceClientProxy(clientContext);

                if (weaponEvent.IsEquipped && weaponEvent.Weapon != null)
                {
                    // è£…å¤‡æ­¦å™¨ - éœ€è¦åºåˆ—åŒ–å®Œæ•´ç‰©å“æ•°æ®
                    var weaponItem = weaponEvent.Weapon as Item;
                    if (weaponItem == null)
                    {
                        Debug.LogWarning("[æ­¦å™¨è¡¥ä¸] âš ï¸ æ­¦å™¨å¯¹è±¡ç±»å‹è½¬æ¢å¤±è´¥");
                        return;
                    }

                    var request = Services.WeaponSyncHelper.CreateWeaponSlotUpdateRequest(
                        weaponEvent.SlotType,
                        weaponItem
                    );

                    bool success = await weaponService.EquipWeaponAsync(request);

                    if (success)
                    {
                        Debug.Log($"[æ­¦å™¨è¡¥ä¸] âœ… æ­¦å™¨è£…å¤‡å·²åŒæ­¥åˆ°æœåŠ¡å™¨: {weaponEvent.SlotTypeName}");
                    }
                    else
                    {
                        Debug.LogWarning($"[æ­¦å™¨è¡¥ä¸] âš ï¸ æœåŠ¡å™¨æ‹’ç»æ­¦å™¨è£…å¤‡");
                    }
                }
                else
                {
                    // å¸ä¸‹æ­¦å™¨
                    var request = new Shared.Data.WeaponSlotUnequipRequest
                    {
                        SlotType = weaponEvent.SlotType
                    };

                    bool success = await weaponService.UnequipWeaponAsync(request);

                    if (success)
                    {
                        Debug.Log($"[æ­¦å™¨è¡¥ä¸] âœ… æ­¦å™¨å¸ä¸‹å·²åŒæ­¥åˆ°æœåŠ¡å™¨: {weaponEvent.SlotTypeName}");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[æ­¦å™¨è¡¥ä¸] åŒæ­¥åˆ°æœåŠ¡å™¨å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Patches\WeaponSwitchPatch.cs`:

```cs
using System;
using HarmonyLib;
using UnityEngine;
using DuckyNet.Client.Core;
using ItemStatsSystem;

namespace DuckyNet.Client.Patches
{
    /// <summary>
    /// æ­¦å™¨åˆ‡æ¢è¡¥ä¸ - ç›‘å¬æœ¬åœ°ç©å®¶çš„æ­¦å™¨åˆ‡æ¢æ“ä½œ
    /// æ‹¦æˆª ItemAgentHolder.ChangeHoldItem æ–¹æ³•æ¥åŒæ­¥å½“å‰æ‰‹æŒçš„æ­¦å™¨æ§½ä½
    /// è¿™æ˜¯æ‰€æœ‰æ­¦å™¨æ˜¾ç¤ºçš„æœ€ç»ˆè·¯å¾„ï¼Œæ¯” SwitchToWeapon æ›´å¯é 
    /// </summary>
    [HarmonyPatch]
    public static class WeaponSwitchPatch
    {
        /// <summary>
        /// æ‹¦æˆª ChangeHoldItem - æ‰€æœ‰æ­¦å™¨æ˜¾ç¤ºçš„æœ€ç»ˆè·¯å¾„
        /// </summary>
        [HarmonyPatch(typeof(ItemAgentHolder), "ChangeHoldItem")]
        [HarmonyPostfix]
        private static void Postfix_ChangeHoldItem(ItemAgentHolder __instance, Item item)
        {
            try
            {
                // æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
                if (!IsMainCharacter(__instance.characterController))
                    return;

                if (item == null)
                {
                    Debug.Log("[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] æ­¦å™¨å·²æ”¶èµ·");
                    // ä¸éœ€è¦åŒæ­¥æ”¶èµ·æ“ä½œï¼Œå› ä¸ºåˆ‡æ¢åˆ°ç©ºæ§½ä½ä¹Ÿæ˜¯ä¸€ç§"åˆ‡æ¢"
                    return;
                }

                // è·å–æ­¦å™¨æ‰€åœ¨çš„æ§½ä½ç´¢å¼•
                int slotIndex = GetWeaponSlotIndex(__instance.characterController, item);
                if (slotIndex == -999)
                {
                    Debug.LogWarning($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] æ— æ³•ç¡®å®šæ­¦å™¨æ§½ä½: {item.DisplayName}");
                    return;
                }

                string slotName = GetSlotName(slotIndex);
                Debug.Log($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] æ˜¾ç¤ºæ­¦å™¨: {item.DisplayName}, æ§½ä½: {slotIndex} ({slotName})");

                // å‘é€åˆ‡æ¢äº‹ä»¶åˆ°æœåŠ¡å™¨
                SendWeaponSwitchToServerAsync(slotIndex).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] å¤„ç†å¤±è´¥: {ex.Message}");
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ¬åœ°ç©å®¶
        /// </summary>
        private static bool IsMainCharacter(CharacterMainControl characterMainControl)
        {
            if (characterMainControl == null)
                return false;

            return characterMainControl.IsMainCharacter;
        }

        /// <summary>
        /// è·å–æ­¦å™¨æ‰€åœ¨çš„æ§½ä½ç´¢å¼•
        /// </summary>
        private static int GetWeaponSlotIndex(CharacterMainControl character, Item weapon)
        {
            if (character == null || weapon == null)
                return -999;

            // æ£€æŸ¥ä¸‰ä¸ªæ­¦å™¨æ§½ä½
            if (character.PrimWeaponSlot()?.Content == weapon)
                return 0;   // ä¸»æ­¦å™¨
            if (character.SecWeaponSlot()?.Content == weapon)
                return 1;   // å‰¯æ­¦å™¨
            if (character.MeleeWeaponSlot()?.Content == weapon)
                return -1;  // è¿‘æˆ˜æ­¦å™¨

            return -999; // æœªçŸ¥æ§½ä½
        }

        /// <summary>
        /// è·å–æ§½ä½åç§°
        /// </summary>
        private static string GetSlotName(int index)
        {
            return index switch
            {
                -1 => "è¿‘æˆ˜æ­¦å™¨",
                0 => "ä¸»æ­¦å™¨",
                1 => "å‰¯æ­¦å™¨",
                _ => "æœªçŸ¥"
            };
        }

        /// <summary>
        /// å°†æ­¦å™¨åˆ‡æ¢ç´¢å¼•è½¬æ¢ä¸º WeaponSlotType
        /// </summary>
        private static Shared.Data.WeaponSlotType? IndexToSlotType(int index)
        {
            return index switch
            {
                -1 => Shared.Data.WeaponSlotType.MeleeWeapon,
                0 => Shared.Data.WeaponSlotType.PrimaryWeapon,
                1 => Shared.Data.WeaponSlotType.SecondaryWeapon,
                _ => null
            };
        }

        /// <summary>
        /// å‘é€æ­¦å™¨åˆ‡æ¢åˆ°æœåŠ¡å™¨
        /// </summary>
        private static async System.Threading.Tasks.Task SendWeaponSwitchToServerAsync(int slotIndex)
        {
            try
            {
                if (!GameContext.IsInitialized || GameContext.Instance?.RpcClient == null)
                {
                    Debug.LogWarning("[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] RPC å®¢æˆ·ç«¯æœªåˆå§‹åŒ–");
                    return;
                }

                var slotType = IndexToSlotType(slotIndex);
                if (!slotType.HasValue)
                {
                    Debug.LogWarning($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] æ— æ•ˆçš„æ§½ä½ç´¢å¼•: {slotIndex}");
                    return;
                }

                // åˆ›å»ºè¯·æ±‚
                var request = new Shared.Data.WeaponSwitchRequest
                {
                    CurrentWeaponSlot = slotType.Value
                };

                // åˆ›å»ºæœåŠ¡ä»£ç†
                var clientContext = new RPC.ClientServerContext(GameContext.Instance.RpcClient);
                var weaponService = new Shared.Services.Generated.WeaponSyncServiceClientProxy(clientContext);

                // å‘é€åˆ°æœåŠ¡å™¨
                bool success = await weaponService.SwitchWeaponSlotAsync(request);

                if (success)
                {
                    Debug.Log($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] âœ… æ­¦å™¨åˆ‡æ¢å·²åŒæ­¥åˆ°æœåŠ¡å™¨: {slotType}");
                }
                else
                {
                    Debug.LogWarning($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] âš ï¸ æœåŠ¡å™¨æ‹’ç»æ­¦å™¨åˆ‡æ¢");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[æ­¦å™¨åˆ‡æ¢è¡¥ä¸] åŒæ­¥åˆ°æœåŠ¡å™¨å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\RPC\RpcClient.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;
using LiteNetLib;
using LiteNetLib.Utils;
using DuckyNet.Shared.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.RPC
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡å®ç°ï¼ˆç”¨äºè°ƒç”¨æœåŠ¡å™¨ï¼‰
    /// </summary>
    public class ClientServerContext : IClientContext
    {
        private readonly RpcClient _client;

        public string ClientId => GameContext.IsInitialized ? GameContext.Instance.PlayerManager.LocalPlayer.Info.SteamId : "local";
        public object NetPeer => _client;
        public ClientSessionState SessionState { get; internal set; } = ClientSessionState.Connected;
        public DateTime LastHeartbeat { get; internal set; } = DateTime.UtcNow;
        public bool IsDisconnected => !_client.IsConnected;
        public int ReconnectCount { get; internal set; } = 0;

        public ClientServerContext(RpcClient client)
        {
            _client = client;
        }

        public void Invoke<TService>(string methodName, params object[] parameters) where TService : class
        {
            _client.InvokeServer<TService>(methodName, parameters);
        }

        public async Task<TResult> InvokeAsync<TService, TResult>(string methodName, params object[] parameters) where TService : class
        {
            return await _client.InvokeServerAsync<TService, TResult>(methodName, parameters);
        }
    }

    /// <summary>
    /// RPC å®¢æˆ·ç«¯
    /// </summary>
    public class RpcClient : INetEventListener
    {
        private readonly NetManager _netManager;
        private readonly RpcInvoker _invoker;
        private readonly ConcurrentDictionary<int, TaskCompletionSource<RpcResponse>> _pendingCalls;
        private readonly RpcTimeoutManager _timeoutManager;
        private readonly ConnectionManager _connectionManager;
        private readonly RpcConfig _config;
        private NetPeer? _serverPeer;
        private int _nextMessageId = 1;
        private DateTime _connectionStartTime;
        private const int CONNECTION_TIMEOUT_MS = 5000; // 5ç§’è¿æ¥è¶…æ—¶

        public event Action? Connected;
        public event Action<string>? Disconnected;
        // public event Action<RpcConnectionState>? ConnectionStateChanged;  // æœªä½¿ç”¨ï¼Œå·²æ³¨é‡Š
        public event Action<string>? ConnectionFailed;

        public bool IsConnected => _connectionManager.State == RpcConnectionState.Connected;
        public RpcConnectionState ConnectionState => _connectionManager.State;

        public RpcClient(RpcConfig? config = null)
        {
            _config = config ?? RpcConfig.Default;
            _netManager = new NetManager(this);
            _invoker = new RpcInvoker();
            _pendingCalls = new ConcurrentDictionary<int, TaskCompletionSource<RpcResponse>>();
            _timeoutManager = new RpcTimeoutManager(_config.DefaultTimeoutMs);
            _connectionManager = new ConnectionManager();

            if (_config.EnableVerboseLogging)
            {
                Console.WriteLine($"[RpcClient] Initialized with timeout: {_config.DefaultTimeoutMs}ms");
            }
        }

        public void RegisterClientService<TService>(object serviceInstance) where TService : class
        {
            _invoker.RegisterService<TService>(serviceInstance);
            Console.WriteLine($"[RpcClient] Registered client service: {typeof(TService).Name}");
        }

        public void Connect(string address, int port)
        {
            try
            {
                _netManager.Start();
                _serverPeer = _netManager.Connect(address, port, string.Empty);
                _connectionManager.SetState(RpcConnectionState.Connecting);
                _connectionStartTime = DateTime.UtcNow;
                Console.WriteLine($"[RpcClient] Connecting to {address}:{port}...");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[RpcClient] Connect failed: {ex.Message}");
                _connectionManager.SetState(RpcConnectionState.Disconnected);
                var reason = $"è¿æ¥å¤±è´¥: {ex.Message}";
                
                // å‘å¸ƒ EventBus äº‹ä»¶
                PublishConnectionFailedEvent(reason);
                
                // ä¿æŒå‘åå…¼å®¹ï¼šåŒæ—¶è§¦å‘åŸæœ‰äº‹ä»¶
                ConnectionFailed?.Invoke(reason);
            }
        }

        public void Disconnect()
        {
            _serverPeer?.Disconnect();
            _netManager.Stop();
            _connectionManager.SetState(RpcConnectionState.Disconnected);
            
            // æ¸…ç†æ‰€æœ‰è¶…æ—¶
            foreach (var kvp in _pendingCalls)
            {
                _timeoutManager.ClearTimeout(kvp.Key);
            }
            
            Console.WriteLine("[RpcClient] Disconnected");
        }

        public void Update()
        {
            _netManager.PollEvents();
            
            // æ£€æŸ¥è¿æ¥è¶…æ—¶
            if (_connectionManager.State == RpcConnectionState.Connecting)
            {
                var elapsed = (DateTime.UtcNow - _connectionStartTime).TotalMilliseconds;
                if (elapsed > CONNECTION_TIMEOUT_MS)
                {
                    Console.WriteLine($"[RpcClient] Connection timeout after {CONNECTION_TIMEOUT_MS}ms");
                    _connectionManager.SetState(RpcConnectionState.Disconnected);
                    _netManager.Stop();
                    var timeoutReason = "è¿æ¥è¶…æ—¶";
                    
                    // å‘å¸ƒ EventBus äº‹ä»¶
                    PublishConnectionFailedEvent($"è¿æ¥è¶…æ—¶: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨");
                    PublishDisconnectedEvent(timeoutReason);
                    
                    // ä¿æŒå‘åå…¼å®¹ï¼šåŒæ—¶è§¦å‘åŸæœ‰äº‹ä»¶
                    ConnectionFailed?.Invoke($"è¿æ¥è¶…æ—¶: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨");
                    Disconnected?.Invoke(timeoutReason);
                }
            }
        }

        public void InvokeServer<TService>(string methodName, params object[] parameters) where TService : class
        {
            if (_serverPeer == null)
            {
                Console.WriteLine("[RpcClient] Not connected to server");
                return;
            }

            var serviceName = GetServiceName(typeof(TService));
            var message = new RpcMessage
            {
                MessageId = _nextMessageId++,
                ServiceName = serviceName,
                MethodName = methodName,
                Parameters = RpcSerializer.Instance.SerializeParameters(parameters)
            };

            SendMessage(message);

            if (_config.EnableVerboseLogging)
            {
                Console.WriteLine($"[RpcClient] Invoke: {serviceName}.{methodName}");
            }
        }

        public async Task<TResult> InvokeServerAsync<TService, TResult>(string methodName, params object[] parameters) where TService : class
        {
            if (_serverPeer == null)
            {
                throw new InvalidOperationException("Not connected to server");
            }

            var serviceName = GetServiceName(typeof(TService));
            var messageId = _nextMessageId++;
            var message = new RpcMessage
            {
                MessageId = messageId,
                ServiceName = serviceName,
                MethodName = methodName,
                Parameters = RpcSerializer.Instance.SerializeParameters(parameters)
            };

            var tcs = new TaskCompletionSource<RpcResponse>();
            _pendingCalls[messageId] = tcs;

            // è®¾ç½®è¶…æ—¶
            var timeoutToken = _timeoutManager.SetTimeout(messageId, _config.DefaultTimeoutMs);
            timeoutToken.Register(() =>
            {
                if (_pendingCalls.TryRemove(messageId, out var pendingTcs))
                {
                    pendingTcs.TrySetException(new TimeoutException(
                        $"RPC call '{methodName}' timed out after {_config.DefaultTimeoutMs}ms"));
                }
            });

            SendMessage(message);

            if (_config.EnableVerboseLogging)
            {
                Console.WriteLine($"[RpcClient] InvokeAsync: {serviceName}.{methodName}");
            }

            try
            {
                var response = await tcs.Task;
                _timeoutManager.ClearTimeout(messageId);

                if (!response.Success)
                {
                    throw new Exception($"RPC call failed: {response.ErrorMessage}");
                }

                if (response.Result == null)
                {
                    return default!;
                }

                return RpcSerializer.Instance.Deserialize<TResult>(response.Result);
            }
            catch
            {
                _timeoutManager.ClearTimeout(messageId);
                throw;
            }
        }

        private void SendMessage(RpcMessage message)
        {
            if (_serverPeer == null) return;

            var data = RpcSerializer.Instance.Serialize(message);
            _serverPeer.Send(data, DeliveryMethod.ReliableOrdered);
        }

        private void HandleMessage(byte[] data)
        {
            try
            {
                // ä½¿ç”¨ç±»å‹æ ‡è®°æ£€æµ‹æ¶ˆæ¯ç±»å‹ï¼ˆæ›´å¯é çš„æ–¹æ³•ï¼‰
                var messageType = RpcSerializer.Instance.DetectMessageType(data);
                
                if (messageType == RpcMessageType.Response)
                {
                    // æ˜ç¡®æ˜¯å“åº”æ¶ˆæ¯
                    try
                    {
                        var response = RpcSerializer.Instance.Deserialize<RpcResponse>(data);
                        if (response != null)
                        {
                            if (_pendingCalls.TryRemove(response.MessageId, out var tcs))
                            {
                                tcs.TrySetResult(response);
                                return; // æˆåŠŸå¤„ç†å“åº”
                            }
                            else
                            {
                                // å“åº”æ¶ˆæ¯ä½†æ²¡æœ‰å¯¹åº”çš„ pending callï¼ˆå¯èƒ½å·²è¶…æ—¶æˆ–é‡å¤ï¼‰
                                if (_config.EnableVerboseLogging)
                                {
                                    Console.WriteLine($"[RpcClient] Received RpcResponse with MessageId {response.MessageId}, but no pending call found (may be timeout or duplicate)");
                                }
                                return; // å¿½ç•¥æ— åŒ¹é…çš„å“åº”
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[RpcClient] Failed to deserialize RpcResponse: {ex.Message}");
                        if (ex.InnerException != null)
                        {
                            Console.WriteLine($"[RpcClient] Inner exception: {ex.InnerException.Message}");
                        }
                    }
                }
                else if (messageType == RpcMessageType.Request)
                {
                    // æ˜ç¡®æ˜¯è¯·æ±‚æ¶ˆæ¯ï¼ˆæœåŠ¡å™¨è°ƒç”¨å®¢æˆ·ç«¯ï¼‰
                    try
                    {
                        var message = RpcSerializer.Instance.Deserialize<RpcMessage>(data);
                        if (message != null)
                        {
                            HandleServerCall(message);
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[RpcClient] Failed to deserialize RpcMessage: {ex.Message}");
                        if (ex.InnerException != null)
                        {
                            Console.WriteLine($"[RpcClient] Inner exception: {ex.InnerException.Message}");
                        }
                    }
                }
                else
                {
                    // æ²¡æœ‰ç±»å‹æ ‡è®°æˆ–ç±»å‹æœªçŸ¥ï¼Œå°è¯•å…¼å®¹æ—§æ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼‰
                    // å…ˆå°è¯•ä½œä¸ºå“åº”ï¼ˆé€šå¸¸å“åº”æ›´å¸¸è§ï¼‰
                    try
                    {
                        var response = RpcSerializer.Instance.Deserialize<RpcResponse>(data);
                        if (response != null && _pendingCalls.TryRemove(response.MessageId, out var tcs))
                        {
                            tcs.TrySetResult(response);
                            return;
                        }
                    }
                    catch
                    {
                        // ä¸æ˜¯å“åº”ï¼Œç»§ç»­å°è¯•ä½œä¸ºè¯·æ±‚
                    }

                    // å°è¯•ä½œä¸ºè¯·æ±‚æ¶ˆæ¯
                    try
                    {
                        var message = RpcSerializer.Instance.Deserialize<RpcMessage>(data);
                        if (message != null)
                        {
                            HandleServerCall(message);
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[RpcClient] Failed to deserialize message (unknown type): {ex.Message}");
                        Console.WriteLine($"[RpcClient] Data length: {data?.Length ?? 0} bytes");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[RpcClient] Error handling message: {ex.Message}");
                if (ex.InnerException != null)
                {
                    RpcLog.Error($"[RpcClient] Inner exception: {ex.InnerException.Message}");
                }
            }
        }

        private void HandleServerCall(RpcMessage message)
        {
            try
            {
                // ååºåˆ—åŒ–å‚æ•°
                object?[]? parameters;
                try
                {
                    parameters = message.Parameters != null
                        ? RpcSerializer.Instance.DeserializeParameters(message.Parameters)
                        : Array.Empty<object>();
                    
                    // è°ƒè¯•æ—¥å¿—ï¼šæ‰“å°ååºåˆ—åŒ–åçš„å‚æ•°ç±»å‹ï¼ˆä»…åœ¨è¯¦ç»†æ¨¡å¼ä¸‹ï¼‰
                    if (parameters != null && _config.EnableVerboseLogging)
                    {
                        for (int i = 0; i < parameters.Length; i++)
                        {
                            Console.WriteLine($"[RpcClient] ååºåˆ—åŒ–å‚æ•°[{i}]: {parameters[i]?.GetType().FullName ?? "null"} = {parameters[i]}");
                        }
                    }
                }
                catch (Exception deserEx)
                {
                    Console.WriteLine($"[RpcClient] ååºåˆ—åŒ–å‚æ•°å¤±è´¥: {deserEx.Message}");
                    Console.WriteLine($"[RpcClient] æ–¹æ³•: {message.ServiceName}.{message.MethodName}");
                    Console.WriteLine($"[RpcClient] å‚æ•°æ•°æ®é•¿åº¦: {message.Parameters?.Length ?? 0} bytes");
                    if (deserEx.InnerException != null)
                    {
                        Console.WriteLine($"[RpcClient] å†…éƒ¨å¼‚å¸¸: {deserEx.InnerException.Message}");
                        if (deserEx.InnerException.StackTrace != null)
                        {
                            Console.WriteLine($"[RpcClient] å†…éƒ¨å †æ ˆ: {deserEx.InnerException.StackTrace}");
                        }
                    }
                    if (deserEx.StackTrace != null)
                    {
                        Console.WriteLine($"[RpcClient] å †æ ˆè·Ÿè¸ª: {deserEx.StackTrace}");
                    }
                    throw;
                }

                // è°ƒç”¨æœ¬åœ°æœåŠ¡æ–¹æ³•
                object? result;
                try
                {
                    result = _invoker.Invoke(message.ServiceName, message.MethodName, parameters, null);
                }
                catch (Exception invokeEx)
                {
                    Console.WriteLine($"[RpcClient] è°ƒç”¨æ–¹æ³•å¤±è´¥: {message.ServiceName}.{message.MethodName}");
                    Console.WriteLine($"[RpcClient] å‚æ•°æ•°é‡: {parameters?.Length ?? 0}");
                    if (parameters != null)
                    {
                        for (int i = 0; i < parameters.Length; i++)
                        {
                            Console.WriteLine($"[RpcClient]   å‚æ•°[{i}]: {parameters[i]?.GetType().FullName ?? "null"} = {parameters[i]}");
                        }
                    }
                    Console.WriteLine($"[RpcClient] é”™è¯¯: {invokeEx.Message}");
                    Console.WriteLine($"[RpcClient] å †æ ˆ: {invokeEx.StackTrace}");
                    throw;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯ VoidTaskResultï¼ˆä¸åº”è¯¥è¢«åºåˆ—åŒ–ï¼‰
                var resultType = result?.GetType();
                if (resultType != null && resultType.Name == "VoidTaskResult")
                {
                    result = null;
                }

                // å‘é€å“åº”
                var response = new RpcResponse
                {
                    MessageId = message.MessageId,
                    Success = true,
                    Result = result != null ? RpcSerializer.Instance.Serialize(result) : null,
                    ErrorMessage = null
                };

                SendResponse(response);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[RpcClient] Error handling server call '{message.ServiceName}.{message.MethodName}': {ex.Message}");
                if (ex.InnerException != null)
                {
                    Console.WriteLine($"[RpcClient] å†…éƒ¨å¼‚å¸¸: {ex.InnerException.Message}");
                }
                Console.WriteLine($"[RpcClient] Stack trace: {ex.StackTrace}");

                var errorResponse = new RpcResponse
                {
                    MessageId = message.MessageId,
                    Success = false,
                    Result = null,
                    ErrorMessage = ex.Message
                };

                SendResponse(errorResponse);
            }
        }

        private void SendResponse(RpcResponse response)
        {
            if (_serverPeer == null) return;

            var data = RpcSerializer.Instance.Serialize(response);
            _serverPeer.Send(data, DeliveryMethod.ReliableOrdered);
        }

        private string GetServiceName(Type serviceType)
        {
            var attr = serviceType.GetCustomAttributes(typeof(RpcServiceAttribute), false);
            if (attr.Length > 0 && attr[0] is RpcServiceAttribute rpcAttr)
            {
                return rpcAttr.ServiceName;
            }
            return serviceType.Name;
        }

        #region INetEventListener Implementation

        public void OnPeerConnected(NetPeer peer)
        {
            _serverPeer = peer;
            _connectionManager.SetState(RpcConnectionState.Connected);
            RpcLog.Info($"[RpcClient] Connected to server: {peer.Address}:{peer.Port}");
            
            // å‘å¸ƒ EventBus äº‹ä»¶ï¼ˆé€šè¿‡ NetworkLifecycleManager æ¥å‘å¸ƒï¼Œè¿™é‡Œåªè§¦å‘ RpcClient äº‹ä»¶ï¼‰
            // NetworkLifecycleManager ä¼šç›‘å¬ Connected äº‹ä»¶å¹¶å‘å¸ƒ NetworkConnectedEvent
            Connected?.Invoke();
        }

        public void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            _connectionManager.SetState(RpcConnectionState.Disconnected);

            // æ¸…ç†æ‰€æœ‰å¾…å¤„ç†çš„è°ƒç”¨
            foreach (var kvp in _pendingCalls)
            {
                kvp.Value.TrySetException(new Exception("Disconnected from server"));
                _timeoutManager.ClearTimeout(kvp.Key);
            }
            _pendingCalls.Clear();

            RpcLog.Info($"[RpcClient] Disconnected: {disconnectInfo.Reason}");
            var reason = disconnectInfo.Reason.ToString();
            
            // å‘å¸ƒ EventBus äº‹ä»¶ï¼ˆé€šè¿‡ NetworkLifecycleManager æ¥å‘å¸ƒï¼‰
            // NetworkLifecycleManager ä¼šç›‘å¬ Disconnected äº‹ä»¶å¹¶å‘å¸ƒ NetworkDisconnectedEvent
            Disconnected?.Invoke(reason);
        }

        public void OnNetworkError(System.Net.IPEndPoint endPoint, System.Net.Sockets.SocketError socketError)
        {
            RpcLog.Error($"[RpcClient] Network error: {socketError}");
            
            // å¦‚æœæ­£åœ¨è¿æ¥ä¸­ï¼Œå°†ç½‘ç»œé”™è¯¯è§†ä¸ºè¿æ¥å¤±è´¥
            if (_connectionManager.State == RpcConnectionState.Connecting)
            {
                _connectionManager.SetState(RpcConnectionState.Disconnected);
                _netManager.Stop();
                string errorMessage = GetSocketErrorMessage(socketError);
                
                // å‘å¸ƒ EventBus äº‹ä»¶
                PublishConnectionFailedEvent(errorMessage);
                PublishDisconnectedEvent(errorMessage);
                
                // ä¿æŒå‘åå…¼å®¹ï¼šåŒæ—¶è§¦å‘åŸæœ‰äº‹ä»¶
                ConnectionFailed?.Invoke(errorMessage);
                Disconnected?.Invoke(errorMessage);
            }
        }
        
        /// <summary>
        /// å‘å¸ƒè¿æ¥å¤±è´¥äº‹ä»¶åˆ° EventBus
        /// </summary>
        private void PublishConnectionFailedEvent(string reason)
        {
            try
            {
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.EventBus.Publish(new NetworkConnectionFailedEvent(reason));
                }
            }
            catch (Exception ex)
            {
                RpcLog.Error($"[RpcClient] å‘å¸ƒè¿æ¥å¤±è´¥äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å‘å¸ƒæ–­å¼€è¿æ¥äº‹ä»¶åˆ° EventBus
        /// </summary>
        private void PublishDisconnectedEvent(string reason)
        {
            try
            {
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.EventBus.Publish(new NetworkDisconnectedEvent(reason));
                }
            }
            catch (Exception ex)
            {
                RpcLog.Error($"[RpcClient] å‘å¸ƒæ–­å¼€è¿æ¥äº‹ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        private string GetSocketErrorMessage(System.Net.Sockets.SocketError error)
        {
            return error switch
            {
                System.Net.Sockets.SocketError.ConnectionRefused => "è¿æ¥è¢«æ‹’ç»: æœåŠ¡å™¨æœªè¿è¡Œæˆ–ç«¯å£é”™è¯¯",
                System.Net.Sockets.SocketError.HostNotFound => "ä¸»æœºæœªæ‰¾åˆ°: æœåŠ¡å™¨åœ°å€æ— æ•ˆ",
                System.Net.Sockets.SocketError.HostUnreachable => "ä¸»æœºä¸å¯è¾¾: æ— æ³•è®¿é—®æœåŠ¡å™¨",
                System.Net.Sockets.SocketError.NetworkUnreachable => "ç½‘ç»œä¸å¯è¾¾: æ£€æŸ¥ç½‘ç»œè¿æ¥",
                System.Net.Sockets.SocketError.TimedOut => "è¿æ¥è¶…æ—¶: æœåŠ¡å™¨æ— å“åº”",
                _ => $"ç½‘ç»œé”™è¯¯: {error}"
            };
        }

        public void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            var data = reader.GetRemainingBytes();
            HandleMessage(data);
        }

        public void OnNetworkReceiveUnconnected(System.Net.IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType)
        {
        }

        public void OnNetworkLatencyUpdate(NetPeer peer, int latency)
        {
        }

        public void OnConnectionRequest(ConnectionRequest request)
        {
        }

        #endregion
    }
}

```

`Client\Services\AnimatorSyncClientServiceImpl.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// åŠ¨ç”»åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// æ¥æ”¶è¿œç¨‹ç©å®¶åŠ¨ç”»çŠ¶æ€å¹¶åº”ç”¨åˆ°å¯¹åº”è§’è‰²
    /// </summary>
    public class AnimatorSyncClientServiceImpl : IAnimatorSyncClientService
    {
        // ç¼“å­˜å·²å¤„ç†çš„è¿œç¨‹ç©å®¶ï¼Œé¿å…é‡å¤ç¦ç”¨ç»„ä»¶
        private HashSet<string> _processedPlayers = new HashSet<string>();
        
        // ä¸ºæ¯ä¸ªè¿œç¨‹ç©å®¶ç¼“å­˜å¹³æ»‘ç»„ä»¶
        private Dictionary<string, RemoteAnimatorSmoother> _smoothers = new Dictionary<string, RemoteAnimatorSmoother>();

        /// <summary>
        /// æ¯å¸§æ›´æ–° - å¹³æ»‘æ’å€¼æ‰€æœ‰è¿œç¨‹ç©å®¶çš„åŠ¨ç”»å‚æ•°
        /// </summary>
        public void Update()
        {
            foreach (var smoother in _smoothers.Values)
            {
                smoother.Update();
            }
        }

        public void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData)
        {
            try
            {
                if (!Core.GameContext.IsInitialized)
                {
                    Debug.LogWarning($"[AnimatorSyncClientService] GameContext æœªåˆå§‹åŒ–ï¼Œè·³è¿‡ç©å®¶ {steamId} çš„åŠ¨ç”»");
                    return;
                }

                // Debug.Log($"[AnimatorSyncClientService] ğŸ“¥ æ”¶åˆ°è¿œç¨‹åŠ¨ç”» - PlayerId:{steamId}, State:{animatorData.StateHash}, Speed:{animatorData.GetFloatParam(0):F2}");

                // ğŸ¯ æ–°æ¶æ„ï¼šç›´æ¥å‘å¸ƒäº‹ä»¶åˆ° EventBusï¼Œç”± RemoteAnimatorSyncManager å¤„ç†
                if (Core.GameContext.Instance.EventBus != null)
                {
                    Core.GameContext.Instance.EventBus.Publish(
                        new RemoteAnimatorUpdateEvent(steamId, animatorData)
                    );
                    // Debug.Log($"[AnimatorSyncClientService] âœ… äº‹ä»¶å·²å‘å¸ƒåˆ° EventBus");
                }
                else
                {
                    Debug.LogError($"[AnimatorSyncClientService] âŒ EventBus ä¸ºç©ºï¼");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AnimatorSyncClientService] å‘å¸ƒåŠ¨ç”»äº‹ä»¶å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬ï¼ˆé˜²æ­¢æœ¬åœ°é€»è¾‘è¦†ç›–åŒæ­¥çš„åŠ¨ç”»å‚æ•°ï¼‰
        /// </summary>
        private void DisableAnimationControl(object characterObject)
        {
            try
            {
                if (!(characterObject is Component comp)) return;

                // ç¦ç”¨ CharacterAnimationControl
                var animControlType = HarmonyLib.AccessTools.TypeByName("CharacterAnimationControl");
                if (animControlType != null)
                {
                    var animControl = comp.GetComponentInChildren(animControlType) as MonoBehaviour;
                    if (animControl != null)
                    {
                        animControl.enabled = false;
                        Debug.Log($"[AnimatorSyncClientService] âœ… å·²ç¦ç”¨è¿œç¨‹ç©å®¶çš„ CharacterAnimationControl");
                    }
                }

                // ç¦ç”¨ CharacterAnimationControl_MagicBlendï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                var magicBlendType = HarmonyLib.AccessTools.TypeByName("CharacterAnimationControl_MagicBlend");
                if (magicBlendType != null)
                {
                    var magicBlend = comp.GetComponentInChildren(magicBlendType) as MonoBehaviour;
                    if (magicBlend != null)
                    {
                        magicBlend.enabled = false;
                        Debug.Log($"[AnimatorSyncClientService] âœ… å·²ç¦ç”¨è¿œç¨‹ç©å®¶çš„ CharacterAnimationControl_MagicBlend");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[AnimatorSyncClientService] ç¦ç”¨åŠ¨ç”»æ§åˆ¶è„šæœ¬å¤±è´¥: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// è¿œç¨‹ç©å®¶åŠ¨ç”»å¹³æ»‘å™¨ - æ¯å¸§æŒç»­åº”ç”¨åŠ¨ç”»å‚æ•°
    /// </summary>
    internal class RemoteAnimatorSmoother
    {
        private readonly Animator _animator;
        private AnimatorSyncData? _targetData;
        
        // å‚æ•°å“ˆå¸Œç¼“å­˜
        private readonly int _moveSpeedHash;
        private readonly int _moveDirXHash;
        private readonly int _moveDirYHash;
        private readonly int _handStateHash;
        private readonly int _dashingHash;
        private readonly int _rightHandOutHash;
        private readonly int _attackHash;
        private readonly int _gunReadyHash;
        
        public RemoteAnimatorSmoother(Animator animator)
        {
            _animator = animator;
            
            // é¢„è®¡ç®—å‚æ•°å“ˆå¸Œ
            _moveSpeedHash = Animator.StringToHash("MoveSpeed");
            _moveDirXHash = Animator.StringToHash("MoveDirX");
            _moveDirYHash = Animator.StringToHash("MoveDirY");
            _handStateHash = Animator.StringToHash("HandState");
            _dashingHash = Animator.StringToHash("Dashing");
            _rightHandOutHash = Animator.StringToHash("RightHandOut");
            _attackHash = Animator.StringToHash("Attack");
            _gunReadyHash = Animator.StringToHash("GunReady");
        }
        
        /// <summary>
        /// æ¥æ”¶æ–°çš„åŠ¨ç”»çŠ¶æ€
        /// </summary>
        public void OnReceiveAnimatorState(AnimatorSyncData syncData)
        {
            _targetData = syncData;
            
            // è°ƒè¯•æ—¥å¿—
            Debug.Log($"[RemoteAnimatorSmoother] æ”¶åˆ°åŠ¨ç”»çŠ¶æ€ - StateHash:{syncData.StateHash}, " +
                      $"MoveSpeed:{syncData.GetFloatParam(0):F2}, MoveDirX:{syncData.GetFloatParam(1):F2}, MoveDirY:{syncData.GetFloatParam(2):F2}, " +
                      $"Dashing:{syncData.GetBoolParam(0)}, RightHandOut:{syncData.GetBoolParam(1)}");
            
            // çŠ¶æ€åˆ‡æ¢ç«‹å³åº”ç”¨
            var currentState = _animator.GetCurrentAnimatorStateInfo(0);
            if (currentState.fullPathHash != syncData.StateHash)
            {
                // ä½¿ç”¨ CrossFade å¹³æ»‘è¿‡æ¸¡
                _animator.CrossFade(syncData.StateHash, 0.2f, 0, syncData.GetNormalizedTime());
                Debug.Log($"[RemoteAnimatorSmoother] åˆ‡æ¢çŠ¶æ€: {currentState.fullPathHash} â†’ {syncData.StateHash}");
            }
            
            // æ³¨æ„ï¼šæ‰€æœ‰å‚æ•°åœ¨ Update() ä¸­æ¯å¸§æŒç»­è®¾ç½®
        }
        
        /// <summary>
        /// æ¯å¸§æ›´æ–° - æŒç»­è®¾ç½®æ‰€æœ‰åŠ¨ç”»å‚æ•°
        /// </summary>
        public void Update()
        {
            if (_targetData == null || _animator == null) return;
            
            try
            {
                // Float å‚æ•° - æ¯å¸§ç›´æ¥è®¾ç½®ï¼ˆç§»é™¤ dampTimeï¼‰
                float moveSpeed = _targetData.GetFloatParam(0);
                float moveDirX = _targetData.GetFloatParam(1);
                float moveDirY = _targetData.GetFloatParam(2);
                
                _animator.SetFloat(_moveSpeedHash, moveSpeed);
                _animator.SetFloat(_moveDirXHash, moveDirX);
                _animator.SetFloat(_moveDirYHash, moveDirY);
                
                // Bool å‚æ•°æ¯å¸§æŒç»­è®¾ç½®ï¼ˆå…³é”®ï¼ï¼‰
                _animator.SetBool(_dashingHash, _targetData.GetBoolParam(0));
                _animator.SetBool(_rightHandOutHash, _targetData.GetBoolParam(1));
                _animator.SetBool(_attackHash, _targetData.GetBoolParam(2));
                _animator.SetBool(_gunReadyHash, _targetData.GetBoolParam(3));
                
                // æ¯ 60 å¸§è®°å½•ä¸€æ¬¡ï¼ˆçº¦ 1 ç§’ï¼‰
                if (Time.frameCount % 60 == 0)
                {
                    Debug.Log($"[RemoteAnimatorSmoother] Update - MoveSpeed:{moveSpeed:F2}, MoveDirX:{moveDirX:F2}, MoveDirY:{moveDirY:F2}, " +
                              $"Dashing:{_targetData.GetBoolParam(0)}, RightHandOut:{_targetData.GetBoolParam(1)}");
                }
                
                // Integer å‚æ•°ç›´æ¥è®¾ç½®
                _animator.SetInteger(_handStateHash, (int)_targetData.GetFloatParam(3));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[RemoteAnimatorSmoother] Update å¤±è´¥: {ex.Message}");
            }
        }
    }
}

```

`Client\Services\CharacterAppearanceClientServiceImpl.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// è§’è‰²å¤–è§‚å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// æ¥æ”¶æœåŠ¡å™¨æ¨é€çš„å¤–è§‚æ•°æ®å¹¶åº”ç”¨åˆ°è§’è‰²
    /// </summary>
    public class CharacterAppearanceClientServiceImpl : ICharacterAppearanceClientService
    {
        public void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData)
        {
            Debug.Log($"[CharacterAppearanceClientService] ğŸ“¦ æ”¶åˆ°æœåŠ¡å™¨æ¨é€çš„å¤–è§‚æ•°æ®: SteamId={steamId}");
            Debug.Log($"[CharacterAppearanceClientService] å¤–è§‚æ•°æ®è¯¦æƒ… - HeadScale: {appearanceData.HeadSetting.ScaleX}, Parts: {appearanceData.Parts.Length}");

            // é€šè¿‡äº‹ä»¶æ€»çº¿å‘å¸ƒå¤–è§‚æ¥æ”¶äº‹ä»¶
            if (GameContext.IsInitialized)
            {
                Debug.Log($"[CharacterAppearanceClientService] âœ… æ­£åœ¨å‘å¸ƒCharacterAppearanceReceivedEventäº‹ä»¶: {steamId}");
                GameContext.Instance.EventBus.Publish(new CharacterAppearanceReceivedEvent(steamId, appearanceData));
                Debug.Log($"[CharacterAppearanceClientService] âœ… äº‹ä»¶å·²å‘å¸ƒåˆ°EventBus");
            }
            else
            {
                Debug.LogError("[CharacterAppearanceClientService] âŒ GameContextæœªåˆå§‹åŒ–ï¼Œæ— æ³•å‘å¸ƒäº‹ä»¶ï¼");
            }
        }
    }

    /// <summary>
    /// è§’è‰²å¤–è§‚æ¥æ”¶äº‹ä»¶
    /// </summary>
    public class CharacterAppearanceReceivedEvent
    {
        public string SteamId { get; }
        public CharacterAppearanceData AppearanceData { get; }

        public CharacterAppearanceReceivedEvent(string steamId, CharacterAppearanceData appearanceData)
        {
            SteamId = steamId;
            AppearanceData = appearanceData;
        }
    }
}

```

`Client\Services\CharacterClientServiceImpl.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// è§’è‰²å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// </summary>
    public class CharacterClientServiceImpl : ICharacterClientService
    {
        public void OnPlayerAppearanceUpdated(string steamId, byte[] appearanceData)
        {
            try
            {
                Debug.Log($"[CharacterClientService] æ”¶åˆ°ç©å®¶å¤–è§‚æ›´æ–°: {steamId} ({appearanceData?.Length ?? 0} bytes)");

                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[CharacterClientService] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                if (steamId == localPlayer.Info.SteamId)
                {
                    Debug.Log("[CharacterClientService] è·³è¿‡æœ¬åœ°ç©å®¶å¤–è§‚æ›´æ–°");
                    return;
                }

                // å‘å¸ƒå¤–è§‚æ›´æ–°äº‹ä»¶ï¼ˆè€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ SceneManagerï¼‰
                if (appearanceData != null)
                {
                    GameContext.Instance.EventBus.Publish(new PlayerAppearanceUpdatedEvent(steamId, appearanceData));
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[CharacterClientService] å¤„ç†å¤–è§‚æ›´æ–°å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Services\EquipmentClientServiceImpl.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;
using ItemStatsSystem;
using Duckov.Utilities;
using UnityEngine;
using System;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// è£…å¤‡åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// æ¥æ”¶æ¥è‡ªæœåŠ¡å™¨çš„è£…å¤‡åŒæ­¥é€šçŸ¥
    /// </summary>
    public class EquipmentClientServiceImpl : IEquipmentClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„è£…å¤‡æ§½ä½æ›´æ–°é€šçŸ¥
        /// </summary>
        public void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[EquipmentClientService] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                // è¿‡æ»¤è‡ªå·±çš„æ›´æ–°ï¼ˆç†è®ºä¸ŠæœåŠ¡å™¨ä¸ä¼šå‘é€ï¼Œä½†åšåŒé‡æ£€æŸ¥ï¼‰
                var localPlayerId = GameContext.Instance.PlayerManager?.LocalPlayer?.Info.SteamId;
                if (!string.IsNullOrEmpty(localPlayerId) && localPlayerId == notification.PlayerId)
                {
                    Debug.Log("[EquipmentClientService] è·³è¿‡æœ¬åœ°ç©å®¶çš„è£…å¤‡æ›´æ–°");
                    return;
                }

                string action = notification.ItemTypeId.HasValue && notification.ItemTypeId.Value > 0 ? "è£…å¤‡" : "å¸ä¸‹";
                Debug.Log($"[EquipmentClientService] æ”¶åˆ°è£…å¤‡æ›´æ–°: ç©å®¶={notification.PlayerId}, æ§½ä½={notification.SlotType}, åŠ¨ä½œ={action}, TypeID={notification.ItemTypeId}");

                // è·å–è¿œç¨‹ç©å®¶
                var remotePlayer = GameContext.Instance.PlayerManager?.GetRemotePlayer(notification.PlayerId);
                if (remotePlayer == null)
                {
                    Debug.LogWarning($"[EquipmentClientService] æ‰¾ä¸åˆ°è¿œç¨‹ç©å®¶: {notification.PlayerId}");
                    return;
                }

                // æ›´æ–°è¿œç¨‹ç©å®¶çš„è£…å¤‡æ•°æ®
                remotePlayer.UpdateEquipmentSlot(notification.SlotType, notification.ItemTypeId);

                // å¦‚æœè§’è‰²å·²åˆ›å»ºï¼Œç«‹å³åº”ç”¨è£…å¤‡
                if (remotePlayer.CharacterObject != null)
                {
                    ApplyEquipmentToCharacter(remotePlayer, notification.SlotType, notification.ItemTypeId);
                }
                else
                {
                    Debug.Log($"[EquipmentClientService] è§’è‰²æœªåˆ›å»ºï¼Œè£…å¤‡æ•°æ®å·²ä¿å­˜ï¼Œå°†åœ¨åˆ›å»ºæ—¶åº”ç”¨");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentClientService] å¤„ç†è£…å¤‡æ›´æ–°å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// æ¥æ”¶æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶ï¼‰
        /// </summary>
        public void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[EquipmentClientService] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                Debug.Log($"[EquipmentClientService] æ”¶åˆ°æ‰¹é‡è£…å¤‡æ•°æ®: {allEquipmentData.PlayersEquipment.Count} ä¸ªç©å®¶");

                var playerManager = GameContext.Instance.PlayerManager;
                if (playerManager == null)
                {
                    Debug.LogWarning("[EquipmentClientService] PlayerManager æœªåˆå§‹åŒ–");
                    return;
                }

                // æ›´æ–°æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®
                foreach (var kvp in allEquipmentData.PlayersEquipment)
                {
                    string playerId = kvp.Key;
                    PlayerEquipmentData equipmentData = kvp.Value;

                    // è·³è¿‡è‡ªå·±
                    if (playerId == playerManager.LocalPlayer?.Info.SteamId)
                    {
                        Debug.Log($"[EquipmentClientService] è·³è¿‡æœ¬åœ°ç©å®¶çš„è£…å¤‡æ•°æ®");
                        continue;
                    }

                    // è·å–æˆ–åˆ›å»ºè¿œç¨‹ç©å®¶
                    var remotePlayer = playerManager.GetRemotePlayer(playerId);
                    if (remotePlayer == null)
                    {
                        Debug.LogWarning($"[EquipmentClientService] æ‰¾ä¸åˆ°è¿œç¨‹ç©å®¶: {playerId}ï¼Œè·³è¿‡è£…å¤‡æ•°æ®");
                        continue;
                    }

                    // æ›´æ–°è£…å¤‡æ•°æ®
                    remotePlayer.SetEquipmentData(equipmentData);

                    Debug.Log($"[EquipmentClientService] å·²æ›´æ–°ç©å®¶ {playerId} çš„è£…å¤‡æ•°æ®: {equipmentData.GetEquippedCount()} ä»¶è£…å¤‡");

                    // å¦‚æœè§’è‰²å·²åˆ›å»ºï¼Œç«‹å³åº”ç”¨æ‰€æœ‰è£…å¤‡
                    if (remotePlayer.CharacterObject != null)
                    {
                        ApplyAllEquipmentToCharacter(remotePlayer);
                    }
                }

                Debug.Log("[EquipmentClientService] âœ… æ‰¹é‡è£…å¤‡æ•°æ®å¤„ç†å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentClientService] å¤„ç†æ‰¹é‡è£…å¤‡æ•°æ®å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// åº”ç”¨å•ä¸ªè£…å¤‡åˆ°è§’è‰²
        /// </summary>
        private void ApplyEquipmentToCharacter(Core.Players.RemotePlayer remotePlayer, EquipmentSlotType slotType, int? itemTypeId)
        {
            try
            {
                var characterMainControl = remotePlayer.CharacterObject?.GetComponent<CharacterMainControl>();
                if (characterMainControl == null || characterMainControl.CharacterItem == null)
                {
                    Debug.LogWarning($"[EquipmentClientService] è§’è‰²ç»„ä»¶æ— æ•ˆ");
                    return;
                }

                int slotHash = GetSlotHash(slotType);
                var slot = characterMainControl.CharacterItem.Slots.GetSlot(slotHash);
                if (slot == null)
                {
                    Debug.LogWarning($"[EquipmentClientService] æ§½ä½ä¸å­˜åœ¨: {slotType}");
                    return;
                }

                if (itemTypeId.HasValue && itemTypeId.Value > 0)
                {
                    // è£…å¤‡æ–°ç‰©å“
                    bool success = Core.Utils.EquipmentTools.CreateAndEquip(
                        itemTypeId.Value,
                        slot,
                        unpluggedItem => unpluggedItem.DestroyTree()
                    );

                    if (success)
                    {
                        Debug.Log($"[EquipmentClientService] âœ… å·²åº”ç”¨è£…å¤‡: {slotType} = TypeID {itemTypeId.Value}");
                    }
                    else
                    {
                        Debug.LogWarning($"[EquipmentClientService] åº”ç”¨è£…å¤‡å¤±è´¥: {slotType}");
                    }
                }
                else
                {
                    // å¸ä¸‹è£…å¤‡
                    if (slot.Content != null)
                    {
                        var removed = slot.Unplug();
                        if (removed != null)
                        {
                            removed.DestroyTree();
                            Debug.Log($"[EquipmentClientService] âœ… å·²å¸ä¸‹è£…å¤‡: {slotType}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentClientService] åº”ç”¨è£…å¤‡å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åº”ç”¨æ‰€æœ‰è£…å¤‡åˆ°è§’è‰²
        /// </summary>
        private void ApplyAllEquipmentToCharacter(Core.Players.RemotePlayer remotePlayer)
        {
            try
            {
                var characterMainControl = remotePlayer.CharacterObject?.GetComponent<CharacterMainControl>();
                if (characterMainControl == null || characterMainControl.CharacterItem == null)
                {
                    Debug.LogWarning($"[EquipmentClientService] è§’è‰²ç»„ä»¶æ— æ•ˆ");
                    return;
                }

                var equipmentData = remotePlayer.GetEquipmentData();
                if (equipmentData == null)
                {
                    Debug.Log("[EquipmentClientService] è¯¥ç©å®¶æ²¡æœ‰è£…å¤‡æ•°æ®");
                    return;
                }

                Debug.Log($"[EquipmentClientService] å¼€å§‹åº”ç”¨æ‰€æœ‰è£…å¤‡: {equipmentData.GetEquippedCount()} ä»¶");

                int successCount = 0;
                foreach (var kvp in equipmentData.Equipment)
                {
                    EquipmentSlotType slotType = kvp.Key;
                    int itemTypeId = kvp.Value;

                    if (itemTypeId > 0)
                    {
                        ApplyEquipmentToCharacter(remotePlayer, slotType, itemTypeId);
                        successCount++;
                    }
                }

                Debug.Log($"[EquipmentClientService] âœ… è£…å¤‡åº”ç”¨å®Œæˆ: {successCount}/{equipmentData.GetEquippedCount()}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[EquipmentClientService] åº”ç”¨æ‰€æœ‰è£…å¤‡å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// è·å–æ§½ä½Hashå€¼
        /// </summary>
        private int GetSlotHash(EquipmentSlotType slotType)
        {
            return slotType switch
            {
                EquipmentSlotType.Armor => CharacterEquipmentController.armorHash,
                EquipmentSlotType.Helmet => CharacterEquipmentController.helmatHash,
                EquipmentSlotType.FaceMask => CharacterEquipmentController.faceMaskHash,
                EquipmentSlotType.Backpack => CharacterEquipmentController.backpackHash,
                EquipmentSlotType.Headset => CharacterEquipmentController.headsetHash,
                _ => 0
            };
        }
    }
}


```

`Client\Services\HealthSyncClientServiceImpl.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// è¡€é‡åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡å®ç°ç±»
    /// è´Ÿè´£å¤„ç†æœåŠ¡å™¨å‘å®¢æˆ·ç«¯å‘é€çš„è¡€é‡åŒæ­¥æ•°æ®
    /// </summary>
    public class HealthSyncClientServiceImpl : IHealthSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„è¡€é‡åŒæ­¥æ•°æ®å›è°ƒæ–¹æ³•
        /// ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œå½“æˆ¿é—´/åœºæ™¯å†…çš„å…¶ä»–ç©å®¶è¡€é‡å˜åŒ–æ—¶è§¦å‘
        /// </summary>
        /// <param name="healthData">å…¶ä»–ç©å®¶çš„è¡€é‡åŒæ­¥æ•°æ®</param>
        public void OnHealthSyncReceived(HealthSyncData healthData)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[HealthSyncClientService] GameContext æœªåˆå§‹åŒ–ï¼Œæ— æ³•å¤„ç†è¡€é‡åŒæ­¥");
                    return;
                }

                Debug.Log($"[HealthSyncClientService] ğŸ’š æ”¶åˆ°ç©å®¶ {healthData.SteamId} è¡€é‡åŒæ­¥: {healthData.CurrentHealth:F0}/{healthData.MaxHealth:F0} (æ­»äº¡:{healthData.IsDead})");

                // é€šè¿‡å…¨å±€ EventBus å‘å¸ƒè¡€é‡åŒæ­¥äº‹ä»¶
                GameContext.Instance.EventBus.Publish(new RemotePlayerHealthSyncEvent(healthData));
            }
            catch (Exception ex)
            {
                Debug.LogError($"[HealthSyncClientService] å¤„ç†è¡€é‡åŒæ­¥æ•°æ®å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Services\ItemNetworkCoordinator.cs`:

```cs
using UnityEngine;
using ItemStatsSystem;
using ItemStatsSystem.Data;
using Duckov.Utilities;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Services.Generated;
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Threading.Tasks;
using NetSerializer;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// ç‰©å“ç½‘ç»œåè°ƒå™¨ - åè°ƒæœ¬åœ°ä¸è¿œç¨‹ç©å®¶çš„ç‰©å“æ‰è½å’Œæ‹¾å–
    /// åŒ…å«ä¼˜åŒ–ï¼šå¯¹è±¡æ± ã€LZ4å‹ç¼©ã€å¢é‡åŒæ­¥
    /// </summary>
    public class ItemNetworkCoordinator
    {
        private readonly ItemSyncServiceClientProxy _itemSyncService;

        // æ ¸å¿ƒæ˜ å°„ï¼šDropId <-> Agent åŒå‘æ˜ å°„
        private readonly Dictionary<uint, DuckovItemAgent> _dropIdToAgent = new Dictionary<uint, DuckovItemAgent>();
        private readonly Dictionary<DuckovItemAgent, uint> _agentToDropId = new Dictionary<DuckovItemAgent, uint>();

        // çŠ¶æ€è¿½è¸ª
        private readonly HashSet<Item> _pendingDrops = new HashSet<Item>(); // é˜²æ­¢é‡å¤ä¸¢å¼ƒ
        private readonly HashSet<Item> _remoteCreating = new HashSet<Item>(); // é˜²æ­¢è¿œç¨‹ç‰©å“è§¦å‘æœ¬åœ°Drop patch

        // åºåˆ—åŒ–å™¨ï¼ˆå¤ç”¨ï¼Œé¿å…é‡å¤åˆ›å»ºï¼‰
        private readonly Serializer _serializer;

        public ItemNetworkCoordinator(ItemSyncServiceClientProxy itemSyncService)
        {
            _itemSyncService = itemSyncService ?? throw new ArgumentNullException(nameof(itemSyncService));

            // åˆå§‹åŒ– NetSerializerï¼ˆåªåˆ›å»ºä¸€æ¬¡ï¼‰
            _serializer = new Serializer(new[]
            {
                typeof(SerializableItemData),
                typeof(SerializableEntry),
                typeof(SerializableVariable),
                typeof(SerializableSlot),
                typeof(SerializableInventoryItem),
                typeof(List<SerializableEntry>),
                typeof(List<SerializableVariable>),
                typeof(List<SerializableSlot>),
                typeof(List<SerializableInventoryItem>),
                typeof(List<int>)
            });
        }

        #region æœ¬åœ°æ“ä½œ

        /// <summary>
        /// ä¸¢å¼ƒç‰©å“åˆ°åœºæ™¯
        /// </summary>
        public async Task<uint?> DropItemAsync(Item item, Vector3 position, bool createRigidbody, Vector3 dropDirection, float randomAngle)
        {
            if (item == null) return null;
            if (_pendingDrops.Contains(item))
            {
                Debug.LogWarning($"[ItemNetworkCoordinator] ç‰©å“æ­£åœ¨ä¸¢å¼ƒä¸­ï¼Œå¿½ç•¥é‡å¤è¯·æ±‚: {item.DisplayName}");
                return null;
            }

            _pendingDrops.Add(item);
            try
            {
                var dropData = CreateDropData(item, position, dropDirection, createRigidbody, randomAngle);

                // å¼‚æ­¥è°ƒç”¨æœåŠ¡å™¨è·å–DropId
                uint dropId = await _itemSyncService.DropItemAsync(dropData);

                if (dropId == 0)
                {
                    // ä¸åœ¨æˆ¿é—´ä¸­ï¼Œç‰©å“ä»…æœ¬åœ°å¯è§ï¼ˆè¿™æ˜¯æ­£å¸¸æƒ…å†µï¼‰
                    Debug.Log($"[ItemNetworkCoordinator] ç‰©å“ä»…æœ¬åœ°å¯è§ï¼ˆä¸åœ¨æˆ¿é—´ä¸­ï¼‰ - Item={item.DisplayName}");
                    return null; // è¿”å› null è¡¨ç¤ºä¸æ³¨å†Œç½‘ç»œæ˜ å°„
                }

                Debug.Log($"[ItemNetworkCoordinator] å‘é€ä¸¢å¼ƒæˆåŠŸ - DropId={dropId}, Item={item.DisplayName}");
                return dropId;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ItemNetworkCoordinator] å‘é€ä¸¢å¼ƒå¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return null;
            }
            finally
            {
                _pendingDrops.Remove(item);
            }
        }

        /// <summary>
        /// æ³¨å†Œæœ¬åœ°æ‰è½çš„ç‰©å“Agent
        /// </summary>
        public void RegisterLocalDrop(uint dropId, DuckovItemAgent agent)
        {
            if (agent == null || dropId == 0)
            {
                Debug.LogWarning($"[ItemNetworkCoordinator] æ³¨å†Œå¤±è´¥ - æ— æ•ˆå‚æ•°: DropId={dropId}, Agent={agent}");
                return;
            }

            // æ·»åŠ ç½‘ç»œæ ‡è®°
            var tag = agent.gameObject.GetOrAddComponent<NetworkDropTag>();
            tag.DropId = dropId;
            tag.IsLocalDrop = true;

            // å»ºç«‹åŒå‘æ˜ å°„
            AddToMapping(dropId, agent);

            Debug.Log($"[ItemNetworkCoordinator] æ³¨å†Œæœ¬åœ°ç‰©å“ - DropId={dropId}");
        }

        /// <summary>
        /// æ‹¾å–ç‰©å“ï¼ˆé€šçŸ¥æœåŠ¡å™¨ï¼‰
        /// </summary>
        public async Task<bool> PickupItemAsync(uint dropId)
        {
            try
            {
                var request = new ItemPickupRequest { DropId = dropId };

                // å¼‚æ­¥é€šçŸ¥æœåŠ¡å™¨
                bool success = await _itemSyncService.PickupItemAsync(request);

                Debug.Log($"[ItemNetworkCoordinator] æ‹¾å–è¯·æ±‚å·²å‘é€ - DropId={dropId}, Success={success}");
                return success;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ItemNetworkCoordinator] æ‹¾å–å¤±è´¥: {ex.Message}");
                return false;
            }
        }

        #endregion

        #region è¿œç¨‹äº‹ä»¶å¤„ç†

        /// <summary>
        /// å¤„ç†è¿œç¨‹ç©å®¶ä¸¢å¼ƒç‰©å“äº‹ä»¶
        /// </summary>
        public void OnRemoteItemDropped(ItemDropData dropData)
        {
            try
            {
                // è¿‡æ»¤è‡ªå·±çš„ç‰©å“ï¼ˆæœ¬åœ°å·²åˆ›å»ºï¼‰
                if (IsLocalPlayer(dropData.DroppedByPlayerId))
                {
                    Debug.Log($"[ItemNetworkCoordinator] è·³è¿‡æœ¬åœ°ç‰©å“ - DropId={dropData.DropId}");
                    return;
                }

                Debug.Log($"[ItemNetworkCoordinator] æ”¶åˆ°è¿œç¨‹æ‰è½ - DropId={dropData.DropId}, Item={dropData.ItemName}, Player={dropData.DroppedByPlayerId}");

                // åˆ›å»ºè¿œç¨‹ç‰©å“
                CreateRemoteItem(dropData);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ItemNetworkCoordinator] å¤„ç†è¿œç¨‹æ‰è½å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// å¤„ç†è¿œç¨‹ç©å®¶æ‹¾å–ç‰©å“äº‹ä»¶
        /// </summary>
        public void OnRemoteItemPickedUp(uint dropId, string playerId)
        {
            try
            {
                // è¿‡æ»¤è‡ªå·±çš„æ“ä½œï¼ˆæœ¬åœ°å·²å¤„ç†ï¼‰
                if (IsLocalPlayer(playerId))
                {
                    Debug.Log($"[ItemNetworkCoordinator] è·³è¿‡æœ¬åœ°æ‹¾å– - DropId={dropId}");
                    return;
                }

                Debug.Log($"[ItemNetworkCoordinator] æ”¶åˆ°è¿œç¨‹æ‹¾å– - DropId={dropId}, Player={playerId}");

                // é”€æ¯æœ¬åœ°çš„ç‰©å“Agent
                DestroyDroppedItem(dropId);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ItemNetworkCoordinator] å¤„ç†è¿œç¨‹æ‹¾å–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        #endregion

        #region æŸ¥è¯¢æ¥å£

        /// <summary>
        /// æ ¹æ®AgentæŸ¥æ‰¾DropId
        /// </summary>
        public uint? GetDropIdByAgent(DuckovItemAgent agent)
        {
            if (agent != null && _agentToDropId.TryGetValue(agent, out var dropId))
            {
                return dropId;
            }
            return null;
        }

        /// <summary>
        /// æ£€æŸ¥Itemæ˜¯å¦æ­£åœ¨è¢«è¿œç¨‹åˆ›å»º
        /// </summary>
        public bool IsRemoteCreating(Item item)
        {
            return _remoteCreating.Contains(item);
        }

        /// <summary>
        /// è·å–å½“å‰ç½‘ç»œç‰©å“æ•°é‡
        /// </summary>
        public int LocalDropCount => _agentToDropId.Count(kv => kv.Value > 0);

        public int RemoteDropCount => _dropIdToAgent.Count;

        public int PendingDropCount => _pendingDrops.Count;

        #endregion

        #region ç§æœ‰è¾…åŠ©æ–¹æ³•

        /// <summary>
        /// åˆ›å»ºä¸¢å¼ƒæ•°æ®ï¼ˆå«å¢é‡åŒæ­¥ä¼˜åŒ–ï¼‰
        /// </summary>
        private ItemDropData CreateDropData(Item item, Vector3 position, Vector3 direction, bool createRigidbody, float randomAngle)
        {
            var dropData = new ItemDropData
            {
                ItemTypeId = item.TypeID,
                ItemName = item.DisplayName,
                Position = ToSerializableVector3(position),
                Direction = ToSerializableVector3(direction),
                CreateRigidbody = createRigidbody,
                RandomAngle = randomAngle
            };

            // å¢é‡åŒæ­¥ä¼˜åŒ–ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“
            if (IsDefaultItem(item))
            {
                dropData.IsDefaultItem = true;
                dropData.ItemDataCompressed = string.Empty;
                Debug.Log($"[ItemNetworkCoordinator] å¢é‡åŒæ­¥ - é»˜è®¤ç‰©å“ï¼Œä¸ä¼ è¾“æ•°æ®: {item.DisplayName}");
            }
            else
            {
                dropData.IsDefaultItem = false;
                dropData.ItemDataCompressed = SerializeAndCompressItem(item);
                Debug.Log($"[ItemNetworkCoordinator] å®Œæ•´åŒæ­¥ - è‡ªå®šä¹‰ç‰©å“ï¼Œæ•°æ®é•¿åº¦={dropData.ItemDataCompressed.Length}");
            }

            return dropData;
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“ï¼ˆå¢é‡åŒæ­¥ä¼˜åŒ–ï¼‰
        /// </summary>
        private bool IsDefaultItem(Item item)
        {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ’æ§½å†…å®¹
            if (item.Slots != null)
            {
                foreach (var slot in item.Slots)
                {
                    if (slot.Content != null)
                    {
                        return false;
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰åº“å­˜ç‰©å“
            if (item.Inventory != null && item.Inventory.GetItemCount() > 0)
            {
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰å˜é‡ï¼ˆæ’é™¤é»˜è®¤çš„ Count=1ï¼‰
            if (item.Variables != null && item.Variables.Count > 0)
            {
                foreach (var variable in item.Variables)
                {
                    // è·³è¿‡é»˜è®¤çš„ Count=1
                    if (variable.Key == "Count" && variable.DataType == CustomDataType.Int && variable.GetInt() == 1)
                    {
                        continue;
                    }
                    // å‘ç°éé»˜è®¤å˜é‡
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// åºåˆ—åŒ–ç‰©å“ï¼ˆç§»é™¤ LZ4 å‹ç¼©ï¼Œç›´æ¥åºåˆ—åŒ–ï¼‰
        /// </summary>
        private string SerializeAndCompressItem(Item item)
        {
            SerializableItemData? simpleData = null;
            try
            {
                // ä»å¯¹è±¡æ± è·å–
                simpleData = SerializationPool.GetItemData();

                // ä½¿ç”¨ ItemTreeData è·å–å®Œæ•´ç‰©å“æ ‘
                var treeData = ItemTreeData.FromItem(item);
                simpleData.RootInstanceID = treeData.rootInstanceID;

                // è½¬æ¢ä¸ºå¯åºåˆ—åŒ–ç»“æ„
                foreach (var entry in treeData.entries)
                {
                    var simpleEntry = SerializationPool.GetEntry();
                    simpleEntry.InstanceID = entry.instanceID;
                    simpleEntry.TypeID = entry.typeID;

                    // è½¬æ¢ variables
                    foreach (var variable in entry.variables)
                    {
                        var simpleVar = SerializationPool.GetVariable();
                        simpleVar.Key = variable.Key ?? "";
                        simpleVar.DataType = (int)variable.DataType;

                        switch (variable.DataType)
                        {
                            case CustomDataType.Int:
                                simpleVar.IntValue = variable.GetInt();
                                break;
                            case CustomDataType.Float:
                                simpleVar.FloatValue = variable.GetFloat();
                                break;
                            case CustomDataType.String:
                                simpleVar.StringValue = variable.GetString() ?? "";
                                break;
                            case CustomDataType.Bool:
                                simpleVar.BoolValue = variable.GetBool();
                                break;
                        }

                        simpleEntry.Variables.Add(simpleVar);
                    }

                    // è½¬æ¢ slots
                    foreach (var slot in entry.slotContents)
                    {
                        var simpleSlot = SerializationPool.GetSlot();
                        simpleSlot.SlotName = slot.slot ?? "";
                        simpleSlot.ItemInstanceID = slot.instanceID;
                        simpleEntry.Slots.Add(simpleSlot);
                    }

                    // è½¬æ¢ inventory
                    foreach (var inv in entry.inventory)
                    {
                        var simpleInv = SerializationPool.GetInventoryItem();
                        simpleInv.Position = inv.position;
                        simpleInv.ItemInstanceID = inv.instanceID;
                        simpleEntry.Inventory.Add(simpleInv);
                    }

                    // è½¬æ¢ inventorySortLocks
                    simpleEntry.InventorySortLocks.AddRange(entry.inventorySortLocks);

                    simpleData.Entries.Add(simpleEntry);
                }

                // ğŸ”¥ ç®€åŒ–ï¼šç›´æ¥åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„ï¼Œä¸å‹ç¼©
                byte[] rawBytes;
                using (var ms = new MemoryStream())
                {
                    _serializer.Serialize(ms, simpleData);
                    rawBytes = ms.ToArray();
                }

                Debug.Log($"[ItemNetworkCoordinator] åºåˆ—åŒ–å®Œæˆ: {rawBytes.Length} bytes (æ— å‹ç¼©)");

                // Base64 ç¼–ç 
                return Convert.ToBase64String(rawBytes);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ItemNetworkCoordinator] åºåˆ—åŒ–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return "";
            }
            finally
            {
                // é‡Šæ”¾åˆ°å¯¹è±¡æ± 
                if (simpleData != null)
                {
                    SerializationPool.ReleaseItemData(simpleData);
                }
            }
        }

        /// <summary>
        /// ååºåˆ—åŒ–ç‰©å“ï¼ˆç§»é™¤ LZ4 è§£å‹ç¼©ï¼‰
        /// </summary>
        private Item? DecompressAndDeserializeItem(string base64Data, int itemTypeId)
        {
            try
            {
                if (string.IsNullOrEmpty(base64Data))
                {
                    Debug.LogError($"[ItemNetworkCoordinator] ååºåˆ—åŒ–å¤±è´¥ - Base64æ•°æ®ä¸ºç©º");
                    return null;
                }

                // ğŸ”¥ ç®€åŒ–ï¼šç›´æ¥ Base64 è§£ç ï¼Œä¸è§£å‹ç¼©
                byte[] rawBytes = Convert.FromBase64String(base64Data);

                Debug.Log($"[ItemNetworkCoordinator] ååºåˆ—åŒ–: {rawBytes.Length} bytes (æ— å‹ç¼©)");

                // ååºåˆ—åŒ–
                SerializableItemData simpleData;
                using (var ms = new MemoryStream(rawBytes))
                {
                    simpleData = (SerializableItemData)_serializer.Deserialize(ms);
                }

                // è½¬æ¢ä¸º ItemTreeData
                var treeData = new ItemTreeData
                {
                    rootInstanceID = simpleData.RootInstanceID,
                    entries = new List<ItemTreeData.DataEntry>()
                };

                foreach (var simpleEntry in simpleData.Entries)
                {
                    var entry = new ItemTreeData.DataEntry
                    {
                        instanceID = simpleEntry.InstanceID,
                        typeID = simpleEntry.TypeID,
                        variables = new List<CustomData>(),
                        slotContents = new List<ItemTreeData.SlotInstanceIDPair>(),
                        inventory = new List<ItemTreeData.InventoryDataEntry>(),
                        inventorySortLocks = new List<int>()
                    };

                    // æ¢å¤ variables
                    foreach (var simpleVar in simpleEntry.Variables)
                    {
                        CustomData? customData = null;
                        switch ((CustomDataType)simpleVar.DataType)
                        {
                            case CustomDataType.Int:
                                customData = new CustomData(simpleVar.Key, simpleVar.IntValue);
                                break;
                            case CustomDataType.Float:
                                customData = new CustomData(simpleVar.Key, simpleVar.FloatValue);
                                break;
                            case CustomDataType.String:
                                customData = new CustomData(simpleVar.Key, simpleVar.StringValue);
                                break;
                            case CustomDataType.Bool:
                                customData = new CustomData(simpleVar.Key, simpleVar.BoolValue);
                                break;
                        }
                        if (customData != null)
                        {
                            entry.variables.Add(customData);
                        }
                    }

                    // æ¢å¤ slots
                    foreach (var simpleSlot in simpleEntry.Slots)
                    {
                        entry.slotContents.Add(new ItemTreeData.SlotInstanceIDPair(
                            simpleSlot.SlotName,
                            simpleSlot.ItemInstanceID));
                    }

                    // æ¢å¤ inventory
                    foreach (var simpleInv in simpleEntry.Inventory)
                    {
                        entry.inventory.Add(new ItemTreeData.InventoryDataEntry(
                            simpleInv.Position,
                            simpleInv.ItemInstanceID));
                    }

                    // æ¢å¤ inventorySortLocks
                    entry.inventorySortLocks.AddRange(simpleEntry.InventorySortLocks);

                    treeData.entries.Add(entry);
                }

                Debug.Log($"[ItemNetworkCoordinator] ååºåˆ—åŒ–æˆåŠŸ - Entries={treeData.entries.Count}");

                // å®ä¾‹åŒ–ç‰©å“æ ‘
                var item = InstantiateItemTreeSync(treeData);

                if (item == null)
                {
                    Debug.LogError($"[ItemNetworkCoordinator] æ— æ³•åˆ›å»ºç‰©å“ - RootTypeId={treeData.RootTypeID}");
                    return null;
                }

                Debug.Log($"[ItemNetworkCoordinator] åˆ›å»ºç‰©å“æˆåŠŸ - TypeId={item.TypeID}, Name={item.DisplayName}");
                return item;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[ItemNetworkCoordinator] ååºåˆ—åŒ–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return null;
            }
        }

        /// <summary>
        /// åˆ›å»ºè¿œç¨‹ç‰©å“
        /// </summary>
        private void CreateRemoteItem(ItemDropData dropData)
        {
            Item? item = null;

            // å¢é‡åŒæ­¥ï¼šå¦‚æœæ˜¯é»˜è®¤ç‰©å“ï¼Œç›´æ¥åˆ›å»º
            if (dropData.IsDefaultItem)
            {
                Debug.Log($"[ItemNetworkCoordinator] åˆ›å»ºé»˜è®¤ç‰©å“ - TypeId={dropData.ItemTypeId}");
                item = ItemAssetsCollection.InstantiateSync(dropData.ItemTypeId);
            }
            else
            {
                // å®Œæ•´åŒæ­¥ï¼šååºåˆ—åŒ–å®Œæ•´ç‰©å“æ•°æ®
                item = DecompressAndDeserializeItem(dropData.ItemDataCompressed, dropData.ItemTypeId);
            }

            if (item == null)
            {
                Debug.LogError($"[ItemNetworkCoordinator] åˆ›å»ºç‰©å“å¤±è´¥ - DropId={dropData.DropId}");
                return;
            }

            // æ ‡è®°ä¸ºè¿œç¨‹åˆ›å»ºï¼Œé˜²æ­¢è§¦å‘Patch
            _remoteCreating.Add(item);
            try
            {
                var position = ToVector3(dropData.Position);
                var direction = ToVector3(dropData.Direction);

                var agent = ItemExtensions.Drop(item, position, dropData.CreateRigidbody, direction, dropData.RandomAngle);

                if (agent != null)
                {
                    // æ·»åŠ ç½‘ç»œæ ‡è®°
                    var tag = agent.gameObject.GetOrAddComponent<NetworkDropTag>();
                    tag.DropId = dropData.DropId;
                    tag.IsLocalDrop = false;

                    // å»ºç«‹æ˜ å°„
                    AddToMapping(dropData.DropId, agent);

                    Debug.Log($"[ItemNetworkCoordinator] è¿œç¨‹ç‰©å“åˆ›å»ºæˆåŠŸ - DropId={dropData.DropId}");
                }
            }
            finally
            {
                _remoteCreating.Remove(item);
            }
        }

        /// <summary>
        /// é”€æ¯æ‰è½çš„ç‰©å“
        /// </summary>
        private void DestroyDroppedItem(uint dropId)
        {
            if (_dropIdToAgent.TryGetValue(dropId, out var agent) && agent != null)
            {
                RemoveFromMapping(dropId, agent);
                UnityEngine.Object.Destroy(agent.gameObject);
                Debug.Log($"[ItemNetworkCoordinator] ç‰©å“å·²é”€æ¯ - DropId={dropId}");
            }
            else
            {
                Debug.LogWarning($"[ItemNetworkCoordinator] æœªæ‰¾åˆ°ç‰©å“ - DropId={dropId}");
            }
        }

        private void AddToMapping(uint dropId, DuckovItemAgent agent)
        {
            _dropIdToAgent[dropId] = agent;
            _agentToDropId[agent] = dropId;
        }

        private void RemoveFromMapping(uint dropId, DuckovItemAgent agent)
        {
            _dropIdToAgent.Remove(dropId);
            _agentToDropId.Remove(agent);
        }

        private bool IsLocalPlayer(string playerId)
        {
            var localPlayerId = Core.GameContext.Instance?.PlayerManager?.LocalPlayer?.Info.SteamId;
            return !string.IsNullOrEmpty(localPlayerId) && localPlayerId == playerId;
        }

        private SerializableVector3 ToSerializableVector3(Vector3 vector) =>
            new SerializableVector3(vector.x, vector.y, vector.z);

        private Vector3 ToVector3(SerializableVector3 position) =>
            new Vector3(position.X, position.Y, position.Z);

        #endregion

        #region ItemTreeData å®ä¾‹åŒ–

        /// <summary>
        /// åŒæ­¥å®ä¾‹åŒ–ç‰©å“æ ‘
        /// </summary>
        private Item? InstantiateItemTreeSync(ItemTreeData treeData)
        {
            var instanceMap = new Dictionary<int, Item>();

            // ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºæ‰€æœ‰ç‰©å“å®ä¾‹
            foreach (var entry in treeData.entries)
            {
                var item = ItemAssetsCollection.InstantiateSync(entry.typeID);
                if (item == null)
                {
                    Debug.LogError($"[ItemNetworkCoordinator] æ— æ³•åˆ›å»ºç‰©å“ TypeID={entry.typeID}");
                    return null;
                }

                // æ¢å¤å˜é‡
                foreach (var variable in entry.variables)
                {
                    item.Variables.Add(new CustomData(variable));
                }

                instanceMap[entry.instanceID] = item;
            }

            // ç¬¬äºŒæ­¥ï¼šå»ºç«‹ç‰©å“é—´çš„å…³ç³»
            foreach (var entry in treeData.entries)
            {
                var item = instanceMap[entry.instanceID];

                // æ¢å¤æ’æ§½å†…å®¹
                if (item.Slots != null)
                {
                    foreach (var slotPair in entry.slotContents)
                    {
                        if (instanceMap.TryGetValue(slotPair.instanceID, out var contentItem))
                        {
                            var slot = item.Slots.GetSlot(slotPair.slot);
                            if (slot != null)
                            {
                                slot.Plug(contentItem, out _);
                            }
                        }
                    }
                }

                // æ¢å¤èƒŒåŒ…å†…å®¹
                if (item.Inventory != null)
                {
                    foreach (var invEntry in entry.inventory)
                    {
                        if (instanceMap.TryGetValue(invEntry.instanceID, out var invItem))
                        {
                            item.Inventory.AddAt(invItem, invEntry.position);
                        }
                    }

                    // æ¢å¤æ’åºé”å®š
                    if (entry.inventorySortLocks != null)
                    {
                        foreach (var lockIndex in entry.inventorySortLocks)
                        {
                            item.Inventory.lockedIndexes.Add(lockIndex);
                        }
                    }
                }
            }

            // è¿”å›æ ¹ç‰©å“
            return instanceMap[treeData.rootInstanceID];
        }

        #endregion
    }

    /// <summary>
    /// ç½‘ç»œæ‰è½ç‰©å“æ ‡è®°ç»„ä»¶
    /// </summary>
    public class NetworkDropTag : MonoBehaviour
    {
        public uint DropId { get; set; }
        public bool IsLocalDrop { get; set; }
    }

    /// <summary>
    /// Unity GameObject æ‰©å±•æ–¹æ³•
    /// </summary>
    public static class GameObjectExtensions
    {
        public static T GetOrAddComponent<T>(this GameObject gameObject) where T : Component
        {
            var component = gameObject.GetComponent<T>();
            return component != null ? component : gameObject.AddComponent<T>();
        }
    }
}


```

`Client\Services\ItemSyncClientServiceImpl.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using UnityEngine;
using DuckyNet.Client.Core;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// ç‰©å“åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// æ¥æ”¶æ¥è‡ªæœåŠ¡å™¨çš„ç‰©å“åŒæ­¥é€šçŸ¥
    /// </summary>
    public class ItemSyncClientServiceImpl : IItemSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶è¿œç¨‹ç©å®¶ä¸¢å¼ƒç‰©å“çš„é€šçŸ¥
        /// </summary>
        public void OnRemoteItemDropped(ItemDropData dropData)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[ItemSyncClientServiceImpl] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                var coordinator = GameContext.Instance.ItemNetworkCoordinator;
                if (coordinator == null)
                {
                    Debug.LogWarning("[ItemSyncClientServiceImpl] ItemNetworkCoordinator æœªåˆå§‹åŒ–");
                    return;
                }

                Debug.Log($"[ItemSyncClientServiceImpl] æ”¶åˆ°è¿œç¨‹ç‰©å“ä¸¢å¼ƒé€šçŸ¥ - DropId={dropData.DropId}, Item={dropData.ItemName}");

                // è½¬å‘åˆ°åè°ƒå™¨å¤„ç†
                coordinator.OnRemoteItemDropped(dropData);
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[ItemSyncClientServiceImpl] å¤„ç†è¿œç¨‹ç‰©å“ä¸¢å¼ƒå¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// æ¥æ”¶è¿œç¨‹ç©å®¶æ‹¾å–ç‰©å“çš„é€šçŸ¥
        /// </summary>
        public void OnRemoteItemPickedUp(uint dropId, string pickedByPlayerId)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[ItemSyncClientServiceImpl] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                var coordinator = GameContext.Instance.ItemNetworkCoordinator;
                if (coordinator == null)
                {
                    Debug.LogWarning("[ItemSyncClientServiceImpl] ItemNetworkCoordinator æœªåˆå§‹åŒ–");
                    return;
                }

                Debug.Log($"[ItemSyncClientServiceImpl] æ”¶åˆ°è¿œç¨‹ç‰©å“æ‹¾å–é€šçŸ¥ - DropId={dropId}, Player={pickedByPlayerId}");

                // è½¬å‘åˆ°åè°ƒå™¨å¤„ç†
                coordinator.OnRemoteItemPickedUp(dropId, pickedByPlayerId);
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[ItemSyncClientServiceImpl] å¤„ç†è¿œç¨‹ç‰©å“æ‹¾å–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }
    }
}


```

`Client\Services\NpcSyncClientServiceImpl.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core;
using UnityEngine;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// NPC åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡ - æ¥æ”¶æœåŠ¡å™¨å¹¿æ’­çš„ NPC äº‹ä»¶
    /// </summary>
    public class NpcSyncClientServiceImpl : INpcSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–å®¢æˆ·ç«¯çš„ NPC ç”Ÿæˆ
        /// </summary>
        public void OnNpcSpawned(NpcSpawnData spawnData)
        {
            try
            {
                if (!GameContext.IsInitialized) return;

                Debug.Log($"[NpcSyncClient] ğŸ“¦ æ”¶åˆ°è¿œç¨‹ NPC ç”Ÿæˆ: {spawnData.NpcType} (ID: {spawnData.NpcId})");
                Debug.Log($"    åœºæ™¯: {spawnData.SceneName}/{spawnData.SubSceneName}");
                Debug.Log($"    ä½ç½®: ({spawnData.PositionX:F2}, {spawnData.PositionY:F2}, {spawnData.PositionZ:F2})");

                // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€åœºæ™¯
                var localSceneData = GameContext.Instance.PlayerManager?.LocalPlayer?.Info?.CurrentScenelData;
                if (localSceneData == null) return;

                bool isSameScene = localSceneData.SceneName == spawnData.SceneName &&
                                  localSceneData.SubSceneName == spawnData.SubSceneName;

                if (!isSameScene)
                {
                    Debug.Log($"[NpcSyncClient] ä¸åœ¨åŒä¸€åœºæ™¯ï¼Œè·³è¿‡åˆ›å»º");
                    return;
                }

                // ä»å¯¹è±¡æ± åˆ›å»ºå½±å­ NPC
                GameContext.Instance.NpcManager?.AddRemoteNpc(spawnData.NpcId, spawnData);
                
                Debug.Log($"[NpcSyncClient] âœ… è¿œç¨‹ NPC å·²åˆ›å»ºå¹¶æ³¨å†Œï¼ˆä½¿ç”¨å¯¹è±¡æ± ï¼‰");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcSyncClient] å¤„ç† NPC ç”Ÿæˆå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ¥æ”¶ NPC æ‰¹é‡ä½ç½®æ›´æ–°
        /// </summary>
        public void OnNpcBatchTransform(NpcBatchTransformData batchData)
        {
            try
            {
                if (!GameContext.IsInitialized) return;

                var npcManager = GameContext.Instance.NpcManager;
                if (npcManager == null) return;

                int missingCount = 0;
                int updatedCount = 0;

                // æ‰¹é‡æ›´æ–°è¿œç¨‹ NPC ä½ç½®
                for (int i = 0; i < batchData.Count; i++)
                {
                    string npcId = batchData.NpcIds[i];
                    Vector3 position = new Vector3(
                        batchData.PositionsX[i], 
                        batchData.PositionsY[i], 
                        batchData.PositionsZ[i]
                    );
                    
                    // å°è¯•æ›´æ–°ä½ç½®
                    var npc = npcManager.GetNpc(npcId);
                    if (npc != null)
                    {
                        // NPC å­˜åœ¨ï¼Œæ›´æ–°ä½ç½®
                        npcManager.UpdateRemoteNpcTransform(npcId, position, batchData.RotationsY[i]);
                        updatedCount++;
                    }
                    else
                    {
                        // NPC ä¸å­˜åœ¨ï¼Œè¯·æ±‚åˆ›å»º
                        if (npcManager.CheckAndRequestMissingNpc(npcId))
                        {
                            missingCount++;
                            Debug.Log($"[NpcSyncClient] ğŸ” å‘ç°ç¼ºå¤± NPCï¼Œå·²è¯·æ±‚: {npcId}");
                        }
                    }
                }

                // åªåœ¨æœ‰ç¼ºå¤±æ—¶è¾“å‡ºæ—¥å¿—
                if (missingCount > 0)
                {
                    Debug.Log($"[NpcSyncClient] ä½ç½®æ›´æ–°å®Œæˆ: {updatedCount} ä¸ªæ›´æ–°, {missingCount} ä¸ªè¯·æ±‚åˆ›å»º");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcSyncClient] å¤„ç†ä½ç½®æ›´æ–°å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ¥æ”¶ NPC é”€æ¯
        /// </summary>
        public void OnNpcDestroyed(NpcDestroyData destroyData)
        {
            try
            {
                if (!GameContext.IsInitialized) return;

                Debug.Log($"[NpcSyncClient] ğŸ—‘ï¸ æ”¶åˆ°è¿œç¨‹ NPC é”€æ¯: {destroyData.NpcId} (åŸå› : {destroyData.Reason})");

                // ç§»é™¤è¿œç¨‹ NPC
                GameContext.Instance.NpcManager?.RemoveRemoteNpc(destroyData.NpcId);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[NpcSyncClient] å¤„ç† NPC é”€æ¯å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Services\PlayerClientServiceImpl.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// ç©å®¶å®¢æˆ·ç«¯æœåŠ¡å®ç°ç±»
    /// <para>å®ç° IPlayerClientService æ¥å£ï¼Œè´Ÿè´£å¤„ç†æœåŠ¡å™¨å‘å®¢æˆ·ç«¯å‘é€çš„ç©å®¶ç›¸å…³äº‹ä»¶å›è°ƒ</para>
    /// <para>è¿™äº›æ–¹æ³•ç”±æœåŠ¡å™¨é€šè¿‡ RPC æœºåˆ¶è°ƒç”¨ï¼Œç”¨äºé€šçŸ¥å®¢æˆ·ç«¯ç©å®¶çŠ¶æ€å˜åŒ–å’Œæ¶ˆæ¯äº‹ä»¶</para>
    /// <para>æ‰€æœ‰äº‹ä»¶éƒ½ä¼šå‘å¸ƒåˆ°å…¨å±€ EventBusï¼Œå®ç°ç³»ç»Ÿé—´è§£è€¦é€šä¿¡</para>
    /// </summary>
    public class PlayerClientServiceImpl : IPlayerClientService
    {
        /// <summary>
        /// æ¥æ”¶èŠå¤©æ¶ˆæ¯å›è°ƒæ–¹æ³•
        /// <para>ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œå½“æœ‰ç©å®¶å‘é€èŠå¤©æ¶ˆæ¯æ—¶ï¼ŒæœåŠ¡å™¨ä¼šå°†æ¶ˆæ¯è½¬å‘ç»™æ‰€æœ‰ç›¸å…³å®¢æˆ·ç«¯</para>
        /// <para>æ­¤æ–¹æ³•ä¼šè®°å½•æ—¥å¿—å¹¶é€šè¿‡å…¨å±€ EventBus å‘å¸ƒäº‹ä»¶ï¼Œä¾›å…¶ä»–æ¨¡å—è®¢é˜…å¤„ç†</para>
        /// </summary>
        /// <param name="sender">å‘é€æ¶ˆæ¯çš„ç©å®¶ä¿¡æ¯å¯¹è±¡ï¼ŒåŒ…å« SteamIdã€SteamName ç­‰ç©å®¶åŸºæœ¬ä¿¡æ¯</param>
        /// <param name="message">èŠå¤©æ¶ˆæ¯çš„æ–‡æœ¬å†…å®¹</param>
        public void OnChatMessage(PlayerInfo sender, string message)
        {
            // åœ¨ Unity æ§åˆ¶å°è¾“å‡ºèŠå¤©æ¶ˆæ¯æ—¥å¿—ï¼Œæ ¼å¼ï¼š[Chat] ç©å®¶åç§°: æ¶ˆæ¯å†…å®¹
            Debug.Log($"[Chat] {sender.SteamName}: {message}");

            // é€šè¿‡å…¨å±€ EventBus å‘å¸ƒèŠå¤©æ¶ˆæ¯äº‹ä»¶ï¼Œå®ç°ç³»ç»Ÿè§£è€¦
            if (GameContext.IsInitialized)
            {
                Debug.Log($"[PlayerClientService] å‘å¸ƒ ChatMessageReceivedEvent: {sender.SteamName}: {message}");
                GameContext.Instance.EventBus.Publish(new ChatMessageReceivedEvent(sender, message));
                Debug.Log($"[PlayerClientService] ChatMessageReceivedEvent å·²å‘å¸ƒ");
            }
            else
            {
                Debug.LogError("[PlayerClientService] GameContext æœªåˆå§‹åŒ–ï¼Œæ— æ³•å‘å¸ƒèŠå¤©æ¶ˆæ¯äº‹ä»¶ï¼");
            }
        }

        /// <summary>
        /// ç©å®¶åŠ å…¥å›è°ƒæ–¹æ³•
        /// <para>ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œå½“æœ‰æ–°ç©å®¶æˆåŠŸç™»å½•åŠ å…¥æ¸¸æˆæ—¶è§¦å‘</para>
        /// <para>æ­¤æ–¹æ³•ä¼šè®°å½•æ—¥å¿—å¹¶é€šè¿‡å…¨å±€ EventBus å‘å¸ƒäº‹ä»¶ï¼Œä¾›å…¶ä»–æ¨¡å—è®¢é˜…å¤„ç†</para>
        /// </summary>
        /// <param name="player">åŠ å…¥æ¸¸æˆçš„ç©å®¶ä¿¡æ¯å¯¹è±¡ï¼ŒåŒ…å«å®Œæ•´çš„ç©å®¶æ•°æ®ï¼ˆSteamIdã€SteamNameã€AvatarUrl ç­‰ï¼‰</param>
        public void OnPlayerJoined(PlayerInfo player)
        {
            // åœ¨ Unity æ§åˆ¶å°è¾“å‡ºç©å®¶åŠ å…¥æ—¥å¿—
            Debug.Log($"[PlayerClientService] Player joined: {player.SteamName}");

            // é€šè¿‡å…¨å±€ EventBus å‘å¸ƒç©å®¶åŠ å…¥äº‹ä»¶ï¼Œå®ç°ç³»ç»Ÿè§£è€¦
            if (GameContext.IsInitialized)
            {
                GameContext.Instance.EventBus.Publish(new PlayerJoinedEvent(player));
            }
        }

        /// <summary>
        /// ç©å®¶ç¦»å¼€å›è°ƒæ–¹æ³•
        /// <para>ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œå½“ç©å®¶ç™»å‡ºæˆ–æ–­å¼€è¿æ¥æ—¶è§¦å‘</para>
        /// <para>æ­¤æ–¹æ³•ä¼šè®°å½•æ—¥å¿—å¹¶é€šè¿‡å…¨å±€ EventBus å‘å¸ƒäº‹ä»¶ï¼Œä¾›å…¶ä»–æ¨¡å—è®¢é˜…å¤„ç†</para>
        /// </summary>
        /// <param name="player">ç¦»å¼€æ¸¸æˆçš„ç©å®¶ä¿¡æ¯å¯¹è±¡ï¼ŒåŒ…å«ç©å®¶æ ‡è¯†ä¿¡æ¯</param>
        public void OnPlayerLeft(PlayerInfo player)
        {
            // åœ¨ Unity æ§åˆ¶å°è¾“å‡ºç©å®¶ç¦»å¼€æ—¥å¿—
            Debug.Log($"[PlayerClientService] Player left: {player.SteamName}");

            // é€šè¿‡å…¨å±€ EventBus å‘å¸ƒç©å®¶ç¦»å¼€äº‹ä»¶ï¼Œå®ç°ç³»ç»Ÿè§£è€¦
            if (GameContext.IsInitialized)
            {
                GameContext.Instance.EventBus.Publish(new PlayerLeftEvent(player));
            }
        }

        /// <summary>
        /// æœåŠ¡å™¨æ¶ˆæ¯é€šçŸ¥å›è°ƒæ–¹æ³•
        /// <para>ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œç”¨äºå‘å®¢æˆ·ç«¯å‘é€å„ç§ç±»å‹çš„æœåŠ¡å™¨æ¶ˆæ¯é€šçŸ¥</para>
        /// <para>æ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹ï¼šä¿¡æ¯ã€è­¦å‘Šã€é”™è¯¯ã€æˆåŠŸç­‰ï¼Œä¸åŒæ¶ˆæ¯ç±»å‹ä¼šä½¿ç”¨ä¸åŒçš„æ—¥å¿—å‰ç¼€</para>
        /// </summary>
        /// <param name="message">æœåŠ¡å™¨å‘é€çš„æ¶ˆæ¯æ–‡æœ¬å†…å®¹</param>
        /// <param name="messageType">æ¶ˆæ¯ç±»å‹æšä¸¾å€¼ï¼Œç”¨äºåŒºåˆ†æ¶ˆæ¯çš„ä¸¥é‡ç¨‹åº¦å’Œç±»å‹</param>
        public void OnServerMessage(string message, MessageType messageType)
        {
            // æ ¹æ®æ¶ˆæ¯ç±»å‹é€‰æ‹©å¯¹åº”çš„æ—¥å¿—å‰ç¼€ï¼Œç”¨äºåœ¨æ§åˆ¶å°ä¸­æ›´æ¸…æ™°åœ°è¯†åˆ«æ¶ˆæ¯ç±»å‹
            string prefix = messageType switch
            {
                MessageType.Info => "[Server/Info]",           // æ™®é€šä¿¡æ¯æ¶ˆæ¯
                MessageType.Warning => "[Server/Warning]",     // è­¦å‘Šæ¶ˆæ¯
                MessageType.Error => "[Server/Error]",         // é”™è¯¯æ¶ˆæ¯
                MessageType.Success => "[Server/Success]",     // æˆåŠŸæ¶ˆæ¯
                _ => "[Server]"                               // é»˜è®¤æ¶ˆæ¯ï¼ˆæœªçŸ¥ç±»å‹ï¼‰
            };

            // åœ¨ Unity æ§åˆ¶å°è¾“å‡ºå¸¦å‰ç¼€çš„æœåŠ¡å™¨æ¶ˆæ¯
            Debug.Log($"{prefix} {message}");
        }

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„ä½ç½®åŒæ­¥æ•°æ®å›è°ƒæ–¹æ³•
        /// <para>ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œå½“æˆ¿é—´/åœºæ™¯å†…çš„å…¶ä»–ç©å®¶å‘é€ä½ç½®åŒæ­¥æ•°æ®æ—¶è§¦å‘</para>
        /// <para>æ­¤æ–¹æ³•ä¼šè§£æåŒæ­¥æ•°æ®å¹¶å‘å¸ƒäº‹ä»¶ï¼Œä¾›è¿œç¨‹ç©å®¶ä½ç½®æ›´æ–°ç³»ç»Ÿå¤„ç†</para>
        /// </summary>
        /// <param name="syncData">å…¶ä»–ç©å®¶çš„ä½ç½®åŒæ­¥æ•°æ®ï¼ŒåŒ…å«ä½ç½®ã€æ—‹è½¬ã€é€Ÿåº¦ç­‰ä¿¡æ¯</param>
        public void OnPlayerUnitySyncReceived(UnitySyncData syncData)
        {
            try
            {
                // è§£æä½ç½®ã€æ—‹è½¬ã€é€Ÿåº¦æ•°æ®
                // é€šè¿‡å…¨å±€ EventBus å‘å¸ƒç©å®¶åŒæ­¥äº‹ä»¶ï¼Œä¾›è¿œç¨‹ç©å®¶ä½ç½®æ›´æ–°ç³»ç»Ÿå¤„ç†
                if (GameContext.IsInitialized)
                {
                    GameContext.Instance.EventBus.Publish(new PlayerUnitySyncEvent(syncData.SteamId, syncData));
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæ›´æ–°æˆ¿é—´ç©å®¶åˆ—è¡¨ä¸­çš„åœºæ™¯ä¿¡æ¯
                    // å› ä¸ºæœåŠ¡å™¨å·²è¿‡æ»¤åœºæ™¯ï¼Œæ”¶åˆ°ä½ç½®åŒæ­¥è¯´æ˜è¯¥ç©å®¶åœ¨åŒä¸€åœºæ™¯
                    var localPlayer = GameContext.Instance.PlayerManager?.LocalPlayer;
                    var roomManager = GameContext.Instance.RoomManager;
                    
                    if (localPlayer != null && roomManager != null)
                    {
                        var playerToUpdate = roomManager.RoomPlayers.Find(p => p.SteamId == syncData.SteamId);
                        if (playerToUpdate != null && 
                            playerToUpdate.CurrentScenelData?.SceneName != localPlayer.Info.CurrentScenelData.SceneName)
                        {
                            playerToUpdate.CurrentScenelData = localPlayer.Info.CurrentScenelData;
                            Debug.Log($"[PlayerClientService] æ›´æ–°ç©å®¶ {syncData.SteamId} çš„åœºæ™¯ä¸º: {localPlayer.Info.CurrentScenelData.SceneName}");
                        }
                    }
                }
                else
                {
                    Debug.LogWarning("[PlayerClientService] GameContext æœªåˆå§‹åŒ–ï¼Œæ— æ³•å‘å¸ƒç©å®¶åŒæ­¥äº‹ä»¶");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[PlayerClientService] å¤„ç†ç©å®¶åŒæ­¥æ•°æ®å¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Services\RoomClientServiceImpl.cs`:

```cs
using UnityEngine;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.EventBus.Events;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// æˆ¿é—´å®¢æˆ·ç«¯æœåŠ¡å®ç°ï¼ˆæ¥æ”¶æœåŠ¡å™¨è°ƒç”¨ï¼‰
    /// </summary>
    public class RoomClientServiceImpl : IRoomClientService
    {
        public void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room)
        {
            Debug.Log($"[RoomClientService] ========== æ”¶åˆ° RPC: OnPlayerJoinedRoom ==========");
            Debug.Log($"[RoomClientService] ç©å®¶: {player.SteamName} ({player.SteamId})");
            Debug.Log($"[RoomClientService] æˆ¿é—´: {room.RoomName} ({room.RoomId})");
            Debug.Log($"[RoomClientService] ğŸ–¼ï¸ å¤´åƒURL: {player.AvatarUrl ?? "(null)"}");

            // å‘å¸ƒåˆ° EventBus
            if (GameContext.IsInitialized)
            {
                Debug.Log($"[RoomClientService] å‘å¸ƒ PlayerJoinedRoomEvent...");
                GameContext.Instance.EventBus.Publish(new PlayerJoinedRoomEvent(player, room));
                Debug.Log($"[RoomClientService] âœ… PlayerJoinedRoomEvent å·²å‘å¸ƒ");
            }
            else
            {
                Debug.LogError($"[RoomClientService] âŒ GameContext æœªåˆå§‹åŒ–ï¼Œæ— æ³•å‘å¸ƒäº‹ä»¶ï¼");
            }
            Debug.Log($"[RoomClientService] ========== å¤„ç†å®Œæˆ ==========");
        }

        public void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room)
        {
            Debug.Log($"[RoomClientService] {player.SteamName} left room {room.RoomName}");

            // å‘å¸ƒåˆ° EventBus
            if (GameContext.IsInitialized)
            {
                GameContext.Instance.EventBus.Publish(new PlayerLeftRoomEvent(player, room));
            }
        }

        public void OnKickedFromRoom(string reason)
        {
            Debug.LogWarning($"[RoomClientService] Kicked from room: {reason}");

            // å‘å¸ƒåˆ° EventBus
            if (GameContext.IsInitialized)
            {
                GameContext.Instance.EventBus.Publish(new KickedFromRoomEvent(reason));
            }
        }
    }
}


```

`Client\Services\SceneClientServiceImpl.cs`:

```cs
using System;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Client.Core.EventBus;
using DuckyNet.Client.Core.EventBus.Events;
using UnityEngine;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// åœºæ™¯å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// </summary>
    public class SceneClientServiceImpl : ISceneClientService, IDisposable
    {
        private readonly EventSubscriberHelper _eventSubscriber = new EventSubscriberHelper();

        public SceneClientServiceImpl()
        {
            // è®¢é˜…ç©å®¶è¿›å…¥åœºæ™¯äº‹ä»¶ï¼Œè‡ªåŠ¨è¯·æ±‚å¤–è§‚æ•°æ®
            if (GameContext.IsInitialized)
            {
                _eventSubscriber.EnsureInitializedAndSubscribe();
                _eventSubscriber.Subscribe<PlayerEnteredSceneEvent>(OnPlayerEnteredSceneEvent);
            }
        }


        /// <summary>
        /// å¤„ç†ç©å®¶è¿›å…¥åœºæ™¯äº‹ä»¶ï¼ˆé€šè¿‡ EventBusï¼‰
        /// </summary>
        private void OnPlayerEnteredSceneEvent(PlayerEnteredSceneEvent evt)
        {

        }

        /// <summary>
        /// ç©å®¶è¿›å…¥åœºæ™¯é€šçŸ¥ï¼ˆæœåŠ¡å™¨è°ƒç”¨ï¼‰
        /// </summary>
        public void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            try
            {
                Debug.Log($"[SceneClientService] ========== OnPlayerEnteredScene è¢«è°ƒç”¨ ==========");
                Debug.Log($"[SceneClientService] ç©å®¶: {playerInfo.SteamName} ({playerInfo.SteamId})");
                Debug.Log($"[SceneClientService] åœºæ™¯: {scenelData.SceneName}/{scenelData.SubSceneName}");
                Debug.Log($"[SceneClientService] GameContext å·²åˆå§‹åŒ–: {GameContext.IsInitialized}");
                
                if (GameContext.IsInitialized)
                {
                    Debug.Log($"[SceneClientService] æ­£åœ¨å‘å¸ƒ PlayerEnteredSceneEvent åˆ° EventBus...");
                    _eventSubscriber.EventBus.Publish(new PlayerEnteredSceneEvent(playerInfo, scenelData));
                    Debug.Log($"[SceneClientService] âœ… äº‹ä»¶å·²å‘å¸ƒ");
                }
                else
                {
                    Debug.LogError($"[SceneClientService] âŒ GameContext æœªåˆå§‹åŒ–ï¼Œæ— æ³•å‘å¸ƒäº‹ä»¶ï¼");
                }
                
                Debug.Log($"[SceneClientService] ========== OnPlayerEnteredScene å¤„ç†å®Œæˆ ==========");
            }
            catch(Exception ex)
            {
                Debug.LogError($"[SceneClientService] å¤„ç†ç©å®¶è¿›å…¥åœºæ™¯å¤±è´¥: {ex.Message}");
                Debug.LogError($"[SceneClientService] å †æ ˆè·Ÿè¸ª: {ex.StackTrace}");
            }
        }
        
     

        /// <summary>
        /// ç©å®¶ç¦»å¼€åœºæ™¯é€šçŸ¥ï¼ˆæœåŠ¡å™¨è°ƒç”¨ï¼‰
        /// </summary>
        public void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            try
            {
                Debug.Log($"[SceneClientService] ç©å®¶ç¦»å¼€åœºæ™¯: {playerInfo.SteamName} <- {scenelData.SceneName}");

                if (GameContext.IsInitialized)
                {
                    _eventSubscriber.EventBus.Publish(new PlayerLeftSceneEvent(playerInfo, scenelData));
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[SceneClientService] å¤„ç†ç©å®¶ç¦»å¼€åœºæ™¯å¤±è´¥: {ex.Message}");
            }
        }

        public void Dispose()
        {
            _eventSubscriber?.Dispose();
        }
    }
}


```

`Client\Services\SerializationPool.cs`:

```cs
using System.Collections.Generic;
using DuckyNet.Shared.Data;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// åºåˆ—åŒ–æ•°æ®å¯¹è±¡æ± 
    /// å‡å°‘ GC å‹åŠ›ï¼Œå¤ç”¨åºåˆ—åŒ–å¯¹è±¡
    /// </summary>
    public static class SerializationPool
    {
        private static readonly Stack<SerializableItemData> _itemDataPool = new Stack<SerializableItemData>();
        private static readonly Stack<SerializableEntry> _entryPool = new Stack<SerializableEntry>();
        private static readonly Stack<SerializableVariable> _variablePool = new Stack<SerializableVariable>();
        private static readonly Stack<SerializableSlot> _slotPool = new Stack<SerializableSlot>();
        private static readonly Stack<SerializableInventoryItem> _inventoryItemPool = new Stack<SerializableInventoryItem>();

        private const int MAX_POOL_SIZE = 50;

        #region ItemData Pool

        public static SerializableItemData GetItemData()
        {
            lock (_itemDataPool)
            {
                if (_itemDataPool.Count > 0)
                {
                    var data = _itemDataPool.Pop();
                    data.Entries.Clear();
                    return data;
                }
            }
            return new SerializableItemData();
        }

        public static void ReleaseItemData(SerializableItemData data)
        {
            if (data == null) return;

            lock (_itemDataPool)
            {
                if (_itemDataPool.Count < MAX_POOL_SIZE)
                {
                    data.Entries.Clear();
                    _itemDataPool.Push(data);
                }
            }
        }

        #endregion

        #region Entry Pool

        public static SerializableEntry GetEntry()
        {
            lock (_entryPool)
            {
                if (_entryPool.Count > 0)
                {
                    var entry = _entryPool.Pop();
                    entry.Variables.Clear();
                    entry.Slots.Clear();
                    entry.Inventory.Clear();
                    entry.InventorySortLocks.Clear();
                    return entry;
                }
            }
            return new SerializableEntry();
        }

        public static void ReleaseEntry(SerializableEntry entry)
        {
            if (entry == null) return;

            // é‡Šæ”¾åµŒå¥—å¯¹è±¡
            foreach (var variable in entry.Variables)
            {
                ReleaseVariable(variable);
            }
            foreach (var slot in entry.Slots)
            {
                ReleaseSlot(slot);
            }
            foreach (var inv in entry.Inventory)
            {
                ReleaseInventoryItem(inv);
            }

            lock (_entryPool)
            {
                if (_entryPool.Count < MAX_POOL_SIZE)
                {
                    entry.Variables.Clear();
                    entry.Slots.Clear();
                    entry.Inventory.Clear();
                    entry.InventorySortLocks.Clear();
                    _entryPool.Push(entry);
                }
            }
        }

        #endregion

        #region Variable Pool

        public static SerializableVariable GetVariable()
        {
            lock (_variablePool)
            {
                if (_variablePool.Count > 0)
                {
                    return _variablePool.Pop();
                }
            }
            return new SerializableVariable();
        }

        public static void ReleaseVariable(SerializableVariable variable)
        {
            if (variable == null) return;

            lock (_variablePool)
            {
                if (_variablePool.Count < MAX_POOL_SIZE)
                {
                    variable.Key = "";
                    variable.StringValue = "";
                    _variablePool.Push(variable);
                }
            }
        }

        #endregion

        #region Slot Pool

        public static SerializableSlot GetSlot()
        {
            lock (_slotPool)
            {
                if (_slotPool.Count > 0)
                {
                    return _slotPool.Pop();
                }
            }
            return new SerializableSlot();
        }

        public static void ReleaseSlot(SerializableSlot slot)
        {
            if (slot == null) return;

            lock (_slotPool)
            {
                if (_slotPool.Count < MAX_POOL_SIZE)
                {
                    slot.SlotName = "";
                    _slotPool.Push(slot);
                }
            }
        }

        #endregion

        #region InventoryItem Pool

        public static SerializableInventoryItem GetInventoryItem()
        {
            lock (_inventoryItemPool)
            {
                if (_inventoryItemPool.Count > 0)
                {
                    return _inventoryItemPool.Pop();
                }
            }
            return new SerializableInventoryItem();
        }

        public static void ReleaseInventoryItem(SerializableInventoryItem item)
        {
            if (item == null) return;

            lock (_inventoryItemPool)
            {
                if (_inventoryItemPool.Count < MAX_POOL_SIZE)
                {
                    _inventoryItemPool.Push(item);
                }
            }
        }

        #endregion

        /// <summary>
        /// æ¸…ç©ºæ‰€æœ‰å¯¹è±¡æ± ï¼ˆç”¨äºæµ‹è¯•æˆ–é‡ç½®ï¼‰
        /// </summary>
        public static void ClearAll()
        {
            lock (_itemDataPool) _itemDataPool.Clear();
            lock (_entryPool) _entryPool.Clear();
            lock (_variablePool) _variablePool.Clear();
            lock (_slotPool) _slotPool.Clear();
            lock (_inventoryItemPool) _inventoryItemPool.Clear();
        }

        /// <summary>
        /// è·å–å¯¹è±¡æ± ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public static string GetPoolStats()
        {
            return $"SerializationPool Stats:\n" +
                   $"  ItemData: {_itemDataPool.Count}\n" +
                   $"  Entry: {_entryPool.Count}\n" +
                   $"  Variable: {_variablePool.Count}\n" +
                   $"  Slot: {_slotPool.Count}\n" +
                   $"  InventoryItem: {_inventoryItemPool.Count}";
        }
    }
}


```

`Client\Services\WeaponFireEffectsPlayer.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Shared.Data;
using DuckyNet.Client.Core.Utils;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// æ­¦å™¨å¼€æªç‰¹æ•ˆæ’­æ”¾å™¨ - è¿œç¨‹ç©å®¶ä¸“ç”¨
    /// ä½¿ç”¨ WeaponEffectsCore æä¾›çš„å…±äº«é€»è¾‘
    /// </summary>
    public static class WeaponFireEffectsPlayer
    {
        private static bool _initialized = false;

        /// <summary>
        /// åˆå§‹åŒ–ï¼ˆè¿œç¨‹ç©å®¶ä¸“ç”¨ï¼‰
        /// </summary>
        public static void Initialize()
        {
            if (_initialized) return;

            try
            {
                // åˆå§‹åŒ–å…±äº«æ ¸å¿ƒ
                WeaponEffectsCore.Initialize();
                
                _initialized = true;
                Debug.Log("[WeaponFireEffectsPlayer] âœ… åˆå§‹åŒ–å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponFireEffectsPlayer] åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ’­æ”¾è¿œç¨‹ç©å®¶çš„å¼€æªç‰¹æ•ˆ
        /// </summary>
        public static void PlayFireEffects(GameObject characterObject, WeaponFireData fireData)
        {
            try
            {
                if (characterObject == null)
                {
                    Debug.LogWarning("[WeaponFireEffectsPlayer] è§’è‰²å¯¹è±¡ä¸ºç©º");
                    return;
                }

                var characterMainControl = characterObject.GetComponent<CharacterMainControl>();
                if (characterMainControl == null)
                {
                    Debug.LogWarning("[WeaponFireEffectsPlayer] æ‰¾ä¸åˆ° CharacterMainControl");
                    return;
                }

                // è·å–å½“å‰æ‰‹æŒçš„æªæ¢° Agent
                var currentAgent = characterMainControl.CurrentHoldItemAgent;
                if (currentAgent == null)
                {
                    Debug.Log("[WeaponFireEffectsPlayer] å½“å‰æ²¡æœ‰æ‰‹æŒæ­¦å™¨ï¼Œè·³è¿‡ç‰¹æ•ˆ");
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦ä¸ºæªæ¢°ç±»å‹
                if (WeaponEffectsCore.ItemAgentGunType == null || 
                    !WeaponEffectsCore.ItemAgentGunType.IsInstanceOfType(currentAgent))
                {
                    Debug.Log("[WeaponFireEffectsPlayer] å½“å‰æ‰‹æŒæ­¦å™¨ä¸æ˜¯æªæ¢°ç±»å‹");
                    return;
                }

                // è½¬æ¢ä½ç½®å’Œæ–¹å‘
                Vector3 muzzlePos = new Vector3(fireData.MuzzlePositionX, fireData.MuzzlePositionY, fireData.MuzzlePositionZ);
                Vector3 muzzleDir = new Vector3(fireData.MuzzleDirectionX, fireData.MuzzleDirectionY, fireData.MuzzleDirectionZ);

                // ä½¿ç”¨å…±äº«æ ¸å¿ƒæ’­æ”¾ç‰¹æ•ˆ
                WeaponEffectsCore.PlayMuzzleFlash(currentAgent);
                WeaponEffectsCore.PlayShellEjection(currentAgent);
                WeaponEffectsCore.PlayShootSound(currentAgent, muzzlePos, fireData.IsSilenced);
                
                // åˆ›å»ºå­å¼¹ï¼ˆè¿œç¨‹ç©å®¶ä¼¤å®³ä¸º0ï¼‰
                WeaponEffectsCore.CreateBullet(currentAgent, muzzlePos, muzzleDir, characterMainControl, 0f);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponFireEffectsPlayer] æ’­æ”¾ç‰¹æ•ˆå¤±è´¥: {ex.Message}");
            }
        }
    }
}


```

`Client\Services\WeaponSyncClientServiceImpl.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Client.Core;
using ItemStatsSystem;
using Duckov.Utilities;
using UnityEngine;
using System;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// æ­¦å™¨åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡å®ç°
    /// æ¥æ”¶æ¥è‡ªæœåŠ¡å™¨çš„æ­¦å™¨åŒæ­¥é€šçŸ¥
    /// </summary>
    public class WeaponSyncClientServiceImpl : IWeaponSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„æ­¦å™¨æ§½ä½æ›´æ–°é€šçŸ¥
        /// </summary>
        public void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[WeaponSyncClientService] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                // è¿‡æ»¤è‡ªå·±çš„æ›´æ–°
                var localPlayerId = GameContext.Instance.PlayerManager?.LocalPlayer?.Info.SteamId;
                if (!string.IsNullOrEmpty(localPlayerId) && localPlayerId == notification.PlayerId)
                {
                    Debug.Log("[WeaponSyncClientService] è·³è¿‡æœ¬åœ°ç©å®¶çš„æ­¦å™¨æ›´æ–°");
                    return;
                }

                string action = notification.ItemTypeId > 0 ? "è£…å¤‡" : "å¸ä¸‹";
                Debug.Log($"[WeaponSyncClientService] æ”¶åˆ°æ­¦å™¨æ›´æ–°: ç©å®¶={notification.PlayerId}, æ§½ä½={notification.SlotType}, åŠ¨ä½œ={action}, æ­¦å™¨={notification.ItemName}");

                // è·å–è¿œç¨‹ç©å®¶
                var remotePlayer = GameContext.Instance.PlayerManager?.GetRemotePlayer(notification.PlayerId);
                if (remotePlayer == null)
                {
                    Debug.LogWarning($"[WeaponSyncClientService] æ‰¾ä¸åˆ°è¿œç¨‹ç©å®¶: {notification.PlayerId}");
                    return;
                }

                // åˆ›å»ºæ­¦å™¨æ•°æ®
                WeaponItemData? weaponData = null;
                if (notification.ItemTypeId > 0)
                {
                    weaponData = new WeaponItemData
                    {
                        ItemTypeId = notification.ItemTypeId,
                        ItemName = notification.ItemName,
                        IsDefaultItem = notification.IsDefaultItem,
                        ItemDataCompressed = notification.ItemDataCompressed
                    };
                }

                // æ›´æ–°è¿œç¨‹ç©å®¶çš„æ­¦å™¨æ•°æ®
                remotePlayer.UpdateWeaponSlot(notification.SlotType, weaponData);

                // å¦‚æœè§’è‰²å·²åˆ›å»ºï¼Œç«‹å³åº”ç”¨æ­¦å™¨
                if (remotePlayer.CharacterObject != null)
                {
                    ApplyWeaponToCharacter(remotePlayer, notification.SlotType, weaponData);
                }
                else
                {
                    Debug.Log($"[WeaponSyncClientService] è§’è‰²æœªåˆ›å»ºï¼Œæ­¦å™¨æ•°æ®å·²ä¿å­˜ï¼Œå°†åœ¨åˆ›å»ºæ—¶åº”ç”¨");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncClientService] å¤„ç†æ­¦å™¨æ›´æ–°å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// æ¥æ”¶æ‰€æœ‰ç©å®¶çš„æ­¦å™¨æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶ï¼‰
        /// </summary>
        public void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[WeaponSyncClientService] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                Debug.Log($"[WeaponSyncClientService] æ”¶åˆ°æ‰¹é‡æ­¦å™¨æ•°æ®: {allWeaponData.PlayersWeapons.Count} ä¸ªç©å®¶");

                var playerManager = GameContext.Instance.PlayerManager;
                if (playerManager == null)
                {
                    Debug.LogWarning("[WeaponSyncClientService] PlayerManager æœªåˆå§‹åŒ–");
                    return;
                }

                // æ›´æ–°æ‰€æœ‰ç©å®¶çš„æ­¦å™¨æ•°æ®
                foreach (var kvp in allWeaponData.PlayersWeapons)
                {
                    string playerId = kvp.Key;
                    PlayerWeaponData weaponData = kvp.Value;

                    // è·³è¿‡è‡ªå·±
                    if (playerId == playerManager.LocalPlayer?.Info.SteamId)
                    {
                        Debug.Log($"[WeaponSyncClientService] è·³è¿‡æœ¬åœ°ç©å®¶çš„æ­¦å™¨æ•°æ®");
                        continue;
                    }

                    // è·å–è¿œç¨‹ç©å®¶
                    var remotePlayer = playerManager.GetRemotePlayer(playerId);
                    if (remotePlayer == null)
                    {
                        Debug.LogWarning($"[WeaponSyncClientService] æ‰¾ä¸åˆ°è¿œç¨‹ç©å®¶: {playerId}ï¼Œè·³è¿‡æ­¦å™¨æ•°æ®");
                        continue;
                    }

                    // è®¾ç½®æ­¦å™¨æ•°æ®
                    remotePlayer.SetWeaponData(weaponData);

                    Debug.Log($"[WeaponSyncClientService] å·²æ›´æ–°ç©å®¶ {playerId} çš„æ­¦å™¨æ•°æ®: {weaponData.GetEquippedCount()} ä»¶æ­¦å™¨");

                    // å¦‚æœè§’è‰²å·²åˆ›å»ºï¼Œç«‹å³åº”ç”¨æ‰€æœ‰æ­¦å™¨
                    if (remotePlayer.CharacterObject != null)
                    {
                        ApplyAllWeaponsToCharacter(remotePlayer);
                    }
                }

                Debug.Log("[WeaponSyncClientService] âœ… æ‰¹é‡æ­¦å™¨æ•°æ®å¤„ç†å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncClientService] å¤„ç†æ‰¹é‡æ­¦å™¨æ•°æ®å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„æ­¦å™¨åˆ‡æ¢é€šçŸ¥
        /// </summary>
        public void OnWeaponSwitched(WeaponSwitchNotification notification)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    Debug.LogWarning("[WeaponSyncClientService] GameContext æœªåˆå§‹åŒ–");
                    return;
                }

                // è¿‡æ»¤è‡ªå·±çš„åˆ‡æ¢
                var localPlayerId = GameContext.Instance.PlayerManager?.LocalPlayer?.Info.SteamId;
                if (!string.IsNullOrEmpty(localPlayerId) && localPlayerId == notification.PlayerId)
                {
                    Debug.Log("[WeaponSyncClientService] è·³è¿‡æœ¬åœ°ç©å®¶çš„æ­¦å™¨åˆ‡æ¢");
                    return;
                }

                Debug.Log($"[WeaponSyncClientService] æ”¶åˆ°æ­¦å™¨åˆ‡æ¢: ç©å®¶={notification.PlayerId}, æ§½ä½={notification.CurrentWeaponSlot}");

                // è·å–è¿œç¨‹ç©å®¶
                var remotePlayer = GameContext.Instance.PlayerManager?.GetRemotePlayer(notification.PlayerId);
                if (remotePlayer == null)
                {
                    Debug.LogWarning($"[WeaponSyncClientService] æ‰¾ä¸åˆ°è¿œç¨‹ç©å®¶: {notification.PlayerId}");
                    return;
                }

                // æ›´æ–°è¿œç¨‹ç©å®¶çš„å½“å‰æ­¦å™¨æ§½ä½
                remotePlayer.SwitchWeaponSlot(notification.CurrentWeaponSlot);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncClientService] å¤„ç†æ­¦å™¨åˆ‡æ¢å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„å¼€æªç‰¹æ•ˆé€šçŸ¥
        /// </summary>
        public void OnWeaponFired(WeaponFireData fireData)
        {
            try
            {
                if (!GameContext.IsInitialized)
                {
                    return;
                }

                // è¿‡æ»¤è‡ªå·±çš„å¼€æª
                var localPlayerId = GameContext.Instance.PlayerManager?.LocalPlayer?.Info.SteamId;
                if (!string.IsNullOrEmpty(localPlayerId) && localPlayerId == fireData.PlayerId)
                {
                    return;
                }

                // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šå®¢æˆ·ç«¯æ¥æ”¶åˆ°çš„æ•°æ®
                Debug.Log($"[WeaponSyncClientService] ğŸ“¥ æ”¶åˆ°å¼€æªç‰¹æ•ˆ: ç©å®¶={fireData.PlayerId}");
                Debug.Log($"    â€¢ ä½ç½®: ({fireData.MuzzlePositionX:F3}, {fireData.MuzzlePositionY:F3}, {fireData.MuzzlePositionZ:F3})");
                Debug.Log($"    â€¢ æ–¹å‘: ({fireData.MuzzleDirectionX:F3}, {fireData.MuzzleDirectionY:F3}, {fireData.MuzzleDirectionZ:F3})");
                Debug.Log($"    â€¢ æ¶ˆéŸ³: {fireData.IsSilenced}");

                // è·å–è¿œç¨‹ç©å®¶
                var remotePlayer = GameContext.Instance.PlayerManager?.GetRemotePlayer(fireData.PlayerId);
                if (remotePlayer == null || remotePlayer.CharacterObject == null)
                {
                    #if DEBUG || UNITY_EDITOR
                    Debug.LogWarning($"[WeaponSyncClientService] æ‰¾ä¸åˆ°è¿œç¨‹ç©å®¶æˆ–è§’è‰²å¯¹è±¡: {fireData.PlayerId}");
                    #endif
                    return;
                }

                // æ’­æ”¾å¼€æªç‰¹æ•ˆï¼ˆä½¿ç”¨ WeaponFireEffectsPlayerï¼‰
                WeaponFireEffectsPlayer.PlayFireEffects(remotePlayer.CharacterObject, fireData);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncClientService] æ’­æ”¾å¼€æªç‰¹æ•ˆå¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åº”ç”¨å•ä¸ªæ­¦å™¨åˆ°è§’è‰²
        /// </summary>
        private void ApplyWeaponToCharacter(Core.Players.RemotePlayer remotePlayer, WeaponSlotType slotType, WeaponItemData? weaponData)
        {
            try
            {
                Debug.Log($"[WeaponSyncClientService] ğŸ” å¼€å§‹åº”ç”¨æ­¦å™¨: æ§½ä½={slotType}, ç©å®¶={remotePlayer.Info.SteamName}");

                var characterMainControl = remotePlayer.CharacterObject?.GetComponent<CharacterMainControl>();
                if (characterMainControl == null || characterMainControl.CharacterItem == null)
                {
                    Debug.LogWarning($"[WeaponSyncClientService] è§’è‰²ç»„ä»¶æ— æ•ˆ: CharacterObject={remotePlayer.CharacterObject != null}, CharacterMainControl={characterMainControl != null}");
                    return;
                }

                int slotHash = GetSlotHash(slotType);
                Debug.Log($"[WeaponSyncClientService] æ§½ä½Hash: {slotHash} (å­—ç¬¦ä¸²Hash={slotType.ToString().GetHashCode()})");
                
                var slot = characterMainControl.CharacterItem.Slots.GetSlot(slotHash);

                if (slot == null)
                {
                    Debug.LogWarning($"[WeaponSyncClientService] âŒ æ§½ä½ä¸å­˜åœ¨: {slotType}, Hash={slotHash}");
                    Debug.LogWarning($"[WeaponSyncClientService] å¯ç”¨æ§½ä½æ•°é‡: {characterMainControl.CharacterItem.Slots.Count}");
                    
                    // æ‰“å°æ‰€æœ‰æ§½ä½ä¿¡æ¯
                    for (int i = 0; i < characterMainControl.CharacterItem.Slots.Count; i++)
                    {
                        var s = characterMainControl.CharacterItem.Slots[i];
                        Debug.Log($"[WeaponSyncClientService] æ§½ä½[{i}]: Key={s.Key}, Hash={s.Key.GetHashCode()}, Content={s.Content?.DisplayName ?? "ç©º"}");
                    }
                    return;
                }

                Debug.Log($"[WeaponSyncClientService] âœ… æ‰¾åˆ°æ§½ä½: {slot.Key}, å½“å‰å†…å®¹={slot.Content?.DisplayName ?? "ç©º"}");

                if (weaponData != null && weaponData.ItemTypeId > 0)
                {
                    // è£…å¤‡æ–°æ­¦å™¨ - ååºåˆ—åŒ–ç‰©å“æ•°æ®
                    Item? weaponItem = WeaponSyncHelper.DeserializeItem(
                        weaponData.ItemDataCompressed,
                        weaponData.ItemTypeId
                    );

                    if (weaponItem != null)
                    {
                        Debug.Log($"[WeaponSyncClientService] ååºåˆ—åŒ–æ­¦å™¨æˆåŠŸ: {weaponItem.DisplayName}, TypeID={weaponItem.TypeID}");
                        
                        bool success = slot.Plug(weaponItem, out Item unpluggedItem);
                        
                        Debug.Log($"[WeaponSyncClientService] Slot.Plug() ç»“æœ: {success}");
                        
                        if (success)
                        {
                            Debug.Log($"[WeaponSyncClientService] âœ… å·²æ’å…¥æ§½ä½: {slotType} = {weaponData.ItemName}");
                            Debug.Log($"[WeaponSyncClientService] æ§½ä½å½“å‰å†…å®¹: {slot.Content?.DisplayName ?? "ç©º"}");

                            // å¤„ç†è¢«æ›¿æ¢çš„æ­¦å™¨
                            if (unpluggedItem != null)
                            {
                                Debug.Log($"[WeaponSyncClientService] é”€æ¯è¢«æ›¿æ¢çš„æ­¦å™¨: {unpluggedItem.DisplayName}");
                                unpluggedItem.DestroyTree();
                            }

                            // ğŸ”‘ æ£€æŸ¥è¯¥æ§½ä½æ˜¯å¦æ˜¯å½“å‰æ‰‹æŒæ§½ä½
                            var currentSlot = remotePlayer.GetWeaponData()?.CurrentWeaponSlot;
                            Debug.Log($"[WeaponSyncClientService] å½“å‰æ‰‹æŒæ§½ä½: {currentSlot?.ToString() ?? "æœªè®¾ç½®"}, è£…å¤‡æ§½ä½: {slotType}");
                            
                            if (currentSlot.HasValue && currentSlot.Value == slotType)
                            {
                                Debug.Log($"[WeaponSyncClientService] ğŸ”¥ è¯¥æ§½ä½æ˜¯å½“å‰æ‰‹æŒæ§½ä½ï¼Œç«‹å³æ˜¾ç¤ºæ­¦å™¨");
                                try
                                {
                                    characterMainControl.ChangeHoldItem(weaponItem);
                                    Debug.Log($"[WeaponSyncClientService] âœ… æ­¦å™¨å·²æ˜¾ç¤ºï¼ˆItemAgentå·²åˆ›å»ºï¼‰");
                                }
                                catch (Exception agentEx)
                                {
                                    Debug.LogError($"[WeaponSyncClientService] ChangeHoldItem å¤±è´¥: {agentEx.Message}");
                                }
                            }
                            else
                            {
                                Debug.Log($"[WeaponSyncClientService] æ­¦å™¨å·²æ’å…¥æ§½ä½ï¼ˆç­‰å¾…åˆ‡æ¢é€šçŸ¥æ‰æ˜¾ç¤ºï¼‰");
                            }
                        }
                        else
                        {
                            Debug.LogWarning($"[WeaponSyncClientService] âŒ Slot.Plug() å¤±è´¥: {slotType}");
                            weaponItem.DestroyTree();
                        }
                    }
                    else
                    {
                        Debug.LogError($"[WeaponSyncClientService] âŒ æ­¦å™¨ååºåˆ—åŒ–å¤±è´¥");
                    }
                }
                else
                {
                    // å¸ä¸‹æ­¦å™¨
                    if (slot.Content != null)
                    {
                        var removed = slot.Unplug();
                        if (removed != null)
                        {
                            // ğŸ”‘ æ¸…é™¤å½“å‰æ‰‹æŒæ­¦å™¨çš„ ItemAgent
                            try
                            {
                                if (characterMainControl.CurrentHoldItemAgent?.Item == removed)
                                {
                                    characterMainControl.ChangeHoldItem(null);
                                    Debug.Log($"[WeaponSyncClientService] âœ… å·²æ¸…é™¤æ­¦å™¨æ˜¾ç¤º");
                                }
                            }
                            catch (Exception agentEx)
                            {
                                Debug.LogError($"[WeaponSyncClientService] æ¸…é™¤æ­¦å™¨æ˜¾ç¤ºå¤±è´¥: {agentEx.Message}");
                            }

                            removed.DestroyTree();
                            Debug.Log($"[WeaponSyncClientService] âœ… å·²å¸ä¸‹æ­¦å™¨: {slotType}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncClientService] åº”ç”¨æ­¦å™¨å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// åº”ç”¨æ‰€æœ‰æ­¦å™¨åˆ°è§’è‰²
        /// </summary>
        private void ApplyAllWeaponsToCharacter(Core.Players.RemotePlayer remotePlayer)
        {
            try
            {
                var weaponData = remotePlayer.GetWeaponData();
                if (weaponData == null)
                {
                    Debug.Log("[WeaponSyncClientService] è¯¥ç©å®¶æ²¡æœ‰æ­¦å™¨æ•°æ®");
                    return;
                }

                Debug.Log($"[WeaponSyncClientService] å¼€å§‹åº”ç”¨æ‰€æœ‰æ­¦å™¨: {weaponData.GetEquippedCount()} ä»¶");

                int successCount = 0;
                var weaponSlots = new[]
                {
                    (WeaponSlotType.PrimaryWeapon, weaponData.PrimaryWeapon),
                    (WeaponSlotType.SecondaryWeapon, weaponData.SecondaryWeapon),
                    (WeaponSlotType.MeleeWeapon, weaponData.MeleeWeapon)
                };

                foreach (var (slotType, weapon) in weaponSlots)
                {
                    if (weapon != null && weapon.ItemTypeId > 0)
                    {
                        ApplyWeaponToCharacter(remotePlayer, slotType, weapon);
                        successCount++;
                    }
                }

                Debug.Log($"[WeaponSyncClientService] âœ… æ­¦å™¨åº”ç”¨å®Œæˆ: {successCount}/{weaponData.GetEquippedCount()}");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncClientService] åº”ç”¨æ‰€æœ‰æ­¦å™¨å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// è·å–æ§½ä½Hashå€¼
        /// </summary>
        private int GetSlotHash(WeaponSlotType slotType)
        {
            return slotType switch
            {
                WeaponSlotType.PrimaryWeapon => "PrimaryWeapon".GetHashCode(),
                WeaponSlotType.SecondaryWeapon => "SecondaryWeapon".GetHashCode(),
                WeaponSlotType.MeleeWeapon => "MeleeWeapon".GetHashCode(),
                _ => 0
            };
        }
    }
}


```

`Client\Services\WeaponSyncHelper.cs`:

```cs
using System;
using System.IO;
using System.Collections.Generic;
using ItemStatsSystem;
using ItemStatsSystem.Data;
using ItemStatsSystem.Items;
using DuckyNet.Shared.Data;
using NetSerializer;
using UnityEngine;
using Duckov.Utilities;

namespace DuckyNet.Client.Services
{
    /// <summary>
    /// æ­¦å™¨åŒæ­¥è¾…åŠ©ç±»
    /// è´Ÿè´£æ­¦å™¨ç‰©å“çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼ˆå‚è€ƒ ItemNetworkCoordinatorï¼‰
    /// </summary>
    public static class WeaponSyncHelper
    {
        // å¤ç”¨åºåˆ—åŒ–å™¨ï¼Œé¿å…é‡å¤åˆ›å»º
        private static Serializer? _serializer;

        private static Serializer GetSerializer()
        {
            if (_serializer == null)
            {
                _serializer = new Serializer(new[]
                {
                    typeof(SerializableItemData),
                    typeof(SerializableEntry),
                    typeof(SerializableVariable),
                    typeof(SerializableSlot),
                    typeof(SerializableInventoryItem),
                    typeof(List<SerializableEntry>),
                    typeof(List<SerializableVariable>),
                    typeof(List<SerializableSlot>),
                    typeof(List<SerializableInventoryItem>),
                    typeof(List<int>)
                });
            }
            return _serializer;
        }

        /// <summary>
        /// åˆ›å»ºæ­¦å™¨æ§½ä½æ›´æ–°è¯·æ±‚
        /// </summary>
        public static WeaponSlotUpdateRequest CreateWeaponSlotUpdateRequest(WeaponSlotType slotType, Item weaponItem)
        {
            if (weaponItem == null)
            {
                throw new ArgumentNullException(nameof(weaponItem));
            }

            var request = new WeaponSlotUpdateRequest
            {
                SlotType = slotType,
                ItemTypeId = weaponItem.TypeID,
                ItemName = weaponItem.DisplayName
            };

            // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“ï¼ˆå¢é‡åŒæ­¥ä¼˜åŒ–ï¼‰
            if (IsDefaultItem(weaponItem))
            {
                request.IsDefaultItem = true;
                request.ItemDataCompressed = string.Empty;
                Debug.Log($"[WeaponSyncHelper] å¢é‡åŒæ­¥ - é»˜è®¤æ­¦å™¨ï¼Œä¸ä¼ è¾“æ•°æ®: {weaponItem.DisplayName}");
            }
            else
            {
                request.IsDefaultItem = false;
                request.ItemDataCompressed = SerializeAndCompressItem(weaponItem);
                Debug.Log($"[WeaponSyncHelper] å®Œæ•´åŒæ­¥ - è‡ªå®šä¹‰æ­¦å™¨ï¼Œæ•°æ®é•¿åº¦={request.ItemDataCompressed.Length}");
            }

            return request;
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“ï¼ˆæ²¡æœ‰é…ä»¶ã€å¼¹è¯ç­‰ä¿®æ”¹ï¼‰
        /// </summary>
        private static bool IsDefaultItem(Item item)
        {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ’æ§½å†…å®¹ï¼ˆå¦‚é…ä»¶ï¼‰
            if (item.Slots != null)
            {
                foreach (var slot in item.Slots)
                {
                    if (slot.Content != null)
                    {
                        return false;
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰åº“å­˜ç‰©å“ï¼ˆå¦‚å¼¹è¯ï¼‰
            if (item.Inventory != null && item.Inventory.GetItemCount() > 0)
            {
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰å˜é‡
            if (item.Variables != null && item.Variables.Count > 0)
            {
                foreach (var variable in item.Variables)
                {
                    // è·³è¿‡é»˜è®¤çš„ Count=1
                    if (variable.Key == "Count" && variable.DataType == CustomDataType.Int && variable.GetInt() == 1)
                    {
                        continue;
                    }
                    // å‘ç°éé»˜è®¤å˜é‡
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// åºåˆ—åŒ–ç‰©å“æ•°æ®
        /// </summary>
        private static string SerializeAndCompressItem(Item item)
        {
            SerializableItemData? simpleData = null;
            try
            {
                // ä»å¯¹è±¡æ± è·å–
                simpleData = SerializationPool.GetItemData();

                // ä½¿ç”¨ ItemTreeData è·å–å®Œæ•´ç‰©å“æ ‘
                var treeData = ItemTreeData.FromItem(item);
                simpleData.RootInstanceID = treeData.rootInstanceID;

                // è½¬æ¢ä¸ºå¯åºåˆ—åŒ–ç»“æ„
                foreach (var entry in treeData.entries)
                {
                    var simpleEntry = SerializationPool.GetEntry();
                    simpleEntry.InstanceID = entry.instanceID;
                    simpleEntry.TypeID = entry.typeID;

                    // è½¬æ¢ variables
                    foreach (var variable in entry.variables)
                    {
                        var simpleVar = SerializationPool.GetVariable();
                        simpleVar.Key = variable.Key ?? "";
                        simpleVar.DataType = (int)variable.DataType;

                        switch (variable.DataType)
                        {
                            case CustomDataType.Int:
                                simpleVar.IntValue = variable.GetInt();
                                break;
                            case CustomDataType.Float:
                                simpleVar.FloatValue = variable.GetFloat();
                                break;
                            case CustomDataType.String:
                                simpleVar.StringValue = variable.GetString() ?? "";
                                break;
                            case CustomDataType.Bool:
                                simpleVar.BoolValue = variable.GetBool();
                                break;
                        }

                        simpleEntry.Variables.Add(simpleVar);
                    }

                    // è½¬æ¢ slots
                    foreach (var slot in entry.slotContents)
                    {
                        var simpleSlot = SerializationPool.GetSlot();
                        simpleSlot.SlotName = slot.slot ?? "";
                        simpleSlot.ItemInstanceID = slot.instanceID;
                        simpleEntry.Slots.Add(simpleSlot);
                    }

                    // è½¬æ¢ inventory
                    foreach (var inv in entry.inventory)
                    {
                        var simpleInv = SerializationPool.GetInventoryItem();
                        simpleInv.Position = inv.position;
                        simpleInv.ItemInstanceID = inv.instanceID;
                        simpleEntry.Inventory.Add(simpleInv);
                    }

                    // è½¬æ¢ inventorySortLocks
                    simpleEntry.InventorySortLocks.AddRange(entry.inventorySortLocks);

                    simpleData.Entries.Add(simpleEntry);
                }

                // åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„
                byte[] rawBytes;
                using (var ms = new MemoryStream())
                {
                    GetSerializer().Serialize(ms, simpleData);
                    rawBytes = ms.ToArray();
                }

                Debug.Log($"[WeaponSyncHelper] åºåˆ—åŒ–å®Œæˆ: {rawBytes.Length} bytes");

                // Base64 ç¼–ç 
                return Convert.ToBase64String(rawBytes);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncHelper] åºåˆ—åŒ–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return "";
            }
            finally
            {
                // é‡Šæ”¾åˆ°å¯¹è±¡æ± 
                if (simpleData != null)
                {
                    SerializationPool.ReleaseItemData(simpleData);
                }
            }
        }

        /// <summary>
        /// ååºåˆ—åŒ–ç‰©å“æ•°æ®
        /// </summary>
        public static Item? DeserializeItem(string base64Data, int itemTypeId)
        {
            try
            {
                if (string.IsNullOrEmpty(base64Data))
                {
                    // é»˜è®¤ç‰©å“ - ç›´æ¥åˆ›å»º
                    Debug.Log($"[WeaponSyncHelper] åˆ›å»ºé»˜è®¤æ­¦å™¨ - TypeId={itemTypeId}");
                    return ItemAssetsCollection.InstantiateSync(itemTypeId);
                }

                // Base64 è§£ç 
                byte[] rawBytes = Convert.FromBase64String(base64Data);
                Debug.Log($"[WeaponSyncHelper] ååºåˆ—åŒ–: {rawBytes.Length} bytes");

                // ååºåˆ—åŒ–
                SerializableItemData simpleData;
                using (var ms = new MemoryStream(rawBytes))
                {
                    simpleData = (SerializableItemData)GetSerializer().Deserialize(ms);
                }

                // è½¬æ¢ä¸º ItemTreeData
                var treeData = new ItemTreeData
                {
                    rootInstanceID = simpleData.RootInstanceID,
                    entries = new List<ItemTreeData.DataEntry>()
                };

                foreach (var simpleEntry in simpleData.Entries)
                {
                    var entry = new ItemTreeData.DataEntry
                    {
                        instanceID = simpleEntry.InstanceID,
                        typeID = simpleEntry.TypeID,
                        variables = new List<CustomData>(),
                        slotContents = new List<ItemTreeData.SlotInstanceIDPair>(),
                        inventory = new List<ItemTreeData.InventoryDataEntry>(),
                        inventorySortLocks = new List<int>()
                    };

                    // æ¢å¤ variables
                    foreach (var simpleVar in simpleEntry.Variables)
                    {
                        CustomData? customData = null;
                        switch ((CustomDataType)simpleVar.DataType)
                        {
                            case CustomDataType.Int:
                                customData = new CustomData(simpleVar.Key, simpleVar.IntValue);
                                break;
                            case CustomDataType.Float:
                                customData = new CustomData(simpleVar.Key, simpleVar.FloatValue);
                                break;
                            case CustomDataType.String:
                                customData = new CustomData(simpleVar.Key, simpleVar.StringValue);
                                break;
                            case CustomDataType.Bool:
                                customData = new CustomData(simpleVar.Key, simpleVar.BoolValue);
                                break;
                        }
                        if (customData != null)
                        {
                            entry.variables.Add(customData);
                        }
                    }

                    // æ¢å¤ slots
                    foreach (var simpleSlot in simpleEntry.Slots)
                    {
                        entry.slotContents.Add(new ItemTreeData.SlotInstanceIDPair(
                            simpleSlot.SlotName,
                            simpleSlot.ItemInstanceID));
                    }

                    // æ¢å¤ inventory
                    foreach (var simpleInv in simpleEntry.Inventory)
                    {
                        entry.inventory.Add(new ItemTreeData.InventoryDataEntry(
                            simpleInv.Position,
                            simpleInv.ItemInstanceID));
                    }

                    // æ¢å¤ inventorySortLocks
                    entry.inventorySortLocks.AddRange(simpleEntry.InventorySortLocks);

                    treeData.entries.Add(entry);
                }

                Debug.Log($"[WeaponSyncHelper] ååºåˆ—åŒ–æˆåŠŸ - Entries={treeData.entries.Count}");

                // å®ä¾‹åŒ–ç‰©å“æ ‘
                var item = InstantiateItemTreeSync(treeData);

                if (item == null)
                {
                    Debug.LogError($"[WeaponSyncHelper] æ— æ³•åˆ›å»ºæ­¦å™¨ - RootTypeId={treeData.RootTypeID}");
                    return null;
                }

                Debug.Log($"[WeaponSyncHelper] åˆ›å»ºæ­¦å™¨æˆåŠŸ - TypeId={item.TypeID}, Name={item.DisplayName}");
                return item;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[WeaponSyncHelper] ååºåˆ—åŒ–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
                return null;
            }
        }

        /// <summary>
        /// åŒæ­¥å®ä¾‹åŒ–ç‰©å“æ ‘
        /// </summary>
        private static Item? InstantiateItemTreeSync(ItemTreeData treeData)
        {
            var instanceMap = new Dictionary<int, Item>();

            // ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºæ‰€æœ‰ç‰©å“å®ä¾‹
            foreach (var entry in treeData.entries)
            {
                var item = ItemAssetsCollection.InstantiateSync(entry.typeID);
                if (item == null)
                {
                    Debug.LogError($"[WeaponSyncHelper] æ— æ³•åˆ›å»ºç‰©å“ TypeID={entry.typeID}");
                    return null;
                }

                // æ¢å¤å˜é‡
                foreach (var variable in entry.variables)
                {
                    item.Variables.Add(new CustomData(variable));
                }

                instanceMap[entry.instanceID] = item;
            }

            // ç¬¬äºŒæ­¥ï¼šå»ºç«‹ç‰©å“é—´çš„å…³ç³»
            foreach (var entry in treeData.entries)
            {
                var item = instanceMap[entry.instanceID];

                // æ¢å¤æ’æ§½å†…å®¹
                if (item.Slots != null)
                {
                    foreach (var slotPair in entry.slotContents)
                    {
                        if (instanceMap.TryGetValue(slotPair.instanceID, out var contentItem))
                        {
                            var slot = item.Slots.GetSlot(slotPair.slot);
                            if (slot != null)
                            {
                                slot.Plug(contentItem, out _);
                            }
                        }
                    }
                }

                // æ¢å¤èƒŒåŒ…å†…å®¹
                if (item.Inventory != null)
                {
                    foreach (var invEntry in entry.inventory)
                    {
                        if (instanceMap.TryGetValue(invEntry.instanceID, out var invItem))
                        {
                            item.Inventory.AddAt(invItem, invEntry.position);
                        }
                    }

                    // æ¢å¤æ’åºé”å®š
                    if (entry.inventorySortLocks != null)
                    {
                        foreach (var lockIndex in entry.inventorySortLocks)
                        {
                            item.Inventory.lockedIndexes.Add(lockIndex);
                        }
                    }
                }
            }

            // è¿”å›æ ¹ç‰©å“
            return instanceMap[treeData.rootInstanceID];
        }
    }
}


```

`Client\UI\ChatWindow.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Client.Patches;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Services.Generated;

namespace DuckyNet.Client.UI
{
    /// <summary>
    /// èŠå¤©æ¶ˆæ¯æ•°æ®
    /// </summary>
    public class ChatMessage
    {
        public string SenderName { get; set; } = string.Empty;
        public string SteamId { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public DateTime Time { get; set; }
        public MessageType Type { get; set; }
    }

    /// <summary>
    /// èŠå¤©çª—å£
    /// æ”¯æŒ Steam å¤´åƒã€è‡ªåŠ¨æ¸éšã€å›ºå®šå¸ƒå±€ã€è¾“å…¥å±è”½
    /// </summary>
    public class ChatWindow : IUIWindow
    {
        private readonly RpcClient _rpcClient;
        private readonly List<ChatMessage> _messages = new List<ChatMessage>();
        
        private bool _isVisible = true; // é»˜è®¤æ˜¾ç¤º
        private bool _showInput = false;
        private bool _isInRoom = false;
        private Vector2 _scrollPosition = Vector2.zero;
        private string _inputMessage = string.Empty;
        
        // è‡ªåŠ¨æ¸éš
        private float _lastMessageTime = 0f;
        private const float AUTO_HIDE_DELAY = 5f;
        private float _fadeAlpha = 1f;

        // å›ºå®šå¸ƒå±€å¸¸é‡
        private const float PANEL_WIDTH = 400f;
        private const float STATUS_HEIGHT = 25f;
        private const float INPUT_AREA_HEIGHT = 80f;
        private const float MESSAGE_AREA_HEIGHT = 320f;
        private const float PANEL_MARGIN_RIGHT = 20f;
        private const float PANEL_MARGIN_BOTTOM = 100f;
        
        // UI æ ·å¼
        private GUIStyle? _messageStyle;
        private GUIStyle? _usernameStyle;
        private GUIStyle? _timestampStyle;
        private GUIStyle? _textFieldStyle;
        private GUIStyle? _hintStyle;
        private GUIStyle? _statusConnectedStyle;
        private GUIStyle? _statusDisconnectedStyle;

        public bool IsVisible => _isVisible;
        public bool IsInputActive => _showInput;

        public ChatWindow(RpcClient rpcClient)
        {
            _rpcClient = rpcClient;
        }

        /// <summary>
        /// è®¾ç½®æˆ¿é—´çŠ¶æ€
        /// </summary>
        public void SetRoomStatus(bool isInRoom)
        {
            _isInRoom = isInRoom;
        }

        /// <summary>
        /// è·å–ç©å®¶å¤´åƒï¼ˆé€šè¿‡ AvatarManagerï¼‰
        /// </summary>
        private Texture2D? GetPlayerAvatar(string steamId)
        {
            if (!GameContext.IsInitialized)
            {
                return null;
            }

            return GameContext.Instance.AvatarManager.GetAvatar(steamId);
        }

        /// <summary>
        /// æ·»åŠ èŠå¤©æ¶ˆæ¯
        /// </summary>
        public void AddMessage(PlayerInfo sender, string message)
        {
            UnityEngine.Debug.Log($"[ChatWindow] AddMessage è¢«è°ƒç”¨: {sender.SteamName}: {message}");
            
            _messages.Add(new ChatMessage
            {
                SenderName = sender.SteamName,
                SteamId = sender.SteamId,
                Message = message,
                Time = DateTime.Now,
                Type = MessageType.Info
            });
            
            UnityEngine.Debug.Log($"[ChatWindow] æ¶ˆæ¯å·²æ·»åŠ ï¼Œå½“å‰æ¶ˆæ¯æ•°: {_messages.Count}");
            
            if (_messages.Count > 100)
            {
                _messages.RemoveAt(0);
            }
            
            _scrollPosition.y = float.MaxValue;
            _lastMessageTime = Time.time;
            _fadeAlpha = 1f;
        }

        public void AddSystemMessage(string message, MessageType type = MessageType.Info)
        {
            _messages.Add(new ChatMessage
            {
                SenderName = "ç³»ç»Ÿ",
                SteamId = "system",
                Message = message,
                Time = DateTime.Now,
                Type = type
            });
            
            if (_messages.Count > 100)
            {
                _messages.RemoveAt(0);
            }
            
            _scrollPosition.y = float.MaxValue;
            _lastMessageTime = Time.time;
            _fadeAlpha = 1f;
        }

        public void Toggle()
        {
            _isVisible = !_isVisible;
        }

        public void Show()
        {
            _isVisible = true;
        }

        public void Hide()
        {
            _isVisible = false;
            _showInput = false;
            InputBlockingPatch.ShouldBlockGameInput = false;
        }

        public void OnGUI()
        {
            if (!_isVisible) return;

            InitializeStyles();
            
            // æ›´æ–°è¾“å…¥å±è”½çŠ¶æ€
            bool shouldBlock = _showInput;
            if (InputBlockingPatch.ShouldBlockGameInput != shouldBlock)
            {
                UnityEngine.Debug.Log($"[ChatWindow] æ›´æ–°è¾“å…¥å±è”½çŠ¶æ€: {InputBlockingPatch.ShouldBlockGameInput} -> {shouldBlock}");
                InputBlockingPatch.ShouldBlockGameInput = shouldBlock;
            }
            
            // è®¡ç®—æ¸éšæ•ˆæœ
            if (_messages.Count > 0 && !_showInput)
            {
                float timeSinceLastMessage = Time.time - _lastMessageTime;
                if (timeSinceLastMessage > AUTO_HIDE_DELAY)
                {
                    float fadeProgress = (timeSinceLastMessage - AUTO_HIDE_DELAY) / 1f;
                    _fadeAlpha = Mathf.Clamp01(1f - fadeProgress);
                }
                else
                {
                    _fadeAlpha = 1f;
                }
            }
            else if (_showInput)
            {
                _fadeAlpha = 1f;
            }
            
            // å›ºå®šé¢æ¿ä½ç½®
            float chatWidth = PANEL_WIDTH;
            float chatHeight = MESSAGE_AREA_HEIGHT + INPUT_AREA_HEIGHT + STATUS_HEIGHT;
            float xPos = Screen.width - chatWidth - PANEL_MARGIN_RIGHT;
            float yPos = Screen.height - chatHeight - PANEL_MARGIN_BOTTOM;

            // å¤„ç†è¾“å…¥å¿«æ·é”®
            Event e = Event.current;
            string focusedControl = GUI.GetNameOfFocusedControl();
            
            if (_showInput && e.type == EventType.KeyDown)
            {
                if (e.keyCode == KeyCode.Return)
                {
                    if (focusedControl == "ChatInput")
                    {
                        if (!string.IsNullOrWhiteSpace(_inputMessage))
                        {
                            SendMessage();
                        }
                        _showInput = false;
                        _inputMessage = string.Empty;
                        GUI.FocusControl(null);
                        InputBlockingPatch.ShouldBlockGameInput = false;
                    }
                    e.Use();
                    return;
                }
                else if (e.keyCode == KeyCode.Escape)
                {
                    _showInput = false;
                    _inputMessage = string.Empty;
                    GUI.FocusControl(null);
                    InputBlockingPatch.ShouldBlockGameInput = false;
                    e.Use();
                    return;
                }
            }
            else if (e.type == EventType.KeyDown && e.keyCode == KeyCode.Return)
            {
                if (_isInRoom && !_showInput && (string.IsNullOrEmpty(focusedControl) || focusedControl == "ChatInput"))
                {
                    _showInput = true;
                    _fadeAlpha = 1f;
                    InputBlockingPatch.ShouldBlockGameInput = true; // ç«‹å³å±è”½æ¸¸æˆè¾“å…¥
                    e.Use();
                }
            }

            // ç‚¹å‡»å¤–éƒ¨å…³é—­è¾“å…¥æ¡†
            if (_showInput && e.type == EventType.MouseDown)
            {
                Rect chatArea = new Rect(xPos, yPos, chatWidth, chatHeight);
                if (!chatArea.Contains(e.mousePosition))
                {
                    _showInput = false;
                    _inputMessage = string.Empty;
                    GUI.FocusControl(null);
                    InputBlockingPatch.ShouldBlockGameInput = false;
                    e.Use();
                }
            }

            GUILayout.BeginArea(new Rect(xPos, yPos, chatWidth, chatHeight));

            // 1. æ¶ˆæ¯åŒºåŸŸï¼ˆå¯æ¸éšï¼‰
            Color originalColor = GUI.color;
            if (!_showInput)
            {
                GUI.color = new Color(1, 1, 1, _fadeAlpha);
            }
            DrawChatMessages();
            GUI.color = originalColor;

            // 2. è¾“å…¥åŒºåŸŸ
            DrawInputArea();

            // 3. çŠ¶æ€æ 
            DrawStatusBar();

            GUILayout.EndArea();
        }

        private void DrawChatMessages()
        {
            _scrollPosition = GUILayout.BeginScrollView(_scrollPosition, GUIStyle.none, GUIStyle.none, GUILayout.Height(MESSAGE_AREA_HEIGHT));
            GUILayout.BeginVertical();
            GUILayout.FlexibleSpace();
            
            foreach (var msg in _messages)
            {
                DrawChatMessageItem(msg);
                GUILayout.Space(5);
            }
            
            GUILayout.EndVertical();
            GUILayout.EndScrollView();
        }

        private void DrawChatMessageItem(ChatMessage msg)
        {
            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            
            GUILayout.BeginVertical();
            
            // å¤´åƒå’Œæ˜µç§°
            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            
            GUILayout.Label(msg.SenderName, _usernameStyle);
            GUILayout.Space(5);
            
            Texture2D? avatar = GetPlayerAvatar(msg.SteamId);
            if (avatar != null)
            {
                GUILayout.Box(avatar, GUIStyle.none, GUILayout.Width(32), GUILayout.Height(32));
            }
            else
            {
                GUILayout.Space(32);
            }
            
            GUILayout.EndHorizontal();
            
            // æ¶ˆæ¯å†…å®¹
            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            
            Color msgColor = GetMessageColor(msg.Type);
            Color oldColor = GUI.color;
            GUI.color = msgColor;
            GUILayout.Label(msg.Message, _messageStyle);
            GUI.color = oldColor;
            
            GUILayout.Space(5);
            GUILayout.EndHorizontal();
            
            // æ—¶é—´æˆ³
            GUILayout.BeginHorizontal();
            GUILayout.FlexibleSpace();
            GUILayout.Label(msg.Time.ToString("HH:mm:ss"), _timestampStyle);
            GUILayout.Space(5);
            GUILayout.EndHorizontal();
            
            GUILayout.EndVertical();
            GUILayout.EndHorizontal();
        }

        private void DrawInputArea()
        {
            GUILayout.BeginVertical(GUILayout.Height(INPUT_AREA_HEIGHT));
            GUILayout.FlexibleSpace();
            
            if (_showInput)
            {
                GUI.SetNextControlName("ChatInput");
                _inputMessage = GUILayout.TextField(_inputMessage, _textFieldStyle, GUILayout.Height(34));
                GUI.FocusControl("ChatInput");
                
                GUILayout.Space(2);
                GUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                GUILayout.Label("Enter å‘é€  |  ESC å–æ¶ˆ", _hintStyle);
                GUILayout.EndHorizontal();
            }
            else
            {
                GUILayout.BeginHorizontal();
                GUILayout.FlexibleSpace();
                GUILayout.Label(_isInRoom ? "æŒ‰ Enter è¾“å…¥æ¶ˆæ¯..." : "æœªåœ¨æˆ¿é—´ï¼Œä¸èƒ½èŠå¤©", _hintStyle);
                GUILayout.EndHorizontal();
            }
            
            GUILayout.EndVertical();
        }

        private void DrawStatusBar()
        {
            GUILayout.BeginHorizontal(GUILayout.Height(STATUS_HEIGHT));
            GUILayout.FlexibleSpace();
            
            if (_rpcClient.IsConnected)
            {
                GUILayout.Label("â— å·²è¿æ¥", _statusConnectedStyle);
            }
            else
            {
                GUILayout.Label("â— æœªè¿æ¥", _statusDisconnectedStyle);
            }
            
            GUILayout.EndHorizontal();
        }

        private void SendMessage()
        {
            try
            {
                if (string.IsNullOrWhiteSpace(_inputMessage) || !_rpcClient.IsConnected)
                    return;

                string message = _inputMessage.Trim();
                _inputMessage = string.Empty;
                // ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„å¼ºç±»å‹ Proxy
                var serverContext = new ClientServerContext(_rpcClient);
                var playerService = new PlayerServiceClientProxy(serverContext);
                playerService.SendChatMessage(message);
                UnityEngine.Debug.Log($"[ChatWindow] å‘é€æ¶ˆæ¯: {message}");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[ChatWindow] å‘é€æ¶ˆæ¯å¤±è´¥: {ex.Message}");
                AddSystemMessage($"å‘é€å¤±è´¥: {ex.Message}", MessageType.Error);
            }
        }

        private Color GetMessageColor(MessageType type)
        {
            return type switch
            {
                MessageType.Warning => Color.yellow,
                MessageType.Error => Color.red,
                MessageType.Success => Color.green,
                _ => Color.white
            };
        }

        private void InitializeStyles()
        {
            if (_messageStyle != null) return;

            _messageStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 12,
                wordWrap = true,
                alignment = TextAnchor.MiddleRight,
                padding = new RectOffset(5, 5, 3, 3),
                normal = { textColor = Color.white }
            };

            _usernameStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 13,
                fontStyle = FontStyle.Bold,
                alignment = TextAnchor.MiddleRight,
                normal = { textColor = new Color(0.8f, 0.9f, 1f) }
            };

            _timestampStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 9,
                alignment = TextAnchor.MiddleRight,
                normal = { textColor = new Color(0.7f, 0.7f, 0.7f) }
            };

            _textFieldStyle = new GUIStyle(GUI.skin.textField)
            {
                fontSize = 13,
                padding = new RectOffset(8, 8, 8, 8),
                normal = { textColor = Color.white }
            };

            _hintStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 9,
                normal = { textColor = new Color(0.8f, 0.8f, 0.8f) }
            };

            _statusConnectedStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 11,
                fontStyle = FontStyle.Bold,
                normal = { textColor = Color.green }
            };

            _statusDisconnectedStyle = new GUIStyle(GUI.skin.label)
            {
                fontSize = 11,
                fontStyle = FontStyle.Bold,
                normal = { textColor = Color.red }
            };
        }

        public void Dispose()
        {
            // ç¡®ä¿æ¸…é™¤è¾“å…¥å±è”½çŠ¶æ€
            InputBlockingPatch.ShouldBlockGameInput = false;
            
            _messages.Clear();
        }
    }
}

```

`Client\UI\DebugWindow.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.DebugModule;

namespace DuckyNet.Client.UI
{
    /// <summary>
    /// è°ƒè¯•çª—å£ - æ¨¡å—åŒ–ç‰ˆæœ¬
    /// è‡ªåŠ¨å‘ç°å¹¶åŠ è½½æ‰€æœ‰è°ƒè¯•æ¨¡å—
    /// </summary>
    public class DebugWindow : IUIWindow
    {
        private readonly RpcClient _client;
        private readonly DebugModuleManager _moduleManager;
        
        private Rect _windowRect = new Rect(Screen.width - 520, 100, 500, 600);
        private bool _isVisible = false;
        private Vector2 _scrollPosition = Vector2.zero;
        
        // åˆ†ç±»æŠ˜å çŠ¶æ€
        private Dictionary<string, bool> _categoryFoldouts = new Dictionary<string, bool>();
        
        // å½“å‰é€‰ä¸­çš„æ ‡ç­¾é¡µ
        private int _selectedTab = 0;
        private string[] _tabs = { "æ¨¡å—", "è®¾ç½®" };

        public bool IsVisible => _isVisible;

        public DebugWindow(RpcClient client)
        {
            _client = client;
            _moduleManager = new DebugModuleManager(client);
            
            // è‡ªåŠ¨å‘ç°å¹¶æ³¨å†Œæ‰€æœ‰æ¨¡å—
            _moduleManager.DiscoverAndRegisterModules();
            
            // åˆå§‹åŒ–æ‰€æœ‰åˆ†ç±»ä¸ºå±•å¼€çŠ¶æ€
            foreach (var category in _moduleManager.GetAllCategories())
            {
                _categoryFoldouts[category] = true;
            }
            
            UnityEngine.Debug.Log($"[DebugWindow] è°ƒè¯•çª—å£åˆå§‹åŒ–å®Œæˆï¼Œå…±åŠ è½½ {_moduleManager.AllModules.Count} ä¸ªæ¨¡å—");
        }

        public void Toggle()
        {
            _isVisible = !_isVisible;
        }

        public void Show()
        {
            _isVisible = true;
        }

        public void Hide()
        {
            _isVisible = false;
        }

        public void Update()
        {
            if (_isVisible)
            {
                _moduleManager.Update();
            }
        }

        public void OnGUI()
        {
            if (!_isVisible) return;

            _windowRect = GUILayout.Window(1002, _windowRect, DrawWindow, "DuckyNet è°ƒè¯•å·¥å…· v2.0");
        }

        private void DrawWindow(int windowId)
        {
            // ç»˜åˆ¶æ ‡ç­¾é¡µ
            _selectedTab = GUILayout.Toolbar(_selectedTab, _tabs);
            
            GUILayout.Space(5);
            
            _scrollPosition = GUILayout.BeginScrollView(_scrollPosition);
            
            switch (_selectedTab)
            {
                case 0:
                    DrawModulesTab();
                    break;
                case 1:
                    DrawSettingsTab();
                    break;
            }
            
            GUILayout.EndScrollView();
            GUI.DragWindow();
        }

        /// <summary>
        /// ç»˜åˆ¶æ¨¡å—æ ‡ç­¾é¡µ
        /// </summary>
        private void DrawModulesTab()
        {
            GUILayout.BeginVertical();

            // æŒ‰åˆ†ç±»æ˜¾ç¤ºæ‰€æœ‰æ¨¡å—
            var categories = _moduleManager.GetAllCategories();
            
            if (categories.Count == 0)
            {
                GUILayout.Label("æœªæ‰¾åˆ°ä»»ä½•è°ƒè¯•æ¨¡å—", GetWarningStyle());
            }
            else
            {
                foreach (var category in categories)
                {
                    DrawCategoryModules(category);
                    GUILayout.Space(10);
                }
            }

            GUILayout.EndVertical();
        }

        /// <summary>
        /// ç»˜åˆ¶è®¾ç½®æ ‡ç­¾é¡µ
        /// </summary>
        private void DrawSettingsTab()
        {
            GUILayout.BeginVertical();

            GUILayout.Label("=== æ¨¡å—è®¾ç½® ===", GetHeaderStyle());
            GUILayout.Space(5);

            // æ˜¾ç¤ºæ‰€æœ‰æ¨¡å—çš„å¼€å…³
            foreach (var module in _moduleManager.AllModules)
            {
                GUILayout.BeginHorizontal();
                
                bool wasEnabled = module.IsEnabled;
                bool isEnabled = GUILayout.Toggle(wasEnabled, "");
                
                if (isEnabled != wasEnabled)
                {
                    module.IsEnabled = isEnabled;
                    UnityEngine.Debug.Log($"[DebugWindow] æ¨¡å— {module.ModuleName} {(isEnabled ? "å¯ç”¨" : "ç¦ç”¨")}");
                }
                
                GUILayout.Label($"{module.ModuleName} ({module.Category})");
                GUILayout.FlexibleSpace();
                
                GUILayout.EndHorizontal();
            }

            GUILayout.Space(10);

            // å…¨å±€æ“ä½œæŒ‰é’®
            GUILayout.Label("=== å…¨å±€æ“ä½œ ===", GetHeaderStyle());
            
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("å¯ç”¨æ‰€æœ‰"))
            {
                foreach (var module in _moduleManager.AllModules)
                {
                    module.IsEnabled = true;
                }
            }
            if (GUILayout.Button("ç¦ç”¨æ‰€æœ‰"))
            {
                foreach (var module in _moduleManager.AllModules)
                {
                    module.IsEnabled = false;
                }
            }
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // ç»Ÿè®¡ä¿¡æ¯
            GUILayout.Label("=== ç»Ÿè®¡ä¿¡æ¯ ===", GetHeaderStyle());
            GUILayout.Label($"æ€»æ¨¡å—æ•°: {_moduleManager.AllModules.Count}");
            GUILayout.Label($"å¯ç”¨æ¨¡å—: {_moduleManager.AllModules.Count(m => m.IsEnabled)}");
            GUILayout.Label($"åˆ†ç±»æ•°é‡: {_moduleManager.GetAllCategories().Count}");

            GUILayout.EndVertical();
        }

        /// <summary>
        /// ç»˜åˆ¶æŸä¸ªåˆ†ç±»ä¸‹çš„æ‰€æœ‰æ¨¡å—
        /// </summary>
        private void DrawCategoryModules(string category)
        {
            // ç¡®ä¿åˆ†ç±»å­˜åœ¨äºå­—å…¸ä¸­
            if (!_categoryFoldouts.ContainsKey(category))
            {
                _categoryFoldouts[category] = true;
            }

            // ç»˜åˆ¶åˆ†ç±»æ ‡é¢˜ï¼ˆå¯æŠ˜å ï¼‰
            GUILayout.BeginHorizontal();
            _categoryFoldouts[category] = GUILayout.Toggle(
                _categoryFoldouts[category], 
                $"â–¼ {category}", 
                GetHeaderStyle()
            );
            GUILayout.EndHorizontal();

            // å¦‚æœå±•å¼€ï¼Œç»˜åˆ¶æ¨¡å—å†…å®¹
            if (_categoryFoldouts[category])
            {
                var modules = _moduleManager.GetModulesByCategory(category);
                
                foreach (var module in modules)
                {
                    if (!module.IsEnabled) continue;

                    try
                    {
                        GUILayout.BeginVertical(GUI.skin.box);
                        
                        // æ¨¡å—æ ‡é¢˜
                        GUILayout.Label($"â— {module.ModuleName}", GetSubHeaderStyle());
                        
                        if (!string.IsNullOrEmpty(module.Description))
                        {
                            var descStyle = new GUIStyle(GUI.skin.label);
                            descStyle.fontSize = 10;
                            descStyle.normal.textColor = Color.gray;
                            GUILayout.Label(module.Description, descStyle);
                        }
                        
                        GUILayout.Space(5);
                        
                        // ç»˜åˆ¶æ¨¡å—UI
                        module.OnGUI();
                        
                        GUILayout.EndVertical();
                        GUILayout.Space(5);
                    }
                    catch (Exception ex)
                    {
                        GUILayout.Label($"æ¨¡å—é”™è¯¯: {ex.Message}", GetErrorStyle());
                        UnityEngine.Debug.LogError($"[DebugWindow] æ¨¡å— {module.ModuleName} æ¸²æŸ“å¤±è´¥: {ex}");
                    }
                }
            }
        }

        private GUIStyle GetHeaderStyle()
        {
            var style = new GUIStyle(GUI.skin.label);
            style.fontStyle = FontStyle.Bold;
            style.fontSize = 13;
            return style;
        }

        private GUIStyle GetSubHeaderStyle()
        {
            var style = new GUIStyle(GUI.skin.label);
            style.fontStyle = FontStyle.Bold;
            style.fontSize = 11;
            return style;
        }

        private GUIStyle GetWarningStyle()
        {
            var style = new GUIStyle(GUI.skin.label);
            style.normal.textColor = Color.yellow;
            return style;
        }

        private GUIStyle GetErrorStyle()
        {
            var style = new GUIStyle(GUI.skin.label);
            style.normal.textColor = Color.red;
            return style;
        }

        public void Dispose()
        {
            _moduleManager?.Dispose();
        }
    }
}

```

`Client\UI\LobbyPage.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Services.Generated;


namespace DuckyNet.Client.UI
{
    /// <summary>
    /// å¤§å…é¡µé¢
    /// <para>è´Ÿè´£å±•ç¤ºæˆ¿é—´åˆ—è¡¨ã€åˆ·æ–°æˆ¿é—´ã€åˆ›å»ºæˆ¿é—´ä¸åŠ å…¥æˆ¿é—´çš„ UI ä¸äº¤äº’é€»è¾‘ã€‚</para>
    /// <para>é€šè¿‡ <see cref="RpcClient"/> è°ƒç”¨æœåŠ¡å™¨ç«¯çš„æˆ¿é—´æœåŠ¡æ¥å£ <see cref="IRoomService"/>ã€‚</para>
    /// </summary>
    public class LobbyPage
    {
        /// <summary>
        /// RPC å®¢æˆ·ç«¯ï¼Œç”¨äºä¸æœåŠ¡å™¨è¿›è¡Œäº¤äº’
        /// </summary>
        private readonly RpcClient _client;

        /// <summary>
        /// æˆ¿é—´æœåŠ¡å®¢æˆ·ç«¯ä»£ç†ï¼ˆå¤ç”¨ï¼Œé¿å…é‡å¤åˆ›å»ºï¼‰
        /// </summary>
        private readonly RoomServiceClientProxy _roomService;

        /// <summary>
        /// ä¸»èœå•çª—å£å¼•ç”¨ï¼Œç”¨äºé¡µé¢åˆ‡æ¢ä¸æˆ¿é—´é¡µè”åŠ¨
        /// </summary>
        private readonly MainMenuWindow _mainWindow;

        /// <summary>
        /// æˆ¿é—´åˆ—è¡¨æ»šåŠ¨è§†å›¾ä½ç½®
        /// </summary>
        private Vector2 _scrollPos;

        /// <summary>
        /// å½“å‰è·å–åˆ°çš„æˆ¿é—´åˆ—è¡¨ï¼ˆæ¥è‡ªæœåŠ¡å™¨ï¼‰
        /// </summary>
        private List<RoomInfo> _roomList = new List<RoomInfo>();

        // åˆ›å»ºæˆ¿é—´è¾“å…¥
        /// <summary>
        /// å¾…åˆ›å»ºæˆ¿é—´åç§°
        /// </summary>
        private string _newRoomName = "æˆ‘çš„æˆ¿é—´";
        /// <summary>
        /// å¾…åˆ›å»ºæˆ¿é—´å¯†ç ï¼ˆå¯ä¸ºç©ºï¼‰
        /// </summary>
        private string _newRoomPassword = "";
        /// <summary>
        /// å¾…åˆ›å»ºæˆ¿é—´æè¿°
        /// </summary>
        private string _newRoomDescription = "";
    /// <summary>
    /// å¾…åˆ›å»ºæˆ¿é—´æœ€å¤§äººæ•°ï¼ˆ2-16ï¼‰
    /// </summary>
    private int _newRoomMaxPlayers = 8;

    // åŠ å…¥æˆ¿é—´å¯†ç è¾“å…¥ï¼ˆæ¯ä¸ªæˆ¿é—´ç‹¬ç«‹çš„å¯†ç è¾“å…¥æ¡†ï¼‰
    /// <summary>
    /// æˆ¿é—´å¯†ç è¾“å…¥å­—å…¸ï¼ˆRoomId -> Passwordï¼‰
    /// </summary>
    private Dictionary<string, string> _roomPasswords = new Dictionary<string, string>();

    /// <summary>
    /// æ„é€ å‡½æ•°
    /// </summary>
        /// <param name="client">ç”¨äºä¸æœåŠ¡å™¨äº¤äº’çš„ RPC å®¢æˆ·ç«¯</param>
        /// <param name="mainWindow">ä¸»èœå•çª—å£ï¼Œç”¨äºé¡µé¢åˆ‡æ¢</param>
        public LobbyPage(RpcClient client, MainMenuWindow mainWindow)
        {
            _client = client;
            _mainWindow = mainWindow;

            // é¢„å…ˆåˆ›å»ºå¹¶ç¼“å­˜æœåŠ¡ä»£ç†ï¼Œåç»­å„æ–¹æ³•ç›´æ¥å¤ç”¨
            var serverContext = new ClientServerContext(_client);
            _roomService = new RoomServiceClientProxy(serverContext);
        }

        /// <summary>
        /// ç»˜åˆ¶å¤§å…é¡µé¢ï¼ˆåœ¨ OnGUI ä¸­è¢«è°ƒç”¨ï¼‰
        /// </summary>
        public void Draw()
        {
            DrawHeaderAndActions();
            DrawRoomListSection();
            DrawCreateRoomSection();
        }

        /// <summary>
        /// ç»˜åˆ¶æ ‡é¢˜ä¸é¡¶éƒ¨æ“ä½œï¼ˆåˆ·æ–°æŒ‰é’®ï¼‰
        /// </summary>
        private void DrawHeaderAndActions()
        {
            GUILayout.Label("æ¸¸æˆå¤§å…", GUI.skin.box);
            GUILayout.Space(10);

            GUILayout.BeginHorizontal();
            
            // åˆ·æ–°æˆ¿é—´åˆ—è¡¨æŒ‰é’®
            if (GUILayout.Button("åˆ·æ–°æˆ¿é—´åˆ—è¡¨"))
            {
                RefreshRoomListAsync();
            }

            GUILayout.FlexibleSpace();
            
            // æ–­å¼€è¿æ¥æŒ‰é’®
            if (GUILayout.Button("æ–­å¼€è¿æ¥", GUILayout.Width(100)))
            {
                _client.Disconnect();
                _mainWindow.SwitchToPage(MainMenuPage.Connect);
            }
            
            GUILayout.EndHorizontal();

            GUILayout.Space(10);
        }

        /// <summary>
        /// ç»˜åˆ¶æˆ¿é—´åˆ—è¡¨åŒºåŸŸ
        /// </summary>
        private void DrawRoomListSection()
        {
            // æˆ¿é—´åˆ—è¡¨
            GUILayout.Label($"æˆ¿é—´åˆ—è¡¨ ({_roomList.Count})", GUI.skin.box);
            _scrollPos = GUILayout.BeginScrollView(_scrollPos, GUILayout.Height(200));

            foreach (var room in _roomList)
            {
                GUILayout.BeginVertical(GUI.skin.box);
                
                // ç¬¬ä¸€è¡Œï¼šæˆ¿é—´åç§° + æ˜¯å¦åŠ å¯†
                GUILayout.BeginHorizontal();
                string lockIcon = room.RequirePassword ? "ğŸ”’" : "ğŸ”“";
                GUILayout.Label($"{lockIcon} {room.RoomName}", GUILayout.Width(200));
                GUILayout.Label($"[{room.CurrentPlayers}/{room.MaxPlayers}]", GUILayout.Width(50));
                GUILayout.FlexibleSpace();
                GUILayout.EndHorizontal();

                // ç¬¬äºŒè¡Œï¼šç®€ä»‹
                if (!string.IsNullOrEmpty(room.Description))
                {
                    GUILayout.Label($"ç®€ä»‹: {room.Description}");
                }
                else
                {
                    GUILayout.Label("ç®€ä»‹: (æ— )", GUI.skin.label);
                }

                // ç¬¬ä¸‰è¡Œï¼šå¯†ç è¾“å…¥æ¡†ï¼ˆå¦‚æœéœ€è¦ï¼‰+ åŠ å…¥æŒ‰é’®
                GUILayout.BeginHorizontal();
                
                if (room.RequirePassword)
                {
                    GUILayout.Label("å¯†ç :", GUILayout.Width(40));
                    
                    // ç¡®ä¿å­—å…¸ä¸­æœ‰è¿™ä¸ªæˆ¿é—´çš„æ¡ç›®
                    if (!_roomPasswords.ContainsKey(room.RoomId))
                    {
                        _roomPasswords[room.RoomId] = "";
                    }
                    
                    _roomPasswords[room.RoomId] = GUILayout.PasswordField(_roomPasswords[room.RoomId], '*', GUILayout.Width(120));
                }
                else
                {
                    GUILayout.FlexibleSpace();
                }
                
                GUILayout.FlexibleSpace();
                
                if (GUILayout.Button("åŠ å…¥", GUILayout.Width(80)))
                {
                    string password = room.RequirePassword && _roomPasswords.ContainsKey(room.RoomId) 
                        ? _roomPasswords[room.RoomId] 
                        : "";
                    JoinRoomAsync(room.RoomId, password);
                }

                GUILayout.EndHorizontal();
                
                GUILayout.EndVertical();
                GUILayout.Space(5);
            }

            GUILayout.EndScrollView();

            GUILayout.Space(10);
        }


        /// <summary>
        /// ç»˜åˆ¶åˆ›å»ºæˆ¿é—´åŒºåŸŸ
        /// </summary>
        private void DrawCreateRoomSection()
        {
            // åˆ›å»ºæˆ¿é—´
            GUILayout.Label("åˆ›å»ºæˆ¿é—´", GUI.skin.box);

            GUILayout.BeginHorizontal();
            GUILayout.Label("æˆ¿é—´åç§°:", GUILayout.Width(80));
            _newRoomName = GUILayout.TextField(_newRoomName);
            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            GUILayout.Label("å¯†ç :", GUILayout.Width(80));
            _newRoomPassword = GUILayout.PasswordField(_newRoomPassword, '*');
            GUILayout.Label("(å¯é€‰)", GUILayout.Width(50));
            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            GUILayout.Label("æè¿°:", GUILayout.Width(80));
            _newRoomDescription = GUILayout.TextField(_newRoomDescription);
            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            GUILayout.Label("æœ€å¤§äººæ•°:", GUILayout.Width(80));
            _newRoomMaxPlayers = (int)GUILayout.HorizontalSlider(_newRoomMaxPlayers, 2, 16);
            GUILayout.Label(_newRoomMaxPlayers.ToString(), GUILayout.Width(30));
            GUILayout.EndHorizontal();

            if (GUILayout.Button("åˆ›å»ºæˆ¿é—´"))
            {
                CreateRoomAsync();
            }
        }

        private async void RefreshRoomListAsync()
        {
            try
            {
                var rooms = await _roomService.GetRoomListAsync();

                _roomList = new List<RoomInfo>(rooms);
                UnityEngine.Debug.Log($"[LobbyPage] æˆ¿é—´åˆ—è¡¨å·²åˆ·æ–°ï¼šå…± {rooms.Length} ä¸ªæˆ¿é—´");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LobbyPage] åˆ·æ–°æˆ¿é—´åˆ—è¡¨å¤±è´¥ï¼š{ex.Message}");
            }
        }

        private async void CreateRoomAsync()
        {
            try
            {
                var result = await _roomService.CreateRoomAsync(new CreateRoomRequest
                {
                    RoomName = _newRoomName,
                    Password = _newRoomPassword,
                    Description = _newRoomDescription,
                    MaxPlayers = _newRoomMaxPlayers
                });

                if (result.Success && result.Room != null)
                {
                    UnityEngine.Debug.Log($"[LobbyPage] æˆ¿é—´åˆ›å»ºæˆåŠŸï¼š{result.Room.RoomId}");
                    
                    // ğŸ”¥ åˆ›å»ºæˆ¿é—´æˆåŠŸåï¼Œç«‹å³åŒæ­¥åœºæ™¯ä¿¡æ¯ï¼ˆç°åœ¨å·²ç»åœ¨æˆ¿é—´ä¸­äº†ï¼‰
                    if (GameContext.IsInitialized)
                    {
                        var sceneManager = GameContext.Instance.SceneClientManager;
                        var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                        
                        if (!string.IsNullOrEmpty(sceneManager._scenelDataList.SceneName))
                        {
                            // ğŸ”¥ æ›´æ–°æœ¬åœ°ç©å®¶çš„åœºæ™¯ä¿¡æ¯
                            localPlayer.Info.CurrentScenelData = sceneManager._scenelDataList;
                            UnityEngine.Debug.Log($"[LobbyPage] ğŸ”¥ åˆ›å»ºæˆ¿é—´ååŒæ­¥åœºæ™¯ä¿¡æ¯: {sceneManager._scenelDataList.SceneName}");
                            
                            // ğŸ”¥ å‘é€åœºæ™¯è¿›å…¥è¯·æ±‚ï¼ˆç°åœ¨æœåŠ¡å™¨çŸ¥é“ä½ åœ¨æˆ¿é—´ä¸­äº†ï¼Œä¼šå¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰äººï¼‰
                            var sceneService = new SceneServiceClientProxy(new ClientServerContext(_client));
                            await sceneService.EnterSceneAsync(sceneManager._scenelDataList);
                            UnityEngine.Debug.Log($"[LobbyPage] ğŸ”¥ åœºæ™¯åŒæ­¥å®Œæˆ");
                        }
                        else
                        {
                            UnityEngine.Debug.Log($"[LobbyPage] âš ï¸ å½“å‰æœªåœ¨åœºæ™¯ä¸­ï¼Œè·³è¿‡åœºæ™¯åŒæ­¥");
                        }
                    }
                    
                    _mainWindow.RoomPage.SetCurrentRoom(result.Room);
                    _mainWindow.SwitchToPage(MainMenuPage.Room);
                }
                else
                {
                    UnityEngine.Debug.LogError($"[LobbyPage] åˆ›å»ºæˆ¿é—´å¤±è´¥ï¼š{result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LobbyPage] åˆ›å»ºæˆ¿é—´å‡ºé”™ï¼š{ex.Message}");
            }
        }

        private async void JoinRoomAsync(string roomId, string password)
        {
            try
            {
                var request = new JoinRoomRequest
                {
                    RoomId = roomId,
                    Password = password
                };

                var result = await _roomService.JoinRoomAsync(request);

                if (result.Success && result.Room != null)
                {
                    UnityEngine.Debug.Log($"[LobbyPage] åŠ å…¥æˆ¿é—´æˆåŠŸï¼š{roomId}");
                    
                    // ğŸ”¥ åŠ å…¥æˆ¿é—´æˆåŠŸåï¼Œç«‹å³åŒæ­¥åœºæ™¯ä¿¡æ¯ï¼ˆç°åœ¨å·²ç»åœ¨æˆ¿é—´ä¸­äº†ï¼‰
                    if (GameContext.IsInitialized)
                    {
                        var sceneManager = GameContext.Instance.SceneClientManager;
                        var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                        
                        if (!string.IsNullOrEmpty(sceneManager._scenelDataList.SceneName))
                        {
                            // ğŸ”¥ æ›´æ–°æœ¬åœ°ç©å®¶çš„åœºæ™¯ä¿¡æ¯
                            localPlayer.Info.CurrentScenelData = sceneManager._scenelDataList;
                            UnityEngine.Debug.Log($"[LobbyPage] ğŸ”¥ åŠ å…¥æˆ¿é—´ååŒæ­¥åœºæ™¯ä¿¡æ¯: {sceneManager._scenelDataList.SceneName}");
                            
                            // ğŸ”¥ å‘é€åœºæ™¯è¿›å…¥è¯·æ±‚ï¼ˆç°åœ¨æœåŠ¡å™¨çŸ¥é“ä½ åœ¨æˆ¿é—´ä¸­äº†ï¼Œä¼šå¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰äººï¼‰
                            var sceneService = new SceneServiceClientProxy(new ClientServerContext(_client));
                            await sceneService.EnterSceneAsync(sceneManager._scenelDataList);
                            UnityEngine.Debug.Log($"[LobbyPage] ğŸ”¥ åœºæ™¯åŒæ­¥å®Œæˆ");
                        }
                        else
                        {
                            UnityEngine.Debug.Log($"[LobbyPage] âš ï¸ å½“å‰æœªåœ¨åœºæ™¯ä¸­ï¼Œè·³è¿‡åœºæ™¯åŒæ­¥");
                        }
                    }
                    
                    _mainWindow.RoomPage.SetCurrentRoom(result.Room);
                    _mainWindow.SwitchToPage(MainMenuPage.Room);
                }
                else
                {
                    UnityEngine.Debug.LogError($"[LobbyPage] åŠ å…¥æˆ¿é—´å¤±è´¥ï¼š{result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[LobbyPage] åŠ å…¥æˆ¿é—´å‡ºé”™ï¼š{ex.Message}");
            }
        }
    }
}


```

`Client\UI\MainMenuWindow.cs`:

```cs
using System;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Services.Generated;


namespace DuckyNet.Client.UI
{
    /// <summary>
    /// ä¸»èœå•é¡µé¢æšä¸¾
    /// </summary>
    public enum MainMenuPage
    {
        Connect,
        Lobby,
        Room
    }

    /// <summary>
    /// ä¸»èœå•çª—å£
    /// </summary>
    public class MainMenuWindow : IUIWindow
    {
        private readonly RpcClient _client;
        private Rect _windowRect = new Rect(100, 100, 400, 300);
        private bool _isVisible = false;

        private PlayerServiceClientProxy _playerServiceClient;

        // ğŸ”¥ é…ç½®ä¿å­˜é”®
        private const string PREF_KEY_SERVER_ADDRESS = "DuckyNet_ServerAddress";
        private const string PREF_KEY_SERVER_PORT = "DuckyNet_ServerPort";

        // è¿æ¥é¡µé¢
        private string _serverAddress = "127.0.0.1";
        private string _serverPort = "9050";
        private string _connectionStatus = "";
        private bool _isConnecting = false;

        // å½“å‰é¡µé¢
        
        private MainMenuPage _currentPage = MainMenuPage.Connect;

        // å­é¡µé¢
        public LobbyPage LobbyPage { get; private set; }
        public RoomPage RoomPage { get; private set; }

        public bool IsVisible => _isVisible;

        private ChatWindow? _chatWindow;

        public MainMenuWindow(RpcClient client, ChatWindow chatWindow)
        {
            _client = client;
            _chatWindow = chatWindow;
            LobbyPage = new LobbyPage(client, this);
            RoomPage = new RoomPage(client, this);
            
            // å°†èŠå¤©çª—å£ä¼ é€’ç»™ RoomPage
            RoomPage.SetChatWindow(chatWindow);
            var serverContext = new ClientServerContext(_client);
            _playerServiceClient = new PlayerServiceClientProxy(serverContext);
            
            // ğŸ”¥ åŠ è½½ä¿å­˜çš„æœåŠ¡å™¨é…ç½®
            LoadServerConfig();
            
            // è®¢é˜…è¿æ¥äº‹ä»¶
            _client.Connected += OnConnected;
            _client.Disconnected += OnDisconnectedHandler;
            _client.ConnectionFailed += OnConnectionFailed;
        }

        public void Toggle()
        {
            _isVisible = !_isVisible;
        }

        public void Show()
        {
            _isVisible = true;
        }

        public void Hide()
        {
            _isVisible = false;
        }

        public void SwitchToPage(MainMenuPage page)
        {
            _currentPage = page;
        }

        private void OnConnected()
        {
            UnityEngine.Debug.Log("[MainMenu] Connected to server");
            _isConnecting = false;
            _connectionStatus = "âœ“ å·²è¿æ¥ï¼Œæ­£åœ¨ç™»å½•...";
            // è¿æ¥æˆåŠŸåè‡ªåŠ¨ç™»å½•
            LoginAsync();
        }

        private void OnDisconnectedHandler(string reason)
        {
            UnityEngine.Debug.Log($"[MainMenu] Disconnected: {reason}");
            _isConnecting = false;
            _currentPage = MainMenuPage.Connect;
            
            // å¦‚æœä¸æ˜¯ä¸»åŠ¨æ–­å¼€ï¼Œæ˜¾ç¤ºæ–­å¼€åŸå› 
            if (_connectionStatus != "")
            {
                _connectionStatus = $"âœ— å·²æ–­å¼€: {reason}";
            }
        }
        
        private void OnConnectionFailed(string errorMessage)
        {
            UnityEngine.Debug.LogError($"[MainMenu] Connection failed: {errorMessage}");
            _isConnecting = false;
            _connectionStatus = $"âœ— {errorMessage}";
            
            // åœ¨èŠå¤©çª—å£æ˜¾ç¤ºé”™è¯¯
            _chatWindow?.AddSystemMessage($"è¿æ¥å¤±è´¥: {errorMessage}", MessageType.Error);
        }

        public void OnGUI()
        {
            if (!_isVisible) return;

            _windowRect = GUILayout.Window(1000, _windowRect, DrawWindow, "DuckyNet ä¸»èœå•");
        }

        private void DrawWindow(int windowId)
        {
            GUILayout.BeginVertical();

            switch (_currentPage)
            {
                case MainMenuPage.Connect:
                    DrawConnectPage();
                    break;
                case MainMenuPage.Lobby:
                    LobbyPage.Draw();
                    break;
                case MainMenuPage.Room:
                    RoomPage.Draw();
                    break;
            }

            GUILayout.EndVertical();
            GUI.DragWindow();
        }

        private void DrawConnectPage()
        {
            GUILayout.Label("è¿æ¥åˆ°æœåŠ¡å™¨", GUI.skin.box);
            GUILayout.Space(10);

            GUILayout.BeginHorizontal();
            GUILayout.Label("æœåŠ¡å™¨åœ°å€:", GUILayout.Width(100));
            _serverAddress = GUILayout.TextField(_serverAddress);
            GUILayout.EndHorizontal();

            GUILayout.BeginHorizontal();
            GUILayout.Label("ç«¯å£:", GUILayout.Width(100));
            _serverPort = GUILayout.TextField(_serverPort);
            GUILayout.EndHorizontal();

            GUILayout.Space(5);
            
            // ğŸ”¥ é…ç½®ç®¡ç†æŒ‰é’®
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("ğŸ’¾ ä¿å­˜é…ç½®", GUILayout.Width(100)))
            {
                SaveServerConfig();
                _connectionStatus = "âœ“ é…ç½®å·²ä¿å­˜";
            }
            
            if (GUILayout.Button("ğŸ—‘ï¸ æ¸…é™¤é…ç½®", GUILayout.Width(100)))
            {
                PlayerPrefs.DeleteKey(PREF_KEY_SERVER_ADDRESS);
                PlayerPrefs.DeleteKey(PREF_KEY_SERVER_PORT);
                PlayerPrefs.Save();
                _serverAddress = "127.0.0.1";
                _serverPort = "9050";
                _connectionStatus = "âœ“ é…ç½®å·²æ¸…é™¤";
                UnityEngine.Debug.Log("[MainMenu] ğŸ—‘ï¸ æ¸…é™¤ä¿å­˜çš„é…ç½®");
            }
            GUILayout.EndHorizontal();

            GUILayout.Space(10);

            // æ˜¾ç¤ºç©å®¶ä¿¡æ¯ï¼ˆåªè¯»ï¼‰
            if (GameContext.IsInitialized)
            {
                var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                var playerInfo = localPlayer.Info;
                
                GUILayout.BeginHorizontal();
                GUILayout.Label("ç©å®¶åç§°:", GUILayout.Width(100));
                GUILayout.Label(playerInfo.SteamName, GUI.skin.box);
                GUILayout.EndHorizontal();

                GUILayout.BeginHorizontal();
                GUILayout.Label("Steam ID:", GUILayout.Width(100));
                GUILayout.Label(playerInfo.SteamId, GUI.skin.box);
                GUILayout.EndHorizontal();

                // æ˜¾ç¤ºå¤´åƒï¼ˆå¦‚æœå·²åŠ è½½ï¼‰
                if (localPlayer.AvatarTexture != null)
                {
                    GUILayout.BeginHorizontal();
                    GUILayout.Label("å¤´åƒ:", GUILayout.Width(100));
                    GUILayout.Box(localPlayer.AvatarTexture, GUILayout.Width(64), GUILayout.Height(64));
                    GUILayout.EndHorizontal();
                }
            }

            GUILayout.Space(10);

            // æ˜¾ç¤ºè¿æ¥çŠ¶æ€
            if (!string.IsNullOrEmpty(_connectionStatus))
            {
                var style = new GUIStyle(GUI.skin.box);
                if (_connectionStatus.StartsWith("âœ“"))
                {
                    style.normal.textColor = Color.green;
                }
                else if (_connectionStatus.StartsWith("âœ—"))
                {
                    style.normal.textColor = Color.red;
                }
                else if (_connectionStatus.StartsWith("â—"))
                {
                    style.normal.textColor = Color.yellow;
                }
                
                GUILayout.Label(_connectionStatus, style);
                GUILayout.Space(5);
            }

            if (_client.IsConnected)
            {
                GUILayout.Label("â— å·²è¿æ¥å¹¶ç™»å½•", GUI.skin.box);

                if (GUILayout.Button("æ–­å¼€è¿æ¥"))
                {
                    _connectionStatus = "";
                    _client.Disconnect();
                }
            }
            else if (_isConnecting)
            {
                GUILayout.Label("â— æ­£åœ¨è¿æ¥...", GUI.skin.box);
                
                if (GUILayout.Button("å–æ¶ˆ"))
                {
                    _client.Disconnect();
                    _isConnecting = false;
                    _connectionStatus = "âœ— å·²å–æ¶ˆè¿æ¥";
                }
            }
            else
            {
                if (GUILayout.Button("è¿æ¥æœåŠ¡å™¨"))
                {
                    Connect();
                }
            }
        }

        private void Connect()
        {
            try
            {
                if (!int.TryParse(_serverPort, out int port))
                {
                    _connectionStatus = "âœ— ç«¯å£å·æ— æ•ˆ";
                    UnityEngine.Debug.LogError("[MainMenu] Invalid port number");
                    return;
                }

                if (string.IsNullOrWhiteSpace(_serverAddress))
                {
                    _connectionStatus = "âœ— æœåŠ¡å™¨åœ°å€ä¸èƒ½ä¸ºç©º";
                    UnityEngine.Debug.LogError("[MainMenu] Server address is empty");
                    return;
                }

                _isConnecting = true;
                _connectionStatus = $"â— æ­£åœ¨è¿æ¥ {_serverAddress}:{port}...";
                _client.Connect(_serverAddress, port);
                
                // ğŸ”¥ ä¿å­˜æœåŠ¡å™¨é…ç½®ï¼ˆè¿æ¥æ—¶ä¿å­˜ï¼Œé¿å…åªæœ‰æˆåŠŸæ‰ä¿å­˜ï¼‰
                SaveServerConfig();
                
                UnityEngine.Debug.Log($"[MainMenu] Connecting to {_serverAddress}:{port}...");
            }
            catch (Exception ex)
            {
                _isConnecting = false;
                _connectionStatus = $"âœ— è¿æ¥å¤±è´¥: {ex.Message}";
                UnityEngine.Debug.LogError($"[MainMenu] Connect failed: {ex.Message}");
            }
        }

        private async void LoginAsync()
        {
            try
            {
                // ä½¿ç”¨æœ¬åœ°ç©å®¶ä¿¡æ¯
                if (!GameContext.IsInitialized)
                {
                    UnityEngine.Debug.LogError("[MainMenu] æ¸¸æˆä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–");
                    return;
                }

                var localPlayer = GameContext.Instance.PlayerManager.LocalPlayer;
                var serverContext = new ClientServerContext(_client);

                // ğŸ”¥ è°ƒè¯•ï¼šæ‰“å°å‘é€çš„ç©å®¶ä¿¡æ¯
                UnityEngine.Debug.Log($"[MainMenu] ç™»å½•ä¿¡æ¯ - SteamName: {localPlayer.Info.SteamName}, SteamId: {localPlayer.Info.SteamId}");
                UnityEngine.Debug.Log($"[MainMenu] ç™»å½•ä¿¡æ¯ - AvatarUrl: {localPlayer.Info.AvatarUrl}");

                var result = await _playerServiceClient.LoginAsync(localPlayer.Info);

                if (result.Success)
                {
                    UnityEngine.Debug.Log("[MainMenu] ç™»å½•æˆåŠŸï¼");
                    _currentPage = MainMenuPage.Lobby;
                }
                else
                {
                    UnityEngine.Debug.LogError($"[MainMenu] ç™»å½•å¤±è´¥: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[MainMenu] ç™»å½•é”™è¯¯: {ex.Message}");
            }
        }

        /// <summary>
        /// ğŸ”¥ åŠ è½½ä¿å­˜çš„æœåŠ¡å™¨é…ç½®
        /// </summary>
        private void LoadServerConfig()
        {
            if (PlayerPrefs.HasKey(PREF_KEY_SERVER_ADDRESS))
            {
                _serverAddress = PlayerPrefs.GetString(PREF_KEY_SERVER_ADDRESS, "127.0.0.1");
                UnityEngine.Debug.Log($"[MainMenu] ğŸ“¥ åŠ è½½æœåŠ¡å™¨åœ°å€: {_serverAddress}");
            }
            
            if (PlayerPrefs.HasKey(PREF_KEY_SERVER_PORT))
            {
                _serverPort = PlayerPrefs.GetString(PREF_KEY_SERVER_PORT, "9050");
                UnityEngine.Debug.Log($"[MainMenu] ğŸ“¥ åŠ è½½æœåŠ¡å™¨ç«¯å£: {_serverPort}");
            }
        }

        /// <summary>
        /// ğŸ”¥ ä¿å­˜æœåŠ¡å™¨é…ç½®
        /// </summary>
        private void SaveServerConfig()
        {
            PlayerPrefs.SetString(PREF_KEY_SERVER_ADDRESS, _serverAddress);
            PlayerPrefs.SetString(PREF_KEY_SERVER_PORT, _serverPort);
            PlayerPrefs.Save();
            UnityEngine.Debug.Log($"[MainMenu] ğŸ’¾ ä¿å­˜æœåŠ¡å™¨é…ç½®: {_serverAddress}:{_serverPort}");
        }

        public void Dispose()
        {
            _client.Connected -= OnConnected;
            _client.Disconnected -= OnDisconnectedHandler;
            _client.ConnectionFailed -= OnConnectionFailed;
            
            // æ¸…ç†å­é¡µé¢èµ„æº
            RoomPage?.Dispose();
        }
    }
}


```

`Client\UI\PlayerListWindow.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.UI
{
    /// <summary>
    /// ç©å®¶åˆ—è¡¨çª—å£
    /// </summary>
    public class PlayerListWindow : IUIWindow
    {
        private readonly RpcClient _client;
        private Rect _windowRect = new Rect(Screen.width - 320, 100, 300, 400);
        private bool _isVisible = false;
        
        private List<PlayerInfo> _players = new List<PlayerInfo>();
        private Vector2 _scrollPos;

        public bool IsVisible => _isVisible;

        public PlayerListWindow(RpcClient client)
        {
            _client = client;
        }

        public void Show()
        {
            _isVisible = true;
            RefreshPlayerListAsync();
        }

        public void Hide()
        {
            _isVisible = false;
        }

        public void Toggle()
        {
            _isVisible = !_isVisible;
            
            if (_isVisible)
            {
                RefreshPlayerListAsync();
            }
        }

        public void OnGUI()
        {
            if (!_isVisible) return;

            // åŠ¨æ€æ˜¾ç¤ºçª—å£æ ‡é¢˜ï¼ˆåŒ…å«å½“å‰åœ°å›¾ï¼‰
            string windowTitle = "åœ¨çº¿ç©å®¶";
            _windowRect = GUILayout.Window(1002, _windowRect, DrawWindow, windowTitle);
        }

        private void DrawWindow(int windowId)
        {
            GUILayout.BeginVertical();

            // åˆ·æ–°æŒ‰é’®
            if (GUILayout.Button("åˆ·æ–°"))
            {
                RefreshPlayerListAsync();
            }

          
            GUILayout.Label($"åœ¨çº¿ç©å®¶ ({_players.Count})", GUI.skin.box);

            // ç©å®¶åˆ—è¡¨
            _scrollPos = GUILayout.BeginScrollView(_scrollPos);
            
            foreach (var player in _players)
            {
                GUILayout.BeginVertical(GUI.skin.box);
                

                    GUILayout.EndVertical();
                GUILayout.Space(2);
            }
            
            GUILayout.EndScrollView();

            GUILayout.EndVertical();
            GUI.DragWindow();
        }

        private async void RefreshPlayerListAsync()
        {
            if (!_client.IsConnected) return;

            try
            {
                var serverContext = new ClientServerContext(_client);
                var players = await serverContext.InvokeAsync<IPlayerService, PlayerInfo[]>(
                    "GetAllOnlinePlayersAsync");
                
                _players = new List<PlayerInfo>(players);
                
                // è°ƒè¯•æ—¥å¿—ï¼šè¾“å‡ºæ¯ä¸ªç©å®¶çš„ SceneName
                foreach (var player in players)
                {
                    UnityEngine.Debug.Log($"[PlayerListWindow] ç©å®¶ {player.SteamName}: SceneName = '{player.CurrentScenelData.SceneName ?? "null"}'");
                }
                
                UnityEngine.Debug.Log($"[PlayerListWindow] Refreshed: {players.Length} players");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[PlayerListWindow] Refresh failed: {ex.Message}");
            }
        }

        public void Dispose()
        {
            _players.Clear();
        }
    }
}


```

`Client\UI\RoomPage.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using DuckyNet.Client.RPC;
using DuckyNet.Client.Core;
using DuckyNet.Client.Core.Helpers;
using DuckyNet.Shared.Services;

namespace DuckyNet.Client.UI
{
    /// <summary>
    /// æˆ¿é—´é¡µé¢
    /// </summary>
    public class RoomPage : IDisposable
    {
        private readonly RpcClient _client;
        private readonly MainMenuWindow? _mainWindow;
        private Vector2 _scrollPos;
        private readonly RoomManager _manager = GameContext.Instance.RoomManager;
        private ChatWindow? _chatWindow;
        public RoomPage(RpcClient client, MainMenuWindow mainWindow)
        {
            _client = client;
            _mainWindow = mainWindow;
        }

        public void Dispose()
        {
            _manager?.Dispose();
        }

        public void SetChatWindow(ChatWindow chatWindow)
        {
            _chatWindow = chatWindow;
        }

        public void SetCurrentRoom(RoomInfo room)
        {
            _manager.SetCurrentRoom(room);

            // é€šçŸ¥èŠå¤©çª—å£å·²è¿›å…¥æˆ¿é—´
            _chatWindow?.SetRoomStatus(true);
        }

        public void Draw()
        {
            if (_manager.CurrentRoom == null)
            {
                GUILayout.Label("æœªåœ¨æˆ¿é—´ä¸­", GUI.skin.box);
                return;
            }

            GUILayout.Label($"æˆ¿é—´: {_manager.CurrentRoom.RoomName}", GUI.skin.box);
            GUILayout.Space(10);

            // æˆ¿é—´ä¿¡æ¯
            GUILayout.BeginVertical(GUI.skin.box);
            GUILayout.Label($"æˆ¿é—´ID: {_manager.CurrentRoom.RoomId}");
            GUILayout.Label($"æè¿°: {_manager.CurrentRoom.Description}");
            GUILayout.Label($"äººæ•°: {_manager.CurrentRoom.CurrentPlayers}/{_manager.CurrentRoom.MaxPlayers}");
            GUILayout.Label($"æˆ¿ä¸»: {_manager.CurrentRoom.HostSteamId}");
            GUILayout.EndVertical();

            GUILayout.Space(10);

            // ç©å®¶åˆ—è¡¨ï¼ˆè‡ªåŠ¨æ›´æ–°ï¼‰
            var playersView = _manager.GetRoomPlayers();
            GUILayout.Label($"æˆ¿é—´ç©å®¶ ({playersView.Count}) - è‡ªåŠ¨åˆ·æ–°", GUI.skin.box);
            
            // æ‰‹åŠ¨åˆ·æ–°æŒ‰é’®ï¼ˆå¯é€‰ï¼Œé€šå¸¸ä¸éœ€è¦ï¼‰
            GUILayout.BeginHorizontal();
            if (GUILayout.Button("ğŸ”„ æ‰‹åŠ¨åˆ·æ–°"))
            {
                _manager.RefreshPlayerListAsync();
            }
            GUILayout.Label("ğŸ’¡ åˆ—è¡¨ä¼šè‡ªåŠ¨æ›´æ–°", GUI.skin.label);
            GUILayout.EndHorizontal();

            _scrollPos = GUILayout.BeginScrollView(_scrollPos, GUILayout.Height(150));

            foreach (var player in playersView)
            {
                GUILayout.BeginHorizontal(GUI.skin.box);

                // å¤´åƒ
                var avatar = GameContext.Instance.AvatarManager.GetAvatar(player.SteamId);
                if (avatar != null)
                {
                    GUILayout.Label(avatar, GUILayout.Width(48), GUILayout.Height(48));
                }
                else
                {
                    GUILayout.Box("", GUILayout.Width(48), GUILayout.Height(48));
                }

                GUILayout.Space(8);

                // æ–‡æœ¬ä¿¡æ¯ï¼ˆåç§°ã€åœºæ™¯ã€å­åœºæ™¯ï¼‰
                GUILayout.BeginVertical();
                GUILayout.Label(player.SteamName, GUI.skin.label);
                var sceneName = player.CurrentScenelData?.SceneName ?? "";
                var subSceneName = player.CurrentScenelData?.SubSceneName ?? "";
                GUILayout.Label($"åœºæ™¯: {sceneName}", GUI.skin.label);
                GUILayout.Label($"å­åœºæ™¯: {subSceneName}", GUI.skin.label);
                GUILayout.EndVertical();
                GUILayout.FlexibleSpace();
                GUILayout.EndHorizontal();
            }
            
            GUILayout.EndScrollView();

            GUILayout.Space(10);

            // æç¤ºä¿¡æ¯
            GUILayout.Label("ğŸ’¡ æç¤º: åœ¨æˆ¿é—´å†…å³å¯ä¸å…¶ä»–ç©å®¶äº¤æ¢æ•°æ®", GUI.skin.box);
            
            GUILayout.Space(5);

            // æˆ¿é—´æ§åˆ¶
            GUILayout.BeginHorizontal();
            
            if (GUILayout.Button("ç¦»å¼€æˆ¿é—´"))
            {
                LeaveRoomAsync();
            }
            
            GUILayout.FlexibleSpace();
            
            // æ–­å¼€è¿æ¥æŒ‰é’®
            if (GUILayout.Button("æ–­å¼€è¿æ¥", GUILayout.Width(100)))
            {
                // å…ˆç¦»å¼€æˆ¿é—´
                LeaveRoomAsync();
                // æ–­å¼€è¿æ¥
                _client.Disconnect();
                _mainWindow?.SwitchToPage(MainMenuPage.Connect);
            }
            
            GUILayout.EndHorizontal();
        }

        // åˆ·æ–°é€»è¾‘å·²è¿ç§»è‡³ RoomPageManager

        private async void LeaveRoomAsync()
        {
            var success = await _manager.LeaveRoomAsync();
            if (success)
            {
                _manager.SetCurrentRoom(new RoomInfo());
                _chatWindow?.SetRoomStatus(false);
                _mainWindow?.SwitchToPage(MainMenuPage.Lobby);
            }
            else
            {
                UnityEngine.Debug.LogWarning("[RoomPage] Failed to leave room (server returned false)");
            }
        }
    }
}


```

`Client\res\info.ini`:

```ini
name = DuckyNet.Client
displayName = DuckyNet
description = DuckyNet

publishedFileId = 3595610321

```

`Console\ConsoleModule.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;
using UnityEngine;

namespace DuckyNet.Console
{
    /// <summary>
    /// é€šç”¨æ§åˆ¶å°æ¨¡å—ï¼Œè´Ÿè´£åˆ›å»ºæ§åˆ¶å°çª—å£ã€Unity æ—¥å¿—é‡å®šå‘å’Œå½©è‰²è¾“å‡º
    /// </summary>
    public static class ConsoleModule
    {
        private static IntPtr _consoleWindow = IntPtr.Zero;
        private static StreamWriter? _consoleWriter;
        private static bool _isInitialized = false;

        #region Windows API å£°æ˜
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool AllocConsole();

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool FreeConsole();

        [DllImport("kernel32.dll")]
        private static extern IntPtr GetConsoleWindow();

        [DllImport("user32.dll")]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        [DllImport("kernel32.dll")]
        private static extern bool SetConsoleCP(uint wCodePageID);

        [DllImport("kernel32.dll")]
        private static extern bool SetConsoleOutputCP(uint wCodePageID);

        [DllImport("kernel32.dll")]
        private static extern uint GetConsoleCP();

        [DllImport("kernel32.dll")]
        private static extern uint GetConsoleOutputCP();

        private const int SW_SHOW = 5;
        private const uint CP_UTF8 = 65001; // UTF-8 ä»£ç é¡µ
        #endregion

        /// <summary>
        /// åˆå§‹åŒ–æ§åˆ¶å°æ¨¡å—
        /// </summary>
        public static void Initialize()
        {
            if (_isInitialized)
            {
                UnityEngine.Debug.LogWarning("[DuckyNet.Console] ConsoleModule å·²ç»åˆå§‹åŒ–ï¼Œè·³è¿‡");
                return;
            }

            try
            {
                CreateConsoleWindow();
                SetupUnityLogRedirection();
                _isInitialized = true;
                
                UnityEngine.Debug.Log("[DuckyNet.Console] ConsoleModule åˆå§‹åŒ–æˆåŠŸ");
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[DuckyNet.Console] ConsoleModule åˆå§‹åŒ–å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// æ¸…ç†æ§åˆ¶å°å’Œæ—¥å¿—é‡å®šå‘
        /// </summary>
        public static void Cleanup()
        {
            if (!_isInitialized) return;

            try
            {
                // ç§»é™¤ Unity æ—¥å¿—ç›‘å¬
                Application.logMessageReceived -= OnUnityLogReceived;

                // å…³é—­æ§åˆ¶å°å†™å…¥æµ
                if (_consoleWriter != null)
                {
                    _consoleWriter.Close();
                    _consoleWriter = null;
                }

                // é‡Šæ”¾æ§åˆ¶å°çª—å£
                if (_consoleWindow != IntPtr.Zero)
                {
                    FreeConsole();
                    _consoleWindow = IntPtr.Zero;
                }

                _isInitialized = false;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[DuckyNet.Console] ConsoleModule æ¸…ç†å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å‘æ§åˆ¶å°å†™å…¥æ¶ˆæ¯ï¼ˆæ”¯æŒæŒ‡å®šé¢œè‰²ï¼‰
        /// </summary>
        private static void Write(string message, ConsoleColor color)
        {
            if (!_isInitialized || _consoleWriter == null) return;

            try
            {
                string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
                string formattedMessage = $"[{timestamp}] {message}";

                System.Console.ForegroundColor = color;
                _consoleWriter.WriteLine(formattedMessage);
                _consoleWriter.Flush();
                System.Console.ResetColor();
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[DuckyNet.Console] æ§åˆ¶å°å†™å…¥å¤±è´¥: {ex.Message}");
            }
        }

        #region ç§æœ‰æ–¹æ³•

        /// <summary>
        /// åˆ›å»ºæ§åˆ¶å°çª—å£
        /// </summary>
        private static void CreateConsoleWindow()
        {
            try
            {
                // åˆ†é…æ§åˆ¶å°
                if (!AllocConsole())
                {
                    throw new InvalidOperationException("æ— æ³•åˆ†é…æ§åˆ¶å°çª—å£");
                }

                // è·å–æ§åˆ¶å°çª—å£å¥æŸ„
                _consoleWindow = GetConsoleWindow();
                if (_consoleWindow == IntPtr.Zero)
                {
                    throw new InvalidOperationException("æ— æ³•è·å–æ§åˆ¶å°çª—å£å¥æŸ„");
                }

                // æ˜¾ç¤ºæ§åˆ¶å°çª—å£
                ShowWindow(_consoleWindow, SW_SHOW);

                // è®¾ç½® UTF-8 ç¼–ç ï¼ˆæ”¯æŒä¸­æ–‡ï¼‰
                SetConsoleCP(CP_UTF8);
                SetConsoleOutputCP(CP_UTF8);
                System.Console.OutputEncoding = System.Text.Encoding.UTF8;
                System.Console.InputEncoding = System.Text.Encoding.UTF8;

                // è®¾ç½®æ§åˆ¶å°æ ‡é¢˜
                System.Console.Title = "DuckyNet Console - Unity Log Viewer";

                // åˆ›å»ºè¾“å‡ºæµ
                _consoleWriter = new StreamWriter(System.Console.OpenStandardOutput(), System.Text.Encoding.UTF8)
                {
                    AutoFlush = true
                };
                System.Console.SetOut(_consoleWriter);
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[DuckyNet.Console] åˆ›å»ºæ§åˆ¶å°çª—å£å¤±è´¥: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// è®¾ç½® Unity æ—¥å¿—é‡å®šå‘
        /// </summary>
        private static void SetupUnityLogRedirection()
        {
            try
            {
                Application.logMessageReceived += OnUnityLogReceived;
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogError($"[DuckyNet.Console] è®¾ç½® Unity æ—¥å¿—é‡å®šå‘å¤±è´¥: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Unity æ—¥å¿—å›è°ƒ - è§£æå¹¶æ¸²æŸ“å¸¦é¢œè‰²çš„æ—¥å¿—
        /// </summary>
        private static void OnUnityLogReceived(string logString, string stackTrace, LogType type)
        {
            try
            {
                // æ ¹æ® Unity æ—¥å¿—ç±»å‹é€‰æ‹©é¢œè‰²
                ConsoleColor color = type switch
                {
                    LogType.Error => ConsoleColor.Red,
                    LogType.Warning => ConsoleColor.Yellow,
                    LogType.Log => ConsoleColor.White,
                    LogType.Exception => ConsoleColor.DarkRed,
                    LogType.Assert => ConsoleColor.Magenta,
                    _ => ConsoleColor.Gray
                };

                // è¾“å‡ºæ—¥å¿—æ¶ˆæ¯
                Write(logString, color);

                // å¦‚æœæ˜¯é”™è¯¯æˆ–å¼‚å¸¸ï¼Œè¾“å‡ºå †æ ˆè·Ÿè¸ª
                if ((type == LogType.Error || type == LogType.Exception) && !string.IsNullOrEmpty(stackTrace))
                {
                    Write(stackTrace, ConsoleColor.DarkRed);
                }
            }
            catch
            {
                // é¿å…æ—¥å¿—å›è°ƒä¸­çš„å¼‚å¸¸å¯¼è‡´æ— é™å¾ªç¯
            }
        }

        #endregion
    }
}


```

`Console\DuckyNetConsole.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <Nullable>enable</Nullable>
    <AssemblyName>DuckyNet.Console</AssemblyName>
    <DuckovPath>C:\Program Files (x86)\Steam\steamapps\common\Escape from Duckov</DuckovPath>
  </PropertyGroup>
  
  <ItemGroup>
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\TeamSoda.*" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\Unity*" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\com.rlabrecque.steamworks.net.dll" />
    <PackageReference Include="Lib.Harmony" Version="2.4.1" />
    <PackageReference Include="LiteNetLib" Version="1.2.0" />
    <PackageReference Include="NetSerializer" Version="4.1.1" />
    <PackageReference Include="Microsoft.CSharp" Version="4.7.0" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\ItemStatsSystem.dll" />
    <ProjectReference Include="..\Shared\DuckyNetShared.csproj" />
  </ItemGroup>

  <!-- å®šä¹‰ res ç›®å½• -->
  <PropertyGroup>
    <ResDir>$(MSBuildProjectDirectory)\res\</ResDir>
  </PropertyGroup>

  <!-- ç¼–è¯‘åå¤åˆ¶è¾“å‡ºæ–‡ä»¶åˆ° res ç›®å½• -->
  <Target Name="CopyOutputsToRes" AfterTargets="Build">
    <ItemGroup>
      <!-- DuckyNet.Console ä¸»è¾“å‡ºï¼ˆä½¿ç”¨ AssemblyNameï¼‰-->
      <OutputFiles Include="$(TargetPath)" />
      <OutputFiles Include="$(TargetDir)$(AssemblyName).pdb" Condition="Exists('$(TargetDir)$(AssemblyName).pdb')" />
      <OutputFiles Include="$(TargetDir)$(AssemblyName).xml" Condition="Exists('$(TargetDir)$(AssemblyName).xml')" />
      <!-- åŒ…å« DuckyNet.Shared.dll -->
      <OutputFiles Include="$(TargetDir)DuckyNet.Shared.dll" Condition="Exists('$(TargetDir)DuckyNet.Shared.dll')" />
      <OutputFiles Include="$(TargetDir)DuckyNet.Shared.pdb" Condition="Exists('$(TargetDir)DuckyNet.Shared.pdb')" />
      <!-- åŒ…å« LiteNetLib.dll -->
      <OutputFiles Include="$(TargetDir)LiteNetLib.dll" Condition="Exists('$(TargetDir)LiteNetLib.dll')" />
      <!-- åŒ…å« NetSerializer.dll -->
      <OutputFiles Include="$(TargetDir)NetSerializer.dll" Condition="Exists('$(TargetDir)NetSerializer.dll')" />
      <!-- åŒ…å« 0Harmony.dll (HarmonyLib) -->
      <OutputFiles Include="$(TargetDir)0Harmony.dll" Condition="Exists('$(TargetDir)0Harmony.dll')" />
    </ItemGroup>
    <Copy SourceFiles="@(OutputFiles)" DestinationFolder="$(ResDir)" SkipUnchangedFiles="false" />
    <Message Text="[DuckyNet.Console] å·²å¤åˆ¶è¾“å‡ºæ–‡ä»¶åˆ° res ç›®å½•" Importance="high" />
  </Target>

  <!-- å®šä¹‰æ¸¸æˆ Mods ç›®å½• -->
  <PropertyGroup>
    <ModsDir>$(DuckovPath)\Duckov_Data\Mods\DuckyNet.Console\</ModsDir>
  </PropertyGroup>

  <!-- å¤åˆ¶ res ç›®å½•åˆ°æ¸¸æˆ Mods ç›®å½• -->
  <Target Name="CopyResToMods" AfterTargets="Build" DependsOnTargets="CopyOutputsToRes">
    <MakeDir Directories="$(ModsDir)" />
    <ItemGroup>
      <ResFiles Include="$(ResDir)**\*.*" />
    </ItemGroup>
    <Copy SourceFiles="@(ResFiles)" DestinationFolder="$(ModsDir)\%(RecursiveDir)" SkipUnchangedFiles="false" />
    <Message Text="[DuckyNet.Console] å·²å¤åˆ¶æ–‡ä»¶åˆ°æ¸¸æˆ Mods ç›®å½•: $(ModsDir)" Importance="high" />
  </Target>

</Project>

```

`Console\ModBehaviour.cs`:

```cs
using System;
using UnityEngine;
using HarmonyLib;

namespace DuckyNet.Console
{
    /// <summary>
    /// DuckyNet æ§åˆ¶å°æ¨¡ç»„ä¸»è¡Œä¸ºç±»
    /// æä¾›å¢å¼ºçš„è°ƒè¯•æ§åˆ¶å°åŠŸèƒ½
    /// </summary>
    public class ModBehaviour : Duckov.Modding.ModBehaviour
    {
        /// <summary>
        /// å…¨å±€å®ä¾‹
        /// </summary>
        public static ModBehaviour? Instance { get; private set; }

        /// <summary>
        /// Harmony å®ä¾‹
        /// </summary>
        private static Harmony? _harmony;

        void Awake()
        {
            try
            {
                // è®¾ç½®å…¨å±€å®ä¾‹
                Instance = this;

                // åˆå§‹åŒ–æ§åˆ¶å°æ¨¡å—ï¼ˆUnity æ—¥å¿—é‡å®šå‘ï¼‰
                ConsoleModule.Initialize();

                // åº”ç”¨ Harmony è¡¥ä¸
                ApplyHarmonyPatches();

                Debug.Log("[DuckyNet.Console] æ§åˆ¶å°æ¨¡ç»„åˆå§‹åŒ–å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DuckyNet.Console] åˆå§‹åŒ–å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        void Start()
        {
            try
            {
                // è¾“å‡º ASCII è‰ºæœ¯å­—
                Debug.Log("______            _          _   _      _   ");
                Debug.Log("|  _  \\          | |        | \\ | |    | |  ");
                Debug.Log("| | | |_   _  ___| | ___   _|  \\| | ___| |_ ");
                Debug.Log("| | | | | | |/ __| |/ / | | | . ` |/ _ \\ __|");
                Debug.Log("| |/ /| |_| | (__|   <| |_| | |\\  |  __/ |_ ");
                Debug.Log("|___/  \\__,_|\\___|_|\\_\\\\__, \\_| \\_/\\___|\\__|");
                Debug.Log("                        __/ |               ");
                Debug.Log("                       |___/                ");
                Debug.Log(" _____                       _      ");
                Debug.Log("/  __ \\                     | |     ");
                Debug.Log("| /  \\/ ___  _ __  ___  ___ | | ___ ");
                Debug.Log("| |    / _ \\| '_ \\/ __|/ _ \\| |/ _ \\");
                Debug.Log("| \\__/| (_) | | | \\__ | (_) | |  __/");
                Debug.Log(" \\____/\\___/|_| |_|___/\\___/|_|\\___|");
                Debug.Log("                                    ");
                Debug.Log("");
                Debug.Log("[DuckyNet.Console] æ§åˆ¶å°æ¨¡ç»„å¯åŠ¨å®Œæˆ");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DuckyNet.Console] å¯åŠ¨å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        void OnDestroy()
        {
            try
            {
                Debug.Log("[DuckyNet.Console] æ­£åœ¨å¸è½½æ§åˆ¶å°æ¨¡ç»„...");
                
                // ç§»é™¤ Harmony è¡¥ä¸
                RemoveHarmonyPatches();

                // æ¸…ç†å®ä¾‹
                Instance = null;

                Debug.Log("[DuckyNet.Console] æ§åˆ¶å°æ¨¡ç»„å·²å¸è½½");
                
                // æ¸…ç†æ§åˆ¶å°æ¨¡å—
                ConsoleModule.Cleanup();
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DuckyNet.Console] å¸è½½å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// åº”ç”¨ Harmony è¡¥ä¸
        /// </summary>
        private void ApplyHarmonyPatches()
        {
            try
            {
                _harmony = new Harmony("com.duckynet.console");
                _harmony.PatchAll();
                Debug.Log("[DuckyNet.Console] Harmony è¡¥ä¸å·²åº”ç”¨");
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DuckyNet.Console] Harmony è¡¥ä¸åº”ç”¨å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// ç§»é™¤ Harmony è¡¥ä¸
        /// </summary>
        private void RemoveHarmonyPatches()
        {
            try
            {
                if (_harmony != null)
                {
                    _harmony.UnpatchAll(_harmony.Id);
                    _harmony = null;
                    Debug.Log("[DuckyNet.Console] Harmony è¡¥ä¸å·²ç§»é™¤");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[DuckyNet.Console] Harmony è¡¥ä¸ç§»é™¤å¤±è´¥: {ex.Message}\n{ex.StackTrace}");
            }
        }
    }
}


```

`Console\res\info.ini`:

```ini
name = DuckyNet.Console
displayName = DuckyNet Console
description = DuckyNet Console

```

`DuckyNet.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36109.1 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DuckyNetServer", "Server\DuckyNetServer.csproj", "{EA030571-E0CB-41AE-8F96-E7F858040A29}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DuckyNetClient", "Client\DuckyNetClient.csproj", "{9E3243DC-763F-4583-B7BE-CFE6430A1E75}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DuckyNetShared", "Shared\DuckyNetShared.csproj", "{BA6424E5-89B6-4098-AB94-B6EF478F8B91}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DuckyNetConsole", "Console\DuckyNetConsole.csproj", "{C7D8F4A3-2B1E-4F8C-9A5D-1E6F7C8D9B0A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EA030571-E0CB-41AE-8F96-E7F858040A29}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EA030571-E0CB-41AE-8F96-E7F858040A29}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EA030571-E0CB-41AE-8F96-E7F858040A29}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EA030571-E0CB-41AE-8F96-E7F858040A29}.Release|Any CPU.Build.0 = Release|Any CPU
		{9E3243DC-763F-4583-B7BE-CFE6430A1E75}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9E3243DC-763F-4583-B7BE-CFE6430A1E75}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9E3243DC-763F-4583-B7BE-CFE6430A1E75}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9E3243DC-763F-4583-B7BE-CFE6430A1E75}.Release|Any CPU.Build.0 = Release|Any CPU
		{BA6424E5-89B6-4098-AB94-B6EF478F8B91}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BA6424E5-89B6-4098-AB94-B6EF478F8B91}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BA6424E5-89B6-4098-AB94-B6EF478F8B91}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BA6424E5-89B6-4098-AB94-B6EF478F8B91}.Release|Any CPU.Build.0 = Release|Any CPU
		{C7D8F4A3-2B1E-4F8C-9A5D-1E6F7C8D9B0A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C7D8F4A3-2B1E-4F8C-9A5D-1E6F7C8D9B0A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C7D8F4A3-2B1E-4F8C-9A5D-1E6F7C8D9B0A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C7D8F4A3-2B1E-4F8C-9A5D-1E6F7C8D9B0A}.Release|Any CPU.Build.0 = Release|Any CPU
		{F8A1B2C3-D4E5-4F6A-8B7C-9D0E1F2A3B4C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F8A1B2C3-D4E5-4F6A-8B7C-9D0E1F2A3B4C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F8A1B2C3-D4E5-4F6A-8B7C-9D0E1F2A3B4C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F8A1B2C3-D4E5-4F6A-8B7C-9D0E1F2A3B4C}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4142C19F-E62D-4840-B6BC-19E7DD3FA977}
	EndGlobalSection
EndGlobal

```

`ExamplePlugin\ExamplePlugin.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AssemblyName>ExamplePlugin</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <!-- ä½¿ç”¨ ProjectReference ä½†è®¾ç½® Private="false"ï¼Œä¸å¤åˆ¶å¼•ç”¨çš„ DLL -->
    <!-- æ’ä»¶è¿è¡Œæ—¶ä¼šä½¿ç”¨æœåŠ¡å™¨å·²åŠ è½½çš„ DLLï¼Œæ‰€ä»¥ä¸éœ€è¦å¤åˆ¶ -->
    <ProjectReference Include="..\Server\DuckyNetServer.csproj" Private="false" />
    <ProjectReference Include="..\Shared\DuckyNetShared.csproj" Private="false" />
  </ItemGroup>

</Project>


```

`ExamplePlugin\WelcomePlugin.cs`:

```cs
using System;
using System.Linq;
using DuckyNet.Server.Plugin;
using DuckyNet.Server.Events;
using DuckyNet.Server.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;

namespace ExamplePlugin
{
    /// <summary>
    /// æ¬¢è¿æ’ä»¶ - ç®€æ´ç‰ˆ
    /// åŠŸèƒ½ï¼šç©å®¶ç™»å½•æ—¶å‘é€æ¬¢è¿æ¶ˆæ¯
    /// </summary>
    public class WelcomePlugin : IPlugin
    {
        public string Name => "æ¬¢è¿æ’ä»¶";
        public string Version => "1.0.0";
        public string Author => "DuckyNet";
        public string Description => "æ³¥åšï¼";

        private IPluginContext _context = null!;
        private PlayerInfo _systemPlayer = null!;

        /// <summary>
        /// æ’ä»¶åŠ è½½æ—¶è°ƒç”¨
        /// </summary>
        public void OnLoad(IPluginContext context)
        {
            _context = context;
            _context.Logger.Info($"{Name} v{Version} æ­£åœ¨åŠ è½½...");

            // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯å‘é€è€…
            _systemPlayer = new PlayerInfo
            {
                SteamId = "SYSTEM",
                SteamName = "æœåŠ¡å™¨",
                CurrentScenelData = new ScenelData("", "")
            };  

            // åªè®¢é˜…ç©å®¶ç™»å½•äº‹ä»¶
            _context.EventBus.Subscribe<PlayerLoginEvent>(OnPlayerLogin);
            _context.Logger.Info($"{Name} åŠ è½½å®Œæˆï¼");
        }

        /// <summary>
        /// æ’ä»¶å¸è½½æ—¶è°ƒç”¨
        /// </summary>
        public void OnUnload()
        {
            _context.EventBus.Unsubscribe<PlayerLoginEvent>(OnPlayerLogin);
            _context.Logger.Info($"{Name} å·²å¸è½½");
        }


        // ========== äº‹ä»¶å¤„ç†å™¨ ==========

        private void OnPlayerLogin(PlayerLoginEvent e)
        {
            var clientContext = _context.RpcServer.GetClientContext(e.ClientId);
            if (clientContext == null) return;

            // ç®€æ´çš„æ¬¢è¿æ¶ˆæ¯
            SendChatToClient(clientContext, $"æ¬¢è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œ{e.Player.SteamName}ï¼ğŸ‰");
            
            // æ˜¾ç¤ºåœ¨çº¿äººæ•°
            var onlineCount = _context.PlayerManager.GetAllOnlinePlayers().Length;
            SendChatToClient(clientContext, $"å½“å‰åœ¨çº¿: {onlineCount} äºº");
        }

        // ========== è¾…åŠ©æ–¹æ³• ==========

        private void SendChatToClient(IClientContext clientContext, string message)
        {
            clientContext.Call<IPlayerClientService>().OnChatMessage(_systemPlayer, message);
        }
    }
}


```

`LICENSE`:

```
Attribution-NonCommercial-ShareAlike 4.0 International

=======================================================================

Creative Commons Corporation ("Creative Commons") is not a law firm and
does not provide legal services or legal advice. Distribution of
Creative Commons public licenses does not create a lawyer-client or
other relationship. Creative Commons makes its licenses and related
information available on an "as-is" basis. Creative Commons gives no
warranties regarding its licenses, any material licensed under their
terms and conditions, or any related information. Creative Commons
disclaims all liability for damages resulting from their use to the
fullest extent possible.

Using Creative Commons Public Licenses

Creative Commons public licenses provide a standard set of terms and
conditions that creators and other rights holders may use to share
original works of authorship and other material subject to copyright
and certain other rights specified in the public license below. The
following considerations are for informational purposes only, are not
exhaustive, and do not form part of our licenses.

     Considerations for licensors: Our public licenses are
     intended for use by those authorized to give the public
     permission to use material in ways otherwise restricted by
     copyright and certain other rights. Our licenses are
     irrevocable. Licensors should read and understand the terms
     and conditions of the license they choose before applying it.
     Licensors should also secure all rights necessary before
     applying our licenses so that the public can reuse the
     material as expected. Licensors should clearly mark any
     material not subject to the license. This includes other CC-
     licensed material, or material used under an exception or
     limitation to copyright. More considerations for licensors:
     wiki.creativecommons.org/Considerations_for_licensors

     Considerations for the public: By using one of our public
     licenses, a licensor grants the public permission to use the
     licensed material under specified terms and conditions. If
     the licensor's permission is not necessary for any reason--for
     example, because of any applicable exception or limitation to
     copyright--then that use is not regulated by the license. Our
     licenses grant only permissions under copyright and certain
     other rights that a licensor has authority to grant. Use of
     the licensed material may still be restricted for other
     reasons, including because others have copyright or other
     rights in the material. A licensor may make special requests,
     such as asking that all changes be marked or described.
     Although not required by our licenses, you are encouraged to
     respect those requests where reasonable. More considerations
     for the public:
     wiki.creativecommons.org/Considerations_for_licensees

=======================================================================

Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
Public License

By exercising the Licensed Rights (defined below), You accept and agree
to be bound by the terms and conditions of this Creative Commons
Attribution-NonCommercial-ShareAlike 4.0 International Public License
("Public License"). To the extent this Public License may be
interpreted as a contract, You are granted the Licensed Rights in
consideration of Your acceptance of these terms and conditions, and the
Licensor grants You such rights in consideration of benefits the
Licensor receives from making the Licensed Material available under
these terms and conditions.


Section 1 -- Definitions.

  a. Adapted Material means material subject to Copyright and Similar
     Rights that is derived from or based upon the Licensed Material
     and in which the Licensed Material is translated, altered,
     arranged, transformed, or otherwise modified in a manner requiring
     permission under the Copyright and Similar Rights held by the
     Licensor. For purposes of this Public License, where the Licensed
     Material is a musical work, performance, or sound recording,
     Adapted Material is always produced where the Licensed Material is
     synched in timed relation with a moving image.

  b. Adapter's License means the license You apply to Your Copyright
     and Similar Rights in Your contributions to Adapted Material in
     accordance with the terms and conditions of this Public License.

  c. BY-NC-SA Compatible License means a license listed at
     creativecommons.org/compatiblelicenses, approved by Creative
     Commons as essentially the equivalent of this Public License.

  d. Copyright and Similar Rights means copyright and/or similar rights
     closely related to copyright including, without limitation,
     performance, broadcast, sound recording, and Sui Generis Database
     Rights, without regard to how the rights are labeled or
     categorized. For purposes of this Public License, the rights
     specified in Section 2(b)(1)-(2) are not Copyright and Similar
     Rights.

  e. Effective Technological Measures means those measures that, in the
     absence of proper authority, may not be circumvented under laws
     fulfilling obligations under Article 11 of the WIPO Copyright
     Treaty adopted on December 20, 1996, and/or similar international
     agreements.

  f. Exceptions and Limitations means fair use, fair dealing, and/or
     any other exception or limitation to Copyright and Similar Rights
     that applies to Your use of the Licensed Material.

  g. License Elements means the license attributes listed in the name
     of a Creative Commons Public License. The License Elements of this
     Public License are Attribution, NonCommercial, and ShareAlike.

  h. Licensed Material means the artistic or literary work, database,
     or other material to which the Licensor applied this Public
     License.

  i. Licensed Rights means the rights granted to You subject to the
     terms and conditions of this Public License, which are limited to
     all Copyright and Similar Rights that apply to Your use of the
     Licensed Material and that the Licensor has authority to license.

  j. Licensor means the individual(s) or entity(ies) granting rights
     under this Public License.

  k. NonCommercial means not primarily intended for or directed towards
     commercial advantage or monetary compensation. For purposes of
     this Public License, the exchange of the Licensed Material for
     other material subject to Copyright and Similar Rights by digital
     file-sharing or similar means is NonCommercial provided there is
     no payment of monetary compensation in connection with the
     exchange.

  l. Share means to provide material to the public by any means or
     process that requires permission under the Licensed Rights, such
     as reproduction, public display, public performance, distribution,
     dissemination, communication, or importation, and to make material
     available to the public including in ways that members of the
     public may access the material from a place and at a time
     individually chosen by them.

  m. Sui Generis Database Rights means rights other than copyright
     resulting from Directive 96/9/EC of the European Parliament and of
     the Council of 11 March 1996 on the legal protection of databases,
     as amended and/or succeeded, as well as other essentially
     equivalent rights anywhere in the world.

  n. You means the individual or entity exercising the Licensed Rights
     under this Public License. Your has a corresponding meaning.


Section 2 -- Scope.

  a. License grant.

       1. Subject to the terms and conditions of this Public License,
          the Licensor hereby grants You a worldwide, royalty-free,
          non-sublicensable, non-exclusive, irrevocable license to
          exercise the Licensed Rights in the Licensed Material to:

            a. reproduce and Share the Licensed Material, in whole or
               in part, for NonCommercial purposes only; and

            b. produce, reproduce, and Share Adapted Material for
               NonCommercial purposes only.

       2. Exceptions and Limitations. For the avoidance of doubt, where
          Exceptions and Limitations apply to Your use, this Public
          License does not apply, and You do not need to comply with
          its terms and conditions.

       3. Term. The term of this Public License is specified in Section
          6(a).

       4. Media and formats; technical modifications allowed. The
          Licensor authorizes You to exercise the Licensed Rights in
          all media and formats whether now known or hereafter created,
          and to make technical modifications necessary to do so. The
          Licensor waives and/or agrees not to assert any right or
          authority to forbid You from making technical modifications
          necessary to exercise the Licensed Rights, including
          technical modifications necessary to circumvent Effective
          Technological Measures. For purposes of this Public License,
          simply making modifications authorized by this Section 2(a)
          (4) never produces Adapted Material.

       5. Downstream recipients.

            a. Offer from the Licensor -- Licensed Material. Every
               recipient of the Licensed Material automatically
               receives an offer from the Licensor to exercise the
               Licensed Rights under the terms and conditions of this
               Public License.

            b. Additional offer from the Licensor -- Adapted Material.
               Every recipient of Adapted Material from You
               automatically receives an offer from the Licensor to
               exercise the Licensed Rights in the Adapted Material
               under the conditions of the Adapter's License You apply.

            c. No downstream restrictions. You may not offer or impose
               any additional or different terms or conditions on, or
               apply any Effective Technological Measures to, the
               Licensed Material if doing so restricts exercise of the
               Licensed Rights by any recipient of the Licensed
               Material.

       6. No endorsement. Nothing in this Public License constitutes or
          may be construed as permission to assert or imply that You
          are, or that Your use of the Licensed Material is, connected
          with, or sponsored, endorsed, or granted official status by,
          the Licensor or others designated to receive attribution as
          provided in Section 3(a)(1)(A)(i).

  b. Other rights.

       1. Moral rights, such as the right of integrity, are not
          licensed under this Public License, nor are publicity,
          privacy, and/or other similar personality rights; however, to
          the extent possible, the Licensor waives and/or agrees not to
          assert any such rights held by the Licensor to the limited
          extent necessary to allow You to exercise the Licensed
          Rights, but not otherwise.

       2. Patent and trademark rights are not licensed under this
          Public License.

       3. To the extent possible, the Licensor waives any right to
          collect royalties from You for the exercise of the Licensed
          Rights, whether directly or through a collecting society
          under any voluntary or waivable statutory or compulsory
          licensing scheme. In all other cases the Licensor expressly
          reserves any right to collect such royalties, including when
          the Licensed Material is used other than for NonCommercial
          purposes.


Section 3 -- License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the
following conditions.

  a. Attribution.

       1. If You Share the Licensed Material (including in modified
          form), You must:

            a. retain the following if it is supplied by the Licensor
               with the Licensed Material:

                 i. identification of the creator(s) of the Licensed
                    Material and any others designated to receive
                    attribution, in any reasonable manner requested by
                    the Licensor (including by pseudonym if
                    designated);

                ii. a copyright notice;

               iii. a notice that refers to this Public License;

                iv. a notice that refers to the disclaimer of
                    warranties;

                 v. a URI or hyperlink to the Licensed Material to the
                    extent reasonably practicable;

            b. indicate if You modified the Licensed Material and
               retain an indication of any previous modifications; and

            c. indicate the Licensed Material is licensed under this
               Public License, and include the text of, or the URI or
               hyperlink to, this Public License.

       2. You may satisfy the conditions in Section 3(a)(1) in any
          reasonable manner based on the medium, means, and context in
          which You Share the Licensed Material. For example, it may be
          reasonable to satisfy the conditions by providing a URI or
          hyperlink to a resource that includes the required
          information.

       3. If requested by the Licensor, You must remove any of the
          information required by Section 3(a)(1)(A) to the extent
          reasonably practicable.

  b. ShareAlike.

     In addition to the conditions in Section 3(a), if You Share
     Adapted Material You produce, the following conditions also apply.

       1. The Adapter's License You apply must be a Creative Commons
          license with the same License Elements, this version or
          later, or a BY-NC-SA Compatible License.

       2. You must include the text of, or the URI or hyperlink to, the
          Adapter's License You apply. You may satisfy this condition
          in any reasonable manner based on the medium, means, and
          context in which You Share Adapted Material.

       3. You may not offer or impose any additional or different terms
          or conditions on, or apply any Effective Technological
          Measures to, Adapted Material that restrict exercise of the
          rights granted under the Adapter's License You apply.


Section 4 -- Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that
apply to Your use of the Licensed Material:

  a. for the avoidance of doubt, Section 2(a)(1) grants You the right
     to extract, reuse, reproduce, and Share all or a substantial
     portion of the contents of the database for NonCommercial purposes
     only;

  b. if You include all or a substantial portion of the database
     contents in a database in which You have Sui Generis Database
     Rights, then the database in which You have Sui Generis Database
     Rights (but not its individual contents) is Adapted Material,
     including for purposes of Section 3(b); and

  c. You must comply with the conditions in Section 3(a) if You Share
     all or a substantial portion of the contents of the database.

For the avoidance of doubt, this Section 4 supplements and does not
replace Your obligations under this Public License where the Licensed
Rights include other Copyright and Similar Rights.


Section 5 -- Disclaimer of Warranties and Limitation of Liability.

  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE
     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS
     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,
     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,
     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR
     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,
     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT
     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT
     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.

  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE
     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,
     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,
     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR
     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR
     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR
     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.

  c. The disclaimer of warranties and limitation of liability provided
     above shall be interpreted in a manner that, to the extent
     possible, most closely approximates an absolute disclaimer and
     waiver of all liability.


Section 6 -- Term and Termination.

  a. This Public License applies for the term of the Copyright and
     Similar Rights licensed here. However, if You fail to comply with
     this Public License, then Your rights under this Public License
     terminate automatically.

  b. Where Your right to use the Licensed Material has terminated under
     Section 6(a), it reinstates:

       1. automatically as of the date the violation is cured, provided
          it is cured within 30 days of Your discovery of the
          violation; or

       2. upon express reinstatement by the Licensor.

     For the avoidance of doubt, this Section 6(b) does not affect any
     right the Licensor may have to seek remedies for Your violations
     of this Public License.

  c. For the avoidance of doubt, the Licensor may also offer the
     Licensed Material under separate terms or conditions or stop
     distributing the Licensed Material at any time; however, doing so
     will not terminate this Public License.

  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public
     License.


Section 7 -- Other Terms and Conditions.

  a. The Licensor shall not be bound by any additional or different
     terms or conditions communicated by You unless expressly agreed.

  b. Any arrangements, understandings, or agreements regarding the
     Licensed Material not stated herein are separate from and
     independent of the terms and conditions of this Public License.


Section 8 -- Interpretation.

  a. For the avoidance of doubt, this Public License does not, and
     shall not be interpreted to, reduce, limit, restrict, or impose
     conditions on any use of the Licensed Material that could lawfully
     be made without permission under this Public License.

  b. To the extent possible, if any provision of this Public License is
     deemed unenforceable, it shall be automatically reformed to the
     minimum extent necessary to make it enforceable. If the provision
     cannot be reformed, it shall be severed from this Public License
     without affecting the enforceability of the remaining terms and
     conditions.

  c. No term or condition of this Public License will be waived and no
     failure to comply consented to unless expressly agreed to by the
     Licensor.

  d. Nothing in this Public License constitutes or may be interpreted
     as a limitation upon, or waiver of, any privileges and immunities
     that apply to the Licensor or You, including from the legal
     processes of any jurisdiction or authority.

=======================================================================

Creative Commons is not a party to its public licenses.
Notwithstanding, Creative Commons may elect to apply one of its public
licenses to material it publishes and in those instances will be
considered the "Licensor." The text of the Creative Commons public
licenses is dedicated to the public domain under the CC0 Public Domain
Dedication. Except for the limited purpose of indicating that material
is shared under a Creative Commons public license or as otherwise
permitted by the Creative Commons policies published at
creativecommons.org/policies, Creative Commons does not authorize the
use of the trademark "Creative Commons" or any other trademark or logo
of Creative Commons without its prior written consent including,
without limitation, in connection with any unauthorized modifications
to any of its public licenses or any other arrangements,
understandings, or agreements concerning use of licensed material. For
the avoidance of doubt, this paragraph does not form part of the public
licenses.

Creative Commons may be contacted at creativecommons.org.


```

`Milk\DecalFadeEffect.cs`:

```cs
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// è´´èŠ±æ¸å˜æ¶ˆå¤±å’Œæ‰©æ•£æ•ˆæœ
    /// </summary>
    public class DecalFadeEffect : MonoBehaviour
    {
        private MeshRenderer? _renderer;
        private Material? _material;
        private float _duration;
        private float _time;
        private float _initialAlpha;
        private Vector3 _initialScale;
        private float _spreadSpeed;
        private float _maxSpreadMultiplier;

        public void Initialize(float duration, float spreadSpeed, float maxSpreadMultiplier)
        {
            _duration = duration;
            _spreadSpeed = spreadSpeed;
            _maxSpreadMultiplier = maxSpreadMultiplier;
        }

        private void Start()
        {
            _renderer = GetComponent<MeshRenderer>();
            if (_renderer != null)
            {
                _material = _renderer.material;
                _initialAlpha = _material != null ? _material.color.a : 1f;
            }
            _initialScale = transform.localScale;
        }

        private void Update()
        {
            if (_material == null) return;

            _time += Time.deltaTime;
            float alpha = _initialAlpha * (1f - _time / _duration);
            
            Color color = _material.color;
            color.a = Mathf.Max(0, alpha);
            _material.color = color;
        }
    }
}
```

`Milk\LineDrippingEffect.cs`:

```cs
using System;
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// çº¿æ¡åŠ¨æ€ä¸‹å‚ã€æ‹‰ä¼¸å˜ç»†å’Œæ–­è£‚æ•ˆæœ
    /// </summary>
    public class LineDrippingEffect : MonoBehaviour
    {
        private LineRenderer? _lineRenderer;
        private Vector3[] _originalPoints = Array.Empty<Vector3>();
        private float _time;
        private float _originalDistance;
        private float _breakDistanceMultiplier;
        private float _thinningSpeed;
        private float _initialStartWidth;
        private float _initialEndWidth;

        public void Initialize(Vector3[] points, float originalDistance, float breakMultiplier, float thinningSpeed)
        {
            _originalPoints = new Vector3[points.Length];
            Array.Copy(points, _originalPoints, points.Length);
            _originalDistance = originalDistance;
            _breakDistanceMultiplier = breakMultiplier;
            _thinningSpeed = thinningSpeed;
        }

        private void Start()
        {
            _lineRenderer = GetComponent<LineRenderer>();
            if (_lineRenderer != null)
            {
                _initialStartWidth = _lineRenderer.startWidth;
                _initialEndWidth = _lineRenderer.endWidth;
            }
        }

        private void Update()
        {
            if (_lineRenderer == null || _originalPoints.Length == 0) return;

            _time += Time.deltaTime;
            
            // è®¡ç®—å½“å‰çº¿æ¡çš„å®é™…é•¿åº¦
            Vector3 startPoint = _originalPoints[0];
            Vector3 endPoint = _originalPoints[_originalPoints.Length - 1];
            float currentDistance = Vector3.Distance(_lineRenderer.GetPosition(0), 
                                                      _lineRenderer.GetPosition(_originalPoints.Length - 1));
            
            // å¦‚æœæ‹‰ä¼¸è¶…è¿‡åŸé•¿åº¦çš„å€æ•°ï¼Œçº¿æ¡æ–­è£‚ï¼ˆé”€æ¯ï¼‰
            if (currentDistance > _originalDistance * _breakDistanceMultiplier)
            {
                Destroy(gameObject);
                return;
            }
            
            // é€æ¸ä¸‹å‚ï¼ˆä¸­é—´éƒ¨åˆ†ä¸‹å‚æ›´å¤šï¼‰
            for (int i = 0; i < _originalPoints.Length; i++)
            {
                float t = i / (float)(_originalPoints.Length - 1);
                Vector3 point = _originalPoints[i];
                
                // ä½¿ç”¨æ­£å¼¦å‡½æ•°è®©ä¸­é—´éƒ¨åˆ†ä¸‹å‚æ›´å¤š
                float sagFactor = Mathf.Sin(t * Mathf.PI);
                point.y -= _time * ParticleConfig.DRIPPING_SPEED * sagFactor;
                
                _lineRenderer.SetPosition(i, point);
            }
            
            // éšæ—¶é—´é€æ¸å˜ç»†ï¼ˆæ‹‰ä¼¸æ•ˆæœï¼‰
            float thinningFactor = 1f - (_time * _thinningSpeed);
            thinningFactor = Mathf.Max(0.2f, thinningFactor);  // æœ€ç»†ä¸ä½äº 20%
            
            _lineRenderer.startWidth = _initialStartWidth * thinningFactor;
            _lineRenderer.endWidth = _initialEndWidth * thinningFactor;
        }
    }
}
```

`Milk\Milk.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <Nullable>enable</Nullable>
    <AssemblyName>Milk</AssemblyName>
    <DuckovPath>C:\Program Files (x86)\Steam\steamapps\common\Escape from Duckov</DuckovPath>
  </PropertyGroup>
  
  <ItemGroup>
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\TeamSoda.*" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\Unity*" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\com.rlabrecque.steamworks.net.dll" />
    <PackageReference Include="Lib.Harmony" Version="2.4.1" />
    <Reference Include="$(DuckovPath)\Duckov_Data\Managed\ItemStatsSystem.dll" />
  </ItemGroup>

  <!-- å®šä¹‰ res ç›®å½• -->
  <PropertyGroup>
    <ResDir>$(MSBuildProjectDirectory)\res\</ResDir>
  </PropertyGroup>

  <!-- ç¼–è¯‘åå¤åˆ¶è¾“å‡ºæ–‡ä»¶åˆ° res ç›®å½• -->
  <Target Name="CopyOutputsToRes" AfterTargets="Build">
    <ItemGroup>
      <!-- Milk ä¸»è¾“å‡ºï¼ˆä½¿ç”¨ AssemblyNameï¼‰-->
      <OutputFiles Include="$(TargetPath)" />
      <OutputFiles Include="$(TargetDir)$(AssemblyName).pdb" Condition="Exists('$(TargetDir)$(AssemblyName).pdb')" />
      <OutputFiles Include="$(TargetDir)$(AssemblyName).xml" Condition="Exists('$(TargetDir)$(AssemblyName).xml')" />
      <!-- åŒ…å« 0Harmony.dll (HarmonyLib) -->
      <OutputFiles Include="$(TargetDir)0Harmony.dll" Condition="Exists('$(TargetDir)0Harmony.dll')" />
    </ItemGroup>
    <Copy SourceFiles="@(OutputFiles)" DestinationFolder="$(ResDir)" SkipUnchangedFiles="false" />
    <Message Text="[Milk] å·²å¤åˆ¶è¾“å‡ºæ–‡ä»¶åˆ° res ç›®å½•" Importance="high" />
  </Target>

  <!-- å®šä¹‰æ¸¸æˆ Mods ç›®å½• -->
  <PropertyGroup>
    <ModsDir>$(DuckovPath)\Duckov_Data\Mods\Milk\</ModsDir>
  </PropertyGroup>

  <!-- å¤åˆ¶ res ç›®å½•åˆ°æ¸¸æˆ Mods ç›®å½• -->
  <Target Name="CopyResToMods" AfterTargets="Build" DependsOnTargets="CopyOutputsToRes">
    <MakeDir Directories="$(ModsDir)" />
    <ItemGroup>
      <ResFiles Include="$(ResDir)**\*.*" />
    </ItemGroup>
    <Copy SourceFiles="@(ResFiles)" DestinationFolder="$(ModsDir)\%(RecursiveDir)" SkipUnchangedFiles="false" />
    <Message Text="[Milk] å·²å¤åˆ¶æ–‡ä»¶åˆ°æ¸¸æˆ Mods ç›®å½•: $(ModsDir)" Importance="high" />
  </Target>

</Project>


```

`Milk\MilkParticleLauncher.cs`:

```cs
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// ç‰›å¥¶ç²’å­å‘å°„å™¨ - è´Ÿè´£åˆ›å»ºå’Œé…ç½®ç‰›å¥¶ç²’å­ç³»ç»Ÿ
    /// </summary>
    public class MilkParticleLauncher
    {
        /// <summary>
        /// å‘å°„ç‰›å¥¶ç²’å­ç‰¹æ•ˆ
        /// </summary>
        /// <param name="characterControl">è§’è‰²æ§åˆ¶å™¨</param>
        public static void ShootMilkParticles(CharacterMainControl characterControl)
        {
            try
            {
                if (characterControl == null) return;

                GameObject characterObject = characterControl.gameObject;
                if (characterObject == null) return;

                // è·å–ç©å®¶å½“å‰çš„ç„å‡†æ–¹å‘
                Vector3 aimDirection = characterControl.CurrentAimDirection;
                if (aimDirection == Vector3.zero)
                {
                    // å¦‚æœç„å‡†æ–¹å‘ä¸ºé›¶ï¼Œä½¿ç”¨è§’è‰²å‰æ–¹
                    aimDirection = characterObject.transform.forward;
                }

                // å‘å°„æ–¹å‘ï¼šç©å®¶ç„å‡†çš„æ–¹å‘
                Vector3 shootDirection = aimDirection.normalized;

                // å‘å°„ä½ç½®ï¼šä»è§’è‰²è„šåº•ä½ç½® + é«˜åº¦åç§» + å‰æ–¹åç§»
                Vector3 shootPosition = characterObject.transform.position + 
                                       Vector3.up * ParticleConfig.SHOOT_HEIGHT_OFFSET + 
                                       shootDirection * ParticleConfig.SHOOT_FORWARD_OFFSET;

                CreateMilkParticleSystem(shootPosition, shootDirection);
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }

        /// <summary>
        /// åˆ›å»ºç‰›å¥¶ç²’å­ç³»ç»Ÿ
        /// </summary>
        /// <param name="position">å‘å°„ä½ç½®</param>
        /// <param name="direction">å‘å°„æ–¹å‘</param>
        private static void CreateMilkParticleSystem(Vector3 position, Vector3 direction)
        {
            // åˆ›å»ºç²’å­ç³»ç»Ÿæ¸¸æˆå¯¹è±¡
            var particleObj = new GameObject("MilkParticleEffect");
            particleObj.transform.position = position;
            particleObj.transform.rotation = Quaternion.LookRotation(direction);

            // æ·»åŠ ç²’å­ç³»ç»Ÿç»„ä»¶å’Œé»ç³Šç³Šæ•ˆæœå¤„ç†å™¨
            var ps = particleObj.AddComponent<ParticleSystem>();
            particleObj.AddComponent<MilkStickyEffectHandler>();
            
            // é…ç½®ç²’å­ç³»ç»Ÿ
            ConfigureParticleSystem(ps);

            // è‡ªåŠ¨é”€æ¯ç²’å­ç³»ç»Ÿ
            Object.Destroy(particleObj, ParticleConfig.PARTICLE_SYSTEM_LIFETIME);

            // æ’­æ”¾å¹¶ç«‹å³å‘å°„ç²’å­
            ps.Play();
            ps.Emit(ParticleConfig.PARTICLE_COUNT);
        }

        /// <summary>
        /// é…ç½®ç²’å­ç³»ç»Ÿçš„å„ä¸ªæ¨¡å—
        /// </summary>
        /// <param name="ps">ç²’å­ç³»ç»Ÿ</param>
        private static void ConfigureParticleSystem(ParticleSystem ps)
        {
            ConfigureMainModule(ps);
            ConfigureEmissionModule(ps);
            ConfigureShapeModule(ps);
            ConfigureRotationModule(ps);
            ConfigureRenderer(ps);
            ConfigureCollisionModule(ps);
            ConfigureTrailsModule(ps);
        }

        /// <summary>
        /// é…ç½®ä¸»æ¨¡å—
        /// </summary>
        private static void ConfigureMainModule(ParticleSystem ps)
        {
            var main = ps.main;
            main.duration = ParticleConfig.BURST_DURATION;  // çŸ­æ—¶é—´çˆ†å‘
            main.loop = false;               // ä¸å¾ªç¯
            main.startLifetime = new ParticleSystem.MinMaxCurve(ParticleConfig.PARTICLE_LIFETIME_MIN, ParticleConfig.PARTICLE_LIFETIME_MAX);
            main.startSpeed = new ParticleSystem.MinMaxCurve(ParticleConfig.SHOOT_FORCE * 0.8f, ParticleConfig.SHOOT_FORCE * 1.2f);  // é€Ÿåº¦éšæœºèŒƒå›´
            main.startSize = new ParticleSystem.MinMaxCurve(ParticleConfig.PARTICLE_SIZE_MIN, ParticleConfig.PARTICLE_SIZE_MAX);
            main.startColor = Color.white;  // ç‰›å¥¶ç™½è‰²
            main.gravityModifier = new ParticleSystem.MinMaxCurve(ParticleConfig.GRAVITY_MODIFIER * 0.8f, ParticleConfig.GRAVITY_MODIFIER * 1.5f);
            main.simulationSpace = ParticleSystemSimulationSpace.World;  // ä¸–ç•Œç©ºé—´æ¨¡æ‹Ÿ
            main.maxParticles = ParticleConfig.PARTICLE_COUNT * 2;  // æœ€å¤§ç²’å­æ•°
        }

        /// <summary>
        /// é…ç½®å‘å°„æ¨¡å—
        /// </summary>
        private static void ConfigureEmissionModule(ParticleSystem ps)
        {
            var emission = ps.emission;
            emission.enabled = true;
            emission.rateOverTime = 0;
            ParticleSystem.Burst burst = new ParticleSystem.Burst(0f, ParticleConfig.PARTICLE_COUNT);
            emission.SetBurst(0, burst);
        }

        /// <summary>
        /// é…ç½®å½¢çŠ¶æ¨¡å—
        /// </summary>
        private static void ConfigureShapeModule(ParticleSystem ps)
        {
            var shape = ps.shape;
            shape.enabled = true;
            shape.shapeType = ParticleSystemShapeType.Cone;
            shape.angle = ParticleConfig.EMISSION_CONE_ANGLE;              // é”¥å½¢å‘å°„è§’åº¦
            shape.radius = ParticleConfig.EMISSION_CONE_RADIUS;            // é”¥å½¢åº•é¢åŠå¾„
            shape.radiusThickness = ParticleConfig.EMISSION_RADIUS_THICKNESS;  // ä»é”¥å½¢è¾¹ç¼˜å‘å°„
        }

        /// <summary>
        /// é…ç½®æ—‹è½¬æ¨¡å—
        /// </summary>
        private static void ConfigureRotationModule(ParticleSystem ps)
        {
            var rotationOverLifetime = ps.rotationOverLifetime;
            rotationOverLifetime.enabled = true;
            rotationOverLifetime.z = new ParticleSystem.MinMaxCurve(ParticleConfig.ROTATION_SPEED_MIN, ParticleConfig.ROTATION_SPEED_MAX);  // éšæœºæ—‹è½¬é€Ÿåº¦
        }

        /// <summary>
        /// é…ç½®æ¸²æŸ“å™¨
        /// </summary>
        private static void ConfigureRenderer(ParticleSystem ps)
        {
            var renderer = ps.GetComponent<ParticleSystemRenderer>();
            if (renderer != null)
            {
                renderer.renderMode = ParticleSystemRenderMode.Billboard;
                renderer.sortingOrder = 100;
                
                // å°è¯•æ‰¾åˆ°åˆé€‚çš„ç²’å­ Shader
                Shader? particleShader = Shader.Find("Legacy Shaders/Particles/Alpha Blended") 
                                       ?? Shader.Find("Particles/Alpha Blended Premultiply")
                                       ?? Shader.Find("Particles/Alpha Blended")
                                       ?? Shader.Find("Mobile/Particles/Alpha Blended")
                                       ?? Shader.Find("Sprites/Default");
                
                if (particleShader != null)
                {
                    Material milkMaterial = new Material(particleShader);
                    milkMaterial.color = Color.white;
                    
                    // è®¾ç½®ç²’å­é¢œè‰²å±æ€§ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    if (milkMaterial.HasProperty("_TintColor"))
                    {
                        milkMaterial.SetColor("_TintColor", Color.white);
                    }
                    
                    renderer.material = milkMaterial;
                    renderer.trailMaterial = new Material(milkMaterial);  // æ‹–å°¾ä½¿ç”¨ç›¸åŒæè´¨
                }
            }
        }

        /// <summary>
        /// é…ç½®ç¢°æ’æ¨¡å—
        /// </summary>
        private static void ConfigureCollisionModule(ParticleSystem ps)
        {
            var collision = ps.collision;
            collision.enabled = true;
            collision.type = ParticleSystemCollisionType.World;
            collision.mode = ParticleSystemCollisionMode.Collision3D;
            collision.dampen = ParticleConfig.COLLISION_DAMPEN;                // é˜»å°¼ç³»æ•°
            collision.bounce = ParticleConfig.COLLISION_BOUNCE;                // åå¼¹ç³»æ•°
            collision.lifetimeLoss = ParticleConfig.COLLISION_LIFETIME_LOSS;   // ç¢°æ’åç”Ÿå‘½æŸå¤±
            collision.collidesWith = ~0;                        // ä¸æ‰€æœ‰å±‚ç¢°æ’
            collision.sendCollisionMessages = true;             // å‘é€ç¢°æ’æ¶ˆæ¯ï¼ˆç”¨äºé»ç³Šç³Šæ•ˆæœï¼‰
        }

        /// <summary>
        /// é…ç½®æ‹–å°¾æ¨¡å—
        /// </summary>
        private static void ConfigureTrailsModule(ParticleSystem ps)
        {
            var trails = ps.trails;
            trails.enabled = true;
            trails.ratio = 1.0f;                            // æ‰€æœ‰ç²’å­éƒ½æœ‰æ‹–å°¾
            trails.lifetime = ParticleConfig.TRAIL_LIFETIME;               // æ‹–å°¾æŒç»­æ—¶é—´
            trails.minVertexDistance = ParticleConfig.TRAIL_MIN_VERTEX_DISTANCE;  // é¡¶ç‚¹æœ€å°è·ç¦»
            trails.worldSpace = true;                       // ä¸–ç•Œç©ºé—´æ‹–å°¾
            trails.dieWithParticles = true;                 // ç²’å­æ¶ˆå¤±æ—¶æ‹–å°¾ä¹Ÿæ¶ˆå¤±
            trails.sizeAffectsWidth = true;                 // ç²’å­å¤§å°å½±å“æ‹–å°¾å®½åº¦
            trails.inheritParticleColor = true;             // ç»§æ‰¿ç²’å­é¢œè‰²
        }
    }
}
```

`Milk\MilkStickyEffectHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// ç²’å­ç¢°æ’ç›‘å¬å™¨ - åˆ›å»ºé»ç³Šç³Šçš„æ‹‰ä¸æ•ˆæœ
    /// </summary>
    public class MilkStickyEffectHandler : MonoBehaviour
    {
        private List<CollisionPointInfo> _collisionPoints = new List<CollisionPointInfo>();
        private List<GameObject> _lineObjects = new List<GameObject>();
        private ParticleSystem? _ps;
        private List<ParticleCollisionEvent> _collisionEvents = new List<ParticleCollisionEvent>();
        
        /// <summary>
        /// ç¢°æ’ç‚¹ä¿¡æ¯
        /// </summary>
        private class CollisionPointInfo
        {
            public Vector3 Position;
            public GameObject? HitObject;
            public float Time;
            public Vector3 Normal;          // ç¢°æ’è¡¨é¢æ³•çº¿
            public bool IsGround;           // æ˜¯å¦ä¸ºåœ°é¢ï¼ˆå¹³æ•´çš„æ°´å¹³å‘ä¸Šè¡¨é¢ï¼‰
        }

        private void Start()
        {
            _ps = GetComponent<ParticleSystem>();
        }

        private void OnParticleCollision(GameObject other)
        {
            if (_ps == null) return;

            int numCollisionEvents = _ps.GetCollisionEvents(other, _collisionEvents);

            for (int i = 0; i < numCollisionEvents; i++)
            {
                Vector3 collisionPoint = _collisionEvents[i].intersection;
                Vector3 normal = _collisionEvents[i].normal;
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºå¹³æ•´çš„åœ°é¢ï¼ˆæ°´å¹³å‘ä¸Šï¼‰
                bool isGround = normal.y > ParticleConfig.VERTICAL_NORMAL_THRESHOLD;
                
                // åˆ›å»ºè´´èŠ±
                SplatDecalCreator.CreateSplatDecal(collisionPoint, normal);
                
                // æ·»åŠ ç¢°æ’ç‚¹ä¿¡æ¯
                var pointInfo = new CollisionPointInfo
                {
                    Position = collisionPoint,
                    HitObject = other,
                    Time = Time.time,
                    Normal = normal,
                    IsGround = isGround
                };
                _collisionPoints.Add(pointInfo);

                // åˆ›å»ºé»ç³Šç³Šè¿çº¿çš„æ¡ä»¶æ£€æŸ¥ï¼ˆå¯é€šè¿‡å¸¸é‡å¼€å…³ï¼‰
                if (ParticleConfig.ENABLE_STICKY_LINES && _collisionPoints.Count >= 2 && _lineObjects.Count < ParticleConfig.MAX_STICKY_LINES)
                {
                    CreateStickyConnections(pointInfo, collisionPoint, other);
                }

                // é™åˆ¶ç¢°æ’ç‚¹ç¼“å­˜æ•°é‡
                if (_collisionPoints.Count > ParticleConfig.MAX_COLLISION_POINTS)
                {
                    _collisionPoints.RemoveAt(0);
                }
            }
        }

        /// <summary>
        /// åˆ›å»ºé»ç³Šç³Šè¿æ¥
        /// </summary>
        private void CreateStickyConnections(CollisionPointInfo pointInfo, Vector3 collisionPoint, GameObject other)
        {
            // 1. æŸ¥æ‰¾å¯ä»¥è¿æ¥çš„é™„è¿‘ç‚¹
            var nearbyPoints = _collisionPoints
                .Where(p => p != pointInfo && 
                           Vector3.Distance(p.Position, collisionPoint) > ParticleConfig.MIN_CONNECTION_DISTANCE &&
                           CanCreateConnection(pointInfo, p, collisionPoint))
                .OrderBy(p => Vector3.Distance(p.Position, collisionPoint))
                .Take(ParticleConfig.NEARBY_CONNECTIONS)
                .ToList();

            foreach (var nearPoint in nearbyPoints)
            {
                if (_lineObjects.Count >= ParticleConfig.MAX_STICKY_LINES) break;
                
                float distance = Vector3.Distance(nearPoint.Position, collisionPoint);
                
                // ç›´æ¥ä½¿ç”¨å›ºå®šæ¦‚ç‡åˆ›å»ºè¿çº¿
                if (distance < ParticleConfig.MAX_CONNECTION_DISTANCE && UnityEngine.Random.value < ParticleConfig.LINE_CREATE_CHANCE)
                {
                    StickyLineCreator.CreateStickyLine(nearPoint.Position, collisionPoint, _lineObjects);
                }
            }
            
            // 2. è¿æ¥åŒä¸€ç‰©ä½“ä¸Šçš„ç‚¹ï¼ˆè‡ªèº«ç²˜è¿ï¼‰
            var sameObjectPoints = _collisionPoints
                .Where(p => p.HitObject == other && 
                           p != pointInfo &&
                           CanCreateConnection(pointInfo, p, collisionPoint))
                .OrderBy(p => Vector3.Distance(p.Position, collisionPoint))
                .Take(ParticleConfig.SELF_STICK_CONNECTIONS)
                .ToList();
                
            foreach (var samePoint in sameObjectPoints)
            {
                if (_lineObjects.Count >= ParticleConfig.MAX_STICKY_LINES) break;
                
                float distance = Vector3.Distance(samePoint.Position, collisionPoint);
                
                // è‡ªèº«ç²˜è¿ä½¿ç”¨å›ºå®šé«˜æ¦‚ç‡
                if (distance > ParticleConfig.MIN_CONNECTION_DISTANCE && 
                    distance < ParticleConfig.SELF_STICK_MAX_DISTANCE && 
                    UnityEngine.Random.value < ParticleConfig.SELF_STICK_CHANCE)
                {
                    StickyLineCreator.CreateStickyLine(samePoint.Position, collisionPoint, _lineObjects);
                }
            }
        }

        /// <summary>
        /// åˆ¤æ–­ä¸¤ä¸ªç‚¹ä¹‹é—´æ˜¯å¦å¯ä»¥åˆ›å»ºè¿æ¥
        /// è§„åˆ™ï¼š
        /// 1. å¢™å£ä¸Šçš„ç‚¹ - å¯ä»¥è¿æ¥
        /// 2. å¤©èŠ±æ¿ä¸Šçš„ç‚¹ - å¯ä»¥è¿æ¥
        /// 3. æœ‰é«˜åº¦å·®çš„ç‚¹ - å¯ä»¥è¿æ¥
        /// 4. ä¸¤ä¸ªéƒ½åœ¨å¹³æ•´åœ°é¢ä¸”é«˜åº¦å·®å° - ä¸è¿æ¥
        /// </summary>
        private bool CanCreateConnection(CollisionPointInfo pointA, CollisionPointInfo pointB, Vector3 currentPosition)
        {
            // 1. å¦‚æœè‡³å°‘æœ‰ä¸€ä¸ªç‚¹ä¸åœ¨åœ°é¢ä¸Šï¼ˆå¢™å£ã€å¤©èŠ±æ¿ï¼‰ï¼Œå¯ä»¥è¿æ¥
            if (!pointA.IsGround || !pointB.IsGround)
            {
                return true;
            }
            
            // 2. å¦‚æœä¸¤ç‚¹éƒ½åœ¨åœ°é¢ä¸Šï¼Œæ£€æŸ¥é«˜åº¦å·®
            float heightDiff = Mathf.Abs(pointA.Position.y - pointB.Position.y);
            if (heightDiff > ParticleConfig.HEIGHT_DIFFERENCE_THRESHOLD)
            {
                return true;  // æœ‰é«˜åº¦å·®ï¼Œå¯ä»¥è¿æ¥ï¼ˆä¾‹å¦‚æ¥¼æ¢¯ã€æ–œå¡ï¼‰
            }
            
            // 3. ä¸¤ä¸ªç‚¹éƒ½åœ¨å¹³æ•´åœ°é¢ä¸Šä¸”é«˜åº¦å·®å¾ˆå° - ä¸åˆ›å»ºè¿æ¥
            return false;
        }

        private void OnDestroy()
        {
            foreach (var lineObj in _lineObjects)
            {
                if (lineObj != null)
                {
                    Destroy(lineObj);
                }
            }
            _lineObjects.Clear();
        }
    }
}
```

`Milk\ModBehaviour.cs`:

```cs
using UnityEngine;
using HarmonyLib;

namespace Milk
{
    /// <summary>
    /// Milk ç²’å­ç‰¹æ•ˆæ¨¡ç»„ä¸»è¡Œä¸ºç±»
    /// æŒ‰ H é”®å‘å°„ç‰›å¥¶ç²’å­
    /// </summary>
    public class ModBehaviour : Duckov.Modding.ModBehaviour
    {

        /// <summary>
        /// å…¨å±€å®ä¾‹
        /// </summary>
        public static ModBehaviour? Instance { get; private set; }

        /// <summary>
        /// Harmony å®ä¾‹
        /// </summary>
        private static Harmony? _harmony;

        void Awake()
        {
            try
            {
                // è®¾ç½®å…¨å±€å®ä¾‹
                Instance = this;

                // è¾“å‡ºæ¨¡ç»„åŠ è½½ä¿¡æ¯
                LogModInfo();

                // åº”ç”¨ Harmony è¡¥ä¸
                ApplyHarmonyPatches();
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }

        void Update()
        {
            try
            {
                // æŒ‰ H é”®å‘å°„ç‰›å¥¶ç²’å­
                if (Input.GetKeyDown(KeyCode.H))
                {
                    ShootMilkParticles();
                }
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }

        void OnDestroy()
        {
            try
            {
                // ç§»é™¤ Harmony è¡¥ä¸
                RemoveHarmonyPatches();

                // æ¸…ç†å®ä¾‹
                Instance = null;
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }

        /// <summary>
        /// å‘å°„ç‰›å¥¶ç²’å­ç‰¹æ•ˆ
        /// </summary>
        private void ShootMilkParticles()
        {
            try
            {
                // è·å–æœ¬åœ°ç©å®¶çš„ CharacterMainControl
                CharacterMainControl? characterControl = CharacterMainControl.Main;
                if (characterControl == null) return;

                // ä½¿ç”¨ç²’å­å‘å°„å™¨å‘å°„ç‰›å¥¶ç²’å­
                MilkParticleLauncher.ShootMilkParticles(characterControl);
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }

        /// <summary>
        /// è¾“å‡ºæ¨¡ç»„ä¿¡æ¯
        /// </summary>
        private void LogModInfo()
        {
            // é™é»˜åŠ è½½
        }

        /// <summary>
        /// åº”ç”¨ Harmony è¡¥ä¸
        /// </summary>
        private void ApplyHarmonyPatches()
        {
            try
            {
                _harmony = new Harmony("com.duckynet.milk");
                _harmony.PatchAll();
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }

        /// <summary>
        /// ç§»é™¤ Harmony è¡¥ä¸
        /// </summary>
        private void RemoveHarmonyPatches()
        {
            try
            {
                if (_harmony != null)
                {
                    _harmony.UnpatchAll(_harmony.Id);
                    _harmony = null;
                }
            }
            catch
            {
                // é™é»˜å¤„ç†å¼‚å¸¸
            }
        }
    }
}


```

`Milk\ParticleConfig.cs`:

```cs
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// ç‰›å¥¶ç²’å­ç³»ç»Ÿé…ç½®ç±»
    /// åŒ…å«æ‰€æœ‰ç²’å­ç³»ç»Ÿç›¸å…³çš„å¸¸é‡é…ç½®
    /// </summary>
    public static class ParticleConfig
    {
        #region åŸºç¡€ç²’å­é…ç½®

        /// <summary>
        /// ç²’å­åˆå§‹å‘å°„é€Ÿåº¦ (m/s)
        /// </summary>
        public const float SHOOT_FORCE = 20f;

        /// <summary>
        /// é‡åŠ›å€æ•°ï¼ˆ1.0 = æ­£å¸¸é‡åŠ›ï¼‰
        /// </summary>
        public const float GRAVITY_MODIFIER = 1.0f;

        /// <summary>
        /// æ¯æ¬¡å‘å°„çš„ç²’å­æ•°é‡
        /// </summary>
        public const int PARTICLE_COUNT = 150;

        /// <summary>
        /// å‘å°„ä½ç½®é«˜åº¦åç§»ï¼ˆç±³ï¼‰- ä»è§’è‰²è„šåº•å‘ä¸Šçš„é«˜åº¦
        /// </summary>
        public const float SHOOT_HEIGHT_OFFSET = 1f;

        /// <summary>
        /// å‘å°„ä½ç½®å‰æ–¹åç§»ï¼ˆç±³ï¼‰- é¿å…è¢«ç©å®¶è‡ªå·±æŒ¡ä½
        /// </summary>
        public const float SHOOT_FORWARD_OFFSET = 0.8f;

        /// <summary>
        /// ç²’å­æŒç»­æ—¶é—´ - æœ€å°å€¼ï¼ˆç§’ï¼‰
        /// </summary>
        public const float PARTICLE_LIFETIME_MIN = 1.0f;

        /// <summary>
        /// ç²’å­æŒç»­æ—¶é—´ - æœ€å¤§å€¼ï¼ˆç§’ï¼‰
        /// </summary>
        public const float PARTICLE_LIFETIME_MAX = 3.0f;

        /// <summary>
        /// ç²’å­å¤§å° - æœ€å°å€¼ï¼ˆç±³ï¼‰
        /// </summary>
        public const float PARTICLE_SIZE_MIN = 0.15f;

        /// <summary>
        /// ç²’å­å¤§å° - æœ€å¤§å€¼ï¼ˆç±³ï¼‰
        /// </summary>
        public const float PARTICLE_SIZE_MAX = 0.35f;

        /// <summary>
        /// ç²’å­ç³»ç»Ÿè‡ªåŠ¨é”€æ¯æ—¶é—´ï¼ˆç§’ï¼‰
        /// </summary>
        public const float PARTICLE_SYSTEM_LIFETIME = 10f;

        /// <summary>
        /// ç²’å­å‘å°„é”¥å½¢è§’åº¦ï¼ˆåº¦ï¼‰
        /// </summary>
        public const float EMISSION_CONE_ANGLE = 15f;

        /// <summary>
        /// ç²’å­å‘å°„é”¥å½¢åŠå¾„ï¼ˆç±³ï¼‰
        /// </summary>
        public const float EMISSION_CONE_RADIUS = 0.1f;

        /// <summary>
        /// ç²’å­å‘å°„ä½ç½®åˆ†å¸ƒï¼ˆ0=ä¸­å¿ƒï¼Œ1=è¾¹ç¼˜ï¼‰
        /// </summary>
        public const float EMISSION_RADIUS_THICKNESS = 0.5f;

        /// <summary>
        /// ç²’å­æ—‹è½¬é€Ÿåº¦ - æœ€å°å€¼ï¼ˆåº¦/ç§’ï¼‰
        /// </summary>
        public const float ROTATION_SPEED_MIN = -180f;

        /// <summary>
        /// ç²’å­æ—‹è½¬é€Ÿåº¦ - æœ€å¤§å€¼ï¼ˆåº¦/ç§’ï¼‰
        /// </summary>
        public const float ROTATION_SPEED_MAX = 180f;

        /// <summary>
        /// ç²’å­çˆ†å‘æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰- çŸ­æ—¶é—´çˆ†å‘
        /// </summary>
        public const float BURST_DURATION = 0.2f;

        #endregion

        #region ç¢°æ’é…ç½®

        /// <summary>
        /// ç¢°æ’é˜»å°¼ç³»æ•°ï¼ˆ0-1ï¼‰
        /// </summary>
        public const float COLLISION_DAMPEN = 0.5f;

        /// <summary>
        /// ç¢°æ’åå¼¹ç³»æ•°ï¼ˆ0-1ï¼‰
        /// </summary>
        public const float COLLISION_BOUNCE = 0.3f;

        /// <summary>
        /// ç¢°æ’åç”Ÿå‘½æŸå¤±ç³»æ•°ï¼ˆ0-1ï¼‰
        /// </summary>
        public const float COLLISION_LIFETIME_LOSS = 0.1f;

        #endregion

        #region æ‹–å°¾é…ç½®

        /// <summary>
        /// æ‹–å°¾æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
        /// </summary>
        public const float TRAIL_LIFETIME = 0.3f;

        /// <summary>
        /// æ‹–å°¾é¡¶ç‚¹æœ€å°è·ç¦»ï¼ˆç±³ï¼‰
        /// </summary>
        public const float TRAIL_MIN_VERTEX_DISTANCE = 0.02f;

        #endregion

        #region é»ç³Šç³Šæ•ˆæœé…ç½®

        /// <summary>
        /// æœ€å¤§çº¿æ¡æ•°é‡ï¼ˆå¢åŠ åˆ°æ”¯æŒæ›´å¤šæ‹‰ä¸ï¼‰
        /// </summary>
        public const int MAX_STICKY_LINES = 200;

        /// <summary>
        /// åˆ›å»ºè¿çº¿çš„æœ€å°è·ç¦»ï¼ˆç±³ï¼‰
        /// </summary>
        public const float MIN_CONNECTION_DISTANCE = 0.1f;

        /// <summary>
        /// åˆ›å»ºè¿çº¿çš„æœ€å¤§è·ç¦»ï¼ˆç±³ï¼‰
        /// </summary>
        public const float MAX_CONNECTION_DISTANCE = 10f;

        /// <summary>
        /// åˆ›å»ºè¿çº¿çš„æ¦‚ç‡ï¼ˆ0-1ï¼‰- æ¯æ¬¡ç¢°æ’æ—¶å°è¯•è¿æ¥çš„æ¦‚ç‡
        /// </summary>
        public const float LINE_CREATE_CHANCE = 0.9f;

        /// <summary>
        /// è‡ªèº«ç²˜è¿æ¦‚ç‡ï¼ˆ0-1ï¼‰
        /// </summary>
        public const float SELF_STICK_CHANCE = 0.9f;

        /// <summary>
        /// å‚ç›´å‘ä¸Šæ³•çº¿é˜ˆå€¼ - è¶…è¿‡æ­¤å€¼è§†ä¸ºåœ°é¢
        /// </summary>
        public const float VERTICAL_NORMAL_THRESHOLD = 0.8f;

        /// <summary>
        /// å‚ç›´å‘ä¸‹æ³•çº¿é˜ˆå€¼ - ä½äºæ­¤å€¼è§†ä¸ºå¤©èŠ±æ¿
        /// </summary>
        public const float CEILING_NORMAL_THRESHOLD = -0.5f;

        /// <summary>
        /// é«˜åº¦å·®é˜ˆå€¼ï¼ˆç±³ï¼‰- è¶…è¿‡æ­¤å€¼è®¤ä¸ºæœ‰é«˜åº¦å·®ï¼Œå¯ä»¥åˆ›å»ºè¿çº¿
        /// </summary>
        public const float HEIGHT_DIFFERENCE_THRESHOLD = 0.3f;

        /// <summary>
        /// è‡ªèº«ç²˜è¿æœ€å¤§è·ç¦»ï¼ˆç±³ï¼‰
        /// </summary>
        public const float SELF_STICK_MAX_DISTANCE = 30f;

        /// <summary>
        /// æœ€å¤§ç¢°æ’ç‚¹ç¼“å­˜æ•°é‡
        /// </summary>
        public const int MAX_COLLISION_POINTS = 100;

        /// <summary>
        /// æ¯æ¬¡ç¢°æ’è¿æ¥åˆ°æœ€è¿‘ç‚¹çš„æ•°é‡ï¼ˆæ¯ä¸ªæ–°ç‚¹è¿æ¥å¤šä¸ªæ—§ç‚¹ï¼‰
        /// </summary>
        public const int NEARBY_CONNECTIONS = 5;

        /// <summary>
        /// è‡ªèº«ç²˜è¿è¿æ¥æ•°é‡ï¼ˆåŒä¸€ç‰©ä½“ä¸Šçš„è¿æ¥ï¼‰
        /// </summary>
        public const int SELF_STICK_CONNECTIONS = 3;

        /// <summary>
        /// æ˜¯å¦å¯ç”¨è¿çº¿åŠŸèƒ½ï¼ˆæš‚æ—¶ç¦ç”¨ï¼‰
        /// </summary>
        public const bool ENABLE_STICKY_LINES = false;

        /// <summary>
        /// é»ç³Šç³Šçº¿æ¡å­˜æ´»æ—¶é—´ï¼ˆç§’ï¼‰
        /// </summary>
        public const float STICKY_LINE_LIFETIME = 8f;

        /// <summary>
        /// çº¿æ¡æ‹‰ä¼¸æ–­è£‚è·ç¦»å€æ•° - å½“æ‹‰ä¼¸è¶…è¿‡åŸé•¿åº¦æ­¤å€æ•°æ—¶æ–­è£‚
        /// </summary>
        public const float LINE_BREAK_DISTANCE_MULTIPLIER = 3f;

        /// <summary>
        /// çº¿æ¡æ‹‰ä¼¸å˜ç»†é€Ÿåº¦ï¼ˆæ¯ç§’ï¼‰
        /// </summary>
        public const float LINE_THINNING_SPEED = 0.05f;

        #endregion

        #region çº¿æ¡æ¸²æŸ“é…ç½®

        /// <summary>
        /// çº¿æ¡èµ·å§‹å®½åº¦
        /// </summary>
        public const float LINE_START_WIDTH = 0.12f;

        /// <summary>
        /// çº¿æ¡ç»“æŸå®½åº¦
        /// </summary>
        public const float LINE_END_WIDTH = 0.06f;

        /// <summary>
        /// çº¿æ¡åˆ†æ®µæ•°
        /// </summary>
        public const int LINE_SEGMENTS = 8;

        /// <summary>
        /// ä¸‹å‚ç³»æ•°ï¼ˆè·ç¦»çš„å€æ•°ï¼‰
        /// </summary>
        public const float SAG_FACTOR = 0.3f;

        /// <summary>
        /// æ‘†åŠ¨èŒƒå›´
        /// </summary>
        public const float WOBBLE_RANGE = 0.03f;

        /// <summary>
        /// ä¸‹å‚é€Ÿåº¦ï¼ˆç±³/ç§’ï¼‰
        /// </summary>
        public const float DRIPPING_SPEED = 0.5f;

        #endregion

        #region è´´èŠ±é…ç½®

        /// <summary>
        /// åœ†å½¢åˆ†æ®µæ•°
        /// </summary>
        public const int DECAL_SEGMENTS = 16;

        /// <summary>
        /// è´´èŠ±è¡¨é¢åç§»ï¼ˆé¿å… Z-fightingï¼‰
        /// </summary>
        public const float DECAL_OFFSET = 0.01f;

        /// <summary>
        /// è´´èŠ±æœ€å°åŠå¾„
        /// </summary>
        public const float DECAL_RADIUS_MIN = 0.2f;

        /// <summary>
        /// è´´èŠ±æœ€å¤§åŠå¾„
        /// </summary>
        public const float DECAL_RADIUS_MAX = 0.4f;

        /// <summary>
        /// è¾¹ç¼˜ä¸è§„åˆ™æœ€å°å€¼
        /// </summary>
        public const float DECAL_IRREGULARITY_MIN = 0.8f;

        /// <summary>
        /// è¾¹ç¼˜ä¸è§„åˆ™æœ€å¤§å€¼
        /// </summary>
        public const float DECAL_IRREGULARITY_MAX = 1.2f;

        /// <summary>
        /// è´´èŠ±é€æ˜åº¦
        /// </summary>
        public const float DECAL_ALPHA = 0.8f;

        /// <summary>
        /// è´´èŠ±å­˜æ´»æ—¶é—´ï¼ˆç§’ï¼‰
        /// </summary>
        public const float DECAL_LIFETIME = 6f;

        /// <summary>
        /// è´´èŠ±æ‰©æ•£é€Ÿåº¦ï¼ˆç±³/ç§’ï¼‰
        /// </summary>
        public const float DECAL_SPREAD_SPEED = 0.05f;

        /// <summary>
        /// è´´èŠ±æœ€å¤§æ‰©æ•£å€æ•°
        /// </summary>
        public const float DECAL_MAX_SPREAD_MULTIPLIER = 1.5f;

        #endregion
    }
}
```

`Milk\SplatDecalCreator.cs`:

```cs
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// è´´èŠ±åˆ›å»ºå™¨ - è´Ÿè´£åœ¨ç¢°æ’ç‚¹åˆ›å»ºåœ†å½¢ç‰›å¥¶è´´èŠ±
    /// </summary>
    public static class SplatDecalCreator
    {
        /// <summary>
        /// åœ¨ç¢°æ’ç‚¹åˆ›å»ºåœ†å½¢è´´èŠ±
        /// </summary>
        /// <param name="position">ç¢°æ’ä½ç½®</param>
        /// <param name="normal">è¡¨é¢æ³•çº¿</param>
        public static void CreateSplatDecal(Vector3 position, Vector3 normal)
        {
            GameObject decalObj = new GameObject("MilkSplatDecal");
            decalObj.transform.position = position + normal * ParticleConfig.DECAL_OFFSET;  // ç¨å¾®åç§»é¿å… Z-fighting
            decalObj.transform.rotation = Quaternion.LookRotation(-normal);  // é¢å‘æ³•çº¿åæ–¹å‘
            
            var meshFilter = decalObj.AddComponent<MeshFilter>();
            var meshRenderer = decalObj.AddComponent<MeshRenderer>();
            
            // åˆ›å»ºåœ†å½¢ç½‘æ ¼
            Mesh mesh = CreateCircularMesh();
            meshFilter.mesh = mesh;
            
            // åˆ›å»ºåŠé€æ˜ç™½è‰²æè´¨
            SetDecalMaterial(meshRenderer);
            
            // æ·»åŠ æ¸å˜æ¶ˆå¤±å’Œæ‰©æ•£æ•ˆæœ
            var fadeEffect = decalObj.AddComponent<DecalFadeEffect>();
            fadeEffect.Initialize(ParticleConfig.DECAL_LIFETIME, ParticleConfig.DECAL_SPREAD_SPEED, ParticleConfig.DECAL_MAX_SPREAD_MULTIPLIER);
            
            // è‡ªåŠ¨é”€æ¯
            Object.Destroy(decalObj, ParticleConfig.DECAL_LIFETIME);
        }

        /// <summary>
        /// åˆ›å»ºåœ†å½¢ç½‘æ ¼ï¼ˆä½¿ç”¨å¤šè¾¹å½¢è¿‘ä¼¼ï¼‰
        /// </summary>
        private static Mesh CreateCircularMesh()
        {
            Mesh mesh = new Mesh();
            Vector3[] vertices = new Vector3[ParticleConfig.DECAL_SEGMENTS + 1];
            int[] triangles = new int[ParticleConfig.DECAL_SEGMENTS * 3];
            Vector2[] uvs = new Vector2[ParticleConfig.DECAL_SEGMENTS + 1];
            
            // ä¸­å¿ƒç‚¹
            vertices[0] = Vector3.zero;
            uvs[0] = new Vector2(0.5f, 0.5f);
            
            // éšæœºåŠå¾„ï¼ˆä¸è§„åˆ™å¤§å°ï¼‰
            float radius = Random.Range(ParticleConfig.DECAL_RADIUS_MIN, ParticleConfig.DECAL_RADIUS_MAX);
            
            // ç”Ÿæˆåœ†å½¢é¡¶ç‚¹
            for (int i = 0; i < ParticleConfig.DECAL_SEGMENTS; i++)
            {
                float angle = (i / (float)ParticleConfig.DECAL_SEGMENTS) * Mathf.PI * 2f;
                float irregularity = Random.Range(ParticleConfig.DECAL_IRREGULARITY_MIN, ParticleConfig.DECAL_IRREGULARITY_MAX);
                float r = radius * irregularity;
                
                vertices[i + 1] = new Vector3(
                    Mathf.Cos(angle) * r,
                    Mathf.Sin(angle) * r,
                    0
                );
                uvs[i + 1] = new Vector2(
                    Mathf.Cos(angle) * 0.5f + 0.5f,
                    Mathf.Sin(angle) * 0.5f + 0.5f
                );
                
                // ä¸‰è§’å½¢ç´¢å¼•
                triangles[i * 3] = 0;
                triangles[i * 3 + 1] = i + 1;
                triangles[i * 3 + 2] = (i + 1) % ParticleConfig.DECAL_SEGMENTS + 1;
            }
            
            mesh.vertices = vertices;
            mesh.triangles = triangles;
            mesh.uv = uvs;
            mesh.RecalculateNormals();
            
            return mesh;
        }

        /// <summary>
        /// è®¾ç½®è´´èŠ±æè´¨
        /// </summary>
        private static void SetDecalMaterial(MeshRenderer meshRenderer)
        {
            var shader = Shader.Find("Sprites/Default") ?? Shader.Find("Unlit/Transparent");
            if (shader != null)
            {
                var material = new Material(shader);
                material.color = new Color(1f, 1f, 1f, ParticleConfig.DECAL_ALPHA);
                meshRenderer.material = material;
            }
        }
    }
}
```

`Milk\StickyLineCreator.cs`:

```cs
using System.Collections.Generic;
using UnityEngine;

namespace Milk
{
    /// <summary>
    /// é»ç³Šç³Šçº¿æ¡åˆ›å»ºå™¨
    /// </summary>
    public static class StickyLineCreator
    {
        /// <summary>
        /// åˆ›å»ºé»ç³Šç³Šæ‹‰ä¸çº¿æ¡
        /// </summary>
        /// <param name="start">èµ·å§‹ä½ç½®</param>
        /// <param name="end">ç»“æŸä½ç½®</param>
        /// <param name="lineObjects">çº¿æ¡å¯¹è±¡åˆ—è¡¨ï¼Œç”¨äºç®¡ç†</param>
        public static void CreateStickyLine(Vector3 start, Vector3 end, List<GameObject> lineObjects)
        {
            GameObject lineObj = new GameObject("MilkStickyLine");
            LineRenderer lineRenderer = lineObj.AddComponent<LineRenderer>();

            // é…ç½®çº¿æ¡æ¸²æŸ“å™¨
            ConfigureLineRenderer(lineRenderer);
            
            // åˆ›å»ºè‡ªç„¶ä¸‹å‚çš„æ›²çº¿
            Vector3[] points = CreateCurvedLine(start, end);
            lineRenderer.SetPositions(points);

            // è®¾ç½®ç™½è‰²åŠé€æ˜æè´¨
            SetLineMaterial(lineRenderer);

            // æ·»åŠ åŠ¨æ€ä¸‹å‚æ•ˆæœï¼ˆåŒ…å«æ‹‰ä¼¸æ–­è£‚å’Œå˜ç»†ï¼‰
            float distance = Vector3.Distance(start, end);
            var drippingEffect = lineObj.AddComponent<LineDrippingEffect>();
            drippingEffect.Initialize(points, distance, ParticleConfig.LINE_BREAK_DISTANCE_MULTIPLIER, ParticleConfig.LINE_THINNING_SPEED);

            // è‡ªåŠ¨é”€æ¯
            Object.Destroy(lineObj, ParticleConfig.STICKY_LINE_LIFETIME);
            lineObjects.Add(lineObj);

            // æ¸…ç†å·²é”€æ¯çš„çº¿æ¡å¼•ç”¨
            lineObjects.RemoveAll(obj => obj == null);
        }

        /// <summary>
        /// é…ç½®çº¿æ¡æ¸²æŸ“å™¨åŸºæœ¬å±æ€§
        /// </summary>
        private static void ConfigureLineRenderer(LineRenderer lineRenderer)
        {
            lineRenderer.startWidth = ParticleConfig.LINE_START_WIDTH;
            lineRenderer.endWidth = ParticleConfig.LINE_END_WIDTH;
            lineRenderer.positionCount = ParticleConfig.LINE_SEGMENTS;
            lineRenderer.useWorldSpace = true;
        }

        /// <summary>
        /// åˆ›å»ºè‡ªç„¶ä¸‹å‚çš„æ›²çº¿ç‚¹
        /// </summary>
        private static Vector3[] CreateCurvedLine(Vector3 start, Vector3 end)
        {
            Vector3[] points = new Vector3[ParticleConfig.LINE_SEGMENTS];
            float distance = Vector3.Distance(start, end);
            float sagAmount = distance * ParticleConfig.SAG_FACTOR;
            
            for (int i = 0; i < ParticleConfig.LINE_SEGMENTS; i++)
            {
                float t = i / (float)(ParticleConfig.LINE_SEGMENTS - 1);
                Vector3 point = Vector3.Lerp(start, end, t);
                
                // æŠ›ç‰©çº¿ä¸‹å‚ï¼ˆæ¨¡æ‹Ÿé‡åŠ›ï¼‰
                float sag = sagAmount * Mathf.Sin(t * Mathf.PI);
                point.y -= sag;
                
                // æ·»åŠ éšæœºæ‘†åŠ¨ï¼ˆä¸è§„åˆ™æ„Ÿï¼‰
                point += new Vector3(
                    Random.Range(-ParticleConfig.WOBBLE_RANGE, ParticleConfig.WOBBLE_RANGE),
                    Random.Range(-ParticleConfig.WOBBLE_RANGE * 0.67f, ParticleConfig.WOBBLE_RANGE * 0.67f),
                    Random.Range(-ParticleConfig.WOBBLE_RANGE, ParticleConfig.WOBBLE_RANGE)
                );
                
                points[i] = point;
            }
            
            return points;
        }

        /// <summary>
        /// è®¾ç½®çº¿æ¡æè´¨
        /// </summary>
        private static void SetLineMaterial(LineRenderer lineRenderer)
        {
            var shader = Shader.Find("Sprites/Default") ?? Shader.Find("Unlit/Color");
            if (shader != null)
            {
                lineRenderer.material = new Material(shader);
                lineRenderer.startColor = new Color(1f, 1f, 1f, 0.7f);  // èµ·å§‹åŠé€æ˜
                lineRenderer.endColor = new Color(1f, 1f, 1f, 0.4f);    // ç»“æŸæ›´é€æ˜
            }
        }
    }
}
```

`Milk\res\info.ini`:

```ini
name = Milk
displayName = çˆ½ï¼é…¸å¥¶å–·æº…
description = çˆ½ï¼é…¸å¥¶å–·æº…


```

`Server\Core\ServerContext.cs`:

```cs
using System;
using DuckyNet.Server.RPC;
using DuckyNet.Server.Managers;
using DuckyNet.Server.Events;

namespace DuckyNet.Server.Core
{
    /// <summary>
    /// æœåŠ¡å™¨å…¨å±€ä¸Šä¸‹æ–‡
    /// æä¾›å¯¹æ ¸å¿ƒç®¡ç†å™¨å’ŒæœåŠ¡çš„å…¨å±€è®¿é—®
    /// </summary>
    public static class ServerContext
    {
        private static bool _isInitialized = false;

        /// <summary>
        /// RPC æœåŠ¡å™¨å®ä¾‹
        /// </summary>
        public static RpcServer Server { get; private set; } = null!;

        /// <summary>
        /// ç©å®¶ç®¡ç†å™¨
        /// </summary>
        public static PlayerManager Players { get; private set; } = null!;

        /// <summary>
        /// æˆ¿é—´ç®¡ç†å™¨
        /// </summary>
        public static RoomManager Rooms { get; private set; } = null!;

        /// <summary>
        /// åœºæ™¯ç®¡ç†å™¨
        /// </summary>
        public static SceneManager Scenes { get; private set; } = null!;

        /// <summary>
        /// å¹¿æ’­ç®¡ç†å™¨
        /// </summary>
        public static BroadcastManager Broadcast { get; private set; } = null!;

        /// <summary>
        /// äº‹ä»¶æ€»çº¿
        /// </summary>
        public static EventBus Events { get; private set; } = null!;

        /// <summary>
        /// åˆå§‹åŒ–æœåŠ¡å™¨ä¸Šä¸‹æ–‡
        /// </summary>
        public static void Initialize(
            RpcServer server,
            PlayerManager playerManager,
            RoomManager roomManager,
            SceneManager sceneManager,
            BroadcastManager broadcastManager,
            EventBus eventBus)
        {
            if (_isInitialized)
            {
                throw new InvalidOperationException("ServerContext å·²ç»åˆå§‹åŒ–è¿‡äº†");
            }

            Server = server ?? throw new ArgumentNullException(nameof(server));
            Players = playerManager ?? throw new ArgumentNullException(nameof(playerManager));
            Rooms = roomManager ?? throw new ArgumentNullException(nameof(roomManager));
            Scenes = sceneManager ?? throw new ArgumentNullException(nameof(sceneManager));
            Broadcast = broadcastManager ?? throw new ArgumentNullException(nameof(broadcastManager));
            Events = eventBus ?? throw new ArgumentNullException(nameof(eventBus));

            _isInitialized = true;

            // åˆå§‹åŒ– ServerEventPublisherï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
            ServerEventPublisher.Initialize(eventBus);

            Console.WriteLine("[ServerContext] âœ… æœåŠ¡å™¨å…¨å±€ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–");
        }

        /// <summary>
        /// æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦å·²åˆå§‹åŒ–
        /// </summary>
        public static void EnsureInitialized()
        {
            if (!_isInitialized)
            {
                throw new InvalidOperationException("ServerContext å°šæœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè°ƒç”¨ Initialize()");
            }
        }

        /// <summary>
        /// é‡ç½®ä¸Šä¸‹æ–‡ï¼ˆä»…ç”¨äºæµ‹è¯•ï¼‰
        /// </summary>
        public static void Reset()
        {
            _isInitialized = false;
            Server = null!;
            Players = null!;
            Rooms = null!;
            Scenes = null!;
            Broadcast = null!;
            Events = null!;
        }
    }
}


```

`Server\Core\ServerInitializer.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using DuckyNet.Server.RPC;
using DuckyNet.Server.Events;
using DuckyNet.Server.Managers;

namespace DuckyNet.Server.Core
{
    /// <summary>
    /// æœåŠ¡å™¨åˆå§‹åŒ–å™¨
    /// [REFACTOR] é˜¶æ®µ1ï¼šè¿‡æ¸¡æ–¹æ¡ˆ - åˆå§‹åŒ–é™æ€ä¾èµ–
    /// TODO(REFACTOR): é˜¶æ®µ2ä¼šç§»é™¤æ‰€æœ‰é™æ€ä¾èµ–ï¼Œä½¿ç”¨å®Œå…¨çš„ä¾èµ–æ³¨å…¥
    /// </summary>
    public static class ServerInitializer
    {
        /// <summary>
        /// åˆå§‹åŒ–é™æ€ä¾èµ–ï¼ˆå…¼å®¹æ€§è¿‡æ¸¡ï¼‰
        /// å½“å‰ä¸€äº›è¾…åŠ©ç±»ï¼ˆRoomBroadcastHelper, ServerEventPublisherï¼‰
        /// ä»ç„¶ä½¿ç”¨é™æ€å­—æ®µï¼Œéœ€è¦æ‰‹åŠ¨åˆå§‹åŒ–
        /// </summary>
        public static void InitializeStaticDependencies(IServiceProvider serviceProvider)
        {
            // åˆå§‹åŒ–äº‹ä»¶å‘å¸ƒå™¨ï¼ˆç”¨äºæœåŠ¡å±‚ä¾¿æ·å‘å¸ƒäº‹ä»¶ï¼‰
            var eventBus = serviceProvider.GetRequiredService<EventBus>();
            ServerEventPublisher.Initialize(eventBus);

            // åˆå§‹åŒ–æˆ¿é—´å¹¿æ’­è¾…åŠ©ç±»ï¼ˆç”¨äº BroadcastToRoom æ‰©å±•æ–¹æ³•ï¼‰
            var roomManager = serviceProvider.GetRequiredService<RoomManager>();
            var playerManager = serviceProvider.GetRequiredService<PlayerManager>();
            RoomBroadcastHelper.Initialize(roomManager, playerManager);
        }
    }
}


```

`Server\Core\ServiceCollectionExtensions.cs`:

```cs
using Microsoft.Extensions.DependencyInjection;
using DuckyNet.Server.RPC;
using DuckyNet.Server.Events;
using DuckyNet.Server.Managers;
using DuckyNet.Server.Services;
using DuckyNet.Server.Plugin;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.RPC;

namespace DuckyNet.Server.Core
{
    /// <summary>
    /// æœåŠ¡é›†åˆæ‰©å±•æ–¹æ³• - é…ç½®ä¾èµ–æ³¨å…¥å®¹å™¨
    /// [REFACTOR] é˜¶æ®µ1ï¼šå¼•å…¥ DI å®¹å™¨
    /// </summary>
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// æ·»åŠ  DuckyNet æ ¸å¿ƒæœåŠ¡ï¼ˆåº•å±‚æ¡†æ¶ï¼‰
        /// </summary>
        public static IServiceCollection AddDuckyNetCore(this IServiceCollection services)
        {
            // æ ¸å¿ƒç½‘ç»œå±‚
            services.AddSingleton<RpcServer>(sp =>
            {
                var config = RpcConfig.Development;
                return new RpcServer(config);
            });

            // äº‹ä»¶æ€»çº¿
            services.AddSingleton<EventBus>();
            services.AddSingleton<IEventBus>(sp => sp.GetRequiredService<EventBus>());

            return services;
        }

        /// <summary>
        /// æ·»åŠ  DuckyNet ä¸šåŠ¡æ¨¡å—ï¼ˆå½“å‰ä¿æŒåŸæœ‰ç»“æ„ï¼‰
        /// TODO(REFACTOR): é˜¶æ®µ3ä¼šæ‹†åˆ†ä¸ºç‹¬ç«‹æ¨¡å—
        /// </summary>
        public static IServiceCollection AddDuckyNetModules(this IServiceCollection services)
        {
            // æ ¸å¿ƒç®¡ç†å™¨ï¼ˆæŒ‰ä¾èµ–é¡ºåºï¼‰
            services.AddSingleton<PlayerManager>();
            services.AddSingleton<RoomManager>();
            services.AddSingleton<SceneManager>();
            
            // äº‹ä»¶ç³»ç»Ÿ
            services.AddSingleton<Server.Events.EventBus>();
            services.AddSingleton<Server.Events.IEventBus>(sp => sp.GetRequiredService<Server.Events.EventBus>());
            
            // ç©å®¶æ¸…ç†äº‹ä»¶å¤„ç†å™¨
            services.AddSingleton<Server.Events.Handlers.PlayerCleanupHandler>();
            
            services.AddSingleton<BroadcastManager>();
            
            // ğŸ”¥ NPC ç®¡ç†ï¼ˆæ”¹ç”¨ PlayerNpcManagerï¼‰
            services.AddSingleton<PlayerNpcManager>();
            
            // NPC å¯è§æ€§è¿½è¸ªå™¨ï¼ˆå•ä¾‹ï¼Œéœ€è¦åœ¨ NpcSyncServiceImpl ä¹‹å‰ï¼‰
            services.AddSingleton<NpcVisibilityTracker>(sp =>
            {
                return new NpcVisibilityTracker
                {
                    SyncRange = 100f
                };
            });

            // æœåŠ¡å®ç°ï¼ˆæŒ‰ä¾èµ–é¡ºåºæ³¨å†Œï¼‰
            // æ³¨æ„ï¼šSceneService éœ€è¦åœ¨ CharacterService ä¹‹å‰æ³¨å†Œ
            services.AddSingleton<PlayerUnitySyncServiceImpl>();
            services.AddSingleton<IPlayerUnitySyncService>(sp => sp.GetRequiredService<PlayerUnitySyncServiceImpl>());

            services.AddSingleton<SceneServiceImpl>();
            services.AddSingleton<ISceneService>(sp => sp.GetRequiredService<SceneServiceImpl>());

            services.AddSingleton<CharacterServiceImpl>();
            services.AddSingleton<ICharacterService>(sp => sp.GetRequiredService<CharacterServiceImpl>());

            services.AddSingleton<PlayerServiceImpl>();
            services.AddSingleton<IPlayerService>(sp => sp.GetRequiredService<PlayerServiceImpl>());

            services.AddSingleton<HealthSyncServiceImpl>();
            services.AddSingleton<IHealthSyncService>(sp => sp.GetRequiredService<HealthSyncServiceImpl>());

            services.AddSingleton<CharacterAppearanceServiceImpl>();
            services.AddSingleton<ICharacterAppearanceService>(sp => sp.GetRequiredService<CharacterAppearanceServiceImpl>());

            services.AddSingleton<AnimatorSyncServiceImpl>();
            services.AddSingleton<IAnimatorSyncService>(sp => sp.GetRequiredService<AnimatorSyncServiceImpl>());

            services.AddSingleton<ItemSyncServiceImpl>();
            services.AddSingleton<IItemSyncService>(sp => sp.GetRequiredService<ItemSyncServiceImpl>());

            services.AddSingleton<EquipmentServerServiceImpl>();
            services.AddSingleton<IEquipmentService>(sp => sp.GetRequiredService<EquipmentServerServiceImpl>());

            services.AddSingleton<WeaponSyncServerServiceImpl>();
            services.AddSingleton<IWeaponSyncService>(sp => sp.GetRequiredService<WeaponSyncServerServiceImpl>());

            // NPC åŒæ­¥æœåŠ¡
            services.AddSingleton<NpcSyncServiceImpl>();
            services.AddSingleton<INpcSyncService>(sp => sp.GetRequiredService<NpcSyncServiceImpl>());

            // RoomService æœ€åæ³¨å†Œï¼ˆä¾èµ–è£…å¤‡å’Œæ­¦å™¨æœåŠ¡ï¼‰
            services.AddSingleton<RoomServiceImpl>();
            services.AddSingleton<IRoomService>(sp => sp.GetRequiredService<RoomServiceImpl>());


            return services;
        }

        /// <summary>
        /// æ·»åŠ æ’ä»¶ç³»ç»Ÿ
        /// </summary>
        public static IServiceCollection AddPluginSystem(this IServiceCollection services)
        {
            services.AddSingleton<PluginManager>(sp =>
            {
                var context = new PluginContext(
                    sp.GetRequiredService<PlayerManager>(),
                    sp.GetRequiredService<RoomManager>(),
                    sp.GetRequiredService<RpcServer>(),
                    sp.GetRequiredService<EventBus>(),
                    new PluginLogger("System")
                );
                return new PluginManager(context);
            });

            return services;
        }

        /// <summary>
        /// åˆå§‹åŒ–æœåŠ¡å™¨ä¸Šä¸‹æ–‡å¹¶æ³¨å†Œæ‰€æœ‰ RPC æœåŠ¡
        /// </summary>
        public static void InitializeServer(IServiceProvider serviceProvider)
        {
            // 1. åˆå§‹åŒ–å…¨å±€ä¸Šä¸‹æ–‡
            var broadcastManager = serviceProvider.GetRequiredService<BroadcastManager>();
            
            // åˆå§‹åŒ–äº‹ä»¶å¤„ç†å™¨
            var playerCleanupHandler = serviceProvider.GetRequiredService<Server.Events.Handlers.PlayerCleanupHandler>();
            
            ServerContext.Initialize(
                serviceProvider.GetRequiredService<RpcServer>(),
                serviceProvider.GetRequiredService<PlayerManager>(),
                serviceProvider.GetRequiredService<RoomManager>(),
                serviceProvider.GetRequiredService<SceneManager>(),
                broadcastManager,
                serviceProvider.GetRequiredService<EventBus>()
            );

            // 2. æ³¨å†Œæ‰€æœ‰æœåŠ¡åˆ° RPC æœåŠ¡å™¨
            var server = ServerContext.Server;
            server.RegisterServerService<IPlayerService>(
                serviceProvider.GetRequiredService<IPlayerService>());
            server.RegisterServerService<IRoomService>(
                serviceProvider.GetRequiredService<IRoomService>());
            server.RegisterServerService<ISceneService>(
                serviceProvider.GetRequiredService<ISceneService>());
            server.RegisterServerService<ICharacterService>(
                serviceProvider.GetRequiredService<ICharacterService>());
            server.RegisterServerService<IPlayerUnitySyncService>(
                serviceProvider.GetRequiredService<IPlayerUnitySyncService>());
            server.RegisterServerService<IHealthSyncService>(
                serviceProvider.GetRequiredService<IHealthSyncService>());
            server.RegisterServerService<ICharacterAppearanceService>(
                serviceProvider.GetRequiredService<ICharacterAppearanceService>());
            server.RegisterServerService<IAnimatorSyncService>(
                serviceProvider.GetRequiredService<IAnimatorSyncService>());
            server.RegisterServerService<IItemSyncService>(
                serviceProvider.GetRequiredService<IItemSyncService>());
            server.RegisterServerService<IEquipmentService>(
                serviceProvider.GetRequiredService<IEquipmentService>());
            server.RegisterServerService<IWeaponSyncService>(
                serviceProvider.GetRequiredService<IWeaponSyncService>());
            server.RegisterServerService<INpcSyncService>(
                serviceProvider.GetRequiredService<INpcSyncService>());
        }
        
        /// <summary>
        /// [å·²è¿‡æ—¶] ä½¿ç”¨ InitializeServer ä»£æ›¿
        /// </summary>
        [Obsolete("ä½¿ç”¨ InitializeServer ä»£æ›¿")]
        public static void RegisterRpcServices(IServiceProvider serviceProvider)
        {
            InitializeServer(serviceProvider);
        }
    }
}


```

`Server\DuckyNetServer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AssemblyName>DuckyNet.Server</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="LiteNetLib" Version="1.2.0" />
    <PackageReference Include="NetSerializer" Version="4.1.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <ProjectReference Include="..\Shared\DuckyNetShared.csproj" />
  </ItemGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
</Project>

```

`Server\Events\EventBus.cs`:

```cs
using System;
using System.Collections.Generic;

namespace DuckyNet.Server.Events
{
    /// <summary>
    /// äº‹ä»¶æ€»çº¿å®ç°
    /// æä¾›çº¿ç¨‹å®‰å…¨çš„äº‹ä»¶å‘å¸ƒ-è®¢é˜…æœºåˆ¶
    /// </summary>
    public class EventBus : IEventBus
    {
        // äº‹ä»¶è®¢é˜…è€…å­—å…¸ï¼šäº‹ä»¶ç±»å‹ -> è®¢é˜…è€…åˆ—è¡¨
        private readonly Dictionary<Type, List<Delegate>> _subscribers = new Dictionary<Type, List<Delegate>>();
        private readonly object _lock = new object();

        /// <summary>
        /// è®¢é˜…äº‹ä»¶
        /// </summary>
        public void Subscribe<TEvent>(Action<TEvent> handler) where TEvent : class
        {
            if (handler == null)
                throw new ArgumentNullException(nameof(handler));

            lock (_lock)
            {
                var eventType = typeof(TEvent);
                if (!_subscribers.ContainsKey(eventType))
                {
                    _subscribers[eventType] = new List<Delegate>();
                }
                _subscribers[eventType].Add(handler);
            }
        }

        /// <summary>
        /// å–æ¶ˆè®¢é˜…äº‹ä»¶
        /// </summary>
        public void Unsubscribe<TEvent>(Action<TEvent> handler) where TEvent : class
        {
            if (handler == null)
                throw new ArgumentNullException(nameof(handler));

            lock (_lock)
            {
                var eventType = typeof(TEvent);
                if (_subscribers.ContainsKey(eventType))
                {
                    _subscribers[eventType].Remove(handler);
                    
                    // å¦‚æœæ²¡æœ‰è®¢é˜…è€…äº†ï¼Œç§»é™¤äº‹ä»¶ç±»å‹
                    if (_subscribers[eventType].Count == 0)
                    {
                        _subscribers.Remove(eventType);
                    }
                }
            }
        }

        /// <summary>
        /// å‘å¸ƒäº‹ä»¶
        /// </summary>
        public void Publish<TEvent>(TEvent eventData) where TEvent : class
        {
            if (eventData == null)
                throw new ArgumentNullException(nameof(eventData));

            List<Delegate> handlers;
            lock (_lock)
            {
                var eventType = typeof(TEvent);
                if (!_subscribers.ContainsKey(eventType))
                    return;

                // å¤åˆ¶è®¢é˜…è€…åˆ—è¡¨ï¼Œé¿å…åœ¨å›è°ƒä¸­ä¿®æ”¹è®¢é˜…è€…åˆ—è¡¨å¯¼è‡´å¼‚å¸¸
                handlers = new List<Delegate>(_subscribers[eventType]);
            }

            // åœ¨é”å¤–æ‰§è¡Œå›è°ƒï¼Œé¿å…æ­»é”
            foreach (var handler in handlers)
            {
                try
                {
                    ((Action<TEvent>)handler).Invoke(eventData);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[EventBus] äº‹ä»¶å¤„ç†å™¨å¼‚å¸¸: {ex.Message}");
                    Console.WriteLine(ex.StackTrace);
                }
            }
        }
    }
}


```

`Server\Events\Handlers\PlayerCleanupHandler.cs`:

```cs
using System;
using DuckyNet.Server.Core;
using DuckyNet.Server.Managers;

namespace DuckyNet.Server.Events.Handlers
{
    /// <summary>
    /// ç©å®¶æ¸…ç†å¤„ç†å™¨ - ç©å®¶æ–­å¼€è¿æ¥æ—¶æ¸…ç†ç›¸å…³æ•°æ®
    /// </summary>
    public class PlayerCleanupHandler
    {
        private readonly NpcVisibilityTracker _npcVisibilityTracker;
        private readonly PlayerManager _playerManager;
        private readonly PlayerNpcManager _playerNpcManager;

        public PlayerCleanupHandler(
            IEventBus eventBus, 
            NpcVisibilityTracker npcVisibilityTracker,
            PlayerManager playerManager,
            PlayerNpcManager playerNpcManager)
        {
            _npcVisibilityTracker = npcVisibilityTracker;
            _playerManager = playerManager;
            _playerNpcManager = playerNpcManager;
            
            eventBus.Subscribe<PlayerDisconnectedEvent>(OnPlayerDisconnected);
        }

        private void OnPlayerDisconnected(PlayerDisconnectedEvent evt)
        {
            if (evt.Player == null) return;

            Console.WriteLine($"[PlayerCleanup] æ¸…ç†ç©å®¶æ•°æ®: {evt.Player.SteamName}");

            // è·å– ClientId
            var clientId = _playerManager.GetClientIdBySteamId(evt.Player.SteamId);

            // æ¸…ç† NPC å¯è§æ€§è¿½è¸ª
            if (clientId != null)
            {
                _npcVisibilityTracker.RemovePlayer(clientId);
                Console.WriteLine($"[PlayerCleanup] âœ… å·²æ¸…ç† NPC å¯è§æ€§è¿½è¸ª");
            }

            // ğŸ”¥ æ¸…ç†ç©å®¶çš„æ‰€æœ‰ NPC
            _playerNpcManager.ClearPlayerNpcs(evt.Player.SteamId);
            Console.WriteLine($"[PlayerCleanup] âœ… å·²æ¸…ç†ç©å®¶çš„æ‰€æœ‰ NPC");
        }
    }
}


```

`Server\Events\IEventBus.cs`:

```cs
using System;

namespace DuckyNet.Server.Events
{
    /// <summary>
    /// äº‹ä»¶æ€»çº¿æ¥å£
    /// æä¾›å‘å¸ƒ-è®¢é˜…æ¨¡å¼çš„äº‹ä»¶ç³»ç»Ÿ
    /// </summary>
    public interface IEventBus
    {
        /// <summary>
        /// è®¢é˜…äº‹ä»¶
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="handler">äº‹ä»¶å¤„ç†å™¨</param>
        void Subscribe<TEvent>(Action<TEvent> handler) where TEvent : class;

        /// <summary>
        /// å–æ¶ˆè®¢é˜…äº‹ä»¶
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="handler">äº‹ä»¶å¤„ç†å™¨</param>
        void Unsubscribe<TEvent>(Action<TEvent> handler) where TEvent : class;

        /// <summary>
        /// å‘å¸ƒäº‹ä»¶
        /// </summary>
        /// <typeparam name="TEvent">äº‹ä»¶ç±»å‹</typeparam>
        /// <param name="eventData">äº‹ä»¶æ•°æ®</param>
        void Publish<TEvent>(TEvent eventData) where TEvent : class;
    }
}


```

`Server\Events\ServerEventPublisher.cs`:

```cs
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Events
{
    /// <summary>
    /// æœåŠ¡å™¨äº‹ä»¶å‘å¸ƒåŠ©æ‰‹
    /// æä¾›é™æ€æ–¹æ³•æ–¹ä¾¿æœåŠ¡å±‚å‘å¸ƒäº‹ä»¶
    /// </summary>
    public static class ServerEventPublisher
    {
        private static IEventBus? _eventBus;

        /// <summary>
        /// åˆå§‹åŒ–äº‹ä»¶å‘å¸ƒå™¨
        /// </summary>
        public static void Initialize(IEventBus eventBus)
        {
            _eventBus = eventBus;
        }

        /// <summary>
        /// å‘å¸ƒç©å®¶ç™»å½•äº‹ä»¶
        /// </summary>
        public static void PublishPlayerLogin(string clientId, PlayerInfo player)
        {
            _eventBus?.Publish(new PlayerLoginEvent
            {
                ClientId = clientId,
                Player = player
            });
        }

        /// <summary>
        /// å‘å¸ƒç©å®¶ç™»å‡ºäº‹ä»¶
        /// </summary>
        public static void PublishPlayerLogout(string clientId, PlayerInfo player)
        {
            _eventBus?.Publish(new PlayerLogoutEvent
            {
                ClientId = clientId,
                Player = player
            });
        }

        /// <summary>
        /// å‘å¸ƒæˆ¿é—´åˆ›å»ºäº‹ä»¶
        /// </summary>
        public static void PublishRoomCreated(RoomInfo room, PlayerInfo host)
        {
            _eventBus?.Publish(new RoomCreatedEvent
            {
                Room = room,
                Host = host
            });
        }

        /// <summary>
        /// å‘å¸ƒç©å®¶åŠ å…¥æˆ¿é—´äº‹ä»¶
        /// </summary>
        public static void PublishPlayerJoinedRoom(RoomInfo room, PlayerInfo player)
        {
            _eventBus?.Publish(new PlayerJoinedRoomEvent
            {
                Room = room,
                Player = player
            });
        }

        /// <summary>
        /// å‘å¸ƒç©å®¶ç¦»å¼€æˆ¿é—´äº‹ä»¶
        /// </summary>
        public static void PublishPlayerLeftRoom(RoomInfo? room, PlayerInfo player)
        {
            _eventBus?.Publish(new PlayerLeftRoomEvent
            {
                Room = room,
                Player = player
            });
        }

        /// <summary>
        /// å‘å¸ƒæˆ¿é—´åˆ é™¤äº‹ä»¶
        /// </summary>
        public static void PublishRoomDeleted(string roomId)
        {
            _eventBus?.Publish(new RoomDeletedEvent
            {
                RoomId = roomId
            });
        }
    }
}


```

`Server\Events\ServerEvents.cs`:

```cs
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Events
{
    /// <summary>
    /// ç©å®¶ç™»å½•äº‹ä»¶
    /// </summary>
    public class PlayerLoginEvent
    {
        public string ClientId { get; set; } = string.Empty;
        public PlayerInfo Player { get; set; } = null!;
    }

    /// <summary>
    /// ç©å®¶ç™»å‡ºäº‹ä»¶
    /// </summary>
    public class PlayerLogoutEvent
    {
        public string ClientId { get; set; } = string.Empty;
        public PlayerInfo Player { get; set; } = null!;
    }

    /// <summary>
    /// ç©å®¶è¿æ¥äº‹ä»¶
    /// </summary>
    public class PlayerConnectedEvent
    {
        public string ClientId { get; set; } = string.Empty;
    }

    /// <summary>
    /// ç©å®¶æ–­å¼€äº‹ä»¶
    /// </summary>
    public class PlayerDisconnectedEvent
    {
        public string ClientId { get; set; } = string.Empty;
        public PlayerInfo? Player { get; set; }
    }

    /// <summary>
    /// æˆ¿é—´åˆ›å»ºäº‹ä»¶
    /// </summary>
    public class RoomCreatedEvent
    {
        public RoomInfo Room { get; set; } = null!;
        public PlayerInfo Host { get; set; } = null!;
    }

    /// <summary>
    /// ç©å®¶åŠ å…¥æˆ¿é—´äº‹ä»¶
    /// </summary>
    public class PlayerJoinedRoomEvent
    {
        public RoomInfo Room { get; set; } = null!;
        public PlayerInfo Player { get; set; } = null!;
    }

    /// <summary>
    /// ç©å®¶ç¦»å¼€æˆ¿é—´äº‹ä»¶
    /// </summary>
    public class PlayerLeftRoomEvent
    {
        public RoomInfo? Room { get; set; }
        public PlayerInfo Player { get; set; } = null!;
    }

    /// <summary>
    /// æˆ¿é—´åˆ é™¤äº‹ä»¶
    /// </summary>
    public class RoomDeletedEvent
    {
        public string RoomId { get; set; } = string.Empty;
    }

    /// <summary>
    /// æœåŠ¡å™¨å¯åŠ¨äº‹ä»¶
    /// </summary>
    public class ServerStartedEvent
    {
        public int Port { get; set; }
    }

    /// <summary>
    /// æœåŠ¡å™¨å…³é—­äº‹ä»¶
    /// </summary>
    public class ServerStoppingEvent
    {
    }
}


```

`Server\Managers\BroadcastManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using DuckyNet.Server.RPC;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Managers
{
    /// <summary>
    /// å¹¿æ’­ç®¡ç†å™¨
    /// ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç±»å‹çš„æ¶ˆæ¯å¹¿æ’­ï¼Œé¿å…é‡å¤ä»£ç 
    /// </summary>
    public class BroadcastManager
    {
        private readonly RpcServer _server;
        private readonly PlayerManager _playerManager;
        private readonly RoomManager _roomManager;
        private readonly SceneManager _sceneManager;

        public BroadcastManager(
            RpcServer server, 
            PlayerManager playerManager, 
            RoomManager roomManager, 
            SceneManager sceneManager)
        {
            _server = server;
            _playerManager = playerManager;
            _roomManager = roomManager;
            _sceneManager = sceneManager;
        }

        /// <summary>
        /// å¹¿æ’­åˆ°æˆ¿é—´å†…æ‰€æœ‰ç©å®¶ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰
        /// </summary>
        public void BroadcastToRoom(PlayerInfo player, Action<PlayerInfo, IClientContext> action)
        {
            var room = _roomManager.GetPlayerRoom(player);
            if (room == null)
            {
                Console.WriteLine($"[BroadcastManager] âš ï¸ ç©å®¶ {player.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­");
                return;
            }

            var roomPlayers = _roomManager.GetRoomPlayers(room.RoomId);
            BroadcastToPlayers(roomPlayers, action);
        }

        /// <summary>
        /// å¹¿æ’­åˆ°æˆ¿é—´å†…æ‰€æœ‰å…¶ä»–ç©å®¶ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰
        /// </summary>
        public void BroadcastToRoomExcludeSelf(PlayerInfo player, Action<PlayerInfo, IClientContext> action)
        {
            var room = _roomManager.GetPlayerRoom(player);
            if (room == null)
            {
                Console.WriteLine($"[BroadcastManager] âš ï¸ ç©å®¶ {player.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­");
                return;
            }

            var roomPlayers = _roomManager.GetRoomPlayers(room.RoomId)
                .Where(p => p.SteamId != player.SteamId)
                .ToArray();
            
            BroadcastToPlayers(roomPlayers, action);
        }

        /// <summary>
        /// å¹¿æ’­åˆ°åŒåœºæ™¯çš„ç©å®¶ï¼ˆåŒæˆ¿é—´+åŒåœºæ™¯ï¼Œä¸åŒ…æ‹¬è‡ªå·±ï¼‰
        /// </summary>
        public void BroadcastToScene(PlayerInfo player, Action<PlayerInfo, IClientContext> action)
        {
            var otherPlayers = _sceneManager.GetOtherPlayersInSameScene(player);
            BroadcastToPlayers(otherPlayers, action);
        }

        /// <summary>
        /// å¹¿æ’­åˆ°åŒåœºæ™¯çš„ç©å®¶ï¼ˆåŒæˆ¿é—´+åŒåœºæ™¯ï¼ŒåŒ…æ‹¬è‡ªå·±ï¼‰
        /// </summary>
        public void BroadcastToSceneIncludeSelf(PlayerInfo player, Action<PlayerInfo, IClientContext> action)
        {
            var room = _roomManager.GetPlayerRoom(player);
            if (room == null)
            {
                Console.WriteLine($"[BroadcastManager] âš ï¸ ç©å®¶ {player.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­");
                return;
            }

            var roomPlayers = _roomManager.GetRoomPlayers(room.RoomId)
                .Where(p => _sceneManager.IsSameScene(player, p))
                .ToArray();
            
            BroadcastToPlayers(roomPlayers, action);
        }

        /// <summary>
        /// å¹¿æ’­åˆ°æŒ‡å®šæˆ¿é—´çš„æ‰€æœ‰ç©å®¶
        /// </summary>
        public void BroadcastToRoomById(string roomId, Action<PlayerInfo, IClientContext> action)
        {
            var roomPlayers = _roomManager.GetRoomPlayers(roomId);
            BroadcastToPlayers(roomPlayers, action);
        }

        /// <summary>
        /// å¹¿æ’­åˆ°æŒ‡å®šæˆ¿é—´çš„æ‰€æœ‰ç©å®¶ï¼Œæ’é™¤æŸä¸ªç©å®¶
        /// </summary>
        public void BroadcastToRoomByIdExclude(string roomId, string excludeSteamId, Action<PlayerInfo, IClientContext> action)
        {
            var roomPlayers = _roomManager.GetRoomPlayers(roomId)
                .Where(p => p.SteamId != excludeSteamId)
                .ToArray();
            
            BroadcastToPlayers(roomPlayers, action);
        }

        /// <summary>
        /// è·å–æˆ¿é—´å†…æ‰€æœ‰ç©å®¶çš„ ClientId åˆ—è¡¨ï¼ˆæ’é™¤è‡ªå·±ï¼‰
        /// </summary>
        public List<string> GetRoomClientIds(PlayerInfo player, bool excludeSelf = true)
        {
            var room = _roomManager.GetPlayerRoom(player);
            if (room == null)
            {
                return new List<string>();
            }

            var roomPlayers = _roomManager.GetRoomPlayers(room.RoomId);
            return GetClientIdsFromPlayers(roomPlayers, excludeSelf ? player.SteamId : null);
        }

        /// <summary>
        /// è·å–åŒåœºæ™¯ç©å®¶çš„ ClientId åˆ—è¡¨ï¼ˆæ’é™¤è‡ªå·±ï¼‰
        /// </summary>
        public List<string> GetSceneClientIds(PlayerInfo player, bool excludeSelf = true)
        {
            var otherPlayers = _sceneManager.GetOtherPlayersInSameScene(player);
            return GetClientIdsFromPlayers(otherPlayers, excludeSelf ? player.SteamId : null);
        }

        /// <summary>
        /// ä½¿ç”¨å¼ºç±»å‹å¹¿æ’­åˆ°æˆ¿é—´ï¼ˆæ’é™¤è‡ªå·±ï¼‰
        /// ä¾‹å¦‚ï¼šBroadcastToRoomTyped<IWeaponSyncClientService>(player, (service) => service.OnWeaponFired(data))
        /// </summary>
        public void BroadcastToRoomTyped<TService>(PlayerInfo player, Action<TService> action, bool excludeSelf = true) 
            where TService : class
        {
            var clientIds = GetRoomClientIds(player, excludeSelf);
            if (clientIds.Count > 0)
            {
                var proxy = _server.BroadcastToClients<TService>(clientIds);
                action(proxy);
            }
        }

        /// <summary>
        /// ä½¿ç”¨å¼ºç±»å‹å¹¿æ’­åˆ°åœºæ™¯ï¼ˆæ’é™¤è‡ªå·±ï¼‰
        /// </summary>
        public void BroadcastToSceneTyped<TService>(PlayerInfo player, Action<TService> action, bool excludeSelf = true) 
            where TService : class
        {
            var clientIds = GetSceneClientIds(player, excludeSelf);
            if (clientIds.Count > 0)
            {
                var proxy = _server.BroadcastToClients<TService>(clientIds);
                action(proxy);
            }
        }

        /// <summary>
        /// å‘é€ç»™å•ä¸ªç©å®¶ï¼ˆé€šè¿‡ SteamIdï¼‰
        /// </summary>
        public void SendToPlayer(string steamId, Action<IClientContext> action)
        {
            var clientId = _playerManager.GetClientIdBySteamId(steamId);
            if (string.IsNullOrEmpty(clientId))
            {
                Console.WriteLine($"[BroadcastManager] âš ï¸ æœªæ‰¾åˆ°ç©å®¶çš„ ClientId: {steamId}");
                return;
            }

            var context = _server.GetClientContext(clientId);
            if (context != null)
            {
                action(context);
            }
            else
            {
                Console.WriteLine($"[BroadcastManager] âš ï¸ æœªæ‰¾åˆ°å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡: {clientId}");
            }
        }

        /// <summary>
        /// æ ¸å¿ƒæ–¹æ³•ï¼šå¹¿æ’­åˆ°ç©å®¶åˆ—è¡¨
        /// </summary>
        private void BroadcastToPlayers(PlayerInfo[] players, Action<PlayerInfo, IClientContext> action)
        {
            foreach (var targetPlayer in players)
            {
                var clientId = _playerManager.GetClientIdBySteamId(targetPlayer.SteamId);
                if (string.IsNullOrEmpty(clientId))
                {
                    Console.WriteLine($"[BroadcastManager] âš ï¸ æ— æ³•è·å– ClientId: {targetPlayer.SteamName}({targetPlayer.SteamId})");
                    continue;
                }

                var context = _server.GetClientContext(clientId);
                if (context == null)
                {
                    Console.WriteLine($"[BroadcastManager] âš ï¸ å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡ä¸º null: {targetPlayer.SteamName}({clientId})");
                    continue;
                }

                try
                {
                    action(targetPlayer, context);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[BroadcastManager] âŒ å¹¿æ’­å¤±è´¥ {targetPlayer.SteamName}: {ex.Message}");
                    Console.WriteLine($"[BroadcastManager] å †æ ˆè·Ÿè¸ª: {ex.StackTrace}");
                }
            }
        }

        /// <summary>
        /// å•ä¸ªå®¢æˆ·ç«¯è°ƒç”¨ï¼ˆå¼ºç±»å‹ï¼‰
        /// </summary>
        public void CallClientTyped<TService>(PlayerInfo player, Action<TService> action)
            where TService : class
        {
            var clientId = _playerManager.GetClientIdBySteamId(player.SteamId);
            if (string.IsNullOrEmpty(clientId))
            {
                Console.WriteLine($"[BroadcastManager] âš ï¸ æœªæ‰¾åˆ°ç©å®¶çš„ ClientId: {player.SteamName}");
                return;
            }

            var clientIds = new List<string> { clientId };
            var proxy = _server.BroadcastToClients<TService>(clientIds);
            action(proxy);
        }

        /// <summary>
        /// ä»ç©å®¶åˆ—è¡¨è·å– ClientId åˆ—è¡¨
        /// </summary>
        private List<string> GetClientIdsFromPlayers(PlayerInfo[] players, string? excludeSteamId = null)
        {
            var clientIds = new List<string>();
            
            foreach (var player in players)
            {
                if (!string.IsNullOrEmpty(excludeSteamId) && player.SteamId == excludeSteamId)
                {
                    continue;
                }

                var clientId = _playerManager.GetClientIdBySteamId(player.SteamId);
                if (!string.IsNullOrEmpty(clientId))
                {
                    clientIds.Add(clientId);
                }
            }

            return clientIds;
        }

        private float Distance(Vector3Data a, Vector3Data b)
        {
            float dx = a.X - b.X;
            float dy = a.Y - b.Y;
            float dz = a.Z - b.Z;
            return (float)Math.Sqrt(dx * dx + dy * dy + dz * dz);
        }
    }
}


```

`Server\Managers\NpcVisibilityTracker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Server.Core;

namespace DuckyNet.Server.Managers
{
    /// <summary>
    /// NPC å¯è§æ€§è¿½è¸ªå™¨ - ç®¡ç†æ¯ä¸ªç©å®¶èƒ½çœ‹åˆ°å“ªäº› NPC
    /// 
    /// åŠŸèƒ½ï¼š
    /// 1. è¿½è¸ªç©å®¶å¯è§çš„ NPC é›†åˆ
    /// 2. è®¡ç®—è¿›å…¥/ç¦»å¼€èŒƒå›´çš„ NPC
    /// 3. ä¸çƒ­åŒºç³»ç»Ÿé›†æˆ
    /// </summary>
    public class NpcVisibilityTracker
    {
        // æ¯ä¸ªç©å®¶å½“å‰å¯è§çš„ NPC é›†åˆ
        private readonly Dictionary<string, HashSet<string>> _playerVisibleNpcs = new Dictionary<string, HashSet<string>>();

        // é…ç½®
        public float SyncRange { get; set; } = 100f; // åŒæ­¥èŒƒå›´

        public NpcVisibilityTracker()
        {
            Console.WriteLine("[NpcVisibilityTracker] âœ… ä½¿ç”¨åŸºç¡€èŒƒå›´æ£€æŸ¥ï¼ˆ100mï¼‰");
        }

        /// <summary>
        /// è®¡ç®—ç©å®¶å½“å‰åº”è¯¥çœ‹åˆ°çš„ NPCï¼ˆé›†æˆçƒ­åŒºç³»ç»Ÿï¼‰
        /// </summary>
        public HashSet<string> CalculateVisibleNpcs(
            PlayerInfo player, 
            List<NpcSpawnData> allNpcs)
        {
            var visible = new HashSet<string>();

            // ç©å®¶ä½ç½®ï¼ˆä» SceneManager ç¼“å­˜ä¸­è·å–ï¼‰
            var playerPosNullable = ServerContext.Scenes.GetPlayerPosition(player.SteamId);
            if (!playerPosNullable.HasValue)
            {
                Console.WriteLine($"âš ï¸ [NpcVisibilityTracker] ç©å®¶ {player.SteamName} ä½ç½®æœªç¼“å­˜ï¼");
                return visible;
            }
            
            var playerPos = playerPosNullable.Value;
            Console.WriteLine($"[NpcVisibilityTracker] ç©å®¶ {player.SteamName} ä½ç½®: ({playerPos.X:F2}, {playerPos.Y:F2}, {playerPos.Z:F2})");

            // è·å–åœºæ™¯ä¿¡æ¯
            var sceneName = player.CurrentScenelData?.SceneName ?? "";
            var subSceneName = player.CurrentScenelData?.SubSceneName ?? "";

            foreach (var npc in allNpcs)
            {
                var npcPos = new Vector3Data(npc.PositionX, npc.PositionY, npc.PositionZ);

                // åŸºç¡€èŒƒå›´æ£€æŸ¥
                float distance = Distance(playerPos, npcPos);
                bool inPlayerRange = distance <= SyncRange;

                if (inPlayerRange)
                {
                    visible.Add(npc.NpcId);
                    Console.WriteLine($"  â†’ NPC {npc.NpcId} åœ¨èŒƒå›´å†…: {distance:F2}m < {SyncRange}m");
                }
                else
                {
                    Console.WriteLine($"  â†’ NPC {npc.NpcId} è¶…å‡ºèŒƒå›´: {distance:F2}m > {SyncRange}m");
                }
            }

            return visible;
        }

        /// <summary>
        /// æ›´æ–°ç©å®¶çš„å¯è§ NPC é›†åˆï¼Œè¿”å›å˜åŒ–
        /// </summary>
        public VisibilityChange UpdatePlayerVisibility(
            string playerId,
            PlayerInfo player,
            List<NpcSpawnData> allNpcs)
        {
            var currentVisible = CalculateVisibleNpcs(player, allNpcs);

            // è·å–ä¸Šæ¬¡å¯è§çš„ NPC
            if (!_playerVisibleNpcs.TryGetValue(playerId, out var lastVisible))
            {
                lastVisible = new HashSet<string>();
                _playerVisibleNpcs[playerId] = lastVisible;
            }

            // è®¡ç®—å˜åŒ–
            var entered = currentVisible.Except(lastVisible).ToList();
            var left = lastVisible.Except(currentVisible).ToList();

            // æ›´æ–°è¿½è¸ª
            _playerVisibleNpcs[playerId] = currentVisible;

            return new VisibilityChange
            {
                EnteredRange = entered,
                LeftRange = left,
                CurrentVisible = currentVisible.ToList()
            };
        }

        /// <summary>
        /// è¿‡æ»¤åœ¨èŒƒå›´å†…çš„ NPCï¼ˆç”¨äºæ‰¹é‡ä½ç½®æ›´æ–°ï¼‰
        /// </summary>
        public List<int> FilterVisibleNpcIndices(
            string playerId,
            string[] npcIds)
        {
            if (!_playerVisibleNpcs.TryGetValue(playerId, out var visible))
                return new List<int>();

            var indices = new List<int>();
            for (int i = 0; i < npcIds.Length; i++)
            {
                if (visible.Contains(npcIds[i]))
                {
                    indices.Add(i);
                }
            }

            return indices;
        }

        /// <summary>
        /// ç§»é™¤ç©å®¶çš„è¿½è¸ªï¼ˆæ–­å¼€è¿æ¥æ—¶ï¼‰
        /// </summary>
        public void RemovePlayer(string playerId)
        {
            _playerVisibleNpcs.Remove(playerId);
        }

        /// <summary>
        /// æ¸…ç†åœºæ™¯å†…çš„ NPC è¿½è¸ªï¼ˆåœºæ™¯å¸è½½æ—¶ï¼‰
        /// </summary>
        public void ClearSceneNpcs(string sceneName, string subSceneName, List<string> npcIds)
        {
            foreach (var visibleSet in _playerVisibleNpcs.Values)
            {
                foreach (var npcId in npcIds)
                {
                    visibleSet.Remove(npcId);
                }
            }
        }

        /// <summary>
        /// è®¡ç®—ä¸¤ç‚¹è·ç¦»
        /// </summary>
        private float Distance(Vector3Data a, Vector3Data b)
        {
            float dx = a.X - b.X;
            float dy = a.Y - b.Y;
            float dz = a.Z - b.Z;
            return (float)Math.Sqrt(dx * dx + dy * dy + dz * dz);
        }

        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public VisibilityTrackerStats GetStats()
        {
            return new VisibilityTrackerStats
            {
                TrackedPlayers = _playerVisibleNpcs.Count,
                TotalVisibleNpcs = _playerVisibleNpcs.Values.Sum(s => s.Count),
                AvgNpcsPerPlayer = _playerVisibleNpcs.Count > 0 
                    ? _playerVisibleNpcs.Values.Average(s => s.Count) 
                    : 0
            };
        }
    }

    /// <summary>
    /// å¯è§æ€§å˜åŒ–
    /// </summary>
    public class VisibilityChange
    {
        public List<string> EnteredRange { get; set; } = new List<string>();
        public List<string> LeftRange { get; set; } = new List<string>();
        public List<string> CurrentVisible { get; set; } = new List<string>();
    }

    /// <summary>
    /// å¯è§æ€§è¿½è¸ªç»Ÿè®¡
    /// </summary>
    public struct VisibilityTrackerStats
    {
        public int TrackedPlayers;
        public int TotalVisibleNpcs;
        public double AvgNpcsPerPlayer;
    }

}


```

`Server\Managers\PlayerManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;
using DuckyNet.Server.RPC;

namespace DuckyNet.Server.Managers
{
    /// <summary>
    /// å¾…ç™»å½•çš„è¿æ¥
    /// </summary>
    public class PendingConnection
    {
        public string ClientId { get; set; } = string.Empty;
        public DateTime ConnectTime { get; set; }
        public const int LOGIN_TIMEOUT_SECONDS = 3;

        public bool IsTimedOut()
        {
            return (DateTime.UtcNow - ConnectTime).TotalSeconds > LOGIN_TIMEOUT_SECONDS;
        }
    }

    /// <summary>
    /// ç©å®¶ç®¡ç†å™¨
    /// è´Ÿè´£ç®¡ç†æ‰€æœ‰åœ¨çº¿ç©å®¶å’Œç™»å½•è¶…æ—¶æ£€æŸ¥
    /// </summary>
    public class PlayerManager
    {

        // ClientId åˆ°ç©å®¶æ˜ å°„ï¼šClientId -> PlayerInfo
        private readonly Dictionary<string, PlayerInfo> _playersByClientId = new Dictionary<string, PlayerInfo>();
        // SteamId åˆ°ç©å®¶æ˜ å°„ï¼šSteamId -> PlayerInfo
        private readonly Dictionary<string, PlayerInfo> _playersBySteamId = new Dictionary<string, PlayerInfo>();
        // SteamId åˆ° ClientId çš„åå‘æ˜ å°„ï¼šSteamId -> ClientIdï¼ˆç”¨äºå¿«é€ŸæŸ¥è¯¢ï¼‰
        private readonly Dictionary<string, string> _clientIdBySteamId = new Dictionary<string, string>();

        // å¾…ç™»å½•è¿æ¥è¡¨ï¼šClientId -> PendingConnection
        private readonly Dictionary<string, PendingConnection> _pendingConnections = new Dictionary<string, PendingConnection>();

        private readonly object _lock = new object();
        private readonly RpcServer _server;
        private readonly RoomManager? _roomManager;

        public PlayerManager(RpcServer server, RoomManager? roomManager = null)
        {
            _server = server;
            _roomManager = roomManager;
        }

        /// <summary>
        /// å½“å®¢æˆ·ç«¯è¿æ¥æ—¶è°ƒç”¨
        /// </summary>
        public void OnClientConnected(string ClientId)
        {
            lock (_lock)
            {
                var pending = new PendingConnection
                {
                    ClientId = ClientId,        
                    ConnectTime = DateTime.UtcNow
                };
                _pendingConnections[ClientId] = pending;

                Console.WriteLine($"[PlayerManager] Client connected: {ClientId}, waiting for login (3s timeout)");
            }
        }

        /// <summary>
        /// å½“å®¢æˆ·ç«¯ç™»å½•æ—¶è°ƒç”¨
        /// </summary>
        public LoginResult OnClientLogin(string ClientId, PlayerInfo playerInfo)
        {
            lock (_lock)
            {
                // éªŒè¯ç©å®¶ä¿¡æ¯
                if (!playerInfo.IsValid())
                {
                    return new LoginResult
                    {
                        Success = false,
                        ErrorMessage = "Invalid player info"
                    };
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰å¾…ç™»å½•è¿æ¥ï¼ˆæŒ‰ ClientIdï¼‰
                if (!_pendingConnections.ContainsKey(ClientId))
                {
                    // å¯èƒ½å·²ç»ç™»å½•è¿‡æˆ–è¶…æ—¶
                    if (_playersBySteamId.ContainsKey(playerInfo.SteamId))
                    {
                        return new LoginResult
                        {
                            Success = false,
                            ErrorMessage = "Already logged in"
                        };
                    }
                }

                // ä»å¾…ç™»å½•åˆ—è¡¨ç§»é™¤ï¼ˆæŒ‰ ClientIdï¼‰
                _pendingConnections.Remove(ClientId);

                // å»ºç«‹ä¸‰ä¸ªæ˜ å°„ï¼ˆä¿æŒæ•°æ®ä¸€è‡´æ€§ï¼‰
                _playersByClientId[ClientId] = playerInfo;
                _playersBySteamId[playerInfo.SteamId] = playerInfo;
                _clientIdBySteamId[playerInfo.SteamId] = ClientId;

                Console.WriteLine($"[PlayerManager] Player logged in: {playerInfo.SteamName} ({playerInfo.SteamId})");

                return new LoginResult
                {
                    Success = true,
                    PlayerInfo = playerInfo,
                    SessionToken = Guid.NewGuid().ToString()
                };
            }
        }

        /// <summary>
        /// å½“å®¢æˆ·ç«¯æ–­å¼€è¿æ¥æ—¶è°ƒç”¨
        /// </summary>
        public void OnClientDisconnected(string ClientId)
        {
            lock (_lock)
            {
                // å…ˆæ ¹æ® ClientId æŸ¥æ‰¾ç©å®¶
                if (_playersByClientId.TryGetValue(ClientId, out var player))
                {
                    // ä»ä¸‰ä¸ªæ˜ å°„ä¸­ç§»é™¤ï¼ˆä¿æŒæ•°æ®ä¸€è‡´æ€§ï¼‰
                    _playersByClientId.Remove(ClientId);
                    _playersBySteamId.Remove(player.SteamId);
                    _clientIdBySteamId.Remove(player.SteamId);
                    Console.WriteLine($"[PlayerManager] Player disconnected: {player.SteamName}");

                    // ğŸ”¥ æ¸…ç†ä½ç½®ç¼“å­˜ï¼ˆæ–°å¢ï¼‰
                    _sceneManager?.RemovePlayerPosition(player.SteamId);

                    // ä»æˆ¿é—´ç§»é™¤
                    _roomManager?.LeaveRoom(player);
                }
                else
                {
                    // å¦‚æœæœªç™»å½•è¿‡ï¼Œå°è¯•ä»å¾…ç™»å½•ä¸­ç§»é™¤ï¼ˆä¾‹å¦‚ç™»å½•å‰æ–­å¼€ï¼‰
                    _pendingConnections.Remove(ClientId);
                }
            }
        }

        /// <summary>
        /// è·å– SceneManagerï¼ˆç”¨äºä½ç½®ç¼“å­˜æ¸…ç†ï¼‰
        /// </summary>
        private SceneManager? _sceneManager;
        
        public void SetSceneManager(SceneManager sceneManager)
        {
            _sceneManager = sceneManager;
        }

        /// <summary>
        /// æ£€æŸ¥ç™»å½•è¶…æ—¶ï¼ˆåº”åœ¨ä¸»å¾ªç¯ä¸­å®šæœŸè°ƒç”¨ï¼‰
        /// </summary>
        public void CheckLoginTimeouts()
        {
            List<string> timedOutClients;

            lock (_lock)
            {
                timedOutClients = _pendingConnections
                    .Where(kvp => kvp.Value.IsTimedOut())
                    .Select(kvp => kvp.Key)
                    .ToList();
            }

            // æ–­å¼€è¶…æ—¶è¿æ¥
            foreach (var clientId in timedOutClients)
            {
                Console.WriteLine($"[PlayerManager] Login timeout: {clientId}, disconnecting...");
                
                lock (_lock)
                {
                    _pendingConnections.Remove(clientId);
                }

                // æ–­å¼€è¿æ¥
                _server.DisconnectClient(clientId, "Login timeout");
            }
        }

        /// <summary>
        /// è·å–ç©å®¶ä¿¡æ¯ï¼ˆé€šè¿‡ ClientIdï¼‰
        /// </summary>
        public PlayerInfo? GetPlayer(string ClientId)
        {
            lock (_lock)
            {
                return _playersByClientId.TryGetValue(ClientId, out var player) ? player : null;
            }
        }

        /// <summary>
        /// é€šè¿‡ SteamId è·å–ç©å®¶ä¿¡æ¯
        /// </summary>
        public PlayerInfo? GetPlayerBySteamId(string steamId)
        {
            lock (_lock)
            {
                return _playersBySteamId.TryGetValue(steamId, out var player) ? player : null;
            }
        }

        /// <summary>
        /// é€šè¿‡ SteamId è·å–å¯¹åº”çš„ ClientIdï¼ˆå¦‚æœåœ¨çº¿ï¼‰
        /// </summary>
        /// <param name="steamId">ç©å®¶çš„ SteamId</param>
        /// <returns>å¯¹åº”çš„ ClientIdï¼›è‹¥æœªæ‰¾åˆ°è¿”å› null</returns>
        public string? GetClientIdBySteamId(string steamId)
        {
            lock (_lock)
            {
                // ä½¿ç”¨å­—å…¸ç´¢å¼•å®ç° O(1) æŸ¥è¯¢ï¼ˆç»Ÿä¸€çš„é«˜æ•ˆæ–¹å¼ï¼‰
                return _clientIdBySteamId.TryGetValue(steamId, out var clientId) ? clientId : null;
            }
        }

        /// <summary>
        /// é€šè¿‡ ClientId æ›´æ–°ç©å®¶çš„åœºæ™¯æ•°æ®ï¼ˆSceneName/SubSceneNameï¼‰
        /// </summary>
        /// <param name="clientId">å®¢æˆ·ç«¯è¿æ¥æ ‡è¯†</param>
        /// <param name="scenelData">åœºæ™¯æ•°æ®ï¼ˆå…è®¸ nullï¼Œå°†è¢«æ ‡å‡†åŒ–ä¸ºç©ºåœºæ™¯ï¼‰</param>
        /// <returns>æ˜¯å¦æ›´æ–°æˆåŠŸï¼ˆç©å®¶å­˜åœ¨æ—¶è¿”å› trueï¼‰</returns>
        public bool UpdatePlayerSceneDataByClientId(string clientId, ScenelData? scenelData)
        {
            lock (_lock)
            {
                if (_playersByClientId.TryGetValue(clientId, out var player))
                {
                    player.CurrentScenelData = scenelData ?? new ScenelData("", "");
                    return true;
                }
                return false;
            }
        }

        /// <summary>
        /// é€šè¿‡ SteamId æ›´æ–°ç©å®¶çš„åœºæ™¯æ•°æ®ï¼ˆSceneName/SubSceneNameï¼‰
        /// </summary>
        /// <param name="steamId">ç©å®¶ SteamId</param>
        /// <param name="scenelData">åœºæ™¯æ•°æ®ï¼ˆå…è®¸ nullï¼Œå°†è¢«æ ‡å‡†åŒ–ä¸ºç©ºåœºæ™¯ï¼‰</param>
        /// <returns>æ˜¯å¦æ›´æ–°æˆåŠŸï¼ˆç©å®¶å­˜åœ¨æ—¶è¿”å› trueï¼‰</returns>
        public bool UpdatePlayerSceneDataBySteamId(string steamId, ScenelData? scenelData)
        {
            lock (_lock)
            {
                if (_playersBySteamId.TryGetValue(steamId, out var player))
                {
                    player.CurrentScenelData = scenelData ?? new ScenelData("", "");
                    return true;
                }
                return false;
            }
        }

        /// <summary>
        /// æ£€æŸ¥ç©å®¶æ˜¯å¦å·²ç™»å½•
        /// </summary>
        public bool IsLoggedIn(string SteamId)
        {
            lock (_lock)
            {
                return _playersBySteamId.ContainsKey(SteamId);
            }
        }

        /// <summary>
        /// è·å–å…¨å±€åœ¨çº¿ç©å®¶åˆ—è¡¨
        /// </summary>
        public PlayerInfo[] GetAllOnlinePlayers()
        {
            lock (_lock)
            {
                    return _playersBySteamId.Values.ToArray();
            }
        }

        /// <summary>
        /// è·å–å½“å‰æˆ¿é—´ç©å®¶åˆ—è¡¨
        /// </summary>
        public PlayerInfo[] GetCurrentRoomPlayers(string clientId)
        {
            if (_roomManager == null)
            {
                return Array.Empty<PlayerInfo>();
            }

            lock (_lock)
            {
                var player = GetPlayer(clientId);
                if (player == null)
                {
                    return Array.Empty<PlayerInfo>();
                }

                var room = _roomManager.GetPlayerRoom(player);
                return room != null ? _roomManager.GetRoomPlayers(room.RoomId) : Array.Empty<PlayerInfo>();
            }
        }

        /// <summary>
        /// è·å–æŒ‡å®šæˆ¿é—´çš„ç©å®¶åˆ—è¡¨
        /// </summary>
        public PlayerInfo[] GetRoomPlayers(string roomId)
        {
            if (_roomManager == null)
            {
                return Array.Empty<PlayerInfo>();
            }

            lock (_lock)
            {
                var players = _roomManager.GetRoomPlayers(roomId);
                return players;
            }
        }


        /// <summary>
        /// è·å–åŒåœºæ™¯çš„å…¶ä»–ç©å®¶ï¼ˆç”¨äºçƒ­åŒºè®¡ç®—ï¼‰
        /// </summary>
        public List<PlayerInfo> GetScenePlayers(PlayerInfo player, bool excludeSelf = true)
        {
            lock (_lock)
            {
                var scenePlayers = _playersBySteamId.Values
                    .Where(p => p.CurrentScenelData != null &&
                               p.CurrentScenelData.SceneName == player.CurrentScenelData?.SceneName &&
                               p.CurrentScenelData.SubSceneName == player.CurrentScenelData?.SubSceneName)
                    .ToList();

                if (excludeSelf)
                {
                    scenePlayers = scenePlayers.Where(p => p.SteamId != player.SteamId).ToList();
                }

                return scenePlayers;
            }
        }

        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public (int TotalPlayers, int PendingLogins) GetStatistics()
        {
            lock (_lock)
            {
                return (
                    TotalPlayers: _playersBySteamId.Count,
                    PendingLogins: _pendingConnections.Count
                );
            }
        }
    }
}


```

`Server\Managers\PlayerNpcManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Managers
{
    /// <summary>
    /// ç©å®¶ NPC ç®¡ç†å™¨ - ç»´æŠ¤æ¯ä¸ªç©å®¶æ‹¥æœ‰çš„ NPC åˆ—è¡¨
    /// </summary>
    public class PlayerNpcManager
    {
        // ç©å®¶ ID (SteamId) -> NPC åˆ—è¡¨
        private readonly Dictionary<string, List<NpcSpawnData>> _playerNpcs = new Dictionary<string, List<NpcSpawnData>>();
        
        // NPC ID -> æ‹¥æœ‰è€…ç©å®¶ ID (å¿«é€ŸæŸ¥æ‰¾)
        private readonly Dictionary<string, string> _npcOwners = new Dictionary<string, string>();
        
        private readonly object _lock = new object();

        /// <summary>
        /// æ·»åŠ ç©å®¶çš„ NPC
        /// </summary>
        public void AddNpc(string playerId, NpcSpawnData npcData)
        {
            lock (_lock)
            {
                if (!_playerNpcs.TryGetValue(playerId, out var npcs))
                {
                    npcs = new List<NpcSpawnData>();
                    _playerNpcs[playerId] = npcs;
                }

                // å»é‡
                if (npcs.Any(n => n.NpcId == npcData.NpcId))
                {
                    Console.WriteLine($"[PlayerNpcManager] NPC å·²å­˜åœ¨: {npcData.NpcId}");
                    return;
                }

                npcs.Add(npcData);
                _npcOwners[npcData.NpcId] = playerId;
                Console.WriteLine($"[PlayerNpcManager] ç©å®¶ {playerId} åˆ›å»º NPC: {npcData.NpcId}");
            }
        }

        /// <summary>
        /// ç§»é™¤ç©å®¶çš„ NPC
        /// </summary>
        public void RemoveNpc(string npcId)
        {
            lock (_lock)
            {
                if (_npcOwners.TryGetValue(npcId, out var playerId))
                {
                    if (_playerNpcs.TryGetValue(playerId, out var npcs))
                    {
                        npcs.RemoveAll(n => n.NpcId == npcId);
                    }
                    _npcOwners.Remove(npcId);
                    Console.WriteLine($"[PlayerNpcManager] ç§»é™¤ NPC: {npcId}");
                }
            }
        }

        /// <summary>
        /// æ›´æ–° NPC ä½ç½®
        /// </summary>
        public void UpdateNpcPosition(string npcId, float x, float y, float z, float rotY)
        {
            lock (_lock)
            {
                if (_npcOwners.TryGetValue(npcId, out var playerId))
                {
                    if (_playerNpcs.TryGetValue(playerId, out var npcs))
                    {
                        var npc = npcs.FirstOrDefault(n => n.NpcId == npcId);
                        if (npc != null)
                        {
                            npc.PositionX = x;
                            npc.PositionY = y;
                            npc.PositionZ = z;
                            npc.RotationY = rotY;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// è·å–ç©å®¶çš„æ‰€æœ‰ NPC
        /// </summary>
        public List<NpcSpawnData> GetPlayerNpcs(string playerId)
        {
            lock (_lock)
            {
                if (_playerNpcs.TryGetValue(playerId, out var npcs))
                {
                    return new List<NpcSpawnData>(npcs);
                }
                return new List<NpcSpawnData>();
            }
        }

        /// <summary>
        /// è·å–åœºæ™¯ä¸­æ‰€æœ‰ç©å®¶çš„ NPCï¼ˆç”¨äºå¯è§æ€§è®¡ç®—ï¼‰
        /// </summary>
        public List<NpcSpawnData> GetSceneNpcs(string sceneName, string subSceneName)
        {
            lock (_lock)
            {
                var result = new List<NpcSpawnData>();
                foreach (var npcs in _playerNpcs.Values)
                {
                    result.AddRange(npcs.Where(n => 
                        n.SceneName == sceneName && n.SubSceneName == subSceneName));
                }
                return result;
            }
        }

        /// <summary>
        /// è·å–æ‰€æœ‰ç©å®¶ IDï¼ˆåŒåœºæ™¯ï¼‰
        /// </summary>
        public List<string> GetPlayersInScene(string sceneName, string subSceneName)
        {
            lock (_lock)
            {
                var result = new List<string>();
                foreach (var kvp in _playerNpcs)
                {
                    if (kvp.Value.Any(n => n.SceneName == sceneName && n.SubSceneName == subSceneName))
                    {
                        result.Add(kvp.Key);
                    }
                }
                return result;
            }
        }

        /// <summary>
        /// æ¸…ç†ç©å®¶çš„æ‰€æœ‰ NPCï¼ˆæ–­å¼€è¿æ¥æ—¶ï¼‰
        /// </summary>
        public void ClearPlayerNpcs(string playerId)
        {
            lock (_lock)
            {
                if (_playerNpcs.TryGetValue(playerId, out var npcs))
                {
                    // æ¸…ç†åå‘ç´¢å¼•
                    foreach (var npc in npcs)
                    {
                        _npcOwners.Remove(npc.NpcId);
                    }
                    _playerNpcs.Remove(playerId);
                    Console.WriteLine($"[PlayerNpcManager] æ¸…ç†ç©å®¶ {playerId} çš„ {npcs.Count} ä¸ª NPC");
                }
            }
        }

        /// <summary>
        /// è·å– NPC çš„æ‹¥æœ‰è€…
        /// </summary>
        public string? GetNpcOwner(string npcId)
        {
            lock (_lock)
            {
                return _npcOwners.TryGetValue(npcId, out var owner) ? owner : null;
            }
        }

        /// <summary>
        /// æ ¹æ® ID è·å– NPCï¼ˆç”¨äºå•ä¸ª NPC è¯·æ±‚ï¼‰
        /// </summary>
        public NpcSpawnData? GetNpcById(string npcId)
        {
            lock (_lock)
            {
                if (_npcOwners.TryGetValue(npcId, out var playerId))
                {
                    if (_playerNpcs.TryGetValue(playerId, out var npcs))
                    {
                        return npcs.FirstOrDefault(n => n.NpcId == npcId);
                    }
                }
                return null;
            }
        }

        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public (int TotalPlayers, int TotalNpcs) GetStats()
        {
            lock (_lock)
            {
                return (_playerNpcs.Count, _npcOwners.Count);
            }
        }
    }
}


```

`Server\Managers\README_STEAMID_INDEXING.md`:

```md
# SteamId ç´¢å¼•æœ€ä½³å®è·µ

## ç»Ÿä¸€çš„ç´¢å¼•æ–¹å¼

åœ¨æ•´ä¸ª Server é¡¹ç›®ä¸­ï¼Œé€šè¿‡ SteamId ç´¢å¼•æ•°æ®ç»Ÿä¸€ä½¿ç”¨ **å­—å…¸ç›´æ¥ç´¢å¼•** çš„æ–¹å¼ï¼Œä¿è¯ O(1) æ—¶é—´å¤æ‚åº¦ã€‚

## âœ… æ­£ç¡®çš„æ¨¡å¼

### 1. å­—å…¸æŸ¥è¯¢ - TryGetValueï¼ˆæ¨èï¼‰
```csharp
if (_playersBySteamId.TryGetValue(steamId, out var player))
{
    // ä½¿ç”¨ player
    return player;
}
return null;
```

### 2. å­—å…¸æŸ¥è¯¢ - ç´¢å¼•å™¨
```csharp
_playersBySteamId[steamId] = playerInfo;  // æ·»åŠ æˆ–æ›´æ–°
_clientIdBySteamId[steamId] = clientId;
```

### 3. å­—å…¸æŸ¥è¯¢ - ContainsKey
```csharp
if (_playersBySteamId.ContainsKey(steamId))
{
    // ç©å®¶å­˜åœ¨
}
```

### 4. å­—å…¸æ“ä½œ - Remove
```csharp
_playersBySteamId.Remove(steamId);
_clientIdBySteamId.Remove(steamId);
```

## âŒ é”™è¯¯çš„æ¨¡å¼ï¼ˆå·²ä¿®å¤ï¼‰

### éå†æŸ¥è¯¢ï¼ˆä½æ•ˆ O(n)ï¼‰
```csharp
// âŒ ä¸è¦è¿™æ ·åšï¼
foreach (var kvp in _playersByClientId)
{
    if (kvp.Value.SteamId == steamId)
    {
        return kvp.Key;
    }
}
```

**é—®é¢˜ï¼š** éœ€è¦éå†æ•´ä¸ªå­—å…¸ï¼Œæ—¶é—´å¤æ‚åº¦ O(n)ï¼Œåœ¨ç©å®¶æ•°é‡å¤šæ—¶æ€§èƒ½ä¸‹é™ã€‚

## å®ç°ç»†èŠ‚

### PlayerManager ä¸­çš„ä¸‰ä¸ªæ˜ å°„

ä¸ºäº†æ”¯æŒé«˜æ•ˆçš„åŒå‘æŸ¥è¯¢ï¼ŒPlayerManager ç»´æŠ¤äº†ä¸‰ä¸ªå­—å…¸ï¼š

```csharp
// ClientId -> PlayerInfo
private readonly Dictionary<string, PlayerInfo> _playersByClientId;

// SteamId -> PlayerInfo
private readonly Dictionary<string, PlayerInfo> _playersBySteamId;

// SteamId -> ClientIdï¼ˆåå‘æ˜ å°„ï¼‰
private readonly Dictionary<string, string> _clientIdBySteamId;
```

### æ•°æ®ä¸€è‡´æ€§ä¿è¯

**å…³é”®åŸåˆ™ï¼š** åœ¨æ‰€æœ‰ä¿®æ”¹ç©å®¶æ˜ å°„çš„åœ°æ–¹ï¼Œå¿…é¡»åŒæ—¶ç»´æŠ¤è¿™ä¸‰ä¸ªå­—å…¸ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§ã€‚

#### æ·»åŠ ç©å®¶ï¼ˆOnClientLoginï¼‰
```csharp
_playersByClientId[ClientId] = playerInfo;
_playersBySteamId[playerInfo.SteamId] = playerInfo;
_clientIdBySteamId[playerInfo.SteamId] = ClientId;
```

#### ç§»é™¤ç©å®¶ï¼ˆOnClientDisconnectedï¼‰
```csharp
_playersByClientId.Remove(ClientId);
_playersBySteamId.Remove(player.SteamId);
_clientIdBySteamId.Remove(player.SteamId);
```

## åº”ç”¨ç¤ºä¾‹

### PlayerManager.cs
- âœ… `GetPlayerBySteamId()` - ä½¿ç”¨ `TryGetValue`
- âœ… `GetClientIdBySteamId()` - ä½¿ç”¨ `TryGetValue`
- âœ… `UpdatePlayerSceneDataBySteamId()` - ä½¿ç”¨ `TryGetValue`
- âœ… `IsLoggedIn()` - ä½¿ç”¨ `ContainsKey`

### RoomManager.cs
- âœ… æ‰€æœ‰æ“ä½œéƒ½ä½¿ç”¨ `_playerRoom.TryGetValue(steamId, ...)` æˆ– `ContainsKey`

### å„ç§ Service å®ç°
- âœ… `PlayerUnitySyncServiceImpl` - ä½¿ç”¨ `TryGetValue` å’Œç´¢å¼•å™¨
- âœ… `HealthSyncServiceImpl` - ä½¿ç”¨ `TryGetValue` å’Œç´¢å¼•å™¨
- âœ… `CharacterAppearanceServiceImpl` - ä½¿ç”¨ `TryGetValue` å’Œç´¢å¼•å™¨
- âœ… `WeaponSyncServerServiceImpl` - ä½¿ç”¨ç´¢å¼•å™¨

## æ€§èƒ½å¯¹æ¯”

| æ“ä½œæ–¹å¼ | æ—¶é—´å¤æ‚åº¦ | 100 ç©å®¶è€—æ—¶ | 1000 ç©å®¶è€—æ—¶ |
|---------|-----------|-------------|--------------|
| å­—å…¸ç´¢å¼• (TryGetValue) | O(1) | ~1Î¼s | ~1Î¼s |
| éå†æŸ¥è¯¢ (foreach) | O(n) | ~10Î¼s | ~100Î¼s |

## æ€»ç»“

- ğŸ¯ **ç»Ÿä¸€ä½¿ç”¨å­—å…¸ç´¢å¼•**ï¼Œé¿å…éå†
- ğŸ”’ **ç»´æŠ¤æ•°æ®ä¸€è‡´æ€§**ï¼ŒåŒæ—¶æ›´æ–°æ‰€æœ‰ç›¸å…³å­—å…¸
- âš¡ **ä¿è¯ O(1) æ€§èƒ½**ï¼Œæ”¯æŒé«˜å¹¶å‘åœºæ™¯
- ğŸ“ **ä»£ç å¯è¯»æ€§å¥½**ï¼Œæ„å›¾æ¸…æ™°æ˜ç¡®


```

`Server\Managers\RoomManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Managers
{
    /// <summary>
    /// æˆ¿é—´ç®¡ç†å™¨
    /// è´Ÿè´£ç®¡ç†æ‰€æœ‰æˆ¿é—´å’Œæˆ¿é—´å†…çš„ç©å®¶
    /// </summary>
    public class RoomManager
    {
        // å…¨å±€æˆ¿é—´è¡¨ï¼šRoomId -> RoomInfo
        private readonly Dictionary<string, RoomInfo> _rooms = new Dictionary<string, RoomInfo>();

        // æˆ¿é—´å†…çš„ç©å®¶ï¼šRoomId -> HashSet<PlayerId>
        private readonly Dictionary<string, HashSet<PlayerInfo>> _roomPlayers = new Dictionary<string, HashSet<PlayerInfo>>();

        // ç©å®¶æ‰€åœ¨æˆ¿é—´ï¼šSteamId -> RoomId
        private readonly Dictionary<string, RoomInfo> _playerRoom = new Dictionary<string, RoomInfo>();

        private readonly object _lock = new object();
        private int _roomIdCounter = 1;

        /// <summary>
        /// åˆ›å»ºæˆ¿é—´
        /// </summary>
        public RoomInfo CreateRoom(PlayerInfo host, CreateRoomRequest request)
        {
            lock (_lock)
            {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦å·²åœ¨å…¶ä»–æˆ¿é—´
                if (_playerRoom.ContainsKey(host.SteamId))
                {
                    throw new InvalidOperationException("ç©å®¶å·²åœ¨å…¶ä»–æˆ¿é—´");
                }

                // åˆ›å»ºæˆ¿é—´
                var roomId = GenerateRoomId();
                var room = new RoomInfo
                {
                    RoomId = roomId,
                    RoomName = request.RoomName,
                    Description = request.Description,
                    Password = request.Password,
                    HostSteamId = host.SteamId,
                    CurrentPlayers = 1,
                    MaxPlayers = request.MaxPlayers,
                    CreateTime = DateTime.UtcNow
                };

                _rooms[roomId] = room;
                _roomPlayers[roomId] = new HashSet<PlayerInfo> { host };
                _playerRoom[host.SteamId] = room;

                Console.WriteLine($"[RoomManager] æˆ¿é—´åˆ›å»º: {roomId} æˆ¿ä¸»: {host.SteamName}");
                return room;
            }
        }

        /// <summary>
        /// åŠ å…¥æˆ¿é—´
        /// </summary>
        public RoomOperationResult JoinRoom(PlayerInfo player, JoinRoomRequest request)
        {
            lock (_lock)
            {
                // æ£€æŸ¥ç©å®¶æ˜¯å¦å·²åœ¨å…¶ä»–æˆ¿é—´
                if (_playerRoom.ContainsKey(player.SteamId))
                {
                    return new RoomOperationResult
                    {
                        Success = false,
                        ErrorMessage = "ç©å®¶å·²åœ¨å…¶ä»–æˆ¿é—´"
                    };
                }

                // æ£€æŸ¥æˆ¿é—´æ˜¯å¦å­˜åœ¨
                if (!_rooms.TryGetValue(request.RoomId, out var room))
                {
                    return new RoomOperationResult
                    {
                        Success = false,
                        ErrorMessage = "æˆ¿é—´ä¸å­˜åœ¨"
                    };
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯åŸæˆ¿ä¸»å›å½’ï¼ˆæˆ¿ä¸»æœ‰ç‰¹æƒï¼Œå³ä½¿æˆ¿é—´æ»¡äº†ä¹Ÿèƒ½è¿›ï¼‰
                bool isReturningHost = room.HostSteamId == player.SteamId;

                // æ£€æŸ¥æˆ¿é—´æ˜¯å¦å·²æ»¡ï¼ˆæˆ¿ä¸»ä¾‹å¤–ï¼‰
                if (room.IsFull && !isReturningHost)
                {
                    return new RoomOperationResult
                    {
                        Success = false,
                        ErrorMessage = "æˆ¿é—´å·²æ»¡"
                    };
                }

                // æ£€æŸ¥æˆ¿é—´çŠ¶æ€ï¼ˆæˆ¿ä¸»ä¾‹å¤–ï¼‰
                if (!room.CanJoin && !isReturningHost)
                {
                    return new RoomOperationResult
                    {
                        Success = false,
                        ErrorMessage = "æˆ¿é—´ä¸æ¥å—æ–°ç©å®¶"
                    };
                }

                // éªŒè¯å¯†ç ï¼ˆæˆ¿ä¸»å›å½’å…å¯†ç ï¼‰
                if (room.RequirePassword && room.Password != request.Password && !isReturningHost)
                {
                    return new RoomOperationResult
                    {
                        Success = false,
                        ErrorMessage = "å¯†ç é”™è¯¯"
                    };
                }

                // åŠ å…¥æˆ¿é—´
                _roomPlayers[request.RoomId].Add(player);
                _playerRoom[player.SteamId] = room;
                room.CurrentPlayers++;

                if (isReturningHost)
                {
                    Console.WriteLine($"[RoomManager] æˆ¿ä¸» {player.SteamName} è¿”å›æˆ¿é—´ {request.RoomId}");
                }
                else
                {
                    Console.WriteLine($"[RoomManager] ç©å®¶ {player.SteamName} åŠ å…¥æˆ¿é—´ {request.RoomId}");
                }

                return new RoomOperationResult
                {
                    Success = true,
                    Room = room
                };
            }
        }

        /// <summary>
        /// ç¦»å¼€æˆ¿é—´
        /// </summary>
        public RoomInfo? LeaveRoom(PlayerInfo player)
        {
            lock (_lock)
            {
                if (!_playerRoom.TryGetValue(player.SteamId, out var room))
                {
                    return null; // ç©å®¶ä¸åœ¨ä»»ä½•æˆ¿é—´
                }

                _roomPlayers[room.RoomId].Remove(player);
                _playerRoom.Remove(player.SteamId);
                room.CurrentPlayers--;

                Console.WriteLine($"[RoomManager] ç©å®¶ {player.SteamName} ç¦»å¼€æˆ¿é—´ {room.RoomId}");

                // å¦‚æœæˆ¿é—´ä¸ºç©ºï¼Œåˆ é™¤æˆ¿é—´
                if (room.CurrentPlayers == 0)
                {
                    _rooms.Remove(room.RoomId);
                    _roomPlayers.Remove(room.RoomId);
                    Console.WriteLine($"[RoomManager] æˆ¿é—´ {room.RoomId} åˆ é™¤ (ç©º)");
                    return null;
                }

                // æˆ¿ä¸»IDæ°¸è¿œç»‘å®šæˆ¿é—´ï¼Œä¸è½¬ç§»æˆ¿ä¸»æƒé™
                // æˆ¿ä¸»å¯ä»¥ç¦»å¼€å¹¶é‡æ–°åŠ å…¥ï¼Œä¿æŒæˆ¿ä¸»èº«ä»½
                if (room.HostSteamId == player.SteamId)
                {
                    Console.WriteLine($"[RoomManager] æˆ¿ä¸» {player.SteamName} ç¦»å¼€æˆ¿é—´ {room.RoomId}, ä½†æˆ¿ä¸»IDä¿æŒä¸å˜ (ç­‰å¾…æˆ¿ä¸»è¿”å›)");
                }

                return room;
            }
        }

        /// <summary>
        /// è·å–æ‰€æœ‰æˆ¿é—´åˆ—è¡¨
        /// </summary>
        public RoomInfo[] GetAllRooms()
        {
            lock (_lock)
            {
                return _rooms.Values.ToArray();
            }
        }

        /// <summary>
        /// è·å–æˆ¿é—´ä¿¡æ¯
        /// </summary>
        public RoomInfo? GetRoom(string roomId)
        {
            lock (_lock)
            {
                return _rooms.TryGetValue(roomId, out var room) ? room : null;
            }
        }

        /// <summary>
        /// è·å–ç©å®¶æ‰€åœ¨æˆ¿é—´
        /// </summary>
        public RoomInfo? GetPlayerRoom(PlayerInfo player)
        {
            lock (_lock)
            {
                if (_playerRoom.TryGetValue(player.SteamId, out var room))
                {
                    return room;
                }
                return null;
            }
        }

        /// <summary>
        /// è·å–æˆ¿é—´å†…çš„ç©å®¶IDåˆ—è¡¨
        /// </summary>
        public PlayerInfo[] GetRoomPlayers(string roomId)
        {
            lock (_lock)
            {
                return _roomPlayers.TryGetValue(roomId, out var players) ? players.ToArray() : Array.Empty<PlayerInfo>();
            }
        }

        /// <summary>
        /// è¸¢å‡ºç©å®¶ï¼ˆä»…æˆ¿ä¸»å¯ç”¨ï¼‰
        /// </summary>
        public bool KickPlayer(PlayerInfo host, PlayerInfo target)
        {
            lock (_lock)
            {
                // æ£€æŸ¥æˆ¿ä¸»æ˜¯å¦åœ¨æˆ¿é—´
                if (!_playerRoom.TryGetValue(host.SteamId, out var room))
                {
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯æˆ¿ä¸»
                if (room.HostSteamId != host.SteamId)
                {
                    return false;
                }

                // æ£€æŸ¥ç›®æ ‡ç©å®¶æ˜¯å¦åœ¨åŒä¸€æˆ¿é—´
                if (!_playerRoom.TryGetValue(target.SteamId, out var targetRoom) || targetRoom.RoomId != room.RoomId)
                {
                    return false;
                }

                // ä¸èƒ½è¸¢è‡ªå·±
                if (host.SteamId == target.SteamId)
                {
                    return false;
                }

                // è¸¢å‡ºç©å®¶
                LeaveRoom(target);
                Console.WriteLine($"[RoomManager] ç©å®¶ {target.SteamName} è¢«æˆ¿ä¸» {host.SteamName} è¸¢å‡ºæˆ¿é—´ {room.RoomId}");
                return true;
            }
        }


        /// <summary>
        /// ç”Ÿæˆæˆ¿é—´ID
        /// </summary>
        private string GenerateRoomId()
        {
            return $"room-{_roomIdCounter++:D6}";
        }

    }
}


```

`Server\Managers\SceneManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Managers
{
    /// <summary>
    /// åœºæ™¯ç®¡ç†å™¨
    /// è´Ÿè´£ç®¡ç†ç©å®¶çš„åœºæ™¯çŠ¶æ€å’Œåœºæ™¯åŒ¹é…é€»è¾‘
    /// æ–°å¢ï¼šç¼“å­˜ç©å®¶ä½ç½®ç”¨äºçƒ­åŒºå’ŒèŒƒå›´è®¡ç®—
    /// </summary>
    public class SceneManager
    {
        private readonly PlayerManager _playerManager;
        private readonly RoomManager _roomManager;
        private readonly object _lock = new object();

        // ç©å®¶ä½ç½®ç¼“å­˜ (SteamId -> Vector3Data)
        private readonly Dictionary<string, Vector3Data> _playerPositions = new Dictionary<string, Vector3Data>();

        public SceneManager(PlayerManager playerManager, RoomManager roomManager)
        {
            _playerManager = playerManager;
            _roomManager = roomManager;
        }

        /// <summary>
        /// ç©å®¶è¿›å…¥åœºæ™¯
        /// </summary>
        public bool EnterScene(string clientId, ScenelData scenelData)
        {
            lock (_lock)
            {
                var nonNullData = scenelData ?? new ScenelData("", "");
                var player = _playerManager.GetPlayer(clientId);
                
                if (player == null)
                {
                    Console.WriteLine($"[SceneManager] âš ï¸ æœªæ‰¾åˆ°ç©å®¶ä¿¡æ¯, ClientId={clientId}");
                    return false;
                }

                Console.WriteLine($"[SceneManager] {player.SteamName} è¿›å…¥åœºæ™¯: {nonNullData.SceneName}/{nonNullData.SubSceneName}");
                
                // æ›´æ–°ç©å®¶çš„åœºæ™¯æ•°æ®
                _playerManager.UpdatePlayerSceneDataByClientId(clientId, nonNullData);
                
                return true;
            }
        }

        /// <summary>
        /// ç©å®¶ç¦»å¼€åœºæ™¯
        /// </summary>
        public bool LeaveScene(string clientId, ScenelData scenelData)
        {
            lock (_lock)
            {
                var player = _playerManager.GetPlayer(clientId);
                
                if (player == null)
                {
                    Console.WriteLine($"[SceneManager] âš ï¸ æœªæ‰¾åˆ°ç©å®¶ä¿¡æ¯, ClientId={clientId}");
                    return false;
                }

                Console.WriteLine($"[SceneManager] {player.SteamName} ç¦»å¼€åœºæ™¯: {scenelData.SceneName}/{scenelData.SubSceneName}");
                
                // æ¸…é™¤ç©å®¶çš„åœºæ™¯æ•°æ®
                _playerManager.UpdatePlayerSceneDataByClientId(clientId, new ScenelData("", ""));
                
                return true;
            }
        }

        /// <summary>
        /// è·å–åœºæ™¯å†…çš„ç©å®¶åˆ—è¡¨
        /// </summary>
        public PlayerInfo[] GetScenePlayers(string clientId, ScenelData scenelData)
        {
            lock (_lock)
            {
                var playerInfo = _playerManager.GetPlayer(clientId);
                if (playerInfo == null)
                {
                    return Array.Empty<PlayerInfo>();
                }

                var room = _roomManager.GetPlayerRoom(playerInfo);
                if (room == null)
                {
                    return Array.Empty<PlayerInfo>();
                }

                var roomPlayers = _roomManager.GetRoomPlayers(room.RoomId);
                
                // åŒ¹é…ç›¸åŒåœºæ™¯å’Œå­åœºæ™¯çš„ç©å®¶
                var matchedPlayers = roomPlayers
                    .Where(p => p.CurrentScenelData.SceneName == scenelData.SceneName && 
                               p.CurrentScenelData.SubSceneName == scenelData.SubSceneName)
                    .ToArray();
                
                return matchedPlayers;
            }
        }

        /// <summary>
        /// è·å–åŒæˆ¿é—´åŒåœºæ™¯çš„å…¶ä»–ç©å®¶ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰
        /// </summary>
        public PlayerInfo[] GetOtherPlayersInSameScene(PlayerInfo player)
        {
            lock (_lock)
            {
                var room = _roomManager.GetPlayerRoom(player);
                if (room == null)
                {
                    return Array.Empty<PlayerInfo>();
                }

                var roomPlayers = _roomManager.GetRoomPlayers(room.RoomId);
                
                return roomPlayers
                    .Where(p => p.SteamId != player.SteamId && 
                               IsSameScene(player, p))
                    .ToArray();
            }
        }

        /// <summary>
        /// æ£€æŸ¥ä¸¤ä¸ªç©å®¶æ˜¯å¦åœ¨åŒä¸€åœºæ™¯ï¼ˆåŒ…æ‹¬å­åœºæ™¯ï¼‰
        /// </summary>
        public bool IsSameScene(PlayerInfo player1, PlayerInfo player2)
        {
            if (player1.CurrentScenelData == null || player2.CurrentScenelData == null)
                return false;

            return player1.CurrentScenelData.SceneName == player2.CurrentScenelData.SceneName &&
                   player1.CurrentScenelData.SubSceneName == player2.CurrentScenelData.SubSceneName;
        }

        /// <summary>
        /// æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨æŒ‡å®šåœºæ™¯ä¸­
        /// </summary>
        public bool IsPlayerInScene(PlayerInfo player, string sceneName, string subSceneName = "")
        {
            if (player.CurrentScenelData == null)
                return false;

            bool sceneMatch = player.CurrentScenelData.SceneName == sceneName;
            
            if (string.IsNullOrEmpty(subSceneName))
            {
                return sceneMatch;
            }
            
            return sceneMatch && player.CurrentScenelData.SubSceneName == subSceneName;
        }

        /// <summary>
        /// æ›´æ–°ç©å®¶ä½ç½®ï¼ˆä»ä½ç½®åŒæ­¥ä¸­è°ƒç”¨ï¼‰
        /// </summary>
        public void UpdatePlayerPosition(string steamId, float x, float y, float z)
        {
            lock (_lock)
            {
                _playerPositions[steamId] = new Vector3Data(x, y, z);
            }
        }

        /// <summary>
        /// è·å–ç©å®¶ä½ç½®
        /// </summary>
        public Vector3Data? GetPlayerPosition(string steamId)
        {
            lock (_lock)
            {
                return _playerPositions.TryGetValue(steamId, out var pos) ? pos : null;
            }
        }

        /// <summary>
        /// è·å–åœºæ™¯å†…æ‰€æœ‰ç©å®¶çš„ä½ç½®
        /// </summary>
        public Dictionary<string, Vector3Data> GetScenePlayerPositions(string sceneName, string subSceneName)
        {
            lock (_lock)
            {
                var result = new Dictionary<string, Vector3Data>();
                
                var scenePlayers = _playerManager.GetAllOnlinePlayers()
                    .Where(p => IsPlayerInScene(p, sceneName, subSceneName));

                foreach (var player in scenePlayers)
                {
                    if (_playerPositions.TryGetValue(player.SteamId, out var pos))
                    {
                        result[player.SteamId] = pos;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// ç§»é™¤ç©å®¶ä½ç½®ï¼ˆæ–­å¼€è¿æ¥æ—¶ï¼‰
        /// </summary>
        public void RemovePlayerPosition(string steamId)
        {
            lock (_lock)
            {
                _playerPositions.Remove(steamId);
            }
        }
    }

    /// <summary>
    /// ç®€å•çš„ 3D ä½ç½®æ•°æ®ç»“æ„
    /// </summary>
    public struct Vector3Data
    {
        public float X, Y, Z;
        
        public Vector3Data(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }
    }
}


```

`Server\Plugin\IPlugin.cs`:

```cs
using System;

namespace DuckyNet.Server.Plugin
{
    /// <summary>
    /// æ’ä»¶æ¥å£
    /// æ‰€æœ‰æ’ä»¶å¿…é¡»å®ç°æ­¤æ¥å£
    /// </summary>
    public interface IPlugin
    {
        /// <summary>
        /// æ’ä»¶åç§°
        /// </summary>
        string Name { get; }

        /// <summary>
        /// æ’ä»¶ç‰ˆæœ¬
        /// </summary>
        string Version { get; }

        /// <summary>
        /// æ’ä»¶ä½œè€…
        /// </summary>
        string Author { get; }

        /// <summary>
        /// æ’ä»¶æè¿°
        /// </summary>
        string Description { get; }

        /// <summary>
        /// æ’ä»¶åŠ è½½æ—¶è°ƒç”¨
        /// </summary>
        /// <param name="context">æ’ä»¶ä¸Šä¸‹æ–‡ï¼Œæä¾›å¯¹æœåŠ¡å™¨èµ„æºçš„è®¿é—®</param>
        void OnLoad(IPluginContext context);

        /// <summary>
        /// æ’ä»¶å¸è½½æ—¶è°ƒç”¨
        /// </summary>
        void OnUnload();

        /// <summary>
        /// æ¯å¸§æ›´æ–°æ—¶è°ƒç”¨ï¼ˆçº¦ 60 FPSï¼‰
        /// </summary>
        void OnUpdate();
    }
}


```

`Server\Plugin\IPluginContext.cs`:

```cs
using DuckyNet.Server.Managers;
using DuckyNet.Server.RPC;
using DuckyNet.Server.Events;

namespace DuckyNet.Server.Plugin
{
    /// <summary>
    /// æ’ä»¶ä¸Šä¸‹æ–‡æ¥å£
    /// æä¾›æ’ä»¶è®¿é—®æœåŠ¡å™¨èµ„æºçš„èƒ½åŠ›
    /// </summary>
    public interface IPluginContext
    {
        /// <summary>
        /// ç©å®¶ç®¡ç†å™¨
        /// </summary>
        PlayerManager PlayerManager { get; }

        /// <summary>
        /// æˆ¿é—´ç®¡ç†å™¨
        /// </summary>
        RoomManager RoomManager { get; }

        /// <summary>
        /// RPC æœåŠ¡å™¨
        /// </summary>
        RpcServer RpcServer { get; }

        /// <summary>
        /// äº‹ä»¶æ€»çº¿
        /// </summary>
        IEventBus EventBus { get; }

        /// <summary>
        /// æ—¥å¿—è®°å½•å™¨
        /// </summary>
        IPluginLogger Logger { get; }
    }
}


```

`Server\Plugin\IPluginLogger.cs`:

```cs
namespace DuckyNet.Server.Plugin
{
    /// <summary>
    /// æ’ä»¶æ—¥å¿—æ¥å£
    /// </summary>
    public interface IPluginLogger
    {
        void Info(string message);
        void Warning(string message);
        void Error(string message);
        void Debug(string message);
    }

    /// <summary>
    /// æ’ä»¶æ—¥å¿—å®ç°
    /// </summary>
    public class PluginLogger : IPluginLogger
    {
        private readonly string _pluginName;

        public PluginLogger(string pluginName)
        {
            _pluginName = pluginName;
        }

        public void Info(string message)
        {
            System.Console.WriteLine($"[Plugin:{_pluginName}] INFO: {message}");
        }

        public void Warning(string message)
        {
            System.Console.WriteLine($"[Plugin:{_pluginName}] WARN: {message}");
        }

        public void Error(string message)
        {
            System.Console.WriteLine($"[Plugin:{_pluginName}] ERROR: {message}");
        }

        public void Debug(string message)
        {
            System.Console.WriteLine($"[Plugin:{_pluginName}] DEBUG: {message}");
        }
    }
}


```

`Server\Plugin\PluginContext.cs`:

```cs
using DuckyNet.Server.Managers;
using DuckyNet.Server.RPC;
using DuckyNet.Server.Events;

namespace DuckyNet.Server.Plugin
{
    /// <summary>
    /// æ’ä»¶ä¸Šä¸‹æ–‡å®ç°
    /// æä¾›æ’ä»¶è®¿é—®æœåŠ¡å™¨èµ„æºçš„èƒ½åŠ›
    /// </summary>
    public class PluginContext : IPluginContext
    {
        public PlayerManager PlayerManager { get; }
        public RoomManager RoomManager { get; }
        public RpcServer RpcServer { get; }
        public IEventBus EventBus { get; }
        public IPluginLogger Logger { get; }

        public PluginContext(
            PlayerManager playerManager,
            RoomManager roomManager,
            RpcServer rpcServer,
            IEventBus eventBus,
            IPluginLogger logger)
        {
            PlayerManager = playerManager;
            RoomManager = roomManager;
            RpcServer = rpcServer;
            EventBus = eventBus;
            Logger = logger;
        }
    }
}


```

`Server\Plugin\PluginManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace DuckyNet.Server.Plugin
{
    /// <summary>
    /// æ’ä»¶ç®¡ç†å™¨
    /// è´Ÿè´£åŠ è½½ã€ç®¡ç†å’Œå¸è½½æ’ä»¶
    /// </summary>
    public class PluginManager
    {
        private readonly List<IPlugin> _plugins = new List<IPlugin>();
        private readonly IPluginContext _context;
        private readonly object _lock = new object();

        public PluginManager(IPluginContext context)
        {
            _context = context;
        }

        /// <summary>
        /// ä»ç›®å½•åŠ è½½æ‰€æœ‰æ’ä»¶
        /// </summary>
        /// <param name="pluginDirectory">æ’ä»¶ç›®å½•è·¯å¾„</param>
        public void LoadPluginsFromDirectory(string pluginDirectory)
        {
            if (!Directory.Exists(pluginDirectory))
            {
                Console.WriteLine($"[PluginManager] æ’ä»¶ç›®å½•ä¸å­˜åœ¨: {pluginDirectory}");
                Directory.CreateDirectory(pluginDirectory);
                Console.WriteLine($"[PluginManager] å·²åˆ›å»ºæ’ä»¶ç›®å½•: {pluginDirectory}");
                return;
            }

            var dllFiles = Directory.GetFiles(pluginDirectory, "*.dll", SearchOption.AllDirectories);
            Console.WriteLine($"[PluginManager] å‘ç° {dllFiles.Length} ä¸ª DLL æ–‡ä»¶");

            foreach (var dllFile in dllFiles)
            {
                try
                {
                    LoadPlugin(dllFile);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[PluginManager] åŠ è½½æ’ä»¶å¤±è´¥: {dllFile}");
                    Console.WriteLine($"[PluginManager] é”™è¯¯: {ex.Message}");
                }
            }

            Console.WriteLine($"[PluginManager] å·²åŠ è½½ {_plugins.Count} ä¸ªæ’ä»¶");
        }

        /// <summary>
        /// ä» DLL æ–‡ä»¶åŠ è½½æ’ä»¶
        /// </summary>
        /// <param name="dllPath">DLL æ–‡ä»¶è·¯å¾„</param>
        public void LoadPlugin(string dllPath)
        {
            if (!File.Exists(dllPath))
            {
                throw new FileNotFoundException($"æ’ä»¶æ–‡ä»¶ä¸å­˜åœ¨: {dllPath}");
            }

            // åŠ è½½ç¨‹åºé›†
            var assembly = Assembly.LoadFrom(dllPath);
            
            // æŸ¥æ‰¾å®ç° IPlugin æ¥å£çš„ç±»å‹
            var pluginTypes = assembly.GetTypes()
                .Where(t => typeof(IPlugin).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract)
                .ToList();

            if (pluginTypes.Count == 0)
            {
                Console.WriteLine($"[PluginManager] æœªæ‰¾åˆ°æ’ä»¶ç±»: {dllPath}");
                return;
            }

            foreach (var pluginType in pluginTypes)
            {
                try
                {
                    // åˆ›å»ºæ’ä»¶å®ä¾‹
                    var plugin = (IPlugin)Activator.CreateInstance(pluginType)!;
                    
                    lock (_lock)
                    {
                        // è°ƒç”¨æ’ä»¶çš„åŠ è½½æ–¹æ³•
                        plugin.OnLoad(_context);
                        _plugins.Add(plugin);
                        
                        Console.WriteLine($"[PluginManager] å·²åŠ è½½æ’ä»¶: {plugin.Name} v{plugin.Version} by {plugin.Author}");
                        Console.WriteLine($"[PluginManager]   æè¿°: {plugin.Description}");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[PluginManager] å®ä¾‹åŒ–æ’ä»¶å¤±è´¥: {pluginType.FullName}");
                    Console.WriteLine($"[PluginManager] é”™è¯¯: {ex.Message}");
                }
            }
        }

        /// <summary>
        /// å¸è½½æ‰€æœ‰æ’ä»¶
        /// </summary>
        public void UnloadAllPlugins()
        {
            lock (_lock)
            {
                foreach (var plugin in _plugins)
                {
                    try
                    {
                        plugin.OnUnload();
                        Console.WriteLine($"[PluginManager] å·²å¸è½½æ’ä»¶: {plugin.Name}");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[PluginManager] å¸è½½æ’ä»¶å¤±è´¥: {plugin.Name}");
                        Console.WriteLine($"[PluginManager] é”™è¯¯: {ex.Message}");
                    }
                }
                _plugins.Clear();
            }
        }

        /// <summary>
        /// æ›´æ–°æ‰€æœ‰æ’ä»¶ï¼ˆåœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨ï¼‰
        /// </summary>
        public void UpdatePlugins()
        {
            lock (_lock)
            {
                foreach (var plugin in _plugins)
                {
                    try
                    {
                        plugin.OnUpdate();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[PluginManager] æ’ä»¶æ›´æ–°å¼‚å¸¸: {plugin.Name}");
                        Console.WriteLine($"[PluginManager] é”™è¯¯: {ex.Message}");
                    }
                }
            }
        }

        /// <summary>
        /// è·å–å·²åŠ è½½çš„æ’ä»¶åˆ—è¡¨
        /// </summary>
        public IReadOnlyList<IPlugin> GetLoadedPlugins()
        {
            lock (_lock)
            {
                return _plugins.AsReadOnly();
            }
        }

        /// <summary>
        /// æ ¹æ®åç§°è·å–æ’ä»¶
        /// </summary>
        public IPlugin? GetPlugin(string name)
        {
            lock (_lock)
            {
                return _plugins.FirstOrDefault(p => p.Name == name);
            }
        }
    }
}


```

`Server\Plugin\README.md`:

```md
# DuckyNet æ’ä»¶ç³»ç»Ÿ

## ğŸ¯ è®¾è®¡ç†å¿µ

DuckyNet æœåŠ¡å™¨é‡‡ç”¨åŸºäº **C# + äº‹ä»¶æ€»çº¿** çš„æ’ä»¶æ¶æ„ï¼š

- âœ… **åŸç”Ÿæ€§èƒ½**ï¼šC# æ’ä»¶ä»¥ DLL å½¢å¼åŠ è½½ï¼Œæ€§èƒ½æ¥è¿‘åŸç”Ÿä»£ç 
- âœ… **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„ IntelliSense æ”¯æŒå’Œç¼–è¯‘æ—¶æ£€æŸ¥
- âœ… **ä¾èµ–æ³¨å…¥**ï¼šé€šè¿‡ `IPluginContext` è®¿é—®æœåŠ¡å™¨èµ„æº
- âœ… **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºå‘å¸ƒ-è®¢é˜…æ¨¡å¼çš„æ¾è€¦åˆæ¶æ„
- âœ… **éš”ç¦»æ€§**ï¼šæ’ä»¶å¼‚å¸¸ä¸ä¼šå¯¼è‡´æœåŠ¡å™¨å´©æºƒ

## ğŸ—ï¸ æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         æ’ä»¶ (YourPlugin.dll)           â”‚
â”‚  implements IPlugin                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ ä¾èµ–æ³¨å…¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      IPluginContext (ä¸Šä¸‹æ–‡)            â”‚
â”‚  - PlayerManager (ç©å®¶ç®¡ç†)             â”‚
â”‚  - RoomManager (æˆ¿é—´ç®¡ç†)               â”‚
â”‚  - RpcServer (RPC æœåŠ¡å™¨)               â”‚
â”‚  - EventBus (äº‹ä»¶æ€»çº¿) â†â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  - Logger (æ—¥å¿—ç³»ç»Ÿ)           â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“ è®¢é˜…                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         äº‹ä»¶æ€»çº¿ (EventBus)             â”‚
â”‚  - PlayerLoginEvent          â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  - RoomCreatedEvent                    â”‚
â”‚  - ...æ›´å¤šäº‹ä»¶                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘ å‘å¸ƒ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æœåŠ¡å±‚ (Services)                  â”‚
â”‚  - PlayerServiceImpl                    â”‚
â”‚  - RoomServiceImpl                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“¦ æ ¸å¿ƒç»„ä»¶

### 1. IPluginï¼ˆæ’ä»¶æ¥å£ï¼‰

æ‰€æœ‰æ’ä»¶å¿…é¡»å®ç°æ­¤æ¥å£ï¼š

```csharp
public interface IPlugin
{
    string Name { get; }          // æ’ä»¶åç§°
    string Version { get; }       // ç‰ˆæœ¬å·
    string Author { get; }        // ä½œè€…
    string Description { get; }   // æè¿°
    
    void OnLoad(IPluginContext context);    // åŠ è½½æ—¶è°ƒç”¨
    void OnUnload();                        // å¸è½½æ—¶è°ƒç”¨
    void OnUpdate();                        // æ¯å¸§æ›´æ–°ï¼ˆçº¦ 60 FPSï¼‰
}
```

### 2. IPluginContextï¼ˆä¸Šä¸‹æ–‡æ¥å£ï¼‰

æä¾›æ’ä»¶è®¿é—®æœåŠ¡å™¨èµ„æºçš„èƒ½åŠ›ï¼š

```csharp
public interface IPluginContext
{
    PlayerManager PlayerManager { get; }    // ç©å®¶ç®¡ç†å™¨
    RoomManager RoomManager { get; }        // æˆ¿é—´ç®¡ç†å™¨
    RpcServer RpcServer { get; }            // RPC æœåŠ¡å™¨
    IEventBus EventBus { get; }             // äº‹ä»¶æ€»çº¿
    IPluginLogger Logger { get; }           // æ—¥å¿—ç³»ç»Ÿ
}
```

### 3. IEventBusï¼ˆäº‹ä»¶æ€»çº¿ï¼‰

å‘å¸ƒ-è®¢é˜…æ¨¡å¼çš„äº‹ä»¶ç³»ç»Ÿï¼š

```csharp
public interface IEventBus
{
    void Subscribe<TEvent>(Action<TEvent> handler);     // è®¢é˜…äº‹ä»¶
    void Unsubscribe<TEvent>(Action<TEvent> handler);   // å–æ¶ˆè®¢é˜…
    void Publish<TEvent>(TEvent eventData);             // å‘å¸ƒäº‹ä»¶
}
```

## ğŸª å¯ç”¨äº‹ä»¶

### æœåŠ¡å™¨äº‹ä»¶

```csharp
// æœåŠ¡å™¨å¯åŠ¨
public class ServerStartedEvent
{
    public int Port { get; set; }
}

// æœåŠ¡å™¨å…³é—­
public class ServerStoppingEvent { }
```

### ç©å®¶äº‹ä»¶

```csharp
// ç©å®¶è¿æ¥ï¼ˆæœªç™»å½•ï¼‰
public class PlayerConnectedEvent
{
    public string ClientId { get; set; }
}

// ç©å®¶ç™»å½•æˆåŠŸ
public class PlayerLoginEvent
{
    public string ClientId { get; set; }
    public PlayerInfo Player { get; set; }
}

// ç©å®¶ç™»å‡º
public class PlayerLogoutEvent
{
    public string ClientId { get; set; }
    public PlayerInfo Player { get; set; }
}

// ç©å®¶æ–­å¼€è¿æ¥
public class PlayerDisconnectedEvent
{
    public string ClientId { get; set; }
    public PlayerInfo? Player { get; set; }  // å¯èƒ½æœªç™»å½•
}
```

### æˆ¿é—´äº‹ä»¶

```csharp
// æˆ¿é—´åˆ›å»º
public class RoomCreatedEvent
{
    public RoomInfo Room { get; set; }
    public PlayerInfo Host { get; set; }
}

// ç©å®¶åŠ å…¥æˆ¿é—´
public class PlayerJoinedRoomEvent
{
    public RoomInfo Room { get; set; }
    public PlayerInfo Player { get; set; }
}

// ç©å®¶ç¦»å¼€æˆ¿é—´
public class PlayerLeftRoomEvent
{
    public RoomInfo? Room { get; set; }  // å¯èƒ½å·²åˆ é™¤
    public PlayerInfo Player { get; set; }
}

// æˆ¿é—´åˆ é™¤
public class RoomDeletedEvent
{
    public string RoomId { get; set; }
}
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. åˆ›å»ºæ’ä»¶é¡¹ç›®

```bash
dotnet new classlib -n MyPlugin -f net8.0
cd MyPlugin
dotnet add reference ../Server/DuckyNetServer.csproj
dotnet add reference ../Shared/DuckyNetShared.csproj
```

### 2. å®ç°æ’ä»¶

```csharp
using DuckyNet.Server.Plugin;
using DuckyNet.Server.Plugin.Events;

public class MyPlugin : IPlugin
{
    public string Name => "æˆ‘çš„æ’ä»¶";
    public string Version => "1.0.0";
    public string Author => "Your Name";
    public string Description => "è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹æ’ä»¶";

    private IPluginContext _context;

    public void OnLoad(IPluginContext context)
    {
        _context = context;
        _context.Logger.Info("æ’ä»¶åŠ è½½æˆåŠŸï¼");
        
        // è®¢é˜…äº‹ä»¶
        _context.EventBus.Subscribe<PlayerLoginEvent>(OnPlayerLogin);
    }

    public void OnUnload()
    {
        // å–æ¶ˆè®¢é˜…
        _context.EventBus.Unsubscribe<PlayerLoginEvent>(OnPlayerLogin);
        _context.Logger.Info("æ’ä»¶å·²å¸è½½");
    }

    public void OnUpdate()
    {
        // æ¯å¸§æ›´æ–°é€»è¾‘ï¼ˆå¯é€‰ï¼‰
    }

    private void OnPlayerLogin(PlayerLoginEvent e)
    {
        _context.Logger.Info($"æ¬¢è¿ {e.Player.SteamName}ï¼");
    }
}
```

### 3. ç¼–è¯‘å’Œéƒ¨ç½²

```bash
# ç¼–è¯‘
dotnet build -c Release

# å¤åˆ¶åˆ°æœåŠ¡å™¨æ’ä»¶ç›®å½•
copy bin\Release\net8.0\MyPlugin.dll <æœåŠ¡å™¨ç›®å½•>\Plugins\
```

### 4. å¯åŠ¨æœåŠ¡å™¨

æœåŠ¡å™¨å¯åŠ¨æ—¶ä¼šè‡ªåŠ¨åŠ è½½ `Plugins` ç›®å½•ä¸‹çš„æ‰€æœ‰ DLLï¼š

```
[PluginManager] å‘ç° 1 ä¸ª DLL æ–‡ä»¶
[Plugin:System] INFO: æˆ‘çš„æ’ä»¶ v1.0.0 æ­£åœ¨åŠ è½½...
[Plugin:System] INFO: æ’ä»¶åŠ è½½æˆåŠŸï¼
[PluginManager] å·²åŠ è½½æ’ä»¶: æˆ‘çš„æ’ä»¶ v1.0.0 by Your Name
```

## ğŸ“š ç¤ºä¾‹æ’ä»¶

æŸ¥çœ‹ `ExamplePlugin` é¡¹ç›®è·å–å®Œæ•´ç¤ºä¾‹ï¼š

- **WelcomePlugin**ï¼šæ¬¢è¿æ¶ˆæ¯å’Œç»Ÿè®¡
- **AntiFloodPlugin**ï¼šé˜²åˆ·å±æ£€æµ‹

## ğŸ”§ é«˜çº§åŠŸèƒ½

### è®¿é—®ç©å®¶ç®¡ç†å™¨

```csharp
// è·å–æ‰€æœ‰åœ¨çº¿ç©å®¶
var players = _context.PlayerManager.GetAllOnlinePlayers();

// è·å–ç‰¹å®šç©å®¶
var player = _context.PlayerManager.GetPlayer(clientId);

// æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨çº¿
bool isOnline = _context.PlayerManager.IsLoggedIn(steamId);
```

### è®¿é—®æˆ¿é—´ç®¡ç†å™¨

```csharp
// è·å–æ‰€æœ‰æˆ¿é—´
var rooms = _context.RoomManager.GetAllRooms();

// è·å–æˆ¿é—´ç©å®¶
var players = _context.RoomManager.GetRoomPlayers(roomId);

// è·å–ç©å®¶æ‰€åœ¨æˆ¿é—´
var room = _context.RoomManager.GetPlayerRoom(player);
```

### è®¿é—® RPC æœåŠ¡å™¨

```csharp
// æ–­å¼€å®¢æˆ·ç«¯è¿æ¥
_context.RpcServer.DisconnectClient(clientId, "è¿è§„æ“ä½œ");

// è·å–å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡
var clientContext = _context.RpcServer.GetClientContext(clientId);
```

### å‘å¸ƒè‡ªå®šä¹‰äº‹ä»¶

```csharp
// å®šä¹‰è‡ªå®šä¹‰äº‹ä»¶
public class MyCustomEvent
{
    public string Message { get; set; }
}

// å‘å¸ƒäº‹ä»¶
_context.EventBus.Publish(new MyCustomEvent 
{ 
    Message = "Hello from plugin!" 
});

// å…¶ä»–æ’ä»¶å¯ä»¥è®¢é˜…
_context.EventBus.Subscribe<MyCustomEvent>(e =>
{
    _context.Logger.Info($"æ”¶åˆ°æ¶ˆæ¯: {e.Message}");
});
```

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **çº¿ç¨‹å®‰å…¨**ï¼šäº‹ä»¶å¤„ç†å™¨åœ¨æœåŠ¡å™¨ä¸»çº¿ç¨‹æ‰§è¡Œï¼Œè®¿é—®å…±äº«èµ„æºæ—¶æ³¨æ„åŒæ­¥
2. **æ€§èƒ½**ï¼š`OnUpdate()` æ¯ç§’è°ƒç”¨çº¦ 60 æ¬¡ï¼Œé¿å…æ‰§è¡Œé‡æ“ä½œ
3. **å¼‚å¸¸å¤„ç†**ï¼šè™½ç„¶æœ‰å¼‚å¸¸ä¿æŠ¤ï¼Œä½†æœ€å¥½åœ¨æ’ä»¶å†…éƒ¨å¤„ç†å¼‚å¸¸
4. **èµ„æºæ¸…ç†**ï¼šåŠ¡å¿…åœ¨ `OnUnload()` ä¸­å–æ¶ˆæ‰€æœ‰äº‹ä»¶è®¢é˜…
5. **æ—¥å¿—è§„èŒƒ**ï¼šä½¿ç”¨ `_context.Logger` è€Œä¸æ˜¯ `Console.WriteLine`

## ğŸ¯ ä¸ºä»€ä¹ˆä¸ç”¨ Luaï¼Ÿ

æˆ‘ä»¬é€‰æ‹© C# è€Œé Lua çš„åŸå› ï¼š

| ç‰¹æ€§ | C# æ’ä»¶ | Lua è„šæœ¬ |
|------|---------|----------|
| **æ€§èƒ½** | â­â­â­â­â­ åŸç”Ÿ | â­â­â­ éœ€è¦è§£é‡Š |
| **ç±»å‹å®‰å…¨** | âœ… ç¼–è¯‘æ—¶æ£€æŸ¥ | âŒ è¿è¡Œæ—¶é”™è¯¯ |
| **IDE æ”¯æŒ** | âœ… å®Œæ•´ IntelliSense | âš ï¸ æœ‰é™ |
| **è°ƒè¯•** | âœ… Visual Studio | âš ï¸ è¾ƒå›°éš¾ |
| **çƒ­é‡è½½** | âš ï¸ éœ€è¦é‡å¯ | âœ… æ”¯æŒ |
| **å­¦ä¹ æ›²çº¿** | âš ï¸ éœ€è¦ C# çŸ¥è¯† | âœ… è¯­æ³•ç®€å• |

**ç»“è®º**ï¼šå¯¹äºéœ€è¦ç¨³å®šæ€§å’Œæ€§èƒ½çš„æœåŠ¡å™¨æ’ä»¶ï¼ŒC# æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚å¦‚æœéœ€è¦é¢‘ç¹çƒ­æ›´æ–°ï¼Œå¯ä»¥è€ƒè™‘æ··åˆæ–¹æ¡ˆï¼ˆC# + Luaï¼‰ã€‚

## ğŸ“– æ›´å¤šèµ„æº

- [ç¤ºä¾‹æ’ä»¶æºç ](../../ExamplePlugin/)
- [æœåŠ¡å™¨ API æ–‡æ¡£](../README.md)
- [äº‹ä»¶ç³»ç»Ÿè¯¦è§£](./Events/README.md)


```

`Server\Program.cs`:

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.AspNetCore.Builder;
using DuckyNet.Server.Core;
using DuckyNet.Server.RPC;
using DuckyNet.Server.Managers;
using DuckyNet.Server.Plugin;
using DuckyNet.Server.Events;
using DuckyNet.Server.Web;

#nullable enable

namespace DuckyNet.Server
{
    /// <summary>
    /// DuckyNet æœåŠ¡å™¨ç¨‹åº
    /// [REFACTOR] é˜¶æ®µ1ï¼šå¼•å…¥ä¾èµ–æ³¨å…¥å®¹å™¨
    /// </summary>
    class Program
    {
        private static IServiceProvider _serviceProvider = null!;
        private static RpcServer _server = null!;
        private static PlayerManager _playerManager = null!;
        private static EventBus _eventBus = null!;
        private static PluginManager _pluginManager = null!;
        private static WebApplication? _webApp = null;
        private static bool _running = true;

        static async Task Main(string[] args)
        {
            Console.WriteLine("=== DuckyNet Server ===");
            Console.WriteLine();

            try
            {
                // ========== é˜¶æ®µ1ï¼šé…ç½®ä¾èµ–æ³¨å…¥å®¹å™¨ ==========
                Console.WriteLine("[Server] Configuring services...");
                var services = new ServiceCollection();
                
                // æ³¨å†Œæ ¸å¿ƒæœåŠ¡
                services.AddDuckyNetCore();
                
                // æ³¨å†Œä¸šåŠ¡æ¨¡å—
                services.AddDuckyNetModules();
                
                // æ³¨å†Œæ’ä»¶ç³»ç»Ÿ
                services.AddPluginSystem();
                
                // æ„å»ºæœåŠ¡æä¾›è€…
                _serviceProvider = services.BuildServiceProvider();
                Console.WriteLine("[Server] âœ“ Services configured");

                // ========== é˜¶æ®µ2ï¼šåˆå§‹åŒ–æ ¸å¿ƒç»„ä»¶ ==========
                Console.WriteLine("[Server] Initializing components...");
                
                // åˆå§‹åŒ–é™æ€ä¾èµ–ï¼ˆè¿‡æ¸¡æ–¹æ¡ˆï¼‰
                ServerInitializer.InitializeStaticDependencies(_serviceProvider);
                
                // è·å–æ ¸å¿ƒæœåŠ¡å®ä¾‹
                _server = _serviceProvider.GetRequiredService<RpcServer>();
                _playerManager = _serviceProvider.GetRequiredService<PlayerManager>();
                _eventBus = _serviceProvider.GetRequiredService<EventBus>();
                _pluginManager = _serviceProvider.GetRequiredService<PluginManager>();
                
                // åˆå§‹åŒ–æœåŠ¡å™¨ä¸Šä¸‹æ–‡å¹¶æ³¨å†Œæ‰€æœ‰ RPC æœåŠ¡
                ServiceCollectionExtensions.InitializeServer(_serviceProvider);
                Console.WriteLine("[Server] âœ“ Components initialized");

                // ========== é˜¶æ®µ3ï¼šå¯åŠ¨æœåŠ¡å™¨ ==========

                // è®¢é˜…äº‹ä»¶
                _server.ClientConnected += OnClientConnected;
                _server.ClientDisconnected += OnClientDisconnected;

                Console.WriteLine("[Server] Starting server...");
                
                // å¯åŠ¨ RPC æœåŠ¡å™¨
                int port = 9050;
                _server.Start(port);
                Console.WriteLine($"[Server] âœ“ RPC Server listening on port {port}");
                Console.WriteLine($"[Server] âœ“ Login timeout: 3 seconds");

                // åŠ è½½æ’ä»¶
                var pluginDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins");
                _pluginManager.LoadPluginsFromDirectory(pluginDir);
                Console.WriteLine($"[Server] âœ“ Plugins loaded from: {pluginDir}");
                Console.WriteLine();

                // å‘å¸ƒæœåŠ¡å™¨å¯åŠ¨äº‹ä»¶
                _eventBus.Publish(new ServerStartedEvent { Port = port });

                // ========== é˜¶æ®µ4ï¼šå¯åŠ¨WebæœåŠ¡å™¨ ==========
                Console.WriteLine("[Server] Starting Web server...");
                _webApp = WebServerStartup.CreateAndConfigureWebApp(_serviceProvider, args);
                var webTask = _webApp.RunAsync("http://localhost:5000");
                Console.WriteLine("[Server] âœ“ Web server started at http://localhost:5000");
                Console.WriteLine("[Server] âœ“ Admin dashboard: http://localhost:5000");
                Console.WriteLine();

                // ========== é˜¶æ®µ5ï¼šå¯åŠ¨åå°ä»»åŠ¡ ==========
                var updateThread = new Thread(UpdateLoop);
                updateThread.IsBackground = true;
                updateThread.Start();

                var timeoutThread = new Thread(TimeoutCheckLoop);
                timeoutThread.IsBackground = true;
                timeoutThread.Start();
                Console.WriteLine("[Server] âœ“ Background tasks started");
                Console.WriteLine();
                Console.WriteLine("==================================");
                Console.WriteLine("  Server is ready!");
                Console.WriteLine("  RPC Server: Port 9050");
                Console.WriteLine("  Web Admin: http://localhost:5000");
                Console.WriteLine("  Press Ctrl+C to stop server");
                Console.WriteLine("==================================");
                Console.WriteLine();
                Console.CancelKeyPress += (s, e) =>
                {
                    e.Cancel = true;
                    _running = false;
                };

                // ä¸»çº¿ç¨‹ç­‰å¾…
                while (_running)
                {
                    Thread.Sleep(100);
                }

                Console.WriteLine("[Server] Shutting down...");
                _eventBus.Publish(new ServerStoppingEvent());
                _pluginManager.UnloadAllPlugins();
                _server.Stop();
                
                // åœæ­¢ Web æœåŠ¡å™¨ï¼ˆè®¾ç½®çŸ­è¶…æ—¶é¿å…å¡ä½ï¼‰
                if (_webApp != null)
                {
                    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));
                    try
                    {
                        await _webApp.StopAsync(cts.Token);
                        Console.WriteLine("[Server] Web server stopped");
                    }
                    catch (OperationCanceledException)
                    {
                        Console.WriteLine("[Server] Web server force stopped (timeout)");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Server] Fatal error: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }
        }

        static void UpdateLoop()
        {
            while (_running)
            {
                _server?.Update();
                _pluginManager?.UpdatePlugins();
                Thread.Sleep(15); // ~60 FPS
            }
        }

        static void TimeoutCheckLoop()
        {
            while (_running)
            {
                _playerManager?.CheckLoginTimeouts();
                Thread.Sleep(1000); // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
            }
        }

        static void OnClientConnected(string clientId)
        {
            _playerManager?.OnClientConnected(clientId);
            Console.WriteLine($"[Server] Client connected: {clientId}");
            _eventBus?.Publish(new PlayerConnectedEvent { ClientId = clientId });
        }

        static void OnClientDisconnected(string clientId)
        {
            var player = _playerManager?.GetPlayer(clientId);
            _playerManager?.OnClientDisconnected(clientId);
            Console.WriteLine($"[Server] Client disconnected: {clientId}");
            _eventBus?.Publish(new PlayerDisconnectedEvent 
            { 
                ClientId = clientId,
                Player = player
            });
        }
    }
}

```

`Server\RPC\RpcServer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using LiteNetLib;
using LiteNetLib.Utils;
using DuckyNet.Shared.RPC;

namespace DuckyNet.Server.RPC
{
    /// <summary>
    /// æœåŠ¡å™¨ç«¯å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡å®ç°
    /// </summary>
    public class ServerClientContext : IClientContext
    {
        private readonly RpcServer _server;
        private readonly NetPeer _peer;

        public string ClientId { get; }
        public object NetPeer => _peer;

        public ClientSessionState SessionState { get; internal set; } = ClientSessionState.Connected;

        public DateTime LastHeartbeat { get; internal set; } = DateTime.UtcNow;

        public bool IsDisconnected => _peer.ConnectionState != LiteNetLib.ConnectionState.Connected;

        public int ReconnectCount { get; internal set; } = 0;

        public ServerClientContext(RpcServer server, NetPeer peer)
        {
            _server = server;
            _peer = peer;
            ClientId = peer.Id.ToString();
        }

        public void Invoke<TService>(string methodName, params object[] parameters) where TService : class
        {
            _server.InvokeClient<TService>(_peer, methodName, parameters);
        }

        public async Task<TResult> InvokeAsync<TService, TResult>(string methodName, params object[] parameters) where TService : class
        {
            return await _server.InvokeClientAsync<TService, TResult>(_peer, methodName, parameters);
        }
    }

    /// <summary>
    /// RPC æœåŠ¡å™¨
    /// è´Ÿè´£å¤„ç†å®¢æˆ·ç«¯è¿æ¥ã€è°ƒç”¨å’Œå“åº”
    /// </summary>
    public class RpcServer : INetEventListener
    {
        private readonly NetManager _netManager;
        private readonly RpcInvoker _invoker;
        private readonly RpcTimeoutManager _timeoutManager;
        private readonly RpcConfig _config;
        private readonly Dictionary<NetPeer, Dictionary<int, TaskCompletionSource<RpcResponse>>> _pendingCalls;
        private readonly Dictionary<NetPeer, ServerClientContext> _clientContexts;
        private int _nextMessageId = 1;

        /// <summary>
        /// å®¢æˆ·ç«¯è¿æ¥äº‹ä»¶
        /// </summary>
        public event Action<string>? ClientConnected;

        /// <summary>
        /// å®¢æˆ·ç«¯æ–­å¼€è¿æ¥äº‹ä»¶
        /// </summary>
        public event Action<string>? ClientDisconnected;

        public RpcServer(RpcConfig? config = null)
        {
            _config = config ?? RpcConfig.Default;
            _netManager = new NetManager(this);
            _invoker = new RpcInvoker();
            _pendingCalls = new Dictionary<NetPeer, Dictionary<int, TaskCompletionSource<RpcResponse>>>();
            _clientContexts = new Dictionary<NetPeer, ServerClientContext>();
            _timeoutManager = new RpcTimeoutManager(_config.DefaultTimeoutMs);
            
            if (_config.EnableVerboseLogging)
            {
                Console.WriteLine($"[RpcServer] Initialized with max clients: {_config.MaxClients}");
            }
        }

        /// <summary>
        /// å¯åŠ¨æœåŠ¡å™¨
        /// </summary>
        public void Start(int port)
        {
            _netManager.Start(port);
            Console.WriteLine($"[RpcServer] Server started on port {port}");
        }

        /// <summary>
        /// åœæ­¢æœåŠ¡å™¨
        /// </summary>
        public void Stop()
        {
            _netManager.Stop();
            Console.WriteLine("[RpcServer] Server stopped");
        }

        /// <summary>
        /// æ›´æ–°ç½‘ç»œï¼ˆéœ€è¦åœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨ï¼‰
        /// </summary>
        public void Update()
        {
            _netManager.PollEvents();
        }

        /// <summary>
        /// æ³¨å†ŒæœåŠ¡å™¨æœåŠ¡ï¼ˆç”¨äºæ¥æ”¶å®¢æˆ·ç«¯çš„RPCè°ƒç”¨ï¼‰
        /// </summary>
        public void RegisterServerService<TService>(object serviceInstance) where TService : class
        {
            _invoker.RegisterService<TService>(serviceInstance);
            Console.WriteLine($"[RpcServer] Registered service: {typeof(TService).Name}");
        }

        /// <summary>
        /// è°ƒç”¨å®¢æˆ·ç«¯æ–¹æ³•ï¼ˆæ— è¿”å›å€¼ï¼‰
        /// </summary>
        public void InvokeClient<TService>(NetPeer peer, string methodName, params object[] parameters) where TService : class
        {
            var serviceName = GetServiceName(typeof(TService));
            var message = new RpcMessage
            {
                MessageId = _nextMessageId++,
                ServiceName = serviceName,
                MethodName = methodName,
                Parameters = RpcSerializer.Instance.SerializeParameters(parameters)
            };

            SendMessage(peer, message);
        }

        /// <summary>
        /// è°ƒç”¨å®¢æˆ·ç«¯æ–¹æ³•ï¼ˆæœ‰è¿”å›å€¼ï¼‰
        /// </summary>
        public async Task<TResult> InvokeClientAsync<TService, TResult>(NetPeer peer, string methodName, params object[] parameters) where TService : class
        {
            var serviceName = GetServiceName(typeof(TService));
            var messageId = _nextMessageId++;
            var message = new RpcMessage
            {
                MessageId = messageId,
                ServiceName = serviceName,
                MethodName = methodName,
                Parameters = RpcSerializer.Instance.SerializeParameters(parameters)
            };

            if (!_pendingCalls.ContainsKey(peer))
            {
                _pendingCalls[peer] = new Dictionary<int, TaskCompletionSource<RpcResponse>>();
            }

            var tcs = new TaskCompletionSource<RpcResponse>();
            _pendingCalls[peer][messageId] = tcs;

            // è®¾ç½®è¶…æ—¶
            var timeoutToken = _timeoutManager.SetTimeout(messageId, _config.DefaultTimeoutMs);
            timeoutToken.Register(() =>
            {
                if (_pendingCalls.TryGetValue(peer, out var peerCalls) &&
                    peerCalls.TryGetValue(messageId, out var pendingTcs))
                {
                    peerCalls.Remove(messageId);
                    pendingTcs.TrySetException(new TimeoutException(
                        $"RPC call to client '{methodName}' timed out after {_config.DefaultTimeoutMs}ms"));
                }
            });

            SendMessage(peer, message);

            try
            {
                var response = await tcs.Task;
                _timeoutManager.ClearTimeout(messageId);

                if (!response.Success)
                {
                    throw new Exception($"RPC call failed: {response.ErrorMessage}");
                }

                if (response.Result == null)
                {
                    return default!;
                }

                return RpcSerializer.Instance.Deserialize<TResult>(response.Result);
            }
            catch
            {
                _timeoutManager.ClearTimeout(messageId);
                throw;
            }
        }

        /// <summary>
        /// å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰å®¢æˆ·ç«¯
        /// </summary>
        public void BroadcastToAll<TService>(string methodName, params object[] parameters) where TService : class
        {
            foreach (var peer in _netManager.ConnectedPeerList)
            {
                InvokeClient<TService>(peer, methodName, parameters);
            }
        }

        /// <summary>
        /// å¹¿æ’­æ¶ˆæ¯ç»™æŒ‡å®šçš„å®¢æˆ·ç«¯åˆ—è¡¨
        /// </summary>
        public void BroadcastToClients<TService>(IEnumerable<string> clientIds, string methodName, params object[] parameters) where TService : class
        {
            foreach (var clientId in clientIds)
            {
                var context = GetClientContext(clientId);
                if (context != null && context.NetPeer is NetPeer peer)
                {
                    InvokeClient<TService>(peer, methodName, parameters);
                }
            }
        }

        /// <summary>
        /// å¹¿æ’­æ¶ˆæ¯ç»™æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
        /// </summary>
        public void BroadcastWhere<TService>(Func<string, bool> predicate, string methodName, params object[] parameters) where TService : class
        {
            foreach (var kvp in _clientContexts)
            {
                if (predicate(kvp.Value.ClientId))
                {
                    InvokeClient<TService>(kvp.Key, methodName, parameters);
                }
            }
        }

        /// <summary>
        /// æ–­å¼€æŒ‡å®šå®¢æˆ·ç«¯è¿æ¥
        /// </summary>
        public void DisconnectClient(string clientId, string reason)
        {
            foreach (var kvp in _clientContexts)
            {
                if (kvp.Value.ClientId == clientId)
                {
                    kvp.Key.Disconnect();
                    RpcLog.Info($"[RpcServer] Disconnected client {clientId}: {reason}");
                    return;
                }
            }
        }

        /// <summary>
        /// è·å–å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡
        /// </summary>
        public ServerClientContext? GetClientContext(string clientId)
        {
            foreach (var kvp in _clientContexts)
            {
                if (kvp.Value.ClientId == clientId)
                {
                    return kvp.Value;
                }
            }
            return null;
        }
        

        private void SendMessage(NetPeer peer, RpcMessage message)
        {
            var data = RpcSerializer.Instance.Serialize(message);
            peer.Send(data, DeliveryMethod.ReliableOrdered);
        }

        private void SendResponse(NetPeer peer, RpcResponse response)
        {
            var data = RpcSerializer.Instance.Serialize(response);
            peer.Send(data, DeliveryMethod.ReliableOrdered);
        }

        private string GetServiceName(Type serviceType)
        {
            var attr = serviceType.GetCustomAttributes(typeof(RpcServiceAttribute), false);
            if (attr.Length > 0)
            {
                return ((RpcServiceAttribute)attr[0]).ServiceName;
            }
            return serviceType.Name;
        }

        #region INetEventListener Implementation

        public void OnPeerConnected(NetPeer peer)
        {
            var context = new ServerClientContext(this, peer);
            _clientContexts[peer] = context;
            RpcLog.Info($"[RpcServer] Client connected: {peer.Address}:{peer.Port} (ID: {peer.Id})");
            
            // è§¦å‘è¿æ¥äº‹ä»¶
            ClientConnected?.Invoke(context.ClientId);
        }

        public void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            var clientId = peer.Id.ToString();
            
            _clientContexts.Remove(peer);
            _pendingCalls.Remove(peer);
            
            Console.WriteLine($"[RpcServer] Client disconnected: {peer.Address}:{peer.Port} - {disconnectInfo.Reason}");
            
            // è§¦å‘æ–­å¼€è¿æ¥äº‹ä»¶
            ClientDisconnected?.Invoke(clientId);
        }

        public void OnNetworkError(System.Net.IPEndPoint endPoint, System.Net.Sockets.SocketError socketError)
        {
            Console.WriteLine($"[RpcServer] Network error: {socketError}");
        }

        public void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            try
            {
                var data = reader.GetRemainingBytes();

                // ä½¿ç”¨ç±»å‹æ ‡è®°æ£€æµ‹æ¶ˆæ¯ç±»å‹ï¼ˆæ›´å¯é çš„æ–¹æ³•ï¼‰
                var messageType = RpcSerializer.Instance.DetectMessageType(data);
                
                if (messageType == RpcMessageType.Request)
                {
                    // æ˜ç¡®æ˜¯è¯·æ±‚æ¶ˆæ¯ï¼ˆå®¢æˆ·ç«¯è°ƒç”¨æœåŠ¡å™¨ï¼‰
                    try
                    {
                        var message = RpcSerializer.Instance.Deserialize<RpcMessage>(data);
                        HandleClientCall(peer, message);
                        return;
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[RpcServer] Failed to deserialize RpcMessage: {ex.Message}");
                    }
                }
                else if (messageType == RpcMessageType.Response)
                {
                    // æ˜ç¡®æ˜¯å“åº”æ¶ˆæ¯ï¼ˆå®¢æˆ·ç«¯å“åº”æœåŠ¡å™¨è°ƒç”¨ï¼‰
                    try
                    {
                        var response = RpcSerializer.Instance.Deserialize<RpcResponse>(data);
                        HandleClientResponse(peer, response);
                        return;
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[RpcServer] Failed to deserialize RpcResponse: {ex.Message}");
                    }
                }
                else
                {
                    // æ²¡æœ‰ç±»å‹æ ‡è®°æˆ–ç±»å‹æœªçŸ¥ï¼Œå°è¯•å…¼å®¹æ—§æ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼‰
                    // å…ˆå°è¯•ä½œä¸ºè¯·æ±‚ï¼ˆæœåŠ¡å™¨æ¥æ”¶çš„é€šå¸¸æ˜¯è¯·æ±‚ï¼‰
                    try
                    {
                        var message = RpcSerializer.Instance.Deserialize<RpcMessage>(data);
                        HandleClientCall(peer, message);
                        return;
                    }
                    catch
                    {
                        // ä¸æ˜¯è¯·æ±‚ï¼Œç»§ç»­å°è¯•ä½œä¸ºå“åº”
                    }

                    // å°è¯•ä½œä¸ºå“åº”
                    try
                    {
                        var response = RpcSerializer.Instance.Deserialize<RpcResponse>(data);
                        HandleClientResponse(peer, response);
                        return;
                    }
                    catch (Exception ex2)
                    {
                        Console.WriteLine($"[RpcServer] Failed to parse message: {ex2.Message}");
                    }

                    Console.WriteLine("[RpcServer] Received unknown message type");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[RpcServer] Error processing message: {ex.Message}");
            }
            finally
            {
                reader.Recycle();
            }
        }

        private async void HandleClientCall(NetPeer peer, RpcMessage message)
        {
            try
            {
                var clientContext = _clientContexts[peer];
                // ä½¿ç”¨ InvokeAsync æ¥å¤„ç†å¯èƒ½çš„å¼‚æ­¥æ–¹æ³•
                var result = await _invoker.InvokeAsync(message.ServiceName, message.MethodName,
                    RpcSerializer.Instance.DeserializeParameters(message.Parameters), clientContext);

                // ç¡®ä¿ result ä¸æ˜¯ Task ç±»å‹ï¼ˆå®‰å…¨æ£€æŸ¥ï¼‰
                if (result is Task)
                {
                    throw new InvalidOperationException($"Method '{message.MethodName}' returned a Task instead of the actual result. This should not happen.");
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯ VoidTaskResultï¼ˆTask çš„å†…éƒ¨ç±»å‹ï¼Œä¸åº”è¯¥è¢«åºåˆ—åŒ–ï¼‰
                var resultType = result?.GetType();
                if (resultType != null && resultType.Name == "VoidTaskResult")
                {
                    // VoidTaskResult ä¸åº”è¯¥è¢«åºåˆ—åŒ–ï¼Œå¯¹äº void/Task æ–¹æ³•ï¼Œè¿”å› null
                    result = null;
                }

                // ä¸è®°å½•è¿”å›ç±»å‹æ—¥å¿—ï¼ˆvoid/Task æ–¹æ³•è¿”å› null æ˜¯æ­£å¸¸çš„ï¼Œä¸éœ€è¦è®°å½•ï¼‰
                // å¦‚æœéœ€è¦è°ƒè¯•ï¼Œå¯ä»¥ä¸´æ—¶å–æ¶ˆæ³¨é‡Šä¸‹é¢è¿™è¡Œï¼š
                // if (_config.EnableVerboseLogging && result != null)
                // {
                //     RpcLog.Info($"[RpcServer] Method '{message.MethodName}' returned type: {result.GetType().FullName}");
                // }

                // å¯¹äº void æˆ– Task æ–¹æ³•ï¼Œresult åº”è¯¥æ˜¯ nullï¼Œä¸éœ€è¦åºåˆ—åŒ–
                var response = new RpcResponse
                {
                    MessageId = message.MessageId,
                    Success = true,
                    Result = result != null ? RpcSerializer.Instance.Serialize(result) : null
                };

                SendResponse(peer, response);
            }
            catch (Exception ex)
            {
                RpcLog.Error($"[RpcServer] Error handling client call '{message.MethodName}': {ex.Message}");
                var response = new RpcResponse
                {
                    MessageId = message.MessageId,
                    Success = false,
                    ErrorMessage = ex.Message
                };

                SendResponse(peer, response);
            }
        }

        private void HandleClientResponse(NetPeer peer, RpcResponse response)
        {
            if (_pendingCalls.TryGetValue(peer, out var peerCalls))
            {
                if (peerCalls.TryGetValue(response.MessageId, out var tcs))
                {
                    peerCalls.Remove(response.MessageId);
                    tcs.SetResult(response);
                }
            }
        }

        public void OnNetworkReceiveUnconnected(System.Net.IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType)
        {
        }

        public void OnNetworkLatencyUpdate(NetPeer peer, int latency)
        {
        }

        public void OnConnectionRequest(ConnectionRequest request)
        {
            if (_netManager.ConnectedPeersCount < _config.MaxClients)
            {
                request.Accept();
            }
            else
            {
                RpcLog.Warning($"[RpcServer] Connection rejected: max clients ({_config.MaxClients}) reached");
                request.Reject();
            }
        }

        #endregion
    }
}

```

`Server\RPC\RpcServerExtensions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;

namespace DuckyNet.Server.RPC
{
    /// <summary>
    /// RpcServer æ‰©å±•æ–¹æ³• - æä¾›å¼ºç±»å‹çš„å¹¿æ’­è°ƒç”¨
    /// </summary>
    public static class RpcServerExtensions
    {
        private static readonly ConcurrentDictionary<Type, object> _broadcastProxyCache = new ConcurrentDictionary<Type, object>();
        private static readonly ConcurrentDictionary<Type, object> _clientsBroadcastProxyCache = new ConcurrentDictionary<Type, object>();
        private static readonly ConcurrentDictionary<Type, object> _whereBroadcastProxyCache = new ConcurrentDictionary<Type, object>();

        /// <summary>
        /// è·å–å¼ºç±»å‹çš„å¹¿æ’­ä»£ç†ï¼ˆå¹¿æ’­åˆ°æ‰€æœ‰å®¢æˆ·ç«¯ï¼‰
        /// </summary>
        /// <typeparam name="TService">æœåŠ¡æ¥å£ç±»å‹</typeparam>
        /// <param name="server">RPCæœåŠ¡å™¨</param>
        /// <returns>å¹¿æ’­ä»£ç†å®ä¾‹</returns>
        public static TService Broadcast<TService>(this RpcServer server) where TService : class
        {
            var serviceType = typeof(TService);
            
            return (TService)_broadcastProxyCache.GetOrAdd(serviceType, t =>
            {
                // æ ¹æ®æ¥å£ç±»å‹åˆ›å»ºå¯¹åº”çš„å¹¿æ’­ä»£ç†
                // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
                var className = (t.Name.StartsWith("I") && t.Name.Length > 1 && char.IsUpper(t.Name[1])) 
                    ? t.Name.Substring(1) 
                    : t.Name;
                var proxyTypeName = $"{t.Namespace}.Generated.{className}BroadcastProxy";
                var proxyType = t.Assembly.GetType(proxyTypeName);
                
                if (proxyType == null)
                {
                    throw new InvalidOperationException(
                        $"æ‰¾ä¸åˆ°å¹¿æ’­ä»£ç†ç±»å‹: {proxyTypeName}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†ä»£ç ç”Ÿæˆå™¨ã€‚");
                }
                
                return Activator.CreateInstance(proxyType, server)!;
            });
        }

        /// <summary>
        /// è·å–å¼ºç±»å‹çš„å¹¿æ’­ä»£ç†ï¼ˆå¹¿æ’­åˆ°æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨ï¼‰
        /// </summary>
        /// <typeparam name="TService">æœåŠ¡æ¥å£ç±»å‹</typeparam>
        /// <param name="server">RPCæœåŠ¡å™¨</param>
        /// <param name="clientIds">å®¢æˆ·ç«¯IDåˆ—è¡¨</param>
        /// <returns>å¹¿æ’­ä»£ç†å®ä¾‹</returns>
        public static TService BroadcastToClients<TService>(this RpcServer server, IEnumerable<string> clientIds) where TService : class
        {
            var serviceType = typeof(TService);
            
            var proxyBase = _clientsBroadcastProxyCache.GetOrAdd(serviceType, t =>
            {
                // æ ¹æ®æ¥å£ç±»å‹åˆ›å»ºå¯¹åº”çš„å¹¿æ’­ä»£ç†
                // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
                var className = (t.Name.StartsWith("I") && t.Name.Length > 1 && char.IsUpper(t.Name[1])) 
                    ? t.Name.Substring(1) 
                    : t.Name;
                var proxyTypeName = $"{t.Namespace}.Generated.{className}ClientsBroadcastProxy";
                var proxyType = t.Assembly.GetType(proxyTypeName);
                
                if (proxyType == null)
                {
                    throw new InvalidOperationException(
                        $"æ‰¾ä¸åˆ°å¹¿æ’­ä»£ç†ç±»å‹: {proxyTypeName}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†ä»£ç ç”Ÿæˆå™¨ã€‚");
                }
                
                return proxyType;
            });

            return (TService)Activator.CreateInstance((Type)proxyBase, server, clientIds)!;
        }

        /// <summary>
        /// è·å–å¼ºç±»å‹çš„å¹¿æ’­ä»£ç†ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
        /// </summary>
        /// <typeparam name="TService">æœåŠ¡æ¥å£ç±»å‹</typeparam>
        /// <param name="server">RPCæœåŠ¡å™¨</param>
        /// <param name="predicate">å®¢æˆ·ç«¯è¿‡æ»¤å™¨</param>
        /// <returns>å¹¿æ’­ä»£ç†å®ä¾‹</returns>
        public static TService BroadcastWhere<TService>(this RpcServer server, Func<string, bool> predicate) where TService : class
        {
            var serviceType = typeof(TService);
            
            var proxyBase = _whereBroadcastProxyCache.GetOrAdd(serviceType, t =>
            {
                // æ ¹æ®æ¥å£ç±»å‹åˆ›å»ºå¯¹åº”çš„å¹¿æ’­ä»£ç†
                // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
                var className = (t.Name.StartsWith("I") && t.Name.Length > 1 && char.IsUpper(t.Name[1])) 
                    ? t.Name.Substring(1) 
                    : t.Name;
                var proxyTypeName = $"{t.Namespace}.Generated.{className}WhereBroadcastProxy";
                var proxyType = t.Assembly.GetType(proxyTypeName);
                
                if (proxyType == null)
                {
                    throw new InvalidOperationException(
                        $"æ‰¾ä¸åˆ°å¹¿æ’­ä»£ç†ç±»å‹: {proxyTypeName}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†ä»£ç ç”Ÿæˆå™¨ã€‚");
                }
                
                return proxyType;
            });

            return (TService)Activator.CreateInstance((Type)proxyBase, server, predicate)!;
        }

        /// <summary>
        /// è·å–å¼ºç±»å‹çš„å¹¿æ’­ä»£ç†ï¼ˆå¹¿æ’­åˆ°æˆ¿é—´å†…æ‰€æœ‰å®¢æˆ·ç«¯ï¼Œå¯é€‰æ’é™¤æŸä¸ªå®¢æˆ·ç«¯ï¼‰
        /// </summary>
        /// <typeparam name="TService">æœåŠ¡æ¥å£ç±»å‹</typeparam>
        /// <param name="server">RPCæœåŠ¡å™¨</param>
        /// <param name="roomId">æˆ¿é—´ID</param>
        /// <param name="exceptClientId">è¦æ’é™¤çš„å®¢æˆ·ç«¯IDï¼ˆå¯é€‰ï¼‰</param>
        /// <returns>å¹¿æ’­ä»£ç†å®ä¾‹</returns>
        public static TService BroadcastToRoom<TService>(this RpcServer server, string roomId, string? exceptClientId = null) where TService : class
        {
            // ä½¿ç”¨ BroadcastWhere å®ç°æˆ¿é—´å†…å¹¿æ’­
            return server.BroadcastWhere<TService>(clientId =>
            {
                // è¿™é‡Œéœ€è¦é€šè¿‡æŸç§æ–¹å¼è·å–å®¢æˆ·ç«¯æ‰€åœ¨æˆ¿é—´
                // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé™æ€è¾…åŠ©æ–¹æ³•
                var inRoom = RoomBroadcastHelper.IsClientInRoom(clientId, roomId);
                var notExcluded = exceptClientId == null || clientId != exceptClientId;
                return inRoom && notExcluded;
            });
        }
    }

    /// <summary>
    /// æˆ¿é—´å¹¿æ’­è¾…åŠ©ç±»ï¼ˆç”¨äº BroadcastToRoomï¼‰
    /// </summary>
    public static class RoomBroadcastHelper
    {
        private static Managers.RoomManager? _roomManager;
        private static Managers.PlayerManager? _playerManager;

        /// <summary>
        /// åˆå§‹åŒ–æˆ¿é—´å¹¿æ’­è¾…åŠ©ç±»ï¼ˆåœ¨æœåŠ¡å™¨å¯åŠ¨æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public static void Initialize(Managers.RoomManager roomManager, Managers.PlayerManager playerManager)
        {
            _roomManager = roomManager;
            _playerManager = playerManager;
        }

        /// <summary>
        /// æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦åœ¨æŒ‡å®šæˆ¿é—´ä¸­
        /// </summary>
        public static bool IsClientInRoom(string clientId, string roomId)
        {
            if (_playerManager == null || _roomManager == null)
            {
                return false;
            }

            var player = _playerManager.GetPlayer(clientId);
            if (player == null)
            {
                return false;
            }

            var playerRoom = _roomManager.GetPlayerRoom(player);
            return playerRoom != null && playerRoom.RoomId == roomId;
        }
    }
}


```

`Server\Services\AnimatorSyncServiceImpl.cs`:

```cs
using System;
using DuckyNet.Server.Core;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// åŠ¨ç”»åŒæ­¥æœåŠ¡å®ç°
    /// æ¥æ”¶å®¢æˆ·ç«¯åŠ¨ç”»çŠ¶æ€å¹¶å¹¿æ’­ç»™åŒåœºæ™¯å…¶ä»–ç©å®¶
    /// </summary>
    public class AnimatorSyncServiceImpl : IAnimatorSyncService
    {
        public void UpdateAnimatorState(IClientContext client, AnimatorSyncData animatorData)
        {
            try
            {
                // è·å–å‘é€è€…çš„ç©å®¶ä¿¡æ¯
                var senderPlayer = ServerContext.Players.GetPlayer(client.ClientId);
                if (senderPlayer == null)
                {
                    Console.WriteLine($"[AnimatorSyncService] âš ï¸ æ— æ³•æ‰¾åˆ°å®¢æˆ·ç«¯ {client.ClientId} å¯¹åº”çš„ç©å®¶");
                    return;
                }

                // éªŒè¯å‘é€è€…æ˜¯å¦åœ¨æˆ¿é—´ä¸­
                var room = ServerContext.Rooms.GetPlayerRoom(senderPlayer);
                if (room == null)
                {
                    Console.WriteLine($"[AnimatorSyncService] ç©å®¶ {senderPlayer.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­ï¼Œè·³è¿‡åŒæ­¥");
                    return;
                }

                // ä½¿ç”¨ BroadcastManager å¹¿æ’­ç»™åŒåœºæ™¯çš„ç©å®¶
                ServerContext.Broadcast.BroadcastToScene(senderPlayer, (targetPlayer, targetContext) =>
                {
                    try
                    {
                        targetContext.Call<IAnimatorSyncClientService>()
                            .OnAnimatorStateUpdated(senderPlayer.SteamId, animatorData);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[AnimatorSyncService] âŒ å‘ {targetPlayer.SteamName} è½¬å‘åŠ¨ç”»çŠ¶æ€å¤±è´¥: {ex.Message}");
                    }
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[AnimatorSyncService] é”™è¯¯: {ex.Message}");
                Console.WriteLine($"[AnimatorSyncService] å †æ ˆè·Ÿè¸ª: {ex.StackTrace}");
            }
        }
    }
}

```

`Server\Services\CharacterAppearanceServiceImpl.cs`:

```cs
using System;
using System.Collections.Generic;
using DuckyNet.Server.Core;
using DuckyNet.Server.Events;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// è§’è‰²å¤–è§‚åŒæ­¥æœåŠ¡å®ç°
    /// ç®¡ç†ç©å®¶å¤–è§‚æ•°æ®çš„å­˜å‚¨å’Œåˆ†å‘
    /// </summary>
    public class CharacterAppearanceServiceImpl : ICharacterAppearanceService
    {
        private readonly Dictionary<string, CharacterAppearanceData> _appearanceCache;
        private readonly object _lock = new object();

        public CharacterAppearanceServiceImpl(EventBus eventBus)
        {
            _appearanceCache = new Dictionary<string, CharacterAppearanceData>();
            
            // è®¢é˜…ç©å®¶æ–­å¼€äº‹ä»¶ï¼Œè‡ªåŠ¨æ¸…ç†ç¼“å­˜
            eventBus.Subscribe<PlayerDisconnectedEvent>(OnPlayerDisconnected);
        }

        /// <summary>
        /// å¤„ç†ç©å®¶æ–­å¼€äº‹ä»¶ï¼šè‡ªåŠ¨æ¸…ç†å¤–è§‚ç¼“å­˜
        /// </summary>
        private void OnPlayerDisconnected(PlayerDisconnectedEvent evt)
        {
            if (evt.Player != null)
            {
                ClearAppearance(evt.Player.SteamId);
            }
        }

        public void UploadAppearance(IClientContext client, CharacterAppearanceData appearanceData)
        {
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            if (player == null)
            {
                Console.WriteLine($"[CharacterAppearanceService] UploadAppearance failed: Player not found for client {client.ClientId}");
                return;
            }

            var steamId = player.SteamId;
            Console.WriteLine($"[CharacterAppearanceService] Uploading appearance for {player.SteamName} ({steamId})");

            lock (_lock)
            {
                // å­˜å‚¨å¤–è§‚æ•°æ®
                _appearanceCache[steamId] = appearanceData;
            }

            // è·å–ç©å®¶æ‰€åœ¨æˆ¿é—´
            var room = ServerContext.Rooms.GetPlayerRoom(player);
            if (room != null)
            {
                // ä½¿ç”¨ BroadcastManager å¹¿æ’­ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰
                Console.WriteLine($"[CharacterAppearanceService] Broadcasting appearance to room {room.RoomName}");
                
                ServerContext.Broadcast.BroadcastToRoomTyped<ICharacterAppearanceClientService>(
                    player, 
                    service => service.OnAppearanceReceived(steamId, appearanceData),
                    excludeSelf: false);
            }
            else
            {
                Console.WriteLine($"[CharacterAppearanceService] Player {steamId} is not in any room, appearance stored but not broadcasted");
            }
        }

        public void RequestAppearance(IClientContext client, string targetSteamId)
        {
            var requester = ServerContext.Players.GetPlayer(client.ClientId);
            if (requester == null)
            {
                Console.WriteLine($"[CharacterAppearanceService] RequestAppearance failed: Requester not found for client {client.ClientId}");
                return;
            }

            Console.WriteLine($"[CharacterAppearanceService] {requester.SteamName} requesting appearance for {targetSteamId}");

            CharacterAppearanceData? appearanceData = null;
            lock (_lock)
            {
                if (_appearanceCache.TryGetValue(targetSteamId, out var data))
                {
                    appearanceData = data;
                }
            }

            if (appearanceData != null)
            {
                Console.WriteLine($"[CharacterAppearanceService] Sending cached appearance for {targetSteamId}");
                
                // ç›´æ¥å‘é€ç»™è¯·æ±‚å®¢æˆ·ç«¯
                client.Call<ICharacterAppearanceClientService>()
                    .OnAppearanceReceived(targetSteamId, appearanceData);
            }
            else
            {
                Console.WriteLine($"[CharacterAppearanceService] No appearance data found for {targetSteamId}");
            }
        }

        /// <summary>
        /// æ¸…ç†ç©å®¶çš„å¤–è§‚æ•°æ®ï¼ˆç©å®¶ç¦»çº¿æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public void ClearAppearance(string steamId)
        {
            lock (_lock)
            {
                if (_appearanceCache.Remove(steamId))
                {
                    Console.WriteLine($"[CharacterAppearanceService] Cleared appearance data for {steamId}");
                }
            }
        }
    }
}

```

`Server\Services\CharacterServiceImpl.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Server.Core;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// è§’è‰²æœåŠ¡å®ç°
    /// </summary>
    public class CharacterServiceImpl : ICharacterService
    {
        public Task<bool> UpdateAppearanceAsync(IClientContext client, byte[] appearanceData)
        {
            var steamId = client.ClientId;
            if (string.IsNullOrEmpty(steamId))
            {
                Console.WriteLine($"[CharacterService] æ›´æ–°å¤–è§‚å¤±è´¥: æ— æ•ˆçš„Client ID");
                return Task.FromResult(false);
            }

            try
            {
                var player = ServerContext.Players.GetPlayer(steamId);
                if (player == null)
                {
                    Console.WriteLine($"[CharacterService] æ›´æ–°å¤–è§‚å¤±è´¥: ç©å®¶ä¸å­˜åœ¨ - {steamId}");
                    return Task.FromResult(false);
                }

                // éªŒè¯æ•°æ®å¤§å°ï¼ˆæœ€å¤§10KBï¼‰
                if (appearanceData == null || appearanceData.Length == 0)
                {
                    Console.WriteLine($"[CharacterService] æ›´æ–°å¤–è§‚å¤±è´¥: æ•°æ®ä¸ºç©º - {steamId}");
                    return Task.FromResult(false);
                }

                if (appearanceData.Length > 10240)
                {
                    Console.WriteLine($"[CharacterService] æ›´æ–°å¤–è§‚å¤±è´¥: æ•°æ®è¿‡å¤§ ({appearanceData.Length} bytes) - {steamId}");
                    return Task.FromResult(false);
                }

                // æ›´æ–°ç©å®¶å¤–è§‚æ•°æ®
                player.AppearanceData = appearanceData;
                Console.WriteLine($"[CharacterService] å¤–è§‚å·²æ›´æ–° ({appearanceData.Length} bytes) - {player.SteamName}({player.SteamId})");

                // é€šçŸ¥åŒæˆ¿é—´çš„å…¶ä»–ç©å®¶
                var room = ServerContext.Rooms.GetPlayerRoom(player);
                if (room != null)
                {
                    ServerContext.Broadcast.BroadcastToRoomExcludeSelf(player, (target, targetContext) =>
                    {
                        targetContext.Call<ICharacterClientService>()
                            .OnPlayerAppearanceUpdated(steamId, appearanceData);
                    });
                    
                    Console.WriteLine($"[CharacterService] å·²å¹¿æ’­å¤–è§‚æ›´æ–°åˆ°æˆ¿é—´ {room.RoomId}");
                }

                return Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CharacterService] æ›´æ–°å¤–è§‚å¼‚å¸¸: {ex.Message}");
                return Task.FromResult(false);
            }
        }

        public Task<byte[]?> GetAppearanceAsync(IClientContext client, string targetSteamId)
        {
            try
            {
                // é€šè¿‡ SteamId æŸ¥æ‰¾ç©å®¶
                var player = ServerContext.Players.GetPlayerBySteamId(targetSteamId);

                if (player == null)
                {
                    Console.WriteLine($"[CharacterService] è·å–å¤–è§‚å¤±è´¥: ç©å®¶ä¸å­˜åœ¨ - {targetSteamId}");
                    return Task.FromResult<byte[]?>(null);
                }

                if (player.AppearanceData == null || player.AppearanceData.Length == 0)
                {
                    Console.WriteLine($"[CharacterService] ç©å®¶æœªè®¾ç½®å¤–è§‚ - {targetSteamId}");
                    return Task.FromResult<byte[]?>(null);
                }

                Console.WriteLine($"[CharacterService] è¿”å›å¤–è§‚æ•°æ® ({player.AppearanceData.Length} bytes) - {targetSteamId}");
                return Task.FromResult<byte[]?>(player.AppearanceData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CharacterService] è·å–å¤–è§‚å¼‚å¸¸: {ex.Message}");
                return Task.FromResult<byte[]?>(null);
            }
        }

        public Task<bool> SetCharacterCreatedAsync(IClientContext client, bool hasCharacter)
        {
            var clientId = client.ClientId;
            if (string.IsNullOrEmpty(clientId))
            {
                Console.WriteLine($"[CharacterService] è®¾ç½®è§’è‰²çŠ¶æ€å¤±è´¥: æ— æ•ˆçš„Client ID");
                return Task.FromResult(false);
            }

            try
            {
                var player = ServerContext.Players.GetPlayer(clientId);
                if (player == null)
                {
                    Console.WriteLine($"[CharacterService] è®¾ç½®è§’è‰²çŠ¶æ€å¤±è´¥: ç©å®¶ä¸å­˜åœ¨ - {clientId}");
                    return Task.FromResult(false);
                }

                var wasHasCharacter = player.HasCharacter;
                player.HasCharacter = hasCharacter;
                Console.WriteLine($"[CharacterService] è§’è‰²çŠ¶æ€å·²æ›´æ–°: {wasHasCharacter} -> {hasCharacter} - {player.SteamName}({player.SteamId})");

                // å¦‚æœè§’è‰²åˆšè¢«åˆ›å»ºï¼Œä¸”ç©å®¶åœ¨åœºæ™¯ä¸­ï¼Œé€šçŸ¥åŒæˆ¿é—´çš„å…¶ä»–ç©å®¶
                if (hasCharacter && !wasHasCharacter)
                {
                    var room = ServerContext.Rooms.GetPlayerRoom(player);
                    if (room != null && !string.IsNullOrEmpty(player.CurrentScenelData.SceneName))
                    {
                        // é€šçŸ¥æˆ¿é—´å†…å…¶ä»–ç©å®¶è§’è‰²å·²åˆ›å»ºï¼ˆé‡æ–°å‘é€åœºæ™¯è¿›å…¥äº‹ä»¶ï¼‰
                        ServerContext.Broadcast.BroadcastToRoomExcludeSelf(player, (target, targetContext) =>
                        {
                            targetContext.Call<ISceneClientService>()
                                .OnPlayerEnteredScene(player, player.CurrentScenelData);
                        });
                        
                        Console.WriteLine($"[CharacterService] å·²é€šçŸ¥æˆ¿é—´ {room.RoomId} è§’è‰²åˆ›å»º");
                    }
                }

                return Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CharacterService] è®¾ç½®è§’è‰²çŠ¶æ€å¼‚å¸¸: {ex.Message}");
                return Task.FromResult(false);
            }
        }
    }
}

```

`Server\Services\EquipmentServerServiceImpl.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Server.Core;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// è£…å¤‡åŒæ­¥æœåŠ¡å™¨ç«¯å®ç°
    /// è´Ÿè´£å­˜å‚¨å’Œå¹¿æ’­ç©å®¶è£…å¤‡æ•°æ®
    /// </summary>
    public class EquipmentServerServiceImpl : IEquipmentService
    {

        /// <summary>
        /// å®¢æˆ·ç«¯æ›´æ–°è£…å¤‡æ§½ä½
        /// </summary>
        public Task<bool> UpdateEquipmentSlotAsync(IClientContext client, EquipmentSlotUpdateRequest request)
        {
            if (client == null)
            {
                Log("UpdateEquipmentSlotAsync å¤±è´¥ï¼šæ²¡æœ‰å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);
            
            if (player == null)
            {
                Log($"UpdateEquipmentSlotAsync å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            try
            {
                // æ›´æ–°æœåŠ¡å™¨ç«¯çš„è£…å¤‡æ•°æ®
                player.EquipmentData.SetEquipment(request.SlotType, request.ItemTypeId);

                string action = request.ItemTypeId.HasValue && request.ItemTypeId.Value > 0 ? "è£…å¤‡" : "å¸ä¸‹";
                Log($"ç©å®¶ {player.SteamName} {action}è£…å¤‡: {request.SlotType} = {request.ItemTypeId}", ConsoleColor.Green);

                // å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastEquipmentUpdate(player, request);

                return Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Log($"UpdateEquipmentSlotAsync å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
                return Task.FromResult(false);
            }
        }

        /// <summary>
        /// å¹¿æ’­è£…å¤‡æ›´æ–°åˆ°æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
        /// </summary>
        private void BroadcastEquipmentUpdate(PlayerInfo player, EquipmentSlotUpdateRequest request)
        {
            // è·å–ç©å®¶æ‰€åœ¨çš„æˆ¿é—´
            var room = ServerContext.Rooms.GetPlayerRoom(player);
            if (room == null)
            {
                Log($"ç©å®¶ {player.SteamName} ä¸åœ¨æˆ¿é—´ä¸­ï¼Œæ— éœ€å¹¿æ’­è£…å¤‡æ›´æ–°", ConsoleColor.Yellow);
                return;
            }

            // åˆ›å»ºå¹¿æ’­é€šçŸ¥
            var notification = new EquipmentSlotUpdateNotification
            {
                PlayerId = player.SteamId,
                SlotType = request.SlotType,
                ItemTypeId = request.ItemTypeId
            };

            // ä½¿ç”¨ BroadcastManager ç®€åŒ–å¹¿æ’­é€»è¾‘
            ServerContext.Broadcast.BroadcastToRoomTyped<IEquipmentClientService>(player, 
                service => service.OnEquipmentSlotUpdated(notification));
                
            Log($"è£…å¤‡æ›´æ–°å·²å¹¿æ’­ (æˆ¿é—´: {room.RoomId})", ConsoleColor.Cyan);
        }

        /// <summary>
        /// å½“ç©å®¶åŠ å…¥æˆ¿é—´æ—¶ï¼Œå‘é€æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®
        /// ç”± RoomService è°ƒç”¨
        /// </summary>
        public void SendAllEquipmentDataToPlayer(string clientId, string roomId)
        {
            try
            {
                var roomPlayers = ServerContext.Rooms.GetRoomPlayers(roomId);
                if (roomPlayers == null || roomPlayers.Length == 0)
                {
                    Log($"æˆ¿é—´ {roomId} æ²¡æœ‰å…¶ä»–ç©å®¶ï¼Œè·³è¿‡å‘é€è£…å¤‡æ•°æ®", ConsoleColor.Yellow);
                    return;
                }

                // æ”¶é›†æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®
                var allEquipmentData = new AllPlayersEquipmentData();
                
                foreach (var player in roomPlayers)
                {
                    // åŒ…æ‹¬è‡ªå·±çš„æ•°æ®ä¹Ÿå‘é€ï¼ˆå®¢æˆ·ç«¯å¯ä»¥ç”¨æ¥éªŒè¯ï¼‰
                    if (player.EquipmentData.GetEquippedCount() > 0)
                    {
                        allEquipmentData.PlayersEquipment[player.SteamId] = player.EquipmentData.Clone();
                    }
                }

                // å‘é€ç»™æ–°åŠ å…¥çš„ç©å®¶
                var clientContext = ServerContext.Server.GetClientContext(clientId);
                if (clientContext != null)
                {
                    clientContext.Call<IEquipmentClientService>()
                        .OnAllPlayersEquipmentReceived(allEquipmentData);
                }
            }
            catch (Exception ex)
            {
                Log($"SendAllEquipmentDataToPlayer å¤±è´¥: {ex.Message}", ConsoleColor.Red);
            }
        }

        /// <summary>
        /// æ—¥å¿—è¾“å‡º
        /// </summary>
        private void Log(string message, ConsoleColor color = ConsoleColor.White)
        {
            Console.ForegroundColor = color;
            Console.WriteLine($"[EquipmentService] {message}");
            Console.ResetColor();
        }
    }
}


```

`Server\Services\HealthSyncServiceImpl.cs`:

```cs
using System;
using System.Collections.Generic;
using DuckyNet.Server.Core;
using DuckyNet.Server.Events;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// è¡€é‡åŒæ­¥æœåŠ¡å®ç°
    /// å¤„ç†ç©å®¶è¡€é‡åŒæ­¥æ•°æ®çš„è½¬å‘
    /// </summary>
    public class HealthSyncServiceImpl : IHealthSyncService
    {
        private readonly object _lock = new object();
        
        /// <summary>
        /// ç©å®¶æœ€åè¡€é‡ç¼“å­˜ - Key: SteamId, Value: æœ€åçš„è¡€é‡æ•°æ®
        /// </summary>
        private readonly Dictionary<string, HealthSyncData> _lastHealthCache = new Dictionary<string, HealthSyncData>();

        public HealthSyncServiceImpl(EventBus eventBus)
        {
            // è®¢é˜…ç©å®¶æ–­å¼€äº‹ä»¶ï¼Œè‡ªåŠ¨æ¸…ç†ç¼“å­˜
            eventBus.Subscribe<PlayerDisconnectedEvent>(OnPlayerDisconnected);
        }

        /// <summary>
        /// å¤„ç†ç©å®¶æ–­å¼€äº‹ä»¶ï¼šè‡ªåŠ¨æ¸…ç†è¡€é‡ç¼“å­˜
        /// </summary>
        private void OnPlayerDisconnected(PlayerDisconnectedEvent evt)
        {
            if (evt.Player != null)
            {
                ClearPlayerHealth(evt.Player.SteamId);
            }
        }
        
        /// <summary>
        /// è·å–ç©å®¶çš„æœ€åè¡€é‡ï¼ˆç”¨äºæ–°ç©å®¶åŠ å…¥æˆ¿é—´æ—¶åŒæ­¥ï¼‰
        /// </summary>
        public HealthSyncData? GetLastHealth(string steamId)
        {
            lock (_lock)
            {
                if (_lastHealthCache.TryGetValue(steamId, out var lastHealth))
                {
                    return lastHealth;
                }
                return null;
            }
        }
        
        /// <summary>
        /// æ¸…é™¤ç©å®¶çš„è¡€é‡ç¼“å­˜ï¼ˆç©å®¶ç¦»å¼€æˆ¿é—´/æ–­å¼€è¿æ¥æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public void ClearPlayerHealth(string steamId)
        {
            lock (_lock)
            {
                if (_lastHealthCache.Remove(steamId))
                {
                    Console.WriteLine($"[HealthSyncService] æ¸…é™¤ç©å®¶ {steamId} çš„è¡€é‡ç¼“å­˜");
                }
            }
        }

        public void SendHealthSync(IClientContext client, HealthSyncData healthData)
        {
            try
            {
                // è·å–å‘é€è€…çš„ç©å®¶ä¿¡æ¯
                var senderPlayer = ServerContext.Players.GetPlayer(client.ClientId);
                if (senderPlayer == null)
                {
                    Console.WriteLine($"[HealthSyncService] âš ï¸ æ— æ³•æ‰¾åˆ°å®¢æˆ·ç«¯ {client.ClientId} å¯¹åº”çš„ç©å®¶");
                    return;
                }
                
                // ç¡®ä¿ SteamId ä¸å‘é€è€…åŒ¹é…ï¼ˆå®‰å…¨éªŒè¯ï¼‰
                healthData.SteamId = senderPlayer.SteamId;
                
                // ç¼“å­˜æœ€åè¡€é‡ï¼ˆç”¨äºæ–°ç©å®¶åŠ å…¥æ—¶åŒæ­¥ï¼‰
                lock (_lock)
                {
                    _lastHealthCache[senderPlayer.SteamId] = healthData;
                }

                // éªŒè¯å‘é€è€…æ˜¯å¦åœ¨æˆ¿é—´ä¸­
                var room = ServerContext.Rooms.GetPlayerRoom(senderPlayer);
                if (room == null)
                {
                    Console.WriteLine($"[HealthSyncService] ç©å®¶ {senderPlayer.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­ï¼Œè·³è¿‡åŒæ­¥");
                    return;
                }

                // ä½¿ç”¨ BroadcastManager å¹¿æ’­ç»™åŒåœºæ™¯çš„ç©å®¶
                ServerContext.Broadcast.BroadcastToScene(senderPlayer, (targetPlayer, targetContext) =>
                {
                    try
                    {
                        targetContext.Call<IHealthSyncClientService>().OnHealthSyncReceived(healthData);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[HealthSyncService] âŒ å‘ {targetPlayer.SteamName} è½¬å‘è¡€é‡æ•°æ®å¤±è´¥: {ex.Message}");
                    }
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[HealthSyncService] å¤„ç†è¡€é‡åŒæ­¥æ•°æ®å¼‚å¸¸: {ex.Message}");
                Console.WriteLine($"[HealthSyncService] å †æ ˆè·Ÿè¸ª: {ex.StackTrace}");
            }
        }
    }
}

```

`Server\Services\ItemSyncServiceImpl.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using DuckyNet.Server.Core;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// ç‰©å“åŒæ­¥æœåŠ¡å®ç°
    /// ç®¡ç†æ‰€æœ‰æ‰è½ç‰©å“ï¼Œåˆ†é…å…¨å±€ DropIdï¼Œå¹¿æ’­ç»™æˆ¿é—´å†…ç©å®¶
    /// </summary>
    public class ItemSyncServiceImpl : IItemSyncService
    {
        // DropId ç”Ÿæˆå™¨ï¼ˆåŸå­é€’å¢ï¼‰
        private uint _nextDropId = 1;
        private readonly object _dropIdLock = new object();

        // ç‰©å“æ˜ å°„ï¼šDropId -> (RoomId, ItemData)
        private readonly ConcurrentDictionary<uint, (string RoomId, ItemDropData ItemData)> _droppedItems 
            = new ConcurrentDictionary<uint, (string, ItemDropData)>();

        /// <summary>
        /// ä¸¢å¼ƒç‰©å“
        /// </summary>
        public async Task<uint> DropItemAsync(IClientContext client, ItemDropData dropData)
        {
            try
            {
                // è·å–ç©å®¶ä¿¡æ¯
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null)
                {
                    Console.WriteLine($"[ItemSyncService] ä¸¢å¼ƒå¤±è´¥ - æœªæ‰¾åˆ°ç©å®¶: ClientId={client.ClientId}");
                    return 0;
                }

                // è·å–ç©å®¶æ‰€åœ¨æˆ¿é—´
                var room = ServerContext.Rooms.GetPlayerRoom(player);
                if (room == null)
                {
                    // ä¸åœ¨æˆ¿é—´ä¸­ï¼šå…è®¸ä¸¢å¼ƒï¼Œä½†ä¸åŒæ­¥ï¼ˆä»…æœ¬åœ°å¯è§ï¼‰
                    Console.WriteLine($"[ItemSyncService] ç©å®¶ä¸åœ¨æˆ¿é—´ï¼Œç‰©å“ä»…æœ¬åœ°å¯è§ - Player={player.SteamName}");
                    return 0; // è¿”å› 0 è¡¨ç¤ºä»…æœ¬åœ°ä¸¢å¼ƒ
                }

                // åˆ†é…å…¨å±€ DropId
                uint dropId = AllocateDropId();
                dropData.DropId = dropId;
                dropData.DroppedByPlayerId = player.SteamId;

                // è®°å½•ç‰©å“
                _droppedItems[dropId] = (room.RoomId, dropData);

                Console.WriteLine($"[ItemSyncService] ç‰©å“ä¸¢å¼ƒ - DropId={dropId}, Item={dropData.ItemName}, " +
                                 $"Player={player.SteamName}, Room={room.RoomId}, IsDefault={dropData.IsDefaultItem}");

                // ä½¿ç”¨ BroadcastManager å¹¿æ’­åˆ°åŒåœºæ™¯çš„å…¶ä»–ç©å®¶
                ServerContext.Broadcast.BroadcastToSceneTyped<IItemSyncClientService>(player, 
                    service => service.OnRemoteItemDropped(dropData));

                Console.WriteLine($"[ItemSyncService] å·²å¹¿æ’­åˆ°æˆ¿é—´ {room.RoomId} åŒåœºæ™¯çš„å…¶ä»–ç©å®¶");

                return await Task.FromResult(dropId);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ItemSyncService] ä¸¢å¼ƒå¼‚å¸¸: {ex.Message}\n{ex.StackTrace}");
                return 0;
            }
        }

        /// <summary>
        /// æ‹¾å–ç‰©å“
        /// </summary>
        public async Task<bool> PickupItemAsync(IClientContext client, ItemPickupRequest request)
        {
            try
            {
                // è·å–ç©å®¶ä¿¡æ¯
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null)
                {
                    Console.WriteLine($"[ItemSyncService] æ‹¾å–å¤±è´¥ - æœªæ‰¾åˆ°ç©å®¶: ClientId={client.ClientId}");
                    return false;
                }

                // è·å–ç©å®¶æ‰€åœ¨æˆ¿é—´
                var room = ServerContext.Rooms.GetPlayerRoom(player);
                if (room == null)
                {
                    Console.WriteLine($"[ItemSyncService] æ‹¾å–å¤±è´¥ - ç©å®¶ä¸åœ¨æˆ¿é—´ä¸­: {player.SteamName}");
                    return false;
                }

                // æ£€æŸ¥ç‰©å“æ˜¯å¦å­˜åœ¨
                if (!_droppedItems.TryRemove(request.DropId, out var itemInfo))
                {
                    Console.WriteLine($"[ItemSyncService] æ‹¾å–å¤±è´¥ - ç‰©å“ä¸å­˜åœ¨: DropId={request.DropId}");
                    return false;
                }

                // éªŒè¯æˆ¿é—´
                if (itemInfo.RoomId != room.RoomId)
                {
                    Console.WriteLine($"[ItemSyncService] æ‹¾å–å¤±è´¥ - ç‰©å“ä¸åœ¨åŒä¸€æˆ¿é—´: DropId={request.DropId}, " +
                                     $"ItemRoom={itemInfo.RoomId}, PlayerRoom={room.RoomId}");
                    return false;
                }

                Console.WriteLine($"[ItemSyncService] ç‰©å“æ‹¾å– - DropId={request.DropId}, Item={itemInfo.ItemData.ItemName}, " +
                                 $"Player={player.SteamName}, Room={room.RoomId}");

                // ä½¿ç”¨ BroadcastManager å¹¿æ’­åˆ°åŒåœºæ™¯çš„å…¶ä»–ç©å®¶
                ServerContext.Broadcast.BroadcastToSceneTyped<IItemSyncClientService>(player, 
                    service => service.OnRemoteItemPickedUp(request.DropId, player.SteamId));

                Console.WriteLine($"[ItemSyncService] å·²å¹¿æ’­æ‹¾å–åˆ°æˆ¿é—´ {room.RoomId} åŒåœºæ™¯çš„å…¶ä»–ç©å®¶");

                return await Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ItemSyncService] æ‹¾å–å¼‚å¸¸: {ex.Message}\n{ex.StackTrace}");
                return false;
            }
        }

        /// <summary>
        /// åˆ†é…æ–°çš„ DropId
        /// </summary>
        private uint AllocateDropId()
        {
            lock (_dropIdLock)
            {
                uint id = _nextDropId++;
                // é˜²æ­¢æº¢å‡ºï¼ˆä» 1 å¼€å§‹ï¼‰
                if (_nextDropId == 0)
                {
                    _nextDropId = 1;
                }
                return id;
            }
        }

        /// <summary>
        /// æ¸…ç†æŒ‡å®šæˆ¿é—´çš„æ‰€æœ‰ç‰©å“ï¼ˆæˆ¿é—´å…³é—­æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public void ClearRoomItems(string roomId)
        {
            int removedCount = 0;
            foreach (var kvp in _droppedItems)
            {
                if (kvp.Value.RoomId == roomId)
                {
                    if (_droppedItems.TryRemove(kvp.Key, out _))
                    {
                        removedCount++;
                    }
                }
            }

            if (removedCount > 0)
            {
                Console.WriteLine($"[ItemSyncService] å·²æ¸…ç†æˆ¿é—´ {roomId} çš„ {removedCount} ä¸ªæ‰è½ç‰©å“");
            }
        }

        /// <summary>
        /// è·å–ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public string GetStats()
        {
            return $"ItemSyncService Stats:\n" +
                   $"  Total Dropped Items: {_droppedItems.Count}\n" +
                   $"  Next DropId: {_nextDropId}";
        }
    }
}

```

`Server\Services\NpcSyncServiceImpl.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.RPC;
using DuckyNet.Server.Core;
using DuckyNet.Server.Managers;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// NPC åŒæ­¥æœåŠ¡å®ç°ï¼ˆç®€åŒ–æ¶æ„ï¼šç©å®¶ â†’ NPC åˆ—è¡¨ï¼‰
    /// </summary>
    public class NpcSyncServiceImpl : INpcSyncService
    {
        private readonly PlayerNpcManager _playerNpcManager;
        private readonly NpcVisibilityTracker _visibilityTracker;

        public NpcSyncServiceImpl(PlayerNpcManager playerNpcManager, NpcVisibilityTracker visibilityTracker)
        {
            _playerNpcManager = playerNpcManager ?? throw new ArgumentNullException(nameof(playerNpcManager));
            _visibilityTracker = visibilityTracker ?? throw new ArgumentNullException(nameof(visibilityTracker));
        }

        /// <summary>
        /// å®¢æˆ·ç«¯é€šçŸ¥ NPC ç”Ÿæˆï¼ˆè®°å½•å¹¶ä¸»åŠ¨æ¨é€ç»™èŒƒå›´å†…ç©å®¶ï¼‰
        /// </summary>
        public async Task NotifyNpcSpawned(IClientContext client, NpcSpawnData spawnData)
        {
            try
            {
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null) return;

                Console.WriteLine($"[NpcSyncService] ğŸ“¥ æ”¶åˆ° NPC ç”Ÿæˆ: {spawnData.NpcType} (ID: {spawnData.NpcId}, æ¥è‡ª: {player.SteamName})");

                // 1. è®°å½•åˆ°ç©å®¶çš„ NPC åˆ—è¡¨
                _playerNpcManager.AddNpc(player.SteamId, spawnData);

                // 2. ğŸ”¥ ä¸»åŠ¨æ¨é€ç»™èŒƒå›´å†…çš„å…¶ä»–ç©å®¶
                var scenePlayers = ServerContext.Players.GetScenePlayers(player, excludeSelf: true);
                if (scenePlayers.Count == 0)
                {
                    Console.WriteLine($"[NpcSyncService] âœ… NPC å·²è®°å½•ï¼ˆæ— å…¶ä»–ç©å®¶åœ¨åœºæ™¯ï¼‰");
                    return;
                }

                // è·å–åœºæ™¯æ‰€æœ‰ NPCï¼ˆç”¨äºå¯è§æ€§è®¡ç®—ï¼‰
                var allNpcs = _playerNpcManager.GetSceneNpcs(
                    player.CurrentScenelData?.SceneName ?? "", 
                    player.CurrentScenelData?.SubSceneName ?? ""
                );

                // å¯¹æ¯ä¸ªç©å®¶æ£€æŸ¥å¯è§æ€§å¹¶æ¨é€
                int pushedCount = 0;
                foreach (var targetPlayer in scenePlayers)
                {
                    var targetClientId = ServerContext.Players.GetClientIdBySteamId(targetPlayer.SteamId);
                    if (targetClientId == null) continue;

                    // æ›´æ–°å¯è§æ€§
                    var change = _visibilityTracker.UpdatePlayerVisibility(
                        targetClientId,
                        targetPlayer,
                        allNpcs
                    );

                    // å¦‚æœæ–° NPC åœ¨è¯¥ç©å®¶èŒƒå›´å†…ï¼Œæ¨é€
                    if (change.EnteredRange.Contains(spawnData.NpcId))
                    {
                        ServerContext.Broadcast.CallClientTyped<INpcSyncClientService>(targetPlayer,
                            service => service.OnNpcSpawned(spawnData));
                        pushedCount++;
                        Console.WriteLine($"[NpcSyncService] ğŸš€ ä¸»åŠ¨æ¨é€ NPC {spawnData.NpcId} ç»™ {targetPlayer.SteamName}");
                    }
                }

                Console.WriteLine($"[NpcSyncService] âœ… NPC å·²è®°å½•å¹¶æ¨é€ç»™ {pushedCount} ä¸ªç©å®¶");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[NpcSyncService] å¤„ç† NPC ç”Ÿæˆå¤±è´¥: {ex.Message}");
            }

            await Task.CompletedTask;
        }

        /// <summary>
        /// å®¢æˆ·ç«¯é€šçŸ¥ NPC ä½ç½®æ›´æ–°ï¼ˆå•ä¸ª - å·²åºŸå¼ƒï¼Œä½¿ç”¨æ‰¹é‡æ›´æ–°ï¼‰
        /// </summary>
        public async Task NotifyNpcTransform(IClientContext client, NpcTransformData transformData)
        {
            try
            {
                // è½¬æ¢ä¸ºæ‰¹é‡æ•°æ®
                var batchData = new NpcBatchTransformData
                {
                    Count = 1,
                    NpcIds = new[] { transformData.NpcId },
                    PositionsX = new[] { transformData.PositionX },
                    PositionsY = new[] { transformData.PositionY },
                    PositionsZ = new[] { transformData.PositionZ },
                    RotationsY = new[] { transformData.RotationY }
                };

                // è°ƒç”¨æ‰¹é‡æ›´æ–°
                await NotifyNpcBatchTransform(client, batchData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[NpcSyncService] å¤„ç† NPC ä½ç½®æ›´æ–°å¤±è´¥: {ex.Message}");
            }
        }

        /// <summary>
        /// å®¢æˆ·ç«¯é€šçŸ¥ NPC æ‰¹é‡ä½ç½®æ›´æ–°ï¼ˆå¸¦èŒƒå›´è¿‡æ»¤ï¼‰
        /// </summary>
        public async Task NotifyNpcBatchTransform(IClientContext client, NpcBatchTransformData batchData)
        {
            try
            {
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null || batchData.Count == 0) return;

                // ğŸ”¥ 1. å…ˆæ›´æ–°æœåŠ¡å™¨è®°å½•çš„ NPC ä½ç½®ï¼ˆå³ä½¿æ²¡æœ‰å…¶ä»–ç©å®¶ä¹Ÿè¦æ›´æ–°ï¼ï¼‰
                for (int i = 0; i < batchData.Count; i++)
                {
                    _playerNpcManager.UpdateNpcPosition(
                        batchData.NpcIds[i],
                        batchData.PositionsX[i],
                        batchData.PositionsY[i],
                        batchData.PositionsZ[i],
                        batchData.RotationsY[i]
                    );
                }

                // 2. è·å–åŒåœºæ™¯çš„å…¶ä»–ç©å®¶
                var scenePlayers = ServerContext.Players.GetScenePlayers(player, excludeSelf: true);
                if (scenePlayers.Count == 0) return; // æ²¡æœ‰å…¶ä»–ç©å®¶ï¼Œæ— éœ€å¹¿æ’­

                // 3. è·å–åœºæ™¯æ‰€æœ‰ç©å®¶çš„ NPCï¼ˆç”¨äºå¯è§æ€§è®¡ç®—ï¼‰
                var allNpcs = _playerNpcManager.GetSceneNpcs(
                    player.CurrentScenelData?.SceneName ?? "", 
                    player.CurrentScenelData?.SubSceneName ?? ""
                );

                // å¯¹æ¯ä¸ªç©å®¶å•ç‹¬è¿‡æ»¤å’Œå‘é€
                foreach (var targetPlayer in scenePlayers)
                {
                    // è·å–è¯¥ç©å®¶çš„å®¢æˆ·ç«¯ ID
                    var targetClientId = ServerContext.Players.GetClientIdBySteamId(targetPlayer.SteamId);
                    if (targetClientId == null) continue;

                    // ğŸ”¥ æ›´æ–°å¯è§æ€§ï¼ˆæ£€æµ‹è¿›å…¥/ç¦»å¼€èŒƒå›´çš„ NPCï¼‰
                    var change = _visibilityTracker.UpdatePlayerVisibility(
                        targetClientId,
                        targetPlayer,
                        allNpcs
                    );

                    // å¤„ç†æ–°è¿›å…¥èŒƒå›´çš„ NPCï¼ˆå‘é€åˆ›å»ºï¼‰
                    foreach (var enteredNpcId in change.EnteredRange)
                    {
                        var enteredNpc = allNpcs.FirstOrDefault(n => n.NpcId == enteredNpcId);
                        if (enteredNpc != null)
                        {
                            ServerContext.Broadcast.CallClientTyped<INpcSyncClientService>(targetPlayer,
                                service => service.OnNpcSpawned(enteredNpc));
                            Console.WriteLine($"[NpcSyncService] ğŸ†• NPC {enteredNpcId} è¿›å…¥ {targetPlayer.SteamName} èŒƒå›´");
                        }
                    }

                    // å¤„ç†ç¦»å¼€èŒƒå›´çš„ NPCï¼ˆå‘é€é”€æ¯ï¼‰
                    foreach (var leftNpcId in change.LeftRange)
                    {
                        ServerContext.Broadcast.CallClientTyped<INpcSyncClientService>(targetPlayer,
                            service => service.OnNpcDestroyed(new NpcDestroyData { NpcId = leftNpcId, Reason = 1 }));
                        Console.WriteLine($"[NpcSyncService] ğŸ—‘ï¸ NPC {leftNpcId} ç¦»å¼€ {targetPlayer.SteamName} èŒƒå›´");
                    }

                    // è¿‡æ»¤åœ¨èŒƒå›´å†…çš„ NPCï¼ˆåªå‘é€ä½ç½®æ›´æ–°ï¼‰
                    var visibleIndices = _visibilityTracker.FilterVisibleNpcIndices(targetClientId, batchData.NpcIds);

                    if (visibleIndices.Count > 0)
                    {
                        // æ„å»ºè¿‡æ»¤åçš„æ‰¹é‡æ•°æ®
                        var filteredBatch = new NpcBatchTransformData
                        {
                            Count = visibleIndices.Count,
                            NpcIds = visibleIndices.Select(i => batchData.NpcIds[i]).ToArray(),
                            PositionsX = visibleIndices.Select(i => batchData.PositionsX[i]).ToArray(),
                            PositionsY = visibleIndices.Select(i => batchData.PositionsY[i]).ToArray(),
                            PositionsZ = visibleIndices.Select(i => batchData.PositionsZ[i]).ToArray(),
                            RotationsY = visibleIndices.Select(i => batchData.RotationsY[i]).ToArray()
                        };

                        // å‘é€ç»™ç›®æ ‡ç©å®¶
                        ServerContext.Broadcast.CallClientTyped<INpcSyncClientService>(targetPlayer,
                            service => service.OnNpcBatchTransform(filteredBatch));
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[NpcSyncService] å¤„ç†æ‰¹é‡ä½ç½®æ›´æ–°å¤±è´¥: {ex.Message}");
            }

            await Task.CompletedTask;
        }

        /// <summary>
        /// å®¢æˆ·ç«¯é€šçŸ¥ NPC é”€æ¯
        /// </summary>
        public async Task NotifyNpcDestroyed(IClientContext client, NpcDestroyData destroyData)
        {
            try
            {
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null) return;

                Console.WriteLine($"[NpcSyncService] ğŸ—‘ï¸ æ”¶åˆ° NPC é”€æ¯: {destroyData.NpcId} (æ¥è‡ª: {player.SteamName})");

                // ä»ç©å®¶çš„ NPC åˆ—è¡¨ä¸­ç§»é™¤
                _playerNpcManager.RemoveNpc(destroyData.NpcId);

                // å¹¿æ’­ç»™åŒåœºæ™¯çš„å…¶ä»–ç©å®¶
                ServerContext.Broadcast.BroadcastToSceneTyped<INpcSyncClientService>(player, 
                    service => service.OnNpcDestroyed(destroyData), 
                    excludeSelf: true);

                Console.WriteLine($"[NpcSyncService] âœ… NPC é”€æ¯å·²å¹¿æ’­");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[NpcSyncService] å¤„ç† NPC é”€æ¯å¤±è´¥: {ex.Message}");
            }

            await Task.CompletedTask;
        }

        /// <summary>
        /// ç©å®¶è¯·æ±‚åœºæ™¯å†…æ‰€æœ‰ NPCï¼ˆä¸­é€”åŠ å…¥æ—¶ - å¸¦èŒƒå›´è¿‡æ»¤ï¼‰
        /// </summary>
        public Task<NpcSpawnData[]> RequestSceneNpcs(IClientContext client, string sceneName, string subSceneName)
        {
            try
            {
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null)
                {
                    Console.WriteLine($"[NpcSyncService] âš ï¸ æœªæ‰¾åˆ°ç©å®¶: {client.ClientId}");
                    return Task.FromResult(Array.Empty<NpcSpawnData>());
                }

                Console.WriteLine($"[NpcSyncService] ğŸ“¥ ç©å®¶è¯·æ±‚åœºæ™¯ NPC: {player.SteamName} â†’ {sceneName}/{subSceneName}");

                // è·å–åœºæ™¯æ‰€æœ‰ç©å®¶çš„ NPC
                var allNpcs = _playerNpcManager.GetSceneNpcs(sceneName, subSceneName);

                // ğŸ”¥ åˆå§‹åŒ–è¯¥ç©å®¶çš„å¯è§æ€§ï¼ˆé‡è¦ï¼ï¼‰
                var change = _visibilityTracker.UpdatePlayerVisibility(
                    client.ClientId,
                    player,
                    allNpcs
                );

                // åªè¿”å›å¯è§èŒƒå›´å†…çš„ NPC
                var visibleNpcs = allNpcs
                    .Where(n => change.CurrentVisible.Contains(n.NpcId))
                    .ToArray();

                Console.WriteLine($"[NpcSyncService] âœ… è¿”å› {visibleNpcs.Length}/{allNpcs.Count} ä¸ªå¯è§ NPC");

                return Task.FromResult(visibleNpcs);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[NpcSyncService] è¯·æ±‚åœºæ™¯ NPC å¤±è´¥: {ex.Message}");
                return Task.FromResult(Array.Empty<NpcSpawnData>());
            }
        }

        /// <summary>
        /// è¯·æ±‚å•ä¸ª NPC ä¿¡æ¯ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
        /// </summary>
        public Task<NpcSpawnData?> RequestSingleNpc(IClientContext client, string npcId)
        {
            try
            {
                var player = ServerContext.Players.GetPlayer(client.ClientId);
                if (player == null)
                {
                    Console.WriteLine($"[NpcSyncService] âš ï¸ æœªæ‰¾åˆ°ç©å®¶: {client.ClientId}");
                    return Task.FromResult<NpcSpawnData?>(null);
                }

                Console.WriteLine($"[NpcSyncService] ğŸ“¥ ç©å®¶è¯·æ±‚å•ä¸ª NPC: {player.SteamName} â†’ {npcId}");

                // ä»æ‰€æœ‰ç©å®¶çš„ NPC ä¸­æŸ¥æ‰¾
                var npc = _playerNpcManager.GetNpcById(npcId);
                if (npc == null)
                {
                    Console.WriteLine($"[NpcSyncService] âš ï¸ NPC ä¸å­˜åœ¨: {npcId}");
                    return Task.FromResult<NpcSpawnData?>(null);
                }

                // æ£€æŸ¥å¯è§æ€§ï¼ˆåªè¿”å›èŒƒå›´å†…çš„ NPCï¼‰
                var distance = CalculateDistance(player, npc);
                if (distance > _visibilityTracker.SyncRange)
                {
                    Console.WriteLine($"[NpcSyncService] âš ï¸ NPC è¶…å‡ºèŒƒå›´: {npcId} (è·ç¦»: {distance:F1}m)");
                    return Task.FromResult<NpcSpawnData?>(null);
                }

                Console.WriteLine($"[NpcSyncService] âœ… è¿”å›å•ä¸ª NPC: {npcId} (è·ç¦»: {distance:F1}m)");
                return Task.FromResult<NpcSpawnData?>(npc);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[NpcSyncService] è¯·æ±‚å•ä¸ª NPC å¤±è´¥: {ex.Message}");
                return Task.FromResult<NpcSpawnData?>(null);
            }
        }

        /// <summary>
        /// è®¡ç®—ç©å®¶ä¸ NPC çš„è·ç¦»
        /// </summary>
        private float CalculateDistance(PlayerInfo player, NpcSpawnData npc)
        {
            // ä» SceneManager ç¼“å­˜ä¸­è·å–ç©å®¶ä½ç½®
            var playerPosNullable = ServerContext.Scenes.GetPlayerPosition(player.SteamId);
            if (!playerPosNullable.HasValue)
            {
                return float.MaxValue;
            }

            var playerPos = playerPosNullable.Value;
            float dx = playerPos.X - npc.PositionX;
            float dy = playerPos.Y - npc.PositionY;
            float dz = playerPos.Z - npc.PositionZ;
            return (float)Math.Sqrt(dx * dx + dy * dy + dz * dz);
        }
    }
}


```

`Server\Services\PlayerServiceImpl.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Server.Core;
using DuckyNet.Server.Events;
using DuckyNet.Server.RPC;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// ç©å®¶æœåŠ¡å®ç°
    /// </summary>
    public class PlayerServiceImpl : IPlayerService
    {
        public async Task<LoginResult> LoginAsync(IClientContext client, PlayerInfo playerInfo)
        {
            Console.WriteLine($"[PlayerService] Login request from {playerInfo.SteamName} ({playerInfo.SteamId})");
            Console.WriteLine($"[PlayerService] AvatarUrl: {playerInfo.AvatarUrl ?? "(null)"}");

            var result = ServerContext.Players.OnClientLogin(client.ClientId, playerInfo);

            if (result.Success)
            {
                // é€šçŸ¥æ‰€æœ‰åœ¨çº¿ç©å®¶ï¼ˆå…¨å±€å¹¿æ’­ï¼‰
                var allPlayers = ServerContext.Players.GetAllOnlinePlayers();
                var clientIds = allPlayers
                    .Select(p => ServerContext.Players.GetClientIdBySteamId(p.SteamId))
                    .Where(id => !string.IsNullOrEmpty(id))
                    .Cast<string>()
                    .ToList();
                
                if (clientIds.Count > 0)
                {
                    ServerContext.Server.BroadcastToClients<IPlayerClientService>(clientIds)
                        .OnPlayerJoined(playerInfo);
                }
                
                // å‘å¸ƒç™»å½•äº‹ä»¶
                ServerEventPublisher.PublishPlayerLogin(client.ClientId, playerInfo);
            }

            return await Task.FromResult(result);
        }

        public void Logout(IClientContext client)
        {
            Console.WriteLine($"[PlayerService] Logout request from {client.ClientId}");
            
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            if (player != null)
            {
                // é€šçŸ¥æ‰€æœ‰åœ¨çº¿ç©å®¶
                var allPlayers = ServerContext.Players.GetAllOnlinePlayers();
                var clientIds = allPlayers
                    .Select(p => ServerContext.Players.GetClientIdBySteamId(p.SteamId))
                    .Where(id => !string.IsNullOrEmpty(id))
                    .Cast<string>()
                    .ToList();
                
                if (clientIds.Count > 0)
                {
                    ServerContext.Server.BroadcastToClients<IPlayerClientService>(clientIds)
                        .OnPlayerLeft(player);
                }
                
                Console.WriteLine($"[PlayerService] Player logged out: {player.SteamName}");
                
                // å‘å¸ƒç™»å‡ºäº‹ä»¶
                ServerEventPublisher.PublishPlayerLogout(client.ClientId, player);
            }
        }

        public void SendChatMessage(IClientContext client, string message)
        {
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            if (player == null)
            {
                Console.WriteLine($"[Chat] ç©å®¶æœªæ‰¾åˆ°: ClientId={client.ClientId}");
                return;
            }

            Console.WriteLine($"[Chat] {player.SteamName}: {message}");
            
            // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨æˆ¿é—´ä¸­
            var room = ServerContext.Rooms.GetPlayerRoom(player);
            
            if (room != null)
            {
                // åœ¨æˆ¿é—´ä¸­ï¼Œå¹¿æ’­åˆ°æˆ¿é—´å†…æ‰€æœ‰ç©å®¶ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰
                Console.WriteLine($"[Chat] å¹¿æ’­åˆ°æˆ¿é—´ {room.RoomId}");
                ServerContext.Broadcast.BroadcastToRoomTyped<IPlayerClientService>(player, 
                    service => service.OnChatMessage(player, message),
                    excludeSelf: false);
            }
            else
            {
                // ä¸åœ¨æˆ¿é—´ä¸­ï¼Œå¹¿æ’­åˆ°å…¨å±€æ‰€æœ‰ç©å®¶
                Console.WriteLine($"[Chat] å¹¿æ’­åˆ°å…¨å±€");
                var allPlayers = ServerContext.Players.GetAllOnlinePlayers();
                var clientIds = allPlayers
                    .Select(p => ServerContext.Players.GetClientIdBySteamId(p.SteamId))
                    .Where(id => !string.IsNullOrEmpty(id))
                    .Cast<string>()
                    .ToList();
                
                if (clientIds.Count > 0)
                {
                    ServerContext.Server.BroadcastToClients<IPlayerClientService>(clientIds)
                        .OnChatMessage(player, message);
                }
            }
        }

        public async Task<PlayerInfo[]> GetAllOnlinePlayersAsync(IClientContext client)
        {
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            if (player == null || !ServerContext.Players.IsLoggedIn(player.SteamId))
            {
                return Array.Empty<PlayerInfo>();
            }

            var players = ServerContext.Players.GetAllOnlinePlayers();
            Console.WriteLine($"[PlayerService] Returning {players.Length} global online players");
            return await Task.FromResult(players);
        }

        public async Task<PlayerInfo[]> GetCurrentRoomPlayersAsync(IClientContext client)
        {
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            if (player == null || !ServerContext.Players.IsLoggedIn(player.SteamId))
            {
                return Array.Empty<PlayerInfo>();
            }

            var players = ServerContext.Players.GetCurrentRoomPlayers(client.ClientId);
            Console.WriteLine($"[PlayerService] Returning {players.Length} room players");
            return await Task.FromResult(players);
        }
    }
}

```

`Server\Services\PlayerUnitySyncServiceImpl.cs`:

```cs
using System;
using System.Collections.Generic;
using DuckyNet.Server.Core;
using DuckyNet.Server.Events;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// ç©å®¶UnityåŒæ­¥æœåŠ¡å®ç°
    /// å¤„ç†ç©å®¶ä½ç½®ã€æ—‹è½¬ã€é€Ÿåº¦ç­‰å®æ—¶åŒæ­¥æ•°æ®
    /// </summary>
    public class PlayerUnitySyncServiceImpl : IPlayerUnitySyncService
    {
        private readonly object _lock = new object();
        
        /// <summary>
        /// ç©å®¶æœ€åä½ç½®ç¼“å­˜ - Key: SteamId (string), Value: æœ€åçš„åŒæ­¥æ•°æ®
        /// ç”¨äºæ–°ç©å®¶åŠ å…¥æˆ¿é—´æ—¶è·å–ç°æœ‰ç©å®¶çš„ä½ç½®
        /// </summary>
        private readonly Dictionary<string, UnitySyncData> _lastPositionCache = new Dictionary<string, UnitySyncData>();

        public PlayerUnitySyncServiceImpl(EventBus eventBus)
        {
            // è®¢é˜…ç©å®¶æ–­å¼€äº‹ä»¶ï¼Œè‡ªåŠ¨æ¸…ç†ç¼“å­˜
            eventBus.Subscribe<PlayerDisconnectedEvent>(OnPlayerDisconnected);
        }

        /// <summary>
        /// å¤„ç†ç©å®¶æ–­å¼€äº‹ä»¶ï¼šè‡ªåŠ¨æ¸…ç†ä½ç½®ç¼“å­˜
        /// </summary>
        private void OnPlayerDisconnected(PlayerDisconnectedEvent evt)
        {
            if (evt.Player != null)
            {
                ClearPlayerPosition(evt.Player.SteamId);
            }
        }
        
        /// <summary>
        /// è·å–ç©å®¶çš„æœ€åä½ç½®ï¼ˆç”¨äºæ–°ç©å®¶åŠ å…¥æˆ¿é—´æ—¶åŒæ­¥ï¼‰
        /// </summary>
        public UnitySyncData? GetLastPosition(string steamId)
        {
            lock (_lock)
            {
                if (_lastPositionCache.TryGetValue(steamId, out var lastSync))
                {
                    return lastSync;
                }
                return null;
            }
        }
        
        /// <summary>
        /// æ¸…é™¤ç©å®¶çš„ä½ç½®ç¼“å­˜ï¼ˆç©å®¶ç¦»å¼€æˆ¿é—´/æ–­å¼€è¿æ¥æ—¶è°ƒç”¨ï¼‰
        /// </summary>
        public void ClearPlayerPosition(string steamId)
        {
            lock (_lock)
            {
                if (_lastPositionCache.Remove(steamId))
                {
                    Console.WriteLine($"[PlayerUnitySyncService] æ¸…é™¤ç©å®¶ {steamId} çš„ä½ç½®ç¼“å­˜");
                }
            }
        }

        public void SendPlayerUnitySync(IClientContext client, UnitySyncData syncData)
        {
            try
            {
                // æ­¥éª¤1: è·å–å‘é€è€…çš„ç©å®¶ä¿¡æ¯
                var senderPlayer = ServerContext.Players.GetPlayer(client.ClientId);
                if (senderPlayer == null)
                {
                    Console.WriteLine($"[PlayerUnitySyncService] âš ï¸ æ— æ³•æ‰¾åˆ°å®¢æˆ·ç«¯ {client.ClientId} å¯¹åº”çš„ç©å®¶");
                    return;
                }

                // ğŸ”¥ ç¼“å­˜ç©å®¶ä½ç½®åˆ° SceneManagerï¼ˆç”¨äºçƒ­åŒºå’ŒèŒƒå›´è®¡ç®—ï¼‰
                var (x, y, z) = syncData.GetPosition();
                ServerContext.Scenes.UpdatePlayerPosition(
                    senderPlayer.SteamId,
                    x,
                    y,
                    z
                );
                
                // ç¡®ä¿ SteamId ä¸å‘é€è€…åŒ¹é…ï¼ˆå®‰å…¨éªŒè¯ï¼‰
                syncData.SteamId = senderPlayer.SteamId;
                
                // ç¼“å­˜æœ€åä½ç½®ï¼ˆç”¨äºæ–°ç©å®¶åŠ å…¥æ—¶åŒæ­¥ï¼‰
                lock (_lock)
                {
                    _lastPositionCache[senderPlayer.SteamId] = syncData;
                }

                // æ­¥éª¤2: éªŒè¯å‘é€è€…æ˜¯å¦åœ¨æˆ¿é—´ä¸­
                var room = ServerContext.Rooms.GetPlayerRoom(senderPlayer);
                if (room == null)
                {
                    Console.WriteLine($"[PlayerUnitySyncService] ç©å®¶ {senderPlayer.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­ï¼Œè·³è¿‡åŒæ­¥");
                    return;
                }

                // æ­¥éª¤3: ä½¿ç”¨ BroadcastManager å¹¿æ’­ç»™åŒåœºæ™¯çš„ç©å®¶
                ServerContext.Broadcast.BroadcastToScene(senderPlayer, (targetPlayer, targetContext) =>
                {
                    try
                    {
                        // é€šè¿‡ RPC è°ƒç”¨å®¢æˆ·ç«¯æ¥æ”¶åŒæ­¥æ•°æ®
                        targetContext.Call<IPlayerClientService>().OnPlayerUnitySyncReceived(syncData);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[PlayerUnitySyncService] âŒ å‘ {targetPlayer.SteamName} è½¬å‘åŒæ­¥æ•°æ®å¤±è´¥: {ex.Message}");
                    }
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[PlayerUnitySyncService] å¤„ç†åŒæ­¥æ•°æ®å¼‚å¸¸: {ex.Message}");
                Console.WriteLine($"[PlayerUnitySyncService] å †æ ˆè·Ÿè¸ª: {ex.StackTrace}");
            }
        }

    }
}

```

`Server\Services\RoomServiceImpl.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Server.Core;
using DuckyNet.Server.Events;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// æˆ¿é—´æœåŠ¡å®ç°
    /// </summary>
    public class RoomServiceImpl : IRoomService
    {
        private readonly PlayerUnitySyncServiceImpl _unitySyncService;
        private readonly EquipmentServerServiceImpl _equipmentService;
        private readonly WeaponSyncServerServiceImpl _weaponSyncService;

        public RoomServiceImpl(
            PlayerUnitySyncServiceImpl unitySyncService,
            EquipmentServerServiceImpl equipmentService,
            WeaponSyncServerServiceImpl weaponSyncService)
        {
            _unitySyncService = unitySyncService;
            _equipmentService = equipmentService;
            _weaponSyncService = weaponSyncService;
        }

        /// <summary>
        /// éªŒè¯ç©å®¶ç™»å½•çŠ¶æ€
        /// </summary>
        private PlayerInfo? ValidatePlayer(IClientContext client)
        {
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            if (player == null || !ServerContext.Players.IsLoggedIn(player.SteamId))
            {
                return null;
            }
            return player;
        }

        public async Task<RoomInfo[]> GetRoomListAsync(IClientContext client)
        {
            if (ValidatePlayer(client) == null)
            {
                throw new UnauthorizedAccessException("Not logged in");
            }

            var rooms = ServerContext.Rooms.GetAllRooms();
            return await Task.FromResult(rooms);
        }

        public async Task<RoomOperationResult> CreateRoomAsync(IClientContext client, CreateRoomRequest request)
        {
            var player = ValidatePlayer(client);
            if (player == null)
            {
                return new RoomOperationResult
                {
                    Success = false,
                    ErrorMessage = "Not logged in"
                };
            }

            try
            {
                var room = ServerContext.Rooms.CreateRoom(player, request);
                
                Console.WriteLine($"[RoomService] Room created: {room.RoomId} by {player.SteamName}");

                // å‘å¸ƒæˆ¿é—´åˆ›å»ºäº‹ä»¶
                ServerEventPublisher.PublishRoomCreated(room, player);

                return await Task.FromResult(new RoomOperationResult
                {
                    Success = true,
                    Room = room
                });
            }
            catch (InvalidOperationException ex)
            {
                return new RoomOperationResult
                {
                    Success = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        public async Task<RoomOperationResult> JoinRoomAsync(IClientContext client, JoinRoomRequest request)
        {
            var player = ValidatePlayer(client);
            if (player == null)
            {
                return new RoomOperationResult
                {
                    Success = false,
                    ErrorMessage = "Not logged in"
                };
            }

            Console.WriteLine($"[RoomService] ç©å®¶ {player.SteamName} åŠ å…¥æˆ¿é—´");

            var result = ServerContext.Rooms.JoinRoom(player, request);

            if (result.Success && result.Room != null)
            {
                // è·å–æˆ¿é—´å†…æ‰€æœ‰ç©å®¶ï¼ˆåŒ…æ‹¬æ–°åŠ å…¥çš„ï¼‰
                var roomPlayers = ServerContext.Players.GetRoomPlayers(request.RoomId);
                
                // 1. é€šçŸ¥æ–°ç©å®¶ï¼šæˆ¿é—´å†…å·²æœ‰çš„å…¶ä»–ç©å®¶
                var otherPlayers = roomPlayers.Where(p => p.SteamId != player.SteamId).ToList();
                if (otherPlayers.Any())
                {
                    foreach (var existingPlayer in otherPlayers)
                    {
                        // é€šçŸ¥æˆ¿é—´æˆå‘˜å…³ç³»
                        client.Call<IRoomClientService>()
                            .OnPlayerJoinedRoom(existingPlayer, result.Room);
                        
                        // å¦‚æœç°æœ‰ç©å®¶åœ¨åœºæ™¯ä¸­ï¼Œå‘é€åœºæ™¯è¿›å…¥äº‹ä»¶
                        if (existingPlayer.CurrentScenelData != null && !string.IsNullOrEmpty(existingPlayer.CurrentScenelData.SceneName))
                        {
                            try
                            {
                                client.Call<ISceneClientService>()
                                    .OnPlayerEnteredScene(existingPlayer, existingPlayer.CurrentScenelData);
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"[RoomService] âŒ å‘é€åœºæ™¯äº‹ä»¶å¤±è´¥ {existingPlayer.SteamName} â†’ {player.SteamName}: {ex.Message}");
                            }
                            
                            // å‘é€ä½ç½®æ•°æ®
                            var lastPosition = _unitySyncService.GetLastPosition(existingPlayer.SteamId);
                            if (lastPosition != null)
                            {
                                client.Call<IPlayerClientService>()
                                    .OnPlayerUnitySyncReceived(lastPosition);
                            }
                        }
                        else
                        {
                            Console.WriteLine($"[RoomService] âš ï¸ ç©å®¶ {existingPlayer.SteamName} ä¸åœ¨åœºæ™¯ä¸­ï¼Œè·³è¿‡åœºæ™¯è¿›å…¥äº‹ä»¶");
                        }
                    }
                    
                    // å‘é€è£…å¤‡å’Œæ­¦å™¨æ•°æ®ç»™æ–°ç©å®¶
                    _equipmentService.SendAllEquipmentDataToPlayer(client.ClientId, request.RoomId);
                    _weaponSyncService.SendAllWeaponDataToPlayer(client.ClientId, request.RoomId);
                }
                
                // 2. é€šçŸ¥æˆ¿é—´å†…æ‰€æœ‰å…¶ä»–ç©å®¶ï¼šæ–°ç©å®¶åŠ å…¥äº†
                ServerContext.Broadcast.BroadcastToRoomExcludeSelf(player, (target, targetContext) =>
                {
                    // é€šçŸ¥æˆ¿é—´æˆå‘˜å…³ç³»
                    targetContext.Call<IRoomClientService>()
                        .OnPlayerJoinedRoom(player, result.Room);
                    
                    // å¦‚æœæ–°ç©å®¶å·²ç»åœ¨åœºæ™¯ä¸­ï¼Œå‘é€åœºæ™¯è¿›å…¥äº‹ä»¶å’Œä½ç½®
                    if (!string.IsNullOrEmpty(player.CurrentScenelData.SceneName))
                    {
                        targetContext.Call<ISceneClientService>()
                            .OnPlayerEnteredScene(player, player.CurrentScenelData);
                        
                        var newPlayerLastPos = _unitySyncService.GetLastPosition(player.SteamId);
                        if (newPlayerLastPos != null)
                        {
                            targetContext.Call<IPlayerClientService>()
                                .OnPlayerUnitySyncReceived(newPlayerLastPos);
                        }
                    }
                });

                Console.WriteLine($"[RoomService] Player {player.SteamName} joined room {request.RoomId}");
                
                // å‘å¸ƒç©å®¶åŠ å…¥æˆ¿é—´äº‹ä»¶
                ServerEventPublisher.PublishPlayerJoinedRoom(result.Room, player);
            }

            return await Task.FromResult(result);
        }

        public async Task<bool> LeaveRoomAsync(IClientContext client)
        {
            var player = ValidatePlayer(client);
            if (player == null)
            {
                return false;
            }

            var room = ServerContext.Rooms.LeaveRoom(player);

            if (room != null)
            {
                // æ¸…é™¤ç©å®¶çš„ä½ç½®ç¼“å­˜å’Œåœºæ™¯æ•°æ®
                _unitySyncService.ClearPlayerPosition(player.SteamId);
                ServerContext.Players.UpdatePlayerSceneDataByClientId(client.ClientId, new ScenelData("", ""));
                Console.WriteLine($"[RoomService] {player.SteamName} ç¦»å¼€æˆ¿é—´ {room.RoomId}");
                
                // å‘å¸ƒç©å®¶ç¦»å¼€æˆ¿é—´äº‹ä»¶
                ServerEventPublisher.PublishPlayerLeftRoom(room, player);
                
                // é€šçŸ¥æˆ¿é—´å†…å…¶ä»–ç©å®¶
                ServerContext.Broadcast.BroadcastToRoomById(room.RoomId, (target, targetContext) =>
                {
                    targetContext.Call<IRoomClientService>()
                        .OnPlayerLeftRoom(player, room);
                });

                Console.WriteLine($"[RoomService] å·²é€šçŸ¥å…¶ä»–ç©å®¶ {player.SteamName} ç¦»å¼€");
            }

            return await Task.FromResult(true);
        }

        public async Task<RoomInfo?> GetCurrentRoomAsync(IClientContext client)
        {
            var player = ValidatePlayer(client);
            if (player == null)
            {
                return null;
            }

            var room = ServerContext.Rooms.GetPlayerRoom(player);
            return await Task.FromResult(room);
        }

        public async Task<RoomInfo?> GetRoomInfoAsync(IClientContext client, string roomId)
        {
            if (ValidatePlayer(client) == null)
            {
                return null;
            }

            var room = ServerContext.Rooms.GetRoom(roomId);
            return await Task.FromResult(room);
        }

        public async Task<PlayerInfo[]> GetRoomPlayersAsync(IClientContext client, string roomId)
        {
            var requester = ValidatePlayer(client);
            if (requester == null)
            {
                return Array.Empty<PlayerInfo>();
            }

            var players = ServerContext.Players.GetRoomPlayers(roomId);
            Console.WriteLine($"[RoomService] GetRoomPlayers: {requester.SteamName} æŸ¥è¯¢æˆ¿é—´ {roomId}, ç©å®¶æ•°: {players.Length}");
            
            // ä¸»åŠ¨å‘è¯·æ±‚è€…å‘é€æˆ¿é—´å†…å…¶ä»–ç©å®¶çš„åŠ å…¥é€šçŸ¥
            var room = ServerContext.Rooms.GetPlayerRoom(requester);
            if (room != null)
            {
                foreach (var otherPlayer in players)
                {
                    if (otherPlayer.SteamId == requester.SteamId)
                        continue;

                    // å‘é€æˆ¿é—´æˆå‘˜é€šçŸ¥
                    client.Call<IRoomClientService>()
                        .OnPlayerJoinedRoom(otherPlayer, room);

                    // ğŸ”¥ å¦‚æœå¯¹æ–¹åœ¨åœºæ™¯ä¸­ï¼Œå‘é€å®Œæ•´çš„åœºæ™¯è¿›å…¥äº‹ä»¶ï¼ˆä¿®å¤åœºæ™¯å†…è¿æ¥çœ‹ä¸åˆ°ç©å®¶çš„é—®é¢˜ï¼‰
                    if (!string.IsNullOrEmpty(otherPlayer.CurrentScenelData.SceneName))
                    {
                        try
                        {
                            client.Call<ISceneClientService>()
                                .OnPlayerEnteredScene(otherPlayer, otherPlayer.CurrentScenelData);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[RoomService] âŒ è¡¥å¿åŒæ­¥å¤±è´¥ {otherPlayer.SteamName} â†’ {requester.SteamName}: {ex.Message}");
                        }
                        
                        // å‘é€ä½ç½®æ•°æ®
                        var lastPosition = _unitySyncService.GetLastPosition(otherPlayer.SteamId);
                        if (lastPosition != null)
                        {
                            client.Call<IPlayerClientService>()
                                .OnPlayerUnitySyncReceived(lastPosition);
                        }
                    }
                }
                
                // ğŸ”¥ è¡¥å¿å‘é€è£…å¤‡å’Œæ­¦å™¨æ•°æ®ï¼ˆä¿®å¤åœºæ™¯å†…è¿æ¥çœ‹ä¸åˆ°è£…å¤‡çš„é—®é¢˜ï¼‰
                _equipmentService.SendAllEquipmentDataToPlayer(client.ClientId, roomId);
                _weaponSyncService.SendAllWeaponDataToPlayer(client.ClientId, roomId);
            }

            return await Task.FromResult(players);
        }

        public async Task<bool> KickPlayerAsync(IClientContext client, string playerId)
        {
            var player = ValidatePlayer(client);
            if (player == null)
            {
                return false;
            }

            var targetPlayer = ServerContext.Players.GetPlayerBySteamId(playerId);
            if (targetPlayer == null)
            {
                return false;
            }

            var result = ServerContext.Rooms.KickPlayer(player, targetPlayer);

            if (result)
            {
                // é€šçŸ¥è¢«è¸¢çš„ç©å®¶
                ServerContext.Broadcast.SendToPlayer(targetPlayer.SteamId, context =>
                {
                    context.Call<IRoomClientService>()
                        .OnKickedFromRoom($"è¢«æˆ¿ä¸» {player.SteamName} è¸¢å‡ºæˆ¿é—´");
                });

                Console.WriteLine($"[RoomService] Player {targetPlayer.SteamName} kicked by {player.SteamName}");
            }

            return await Task.FromResult(result);
        }
    }
}

```

`Server\Services\SceneServiceImpl.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.RPC;
using DuckyNet.Server.Core;
using DuckyNet.Shared.Data;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// åœºæ™¯æœåŠ¡å®ç°
    /// ğŸ“Œ æ ¸å¿ƒé€»è¾‘ï¼šåœºæ™¯è¿›å…¥/ç¦»å¼€æ—¶ï¼Œå¹¿æ’­ç»™åŒæˆ¿é—´çš„æ‰€æœ‰ç©å®¶
    /// </summary>
    public class SceneServiceImpl : ISceneService
    {

        /// <summary>
        /// ç©å®¶è¿›å…¥åœºæ™¯
        /// ğŸ“¢ å¹¿æ’­é€»è¾‘ï¼š
        /// 1. å¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰äººï¼šè¯¥ç©å®¶è¿›å…¥äº†åœºæ™¯
        /// 2. ç»™æ–°è¿›å…¥çš„ç©å®¶å‘é€ï¼šæˆ¿é—´å†…æ‰€æœ‰å…¶ä»–ç©å®¶çš„çŠ¶æ€ï¼ˆä½ç½®ã€çš®è‚¤ã€è£…å¤‡ã€æ­¦å™¨ï¼‰
        /// </summary>
        public Task<bool> EnterSceneAsync(IClientContext client, ScenelData scenelData)
        {
            var nonNullData = scenelData ?? new ScenelData("", "");
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            
            if (player == null)
            {
                Console.WriteLine($"[SceneService] âš ï¸ æœªæ‰¾åˆ°ç©å®¶ä¿¡æ¯, ClientId={client.ClientId}");
                return Task.FromResult(false);
            }

            // âœ… é˜²å¾¡æ€§æ£€æŸ¥ï¼šéªŒè¯ç©å®¶æ˜¯å¦åœ¨æˆ¿é—´ä¸­
            var room = ServerContext.Rooms.GetPlayerRoom(player);
            if (room == null)
            {
                Console.WriteLine($"[SceneService] âŒ ç©å®¶ {player.SteamName} ä¸åœ¨ä»»ä½•æˆ¿é—´ä¸­ï¼Œæ— æ³•è¿›å…¥åœºæ™¯");
                return Task.FromResult(false);
            }

            // âœ… é˜²å¾¡æ€§æ£€æŸ¥ï¼šéªŒè¯åœºæ™¯æ•°æ®æœ‰æ•ˆæ€§
            if (string.IsNullOrEmpty(nonNullData.SceneName))
            {
                Console.WriteLine($"[SceneService] âŒ åœºæ™¯åä¸ºç©ºï¼Œç©å®¶ {player.SteamName} è¿›å…¥åœºæ™¯å¤±è´¥");
                return Task.FromResult(false);
            }

            // 1ï¸âƒ£ ä½¿ç”¨ SceneManager æ›´æ–°åœºæ™¯æ•°æ®
            if (!ServerContext.Scenes.EnterScene(client.ClientId, nonNullData))
            {
                return Task.FromResult(false);
            }
            
            // 2ï¸âƒ£ ä½¿ç”¨ BroadcastManager å¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰ç©å®¶
            ServerContext.Broadcast.BroadcastToRoom(player, (target, targetContext) =>
            {
                try
                {
                    targetContext.Call<ISceneClientService>().OnPlayerEnteredScene(player, nonNullData);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[SceneService] âŒ å¹¿æ’­å¤±è´¥ {player.SteamName} â†’ {target.SteamName}: {ex.Message}");
                }
            });
            
            // 3ï¸âƒ£ ç»™æ–°è¿›å…¥çš„ç©å®¶åŒæ­¥æˆ¿é—´å†…å…¶ä»–ç©å®¶çš„çŠ¶æ€
            SyncExistingPlayersToNewPlayer(client, player, nonNullData);
            
            return Task.FromResult(true);
        }

        /// <summary>
        /// ç»™æ–°è¿›å…¥åœºæ™¯çš„ç©å®¶åŒæ­¥æˆ¿é—´å†…å·²å­˜åœ¨çš„å…¶ä»–ç©å®¶
        /// ğŸ“¤ å‘é€ï¼šç©å®¶ä¿¡æ¯ã€åœºæ™¯ä½ç½®ã€å¤–è§‚ã€è£…å¤‡ã€æ­¦å™¨æ•°æ®
        /// </summary>
        private void SyncExistingPlayersToNewPlayer(IClientContext newPlayerClient, PlayerInfo newPlayer, ScenelData scenelData)
        {
            // è·å–æˆ¿é—´
            var room = ServerContext.Rooms.GetPlayerRoom(newPlayer);
            if (room == null)
            {
                Console.WriteLine($"[SceneService] âš ï¸ ç©å®¶ä¸åœ¨æˆ¿é—´ä¸­ï¼Œæ— æ³•åŒæ­¥å…¶ä»–ç©å®¶: {newPlayer.SteamName}");
                return;
            }

            // è·å–æˆ¿é—´å†…æ‰€æœ‰ç©å®¶
            var roomPlayers = ServerContext.Players.GetRoomPlayers(room.RoomId);
            
            // ç­›é€‰å‡ºåœ¨åŒä¸€åœºæ™¯ä¸”ä¸æ˜¯è‡ªå·±çš„ç©å®¶
            var existingPlayers = roomPlayers
                .Where(p => p.SteamId != newPlayer.SteamId && 
                           p.CurrentScenelData.SceneName == scenelData.SceneName &&
                           p.CurrentScenelData.SubSceneName == scenelData.SubSceneName)
                .ToList();

            if (existingPlayers.Count == 0)
            {
                Console.WriteLine($"[SceneService] åœºæ™¯å†…æ²¡æœ‰å…¶ä»–ç©å®¶ï¼Œæ— éœ€åŒæ­¥: {newPlayer.SteamName}");
                return;
            }

            Console.WriteLine($"[SceneService] åŒæ­¥ {existingPlayers.Count} ä¸ªç°æœ‰ç©å®¶ç»™ {newPlayer.SteamName}");

            // ç»™æ–°ç©å®¶å‘é€æ¯ä¸ªç°æœ‰ç©å®¶çš„è¿›å…¥åœºæ™¯äº‹ä»¶
            foreach (var existingPlayer in existingPlayers)
            {
                try
                {
                    newPlayerClient.Call<ISceneClientService>()
                        .OnPlayerEnteredScene(existingPlayer, existingPlayer.CurrentScenelData);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[SceneService] âŒ åŒæ­¥å¤±è´¥ {existingPlayer.SteamName} â†’ {newPlayer.SteamName}: {ex.Message}");
                }
            }
        }

        public Task<PlayerInfo[]> GetScenePlayersAsync(IClientContext client, ScenelData scenelData)
        {
            // ä½¿ç”¨ SceneManager è·å–åœºæ™¯ç©å®¶
            var players = ServerContext.Scenes.GetScenePlayers(client.ClientId, scenelData);
            return Task.FromResult(players);
        }

        /// <summary>
        /// ç©å®¶ç¦»å¼€åœºæ™¯
        /// ğŸ“¢ å¹¿æ’­é€»è¾‘ï¼šç¦»å¼€åœºæ™¯æ—¶ï¼Œå¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰äººï¼ˆç”¨äºé”€æ¯è§’è‰²ï¼‰
        /// </summary>
        public Task<bool> LeaveSceneAsync(IClientContext client, ScenelData scenelData)
        {
            var player = ServerContext.Players.GetPlayer(client.ClientId);
            
            if (player == null)
            {
                Console.WriteLine($"[SceneService] âš ï¸ æœªæ‰¾åˆ°ç©å®¶ä¿¡æ¯, ClientId={client.ClientId}");
                return Task.FromResult(false);
            }

            // 1ï¸âƒ£ ä½¿ç”¨ SceneManager æ¸…é™¤åœºæ™¯æ•°æ®
            if (!ServerContext.Scenes.LeaveScene(client.ClientId, scenelData))
            {
                return Task.FromResult(false);
            }
            
            // 2ï¸âƒ£ ä½¿ç”¨ BroadcastManager å¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰ç©å®¶
            ServerContext.Broadcast.BroadcastToRoom(player, (target, targetContext) =>
            {
                targetContext.Call<ISceneClientService>().OnPlayerLeftScene(player, scenelData);
                Console.WriteLine($"[SceneService] âœ… é€šçŸ¥ {target.SteamName}: {player.SteamName} ç¦»å¼€åœºæ™¯ {scenelData.SceneName}");
            });
            
            return Task.FromResult(true);
        }
    }
}

```

`Server\Services\WeaponSyncServerServiceImpl.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Services;
using DuckyNet.Server.Core;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Server.Services
{
    /// <summary>
    /// æ­¦å™¨åŒæ­¥æœåŠ¡å™¨ç«¯å®ç°
    /// è´Ÿè´£å­˜å‚¨å’Œå¹¿æ’­ç©å®¶æ­¦å™¨æ•°æ®
    /// </summary>
    public class WeaponSyncServerServiceImpl : IWeaponSyncService
    {

        /// <summary>
        /// è£…å¤‡æ­¦å™¨åˆ°æ§½ä½
        /// </summary>
        public Task<bool> EquipWeaponAsync(IClientContext client, WeaponSlotUpdateRequest request)
        {
            if (client == null)
            {
                Log("EquipWeaponAsync å¤±è´¥ï¼šæ²¡æœ‰å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);

            if (player == null)
            {
                Log($"EquipWeaponAsync å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            try
            {
                // åˆ›å»ºæ­¦å™¨æ•°æ®
                var weaponData = new WeaponItemData
                {
                    ItemTypeId = request.ItemTypeId,
                    ItemName = request.ItemName,
                    IsDefaultItem = request.IsDefaultItem,
                    ItemDataCompressed = request.ItemDataCompressed
                };

                // æ›´æ–°æœåŠ¡å™¨ç«¯çš„æ­¦å™¨æ•°æ®
                if (player.WeaponData == null)
                {
                    player.WeaponData = new PlayerWeaponData();
                }

                player.WeaponData.SetWeapon(request.SlotType, weaponData);

                string dataSize = request.IsDefaultItem ? "é»˜è®¤" : $"{request.ItemDataCompressed.Length}å­—èŠ‚";
                Log($"ç©å®¶ {player.SteamName} è£…å¤‡æ­¦å™¨: {request.SlotType} = {request.ItemName} (TypeID={request.ItemTypeId}, æ•°æ®={dataSize})", 
                    ConsoleColor.Green);

                // å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastWeaponUpdate(player, request, isUnequip: false);

                return Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Log($"EquipWeaponAsync å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
                return Task.FromResult(false);
            }
        }

        /// <summary>
        /// å¸ä¸‹æ­¦å™¨æ§½ä½
        /// </summary>
        public Task<bool> UnequipWeaponAsync(IClientContext client, WeaponSlotUnequipRequest request)
        {
            if (client == null)
            {
                Log("UnequipWeaponAsync å¤±è´¥ï¼šæ²¡æœ‰å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);

            if (player == null)
            {
                Log($"UnequipWeaponAsync å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            try
            {
                // æ›´æ–°æœåŠ¡å™¨ç«¯çš„æ­¦å™¨æ•°æ®ï¼ˆè®¾ä¸ºnullï¼‰
                if (player.WeaponData == null)
                {
                    player.WeaponData = new PlayerWeaponData();
                }

                player.WeaponData.SetWeapon(request.SlotType, null);

                Log($"ç©å®¶ {player.SteamName} å¸ä¸‹æ­¦å™¨: {request.SlotType}", ConsoleColor.Yellow);

                // åˆ›å»ºå¸ä¸‹é€šçŸ¥
                var notification = new WeaponSlotUpdateNotification
                {
                    PlayerId = player.SteamId,
                    SlotType = request.SlotType,
                    ItemTypeId = 0, // 0 è¡¨ç¤ºå¸ä¸‹
                    ItemName = "",
                    IsDefaultItem = true,
                    ItemDataCompressed = ""
                };

                // å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastWeaponNotification(player, notification);

                return Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Log($"UnequipWeaponAsync å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
                return Task.FromResult(false);
            }
        }

        /// <summary>
        /// å¹¿æ’­æ­¦å™¨å°„å‡»ç‰¹æ•ˆ
        /// </summary>
        public Task BroadcastWeaponFireAsync(IClientContext client, WeaponFireData fireData)
        {
            if (client == null)
            {
                Log("BroadcastWeaponFireAsync å¤±è´¥ï¼šæ²¡æœ‰å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡", ConsoleColor.Red);
                return Task.CompletedTask;
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);

            if (player == null)
            {
                Log($"BroadcastWeaponFireAsync å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return Task.CompletedTask;
            }

            try
            {
                // è®¾ç½®ç©å®¶ID
                fireData.PlayerId = player.SteamId;

                // å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastWeaponFireToRoom(player, fireData);

                return Task.CompletedTask;
            }
            catch (Exception ex)
            {
                Log($"BroadcastWeaponFireAsync å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
                return Task.CompletedTask;
            }
        }

        /// <summary>
        /// åˆ‡æ¢å½“å‰æ­¦å™¨æ§½ä½
        /// </summary>
        public Task<bool> SwitchWeaponSlotAsync(IClientContext client, WeaponSwitchRequest request)
        {
            if (client == null)
            {
                Log("SwitchWeaponSlotAsync å¤±è´¥ï¼šæ²¡æœ‰å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);

            if (player == null)
            {
                Log($"SwitchWeaponSlotAsync å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return Task.FromResult(false);
            }

            try
            {
                // æ›´æ–°æœåŠ¡å™¨ç«¯çš„å½“å‰æ­¦å™¨æ§½ä½
                if (player.WeaponData == null)
                {
                    player.WeaponData = new PlayerWeaponData();
                }

                player.WeaponData.CurrentWeaponSlot = request.CurrentWeaponSlot;

                Log($"ç©å®¶ {player.SteamName} åˆ‡æ¢æ­¦å™¨: {request.CurrentWeaponSlot}", ConsoleColor.Cyan);

                // åˆ›å»ºåˆ‡æ¢é€šçŸ¥
                var notification = new WeaponSwitchNotification
                {
                    PlayerId = player.SteamId,
                    CurrentWeaponSlot = request.CurrentWeaponSlot
                };

                // å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastWeaponSwitchNotification(player, notification);

                return Task.FromResult(true);
            }
            catch (Exception ex)
            {
                Log($"SwitchWeaponSlotAsync å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
                return Task.FromResult(false);
            }
        }

        /// <summary>
        /// å¹¿æ’­æ­¦å™¨æ›´æ–°åˆ°æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
        /// </summary>
        private void BroadcastWeaponUpdate(PlayerInfo player, WeaponSlotUpdateRequest request, bool isUnequip)
        {
            var notification = new WeaponSlotUpdateNotification
            {
                PlayerId = player.SteamId,
                SlotType = request.SlotType,
                ItemTypeId = isUnequip ? 0 : request.ItemTypeId,
                ItemName = request.ItemName,
                IsDefaultItem = request.IsDefaultItem,
                ItemDataCompressed = request.ItemDataCompressed
            };

            BroadcastWeaponNotification(player, notification);
        }

        /// <summary>
        /// å¹¿æ’­æ­¦å™¨é€šçŸ¥ï¼ˆåªå‘é€ç»™åŒæˆ¿é—´ä¸”åŒåœºæ™¯çš„ç©å®¶ï¼‰
        /// </summary>
        private void BroadcastWeaponNotification(PlayerInfo player, WeaponSlotUpdateNotification notification)
        {
            // ä½¿ç”¨ BroadcastManager ç®€åŒ–å¹¿æ’­é€»è¾‘
            var room = ServerContext.Rooms.GetPlayerRoom(player);
            if (room == null)
            {
                Log($"ç©å®¶ {player.SteamName} ä¸åœ¨æˆ¿é—´ä¸­ï¼Œæ— éœ€å¹¿æ’­æ­¦å™¨æ›´æ–°", ConsoleColor.Yellow);
                return;
            }

            ServerContext.Broadcast.BroadcastToSceneTyped<IWeaponSyncClientService>(player, 
                service => service.OnWeaponSlotUpdated(notification));

            Log($"æ­¦å™¨æ›´æ–°å·²å¹¿æ’­ (æˆ¿é—´: {room.RoomId}, åœºæ™¯: {player.CurrentScenelData.SceneName})", ConsoleColor.Cyan);
        }

        /// <summary>
        /// æ‰¹é‡é€šçŸ¥æ­¦å™¨å¼€ç«ï¼ˆæ’­æ”¾ç‰¹æ•ˆï¼‰- éœ°å¼¹æª/è¿å‘æ­¦å™¨ä¼˜åŒ–
        /// ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šéœ°å¼¹æª 8 å‘å¼¹ä¸¸åªéœ€ 1 æ¬¡ RPC è°ƒç”¨
        /// </summary>
        public void NotifyWeaponFireBatch(IClientContext client, WeaponFireBatchData batchData)
        {
            if (client == null || batchData == null || batchData.BulletCount == 0)
            {
                Log("NotifyWeaponFireBatch å¤±è´¥ï¼šæ— æ•ˆå‚æ•°", ConsoleColor.Red);
                return;
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);

            if (player == null)
            {
                Log($"NotifyWeaponFireBatch å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return;
            }

            try
            {
                // è®¾ç½® PlayerId
                batchData.PlayerId = player.SteamId;

                // ğŸ”¥ æ‰¹é‡å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastWeaponFireBatchToRoom(player, batchData);
            }
            catch (Exception ex)
            {
                Log($"NotifyWeaponFireBatch å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
            }
        }

        /// <summary>
        /// é€šçŸ¥æ­¦å™¨å¼€ç«ï¼ˆæ’­æ”¾ç‰¹æ•ˆï¼‰- å•å‘
        /// </summary>
        public void NotifyWeaponFire(IClientContext client, WeaponFireData fireData)
        {
            if (client == null)
            {
                Log("NotifyWeaponFire å¤±è´¥ï¼šæ²¡æœ‰å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡", ConsoleColor.Red);
                return;
            }

            var playerId = client.ClientId;
            var player = ServerContext.Players.GetPlayer(playerId);

            if (player == null)
            {
                Log($"NotifyWeaponFire å¤±è´¥ï¼šæ‰¾ä¸åˆ°ç©å®¶ {playerId}", ConsoleColor.Red);
                return;
            }

            try
            {
                // è®¾ç½® PlayerId
                fireData.PlayerId = player.SteamId;

                // å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶
                BroadcastWeaponFireNotification(player, fireData);
            }
            catch (Exception ex)
            {
                Log($"NotifyWeaponFire å¼‚å¸¸: {ex.Message}", ConsoleColor.Red);
            }
        }

        /// <summary>
        /// å¹¿æ’­æ­¦å™¨å¼€ç«é€šçŸ¥ï¼ˆåªå‘é€ç»™åŒæˆ¿é—´ä¸”åŒåœºæ™¯çš„ç©å®¶ï¼‰
        /// </summary>
        private void BroadcastWeaponFireNotification(PlayerInfo player, WeaponFireData fireData)
        {
            // ä½¿ç”¨ BroadcastManager ç®€åŒ–å¹¿æ’­é€»è¾‘
            ServerContext.Broadcast.BroadcastToSceneTyped<IWeaponSyncClientService>(player, 
                service => service.OnWeaponFired(fireData));
        }

        /// <summary>
        /// å¹¿æ’­æ­¦å™¨åˆ‡æ¢é€šçŸ¥ï¼ˆåªå‘é€ç»™åŒæˆ¿é—´ä¸”åŒåœºæ™¯çš„ç©å®¶ï¼‰
        /// </summary>
        private void BroadcastWeaponSwitchNotification(PlayerInfo player, WeaponSwitchNotification notification)
        {
            var room = ServerContext.Rooms.GetPlayerRoom(player);
            if (room == null)
            {
                Log($"ç©å®¶ {player.SteamName} ä¸åœ¨æˆ¿é—´ä¸­ï¼Œæ— éœ€å¹¿æ’­æ­¦å™¨åˆ‡æ¢", ConsoleColor.Yellow);
                return;
            }

            ServerContext.Broadcast.BroadcastToSceneTyped<IWeaponSyncClientService>(player, 
                service => service.OnWeaponSwitched(notification));

            Log($"æ­¦å™¨åˆ‡æ¢å·²å¹¿æ’­: {notification.CurrentWeaponSlot} (åœºæ™¯: {player.CurrentScenelData.SceneName})", ConsoleColor.Cyan);
        }

        /// <summary>
        /// å¹¿æ’­æ­¦å™¨å°„å‡»ç‰¹æ•ˆï¼ˆåªå‘é€ç»™åŒæˆ¿é—´ä¸”åŒåœºæ™¯çš„ç©å®¶ï¼‰
        /// </summary>
        private void BroadcastWeaponFireToRoom(PlayerInfo player, WeaponFireData fireData)
        {
            ServerContext.Broadcast.BroadcastToSceneTyped<IWeaponSyncClientService>(player, 
                service => service.OnWeaponFired(fireData));
        }

        /// <summary>
        /// å½“ç©å®¶åŠ å…¥æˆ¿é—´æ—¶ï¼Œå‘é€æ‰€æœ‰ç©å®¶çš„æ­¦å™¨æ•°æ®
        /// </summary>
        public void SendAllWeaponDataToPlayer(string clientId, string roomId)
        {
            try
            {
                var roomPlayers = ServerContext.Rooms.GetRoomPlayers(roomId);
                if (roomPlayers == null || roomPlayers.Length == 0)
                {
                    Log($"æˆ¿é—´ {roomId} æ²¡æœ‰å…¶ä»–ç©å®¶ï¼Œè·³è¿‡å‘é€æ­¦å™¨æ•°æ®", ConsoleColor.Yellow);
                    return;
                }

                var allWeaponData = new AllPlayersWeaponData();

                foreach (var player in roomPlayers)
                {
                    if (player.WeaponData != null && player.WeaponData.GetEquippedCount() > 0)
                    {
                        allWeaponData.PlayersWeapons[player.SteamId] = player.WeaponData;
                    }
                }

                var clientContext = ServerContext.Server.GetClientContext(clientId);
                if (clientContext != null)
                {
                    clientContext.Call<IWeaponSyncClientService>()
                        .OnAllPlayersWeaponReceived(allWeaponData);
                }
            }
            catch (Exception ex)
            {
                Log($"SendAllWeaponDataToPlayer å¤±è´¥: {ex.Message}", ConsoleColor.Red);
            }
        }

        /// <summary>
        /// æ‰¹é‡å¹¿æ’­æ­¦å™¨å°„å‡»ç‰¹æ•ˆï¼ˆåªå‘é€ç»™åŒæˆ¿é—´ä¸”åŒåœºæ™¯çš„ç©å®¶ï¼‰
        /// ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šéœ°å¼¹æª 8 å‘å¼¹ä¸¸ä¸€æ¬¡æ€§å¹¿æ’­
        /// </summary>
        private void BroadcastWeaponFireBatchToRoom(PlayerInfo player, WeaponFireBatchData batchData)
        {
            // è½¬æ¢ä¸º WeaponFireData æ•°ç»„å¹¶é€ä¸ªå‘é€
            var fireDataArray = batchData.ToFireDataArray();
            
            foreach (var fireData in fireDataArray)
            {
                ServerContext.Broadcast.BroadcastToSceneTyped<IWeaponSyncClientService>(player, 
                    service => service.OnWeaponFired(fireData));
            }
        }

        private void Log(string message, ConsoleColor color = ConsoleColor.White)
        {
            Console.ForegroundColor = color;
            Console.WriteLine($"[WeaponSyncService] {message}");
            Console.ResetColor();
        }
    }
}


```

`Server\Web\Controllers\DashboardController.cs`:

```cs
using Microsoft.AspNetCore.Mvc;
using DuckyNet.Server.Managers;
using System.Linq;

namespace DuckyNet.Server.Web.Controllers
{
    /// <summary>
    /// åå°ç®¡ç† - æ€»è§ˆé¢æ¿
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class DashboardController : ControllerBase
    {
        private readonly PlayerManager _playerManager;
        private readonly RoomManager _roomManager;
        private readonly PlayerNpcManager _npcManager;

        public DashboardController(
            PlayerManager playerManager,
            RoomManager roomManager,
            PlayerNpcManager npcManager)
        {
            _playerManager = playerManager;
            _roomManager = roomManager;
            _npcManager = npcManager;
        }

        /// <summary>
        /// è·å–æœåŠ¡å™¨æ¦‚è§ˆä¿¡æ¯
        /// </summary>
        [HttpGet("overview")]
        public IActionResult GetOverview()
        {
            var rooms = _roomManager.GetAllRooms();
            var players = _playerManager.GetAllOnlinePlayers();
            var npcStats = _npcManager.GetStats();

            return Ok(new
            {
                onlinePlayers = players.Length,
                totalRooms = rooms.Length,
                totalNpcs = npcStats.TotalNpcs,
                serverTime = DateTime.UtcNow,
                uptime = "è¿è¡Œä¸­" // å¯ä»¥åç»­æ·»åŠ çœŸå®çš„è¿è¡Œæ—¶é—´ç»Ÿè®¡
            });
        }
    }
}


```

`Server\Web\Controllers\MonitorController.cs`:

```cs
using Microsoft.AspNetCore.Mvc;
using DuckyNet.Server.Managers;
using System;
using System.Linq;

namespace DuckyNet.Server.Web.Controllers
{
    /// <summary>
    /// åå°ç®¡ç† - å®æ—¶ç›‘æ§
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class MonitorController : ControllerBase
    {
        private readonly PlayerManager _playerManager;
        private readonly RoomManager _roomManager;
        private readonly SceneManager _sceneManager;
        private readonly PlayerNpcManager _npcManager;
        private static readonly DateTime _startTime = DateTime.UtcNow;

        public MonitorController(
            PlayerManager playerManager,
            RoomManager roomManager,
            SceneManager sceneManager,
            PlayerNpcManager npcManager)
        {
            _playerManager = playerManager;
            _roomManager = roomManager;
            _sceneManager = sceneManager;
            _npcManager = npcManager;
        }

        /// <summary>
        /// è·å–æœåŠ¡å™¨æ€§èƒ½ç»Ÿè®¡
        /// </summary>
        [HttpGet("performance")]
        public IActionResult GetPerformance()
        {
            var uptime = DateTime.UtcNow - _startTime;
            var players = _playerManager.GetAllOnlinePlayers();
            var rooms = _roomManager.GetAllRooms();
            var npcStats = _npcManager.GetStats();

            return Ok(new
            {
                server = new
                {
                    startTime = _startTime,
                    uptime = new
                    {
                        days = uptime.Days,
                        hours = uptime.Hours,
                        minutes = uptime.Minutes,
                        seconds = uptime.Seconds,
                        totalSeconds = (long)uptime.TotalSeconds
                    },
                    uptimeString = $"{uptime.Days}å¤© {uptime.Hours}å°æ—¶ {uptime.Minutes}åˆ†é’Ÿ"
                },
                connections = new
                {
                    totalPlayers = players.Length,
                    pendingLogins = _playerManager.GetStatistics().PendingLogins,
                    refreshMethod = "HTTP Polling (3s)"
                },
                resources = new
                {
                    totalRooms = rooms.Length,
                    totalNpcs = npcStats.TotalNpcs,
                    playersWithNpcs = npcStats.TotalPlayers
                },
                timestamp = DateTime.UtcNow
            });
        }

        /// <summary>
        /// è·å–ç©å®¶åˆ†å¸ƒç»Ÿè®¡
        /// </summary>
        [HttpGet("player-distribution")]
        public IActionResult GetPlayerDistribution()
        {
            var players = _playerManager.GetAllOnlinePlayers();
            var rooms = _roomManager.GetAllRooms();

            // æŒ‰æˆ¿é—´åˆ†ç»„
            var roomDistribution = rooms.Select(room => new
            {
                roomId = room.RoomId,
                roomName = room.RoomName,
                playerCount = room.CurrentPlayers,
                maxPlayers = room.MaxPlayers,
                utilization = room.MaxPlayers > 0 
                    ? (double)room.CurrentPlayers / room.MaxPlayers * 100 
                    : 0
            }).ToList();

            // æŒ‰åœºæ™¯åˆ†ç»„
            var sceneDistribution = players
                .Where(p => !string.IsNullOrEmpty(p.CurrentScenelData?.SceneName))
                .GroupBy(p => new 
                { 
                    SceneName = p.CurrentScenelData!.SceneName,
                    SubSceneName = p.CurrentScenelData.SubSceneName 
                })
                .Select(g => new
                {
                    sceneName = g.Key.SceneName,
                    subSceneName = g.Key.SubSceneName,
                    playerCount = g.Count(),
                    players = g.Select(p => p.SteamName).ToList()
                })
                .OrderByDescending(x => x.playerCount)
                .ToList();

            return Ok(new
            {
                totalPlayers = players.Length,
                playersInRooms = rooms.Sum(r => r.CurrentPlayers),
                playersInScenes = sceneDistribution.Sum(s => s.playerCount),
                roomDistribution,
                sceneDistribution
            });
        }

        /// <summary>
        /// è·å–NPCç»Ÿè®¡è¯¦æƒ…
        /// </summary>
        [HttpGet("npc-stats")]
        public IActionResult GetNpcStats()
        {
            var npcStats = _npcManager.GetStats();
            var players = _playerManager.GetAllOnlinePlayers();

            // è·å–æ¯ä¸ªç©å®¶çš„NPCæ•°é‡
            var playerNpcCounts = players.Select(p => new
            {
                steamId = p.SteamId,
                steamName = p.SteamName,
                npcCount = _npcManager.GetPlayerNpcs(p.SteamId).Count
            })
            .Where(x => x.npcCount > 0)
            .OrderByDescending(x => x.npcCount)
            .ToList();

            // æŒ‰åœºæ™¯ç»Ÿè®¡NPC
            var sceneNpcCounts = players
                .Where(p => !string.IsNullOrEmpty(p.CurrentScenelData?.SceneName))
                .Select(p => new
                {
                    sceneName = p.CurrentScenelData!.SceneName,
                    subSceneName = p.CurrentScenelData.SubSceneName,
                    npcCount = _npcManager.GetSceneNpcs(
                        p.CurrentScenelData.SceneName, 
                        p.CurrentScenelData.SubSceneName).Count
                })
                .GroupBy(x => new { x.sceneName, x.subSceneName })
                .Select(g => new
                {
                    sceneName = g.Key.sceneName,
                    subSceneName = g.Key.subSceneName,
                    npcCount = g.First().npcCount
                })
                .OrderByDescending(x => x.npcCount)
                .ToList();

            return Ok(new
            {
                overview = new
                {
                    totalNpcs = npcStats.TotalNpcs,
                    playersWithNpcs = npcStats.TotalPlayers,
                    averageNpcsPerPlayer = npcStats.TotalPlayers > 0 
                        ? (double)npcStats.TotalNpcs / npcStats.TotalPlayers 
                        : 0
                },
                playerNpcCounts,
                sceneNpcCounts
            });
        }

        /// <summary>
        /// è·å–çƒ­é—¨åœºæ™¯æ’è¡Œ
        /// </summary>
        [HttpGet("hot-scenes")]
        public IActionResult GetHotScenes()
        {
            var players = _playerManager.GetAllOnlinePlayers();

            var hotScenes = players
                .Where(p => !string.IsNullOrEmpty(p.CurrentScenelData?.SceneName))
                .GroupBy(p => new 
                { 
                    SceneName = p.CurrentScenelData!.SceneName,
                    SubSceneName = p.CurrentScenelData.SubSceneName 
                })
                .Select(g => new
                {
                    sceneName = g.Key.SceneName,
                    subSceneName = g.Key.SubSceneName,
                    playerCount = g.Count(),
                    npcCount = _npcManager.GetSceneNpcs(g.Key.SceneName, g.Key.SubSceneName).Count,
                    players = g.Select(p => new
                    {
                        steamId = p.SteamId,
                        steamName = p.SteamName
                    }).ToList()
                })
                .OrderByDescending(x => x.playerCount)
                .Take(10)
                .ToList();

            return Ok(hotScenes);
        }

        /// <summary>
        /// è·å–ç³»ç»Ÿå¥åº·çŠ¶æ€
        /// </summary>
        [HttpGet("health")]
        public IActionResult GetHealth()
        {
            var uptime = DateTime.UtcNow - _startTime;
            var players = _playerManager.GetAllOnlinePlayers();
            var rooms = _roomManager.GetAllRooms();

            var isHealthy = true;
            var warnings = new System.Collections.Generic.List<string>();

            // æ£€æŸ¥æ˜¯å¦æœ‰ç©å®¶ä½†æ²¡æœ‰æˆ¿é—´
            if (players.Length > 0 && rooms.Length == 0)
            {
                warnings.Add("æœ‰ç©å®¶åœ¨çº¿ä½†æ²¡æœ‰æ´»è·ƒæˆ¿é—´");
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰æˆ¿é—´æ»¡å‘˜
            var fullRooms = rooms.Count(r => r.IsFull);
            if (fullRooms > 0)
            {
                warnings.Add($"æœ‰ {fullRooms} ä¸ªæˆ¿é—´å·²æ»¡å‘˜");
            }

            return Ok(new
            {
                status = isHealthy ? "healthy" : "warning",
                uptime = $"{uptime.Days}å¤© {uptime.Hours}å°æ—¶ {uptime.Minutes}åˆ†é’Ÿ",
                metrics = new
                {
                    onlinePlayers = players.Length,
                    activeRooms = rooms.Length
                },
                warnings
            });
        }
    }
}


```

`Server\Web\Controllers\NpcsController.cs`:

```cs
using Microsoft.AspNetCore.Mvc;
using DuckyNet.Server.Managers;
using System.Linq;

namespace DuckyNet.Server.Web.Controllers
{
    /// <summary>
    /// åå°ç®¡ç† - NPCç®¡ç†
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class NpcsController : ControllerBase
    {
        private readonly PlayerNpcManager _npcManager;

        public NpcsController(PlayerNpcManager npcManager)
        {
            _npcManager = npcManager;
        }

        /// <summary>
        /// è·å–æ‰€æœ‰NPCåˆ—è¡¨
        /// </summary>
        [HttpGet]
        public IActionResult GetAllNpcs()
        {
            var stats = _npcManager.GetStats();
            
            // è·å–æ‰€æœ‰åœºæ™¯ä¸­çš„NPC
            var allNpcs = new System.Collections.Generic.List<object>();
            
            // è¿™é‡Œæˆ‘ä»¬éœ€è¦éå†æ‰€æœ‰ç©å®¶çš„NPC
            // ç”±äºPlayerNpcManageræ²¡æœ‰æä¾›GetAllNpcsæ–¹æ³•ï¼Œæˆ‘ä»¬è¿”å›ç»Ÿè®¡ä¿¡æ¯
            return Ok(new
            {
                totalNpcs = stats.TotalNpcs,
                totalPlayers = stats.TotalPlayers,
                message = "ä½¿ç”¨ /api/scenes æŸ¥çœ‹å…·ä½“åœºæ™¯ä¸­çš„NPC"
            });
        }

        /// <summary>
        /// è·å–æŒ‡å®šNPCçš„è¯¦ç»†ä¿¡æ¯
        /// </summary>
        [HttpGet("{npcId}")]
        public IActionResult GetNpcDetail(string npcId)
        {
            var npc = _npcManager.GetNpcById(npcId);
            if (npc == null)
            {
                return NotFound(new { message = "NPCä¸å­˜åœ¨" });
            }

            var owner = _npcManager.GetNpcOwner(npcId);

            return Ok(new
            {
                npcId = npc.NpcId,
                npcType = npc.NpcType,
                sceneName = npc.SceneName,
                subSceneName = npc.SubSceneName,
                position = new
                {
                    x = npc.PositionX,
                    y = npc.PositionY,
                    z = npc.PositionZ
                },
                rotationY = npc.RotationY,
                maxHealth = npc.MaxHealth,
                spawnTime = DateTimeOffset.FromUnixTimeMilliseconds(npc.SpawnTimestamp).UtcDateTime,
                owner
            });
        }
    }
}


```

`Server\Web\Controllers\PlayersController.cs`:

```cs
using Microsoft.AspNetCore.Mvc;
using DuckyNet.Server.Managers;
using System.Linq;

namespace DuckyNet.Server.Web.Controllers
{
    /// <summary>
    /// åå°ç®¡ç† - ç©å®¶ç®¡ç†
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class PlayersController : ControllerBase
    {
        private readonly PlayerManager _playerManager;
        private readonly RoomManager _roomManager;
        private readonly SceneManager _sceneManager;

        public PlayersController(
            PlayerManager playerManager,
            RoomManager roomManager,
            SceneManager sceneManager)
        {
            _playerManager = playerManager;
            _roomManager = roomManager;
            _sceneManager = sceneManager;
        }

        /// <summary>
        /// è·å–æ‰€æœ‰åœ¨çº¿ç©å®¶åˆ—è¡¨
        /// </summary>
        [HttpGet]
        public IActionResult GetAllPlayers()
        {
            var players = _playerManager.GetAllOnlinePlayers();
            var playerList = players.Select(p =>
            {
                var room = _roomManager.GetPlayerRoom(p);
                var position = _sceneManager.GetPlayerPosition(p.SteamId);

                return new
                {
                    steamId = p.SteamId,
                    steamName = p.SteamName,
                    sceneName = p.CurrentScenelData?.SceneName ?? "",
                    subSceneName = p.CurrentScenelData?.SubSceneName ?? "",
                    roomId = room?.RoomId ?? "",
                    roomName = room?.RoomName ?? "",
                    position = position != null ? new
                    {
                        x = position.Value.X,
                        y = position.Value.Y,
                        z = position.Value.Z
                    } : null
                };
            }).ToList();

            return Ok(playerList);
        }

        /// <summary>
        /// è·å–æŒ‡å®šç©å®¶çš„è¯¦ç»†ä¿¡æ¯
        /// </summary>
        [HttpGet("{steamId}")]
        public IActionResult GetPlayerDetail(string steamId)
        {
            var player = _playerManager.GetPlayerBySteamId(steamId);
            if (player == null)
            {
                return NotFound(new { message = "ç©å®¶ä¸å­˜åœ¨" });
            }

            var room = _roomManager.GetPlayerRoom(player);
            var position = _sceneManager.GetPlayerPosition(steamId);

            return Ok(new
            {
                steamId = player.SteamId,
                steamName = player.SteamName,
                sceneName = player.CurrentScenelData?.SceneName ?? "",
                subSceneName = player.CurrentScenelData?.SubSceneName ?? "",
                roomId = room?.RoomId ?? "",
                roomName = room?.RoomName ?? "",
                position = position != null ? new
                {
                    x = position.Value.X,
                    y = position.Value.Y,
                    z = position.Value.Z
                } : null
            });
        }
    }
}


```

`Server\Web\Controllers\RoomsController.cs`:

```cs
using Microsoft.AspNetCore.Mvc;
using DuckyNet.Server.Managers;
using System.Linq;

namespace DuckyNet.Server.Web.Controllers
{
    /// <summary>
    /// åå°ç®¡ç† - æˆ¿é—´ç®¡ç†
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class RoomsController : ControllerBase
    {
        private readonly RoomManager _roomManager;
        private readonly PlayerManager _playerManager;

        public RoomsController(RoomManager roomManager, PlayerManager playerManager)
        {
            _roomManager = roomManager;
            _playerManager = playerManager;
        }

        /// <summary>
        /// è·å–æ‰€æœ‰æˆ¿é—´åˆ—è¡¨
        /// </summary>
        [HttpGet]
        public IActionResult GetAllRooms()
        {
            var rooms = _roomManager.GetAllRooms();
            var roomList = rooms.Select(room => new
            {
                roomId = room.RoomId,
                roomName = room.RoomName,
                description = room.Description,
                hostSteamId = room.HostSteamId,
                currentPlayers = room.CurrentPlayers,
                maxPlayers = room.MaxPlayers,
                requirePassword = room.RequirePassword,
                createTime = room.CreateTime,
                isFull = room.IsFull
            }).ToList();

            return Ok(roomList);
        }

        /// <summary>
        /// è·å–æŒ‡å®šæˆ¿é—´çš„è¯¦ç»†ä¿¡æ¯
        /// </summary>
        [HttpGet("{roomId}")]
        public IActionResult GetRoomDetail(string roomId)
        {
            var room = _roomManager.GetRoom(roomId);
            if (room == null)
            {
                return NotFound(new { message = "æˆ¿é—´ä¸å­˜åœ¨" });
            }

            var players = _roomManager.GetRoomPlayers(roomId);
            var playerList = players.Select(p => new
            {
                steamId = p.SteamId,
                steamName = p.SteamName,
                sceneName = p.CurrentScenelData?.SceneName ?? "",
                subSceneName = p.CurrentScenelData?.SubSceneName ?? ""
            }).ToList();

            return Ok(new
            {
                roomInfo = new
                {
                    roomId = room.RoomId,
                    roomName = room.RoomName,
                    description = room.Description,
                    hostSteamId = room.HostSteamId,
                    currentPlayers = room.CurrentPlayers,
                    maxPlayers = room.MaxPlayers,
                    requirePassword = room.RequirePassword,
                    createTime = room.CreateTime
                },
                players = playerList
            });
        }
    }
}


```

`Server\Web\Controllers\ScenesController.cs`:

```cs
using Microsoft.AspNetCore.Mvc;
using DuckyNet.Server.Managers;
using System.Linq;
using System.Collections.Generic;

namespace DuckyNet.Server.Web.Controllers
{
    /// <summary>
    /// åå°ç®¡ç† - åœºæ™¯ç®¡ç†
    /// </summary>
    [ApiController]
    [Route("api/[controller]")]
    public class ScenesController : ControllerBase
    {
        private readonly PlayerManager _playerManager;
        private readonly SceneManager _sceneManager;
        private readonly PlayerNpcManager _npcManager;

        public ScenesController(
            PlayerManager playerManager,
            SceneManager sceneManager,
            PlayerNpcManager npcManager)
        {
            _playerManager = playerManager;
            _sceneManager = sceneManager;
            _npcManager = npcManager;
        }

        /// <summary>
        /// è·å–æ‰€æœ‰åœºæ™¯åˆ—è¡¨ï¼ˆæ ¹æ®åœ¨çº¿ç©å®¶ç»Ÿè®¡ï¼‰
        /// </summary>
        [HttpGet]
        public IActionResult GetAllScenes()
        {
            var players = _playerManager.GetAllOnlinePlayers();
            
            // æŒ‰åœºæ™¯åˆ†ç»„ç»Ÿè®¡
            var sceneGroups = players
                .Where(p => !string.IsNullOrEmpty(p.CurrentScenelData?.SceneName))
                .GroupBy(p => new
                {
                    SceneName = p.CurrentScenelData!.SceneName,
                    SubSceneName = p.CurrentScenelData.SubSceneName
                })
                .Select(g => new
                {
                    sceneName = g.Key.SceneName,
                    subSceneName = g.Key.SubSceneName,
                    playerCount = g.Count(),
                    npcCount = _npcManager.GetSceneNpcs(g.Key.SceneName, g.Key.SubSceneName).Count
                })
                .ToList();

            return Ok(sceneGroups);
        }

        /// <summary>
        /// è·å–æŒ‡å®šåœºæ™¯çš„è¯¦ç»†ä¿¡æ¯
        /// </summary>
        [HttpGet("{sceneName}/{subSceneName}")]
        public IActionResult GetSceneDetail(string sceneName, string subSceneName)
        {
            var players = _playerManager.GetAllOnlinePlayers()
                .Where(p => p.CurrentScenelData?.SceneName == sceneName &&
                           p.CurrentScenelData?.SubSceneName == subSceneName)
                .ToList();

            var npcs = _npcManager.GetSceneNpcs(sceneName, subSceneName);

            var playerList = players.Select(p =>
            {
                var position = _sceneManager.GetPlayerPosition(p.SteamId);
                return new
                {
                    steamId = p.SteamId,
                    steamName = p.SteamName,
                    position = position != null ? new
                    {
                        x = position.Value.X,
                        y = position.Value.Y,
                        z = position.Value.Z
                    } : null
                };
            }).ToList();

            var npcList = npcs.Select(npc => new
            {
                npcId = npc.NpcId,
                npcType = npc.NpcType,
                position = new
                {
                    x = npc.PositionX,
                    y = npc.PositionY,
                    z = npc.PositionZ
                },
                rotationY = npc.RotationY,
                maxHealth = npc.MaxHealth,
                spawnTime = DateTimeOffset.FromUnixTimeMilliseconds(npc.SpawnTimestamp).UtcDateTime,
                owner = _npcManager.GetNpcOwner(npc.NpcId)
            }).ToList();

            return Ok(new
            {
                sceneName,
                subSceneName,
                players = playerList,
                npcs = npcList
            });
        }
    }
}


```

`Server\Web\README.md`:

```md
# DuckyNet æœåŠ¡å™¨ç®¡ç†åå°

## åŠŸèƒ½ä»‹ç»

åŸºäº **Vue3** å’Œ **ASP.NET Core** çš„ Steam é£æ ¼æœåŠ¡å™¨ç®¡ç†åå°ï¼Œæä¾›å®æ—¶ç›‘æ§å’Œç®¡ç†åŠŸèƒ½ã€‚

### ä¸»è¦åŠŸèƒ½

1. **æœåŠ¡å™¨æ¦‚è§ˆ**
   - åœ¨çº¿ç©å®¶æ•°é‡
   - æ´»è·ƒæˆ¿é—´æ•°é‡
   - NPC æ€»æ•°
   - æœåŠ¡å™¨è¿è¡ŒçŠ¶æ€

2. **æˆ¿é—´ç®¡ç†**
   - æŸ¥çœ‹æ‰€æœ‰æˆ¿é—´åˆ—è¡¨
   - æŸ¥çœ‹æˆ¿é—´è¯¦ç»†ä¿¡æ¯
   - æŸ¥çœ‹æˆ¿é—´å†…ç©å®¶
   - æˆ¿é—´çŠ¶æ€ç›‘æ§ï¼ˆäººæ•°ã€å¯†ç ã€åˆ›å»ºæ—¶é—´ï¼‰

3. **ç©å®¶ç®¡ç†**
   - æŸ¥çœ‹æ‰€æœ‰åœ¨çº¿ç©å®¶
   - æŸ¥çœ‹ç©å®¶ä½ç½®ä¿¡æ¯
   - æŸ¥çœ‹ç©å®¶æ‰€åœ¨æˆ¿é—´å’Œåœºæ™¯
   - ç©å®¶çŠ¶æ€å®æ—¶ç›‘æ§

4. **åœºæ™¯ç®¡ç†**
   - æŸ¥çœ‹æ‰€æœ‰æ´»è·ƒåœºæ™¯
   - æŸ¥çœ‹åœºæ™¯å†…çš„ç©å®¶å’Œ NPC
   - NPC ä½ç½®å’Œè¡€é‡ä¿¡æ¯
   - åœºæ™¯çƒ­åº¦ç»Ÿè®¡

## æŠ€æœ¯æ ˆ

### åç«¯
- ASP.NET Core 8.0
- Web API
- Swagger API æ–‡æ¡£

### å‰ç«¯
- Vue 3 (é€šè¿‡ CDN)
- Axios (HTTP è¯·æ±‚)
- Steam é£æ ¼ CSS

## å¯åŠ¨æœåŠ¡å™¨

### 1. è¿˜åŸä¾èµ–åŒ…
```bash
cd Server
dotnet restore
```

### 2. è¿è¡ŒæœåŠ¡å™¨
```bash
dotnet run
```

### 3. è®¿é—®åå°
å¯åŠ¨æˆåŠŸåï¼Œè®¿é—®ï¼š
- **ç®¡ç†åå°**: http://localhost:5000
- **API æ–‡æ¡£**: http://localhost:5000/swagger (å¼€å‘æ¨¡å¼)
- **RPC æœåŠ¡å™¨**: ç«¯å£ 9050

## API ç«¯ç‚¹

### Dashboard API
- `GET /api/dashboard/overview` - è·å–æœåŠ¡å™¨æ¦‚è§ˆ

### æˆ¿é—´ API
- `GET /api/rooms` - è·å–æ‰€æœ‰æˆ¿é—´
- `GET /api/rooms/{roomId}` - è·å–æˆ¿é—´è¯¦æƒ…

### ç©å®¶ API
- `GET /api/players` - è·å–æ‰€æœ‰åœ¨çº¿ç©å®¶
- `GET /api/players/{steamId}` - è·å–ç©å®¶è¯¦æƒ…

### åœºæ™¯ API
- `GET /api/scenes` - è·å–æ‰€æœ‰åœºæ™¯
- `GET /api/scenes/{sceneName}/{subSceneName}` - è·å–åœºæ™¯è¯¦æƒ…

### NPC API
- `GET /api/npcs` - è·å– NPC ç»Ÿè®¡
- `GET /api/npcs/{npcId}` - è·å– NPC è¯¦æƒ…

## ç›®å½•ç»“æ„

```
Server/Web/
â”œâ”€â”€ Controllers/           # Web API æ§åˆ¶å™¨
â”‚   â”œâ”€â”€ DashboardController.cs
â”‚   â”œâ”€â”€ RoomsController.cs
â”‚   â”œâ”€â”€ PlayersController.cs
â”‚   â”œâ”€â”€ ScenesController.cs
â”‚   â””â”€â”€ NpcsController.cs
â”œâ”€â”€ wwwroot/              # é™æ€èµ„æº
â”‚   â”œâ”€â”€ index.html        # ä¸»é¡µé¢
â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â””â”€â”€ steam-style.css
â”‚   â””â”€â”€ js/
â”‚       â””â”€â”€ app.js
â”œâ”€â”€ WebServerStartup.cs   # Web æœåŠ¡å™¨é…ç½®
â””â”€â”€ README.md             # æœ¬æ–‡æ¡£
```

## ç‰¹æ€§

### è‡ªåŠ¨åˆ·æ–°
- æ•°æ®æ¯ 5 ç§’è‡ªåŠ¨åˆ·æ–°
- æœåŠ¡å™¨æ—¶é—´æ¯ç§’æ›´æ–°

### Steam é£æ ¼ç•Œé¢
- æ·±è‰²ä¸»é¢˜
- Steam è“è‰²å¼ºè°ƒè‰²
- æµç•…çš„åŠ¨ç”»è¿‡æ¸¡
- æ‚¬åœæ•ˆæœ

### å“åº”å¼è®¾è®¡
- è‡ªé€‚åº”å¡ç‰‡å¸ƒå±€
- ç½‘æ ¼ç³»ç»Ÿ
- æ»šåŠ¨æ¡æ ·å¼å®šåˆ¶

## å¼€å‘è¯´æ˜

### ä¿®æ”¹ Web ç«¯å£
åœ¨ `Program.cs` ä¸­ä¿®æ”¹ï¼š
```csharp
var webTask = _webApp.RunAsync("http://localhost:5000");
```

### æ·»åŠ æ–°çš„ API
1. åœ¨ `Controllers/` ç›®å½•åˆ›å»ºæ–°çš„æ§åˆ¶å™¨
2. ç»§æ‰¿ `ControllerBase`
3. æ·»åŠ  `[ApiController]` å’Œ `[Route("api/[controller]")]` ç‰¹æ€§
4. é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥æ‰€éœ€çš„ Manager

### ä¿®æ”¹å‰ç«¯æ ·å¼
ç¼–è¾‘ `wwwroot/css/steam-style.css` æ–‡ä»¶

### æ·»åŠ æ–°åŠŸèƒ½
1. åœ¨ `app.js` çš„ `data()` ä¸­æ·»åŠ å“åº”å¼æ•°æ®
2. åœ¨ `methods` ä¸­æ·»åŠ æ–°æ–¹æ³•
3. åœ¨ `index.html` ä¸­æ·»åŠ å¯¹åº”çš„ UI

## æ³¨æ„äº‹é¡¹

1. Web æœåŠ¡å™¨å’Œ RPC æœåŠ¡å™¨åŒæ—¶è¿è¡Œ
2. æ‰€æœ‰ Manager é€šè¿‡ä¾èµ–æ³¨å…¥å…±äº«
3. æ•°æ®å®æ—¶æ€§å–å†³äºè‡ªåŠ¨åˆ·æ–°é—´éš”
4. CORS å·²å¯ç”¨ï¼Œå…è®¸è·¨åŸŸè®¿é—®

## æ•…éšœæ’é™¤

### ç«¯å£è¢«å ç”¨
ä¿®æ”¹ `Program.cs` ä¸­çš„ Web ç«¯å£å·

### æ— æ³•è®¿é—®é™æ€æ–‡ä»¶
æ£€æŸ¥ `wwwroot` ç›®å½•æ˜¯å¦å­˜åœ¨ä¸”åŒ…å«æ‰€æœ‰æ–‡ä»¶

### API è¿”å›ç©ºæ•°æ®
ç¡®ä¿æ¸¸æˆæœåŠ¡å™¨æ­£åœ¨è¿è¡Œä¸”æœ‰ç©å®¶è¿æ¥

## æœªæ¥æ”¹è¿›

- [ ] æ·»åŠ å®æ—¶ WebSocket æ¨é€
- [ ] æ·»åŠ ç©å®¶è¸¢å‡ºåŠŸèƒ½
- [ ] æ·»åŠ æœåŠ¡å™¨é…ç½®ç®¡ç†
- [ ] æ·»åŠ æ—¥å¿—æŸ¥çœ‹åŠŸèƒ½
- [ ] æ·»åŠ æ€§èƒ½ç›‘æ§å›¾è¡¨
- [ ] æ·»åŠ ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†

## è®¸å¯è¯

ä¸ DuckyNet é¡¹ç›®ä¿æŒä¸€è‡´


```

`Server\Web\WebServerStartup.cs`:

```cs
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using DuckyNet.Server.Managers;

namespace DuckyNet.Server.Web
{
    /// <summary>
    /// Web æœåŠ¡å™¨å¯åŠ¨é…ç½®
    /// </summary>
    public static class WebServerStartup
    {
        /// <summary>
        /// é…ç½®å¹¶å¯åŠ¨ Web æœåŠ¡å™¨
        /// </summary>
        public static WebApplication CreateAndConfigureWebApp(
            IServiceProvider gameServiceProvider,
            string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            // é…ç½® Web æœåŠ¡
            builder.Services.AddControllers();
            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();
            
            // å¯ç”¨ CORSï¼ˆå…è®¸Vueå‰ç«¯è®¿é—®ï¼‰
            builder.Services.AddCors(options =>
            {
                options.AddDefaultPolicy(policy =>
                {
                    policy.WithOrigins("http://localhost:3000", "http://localhost:3001") // Vueå¼€å‘æœåŠ¡å™¨ï¼ˆæ”¯æŒå¤šç«¯å£ï¼‰
                          .AllowAnyMethod()
                          .AllowAnyHeader()
                          .AllowCredentials(); // å…è®¸WebSocket
                });
            });

            // ä»æ¸¸æˆæœåŠ¡æä¾›è€…ä¸­è·å–å•ä¾‹æœåŠ¡å¹¶æ³¨å…¥åˆ° Web æœåŠ¡ä¸­
            builder.Services.AddSingleton(gameServiceProvider.GetRequiredService<PlayerManager>());
            builder.Services.AddSingleton(gameServiceProvider.GetRequiredService<RoomManager>());
            builder.Services.AddSingleton(gameServiceProvider.GetRequiredService<SceneManager>());
            builder.Services.AddSingleton(gameServiceProvider.GetRequiredService<PlayerNpcManager>());

            var app = builder.Build();

            // é…ç½® HTTP è¯·æ±‚ç®¡é“
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
            }

            app.UseCors();
            app.UseRouting();
            app.MapControllers();
            
            // æ ¹è·¯å¾„æç¤ºä¿¡æ¯
            app.MapGet("/", async context =>
            {
                context.Response.ContentType = "application/json; charset=utf-8";
                await context.Response.WriteAsync(@"{
    ""name"": ""DuckyNet Server API"",
    ""version"": ""1.0.0"",
    ""swagger"": ""/swagger"",
    ""frontend"": ""http://localhost:3001 (Vue3 Dev Server)"",
    ""refresh"": ""HTTP Polling (3 seconds)""
}");
            });

            return app;
        }
    }
}


```

`Server\Web\wwwroot\css\steam-style.css`:

```css
/* Steam é£æ ¼é…è‰² */
:root {
    --steam-dark: #1b2838;
    --steam-darker: #171a21;
    --steam-blue: #1a9fff;
    --steam-blue-hover: #66c0f4;
    --steam-gray: #2a475e;
    --steam-light-gray: #c7d5e0;
    --steam-green: #5c7e10;
    --steam-card-bg: #16202d;
    --steam-border: #3c4f5e;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: "Motiva Sans", Arial, sans-serif;
    background: linear-gradient(135deg, var(--steam-darker) 0%, var(--steam-dark) 100%);
    color: var(--steam-light-gray);
    min-height: 100vh;
}

/* é¡¶éƒ¨å¯¼èˆªæ  */
.steam-header {
    background: var(--steam-darker);
    border-bottom: 2px solid var(--steam-blue);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    gap: 2rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.header-logo h1 {
    font-size: 1.5rem;
    color: var(--steam-blue-hover);
    font-weight: bold;
}

.header-nav {
    display: flex;
    gap: 0.5rem;
    flex: 1;
}

.nav-button {
    background: transparent;
    border: 2px solid var(--steam-gray);
    color: var(--steam-light-gray);
    padding: 0.5rem 1.5rem;
    cursor: pointer;
    font-size: 1rem;
    border-radius: 3px;
    transition: all 0.3s ease;
}

.nav-button:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
}

.nav-button.active {
    background: linear-gradient(to bottom, var(--steam-blue) 0%, #1a7dc4 100%);
    border-color: var(--steam-blue);
    color: white;
    box-shadow: 0 0 10px rgba(26, 159, 255, 0.5);
}

.header-time {
    color: var(--steam-light-gray);
    font-size: 0.9rem;
}

/* ä¸»å†…å®¹åŒº */
.steam-main {
    padding: 2rem;
    max-width: 1600px;
    margin: 0 auto;
}

.content-panel {
    background: var(--steam-card-bg);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 2rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
}

.panel-title {
    color: var(--steam-blue-hover);
    font-size: 1.8rem;
    margin-bottom: 1.5rem;
    border-bottom: 2px solid var(--steam-blue);
    padding-bottom: 0.5rem;
}

/* ç»Ÿè®¡å¡ç‰‡ç½‘æ ¼ */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
}

.stat-card {
    background: linear-gradient(135deg, var(--steam-gray) 0%, var(--steam-dark) 100%);
    border: 1px solid var(--steam-border);
    border-radius: 8px;
    padding: 1.5rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(26, 159, 255, 0.3);
}

.stat-icon {
    font-size: 3rem;
}

.stat-content {
    flex: 1;
}

.stat-value {
    font-size: 2.5rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.stat-label {
    color: var(--steam-light-gray);
    font-size: 0.9rem;
    margin-top: 0.25rem;
}

/* æˆ¿é—´åˆ—è¡¨ */
.room-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.room-card {
    background: var(--steam-dark);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.room-card:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
    transform: translateX(5px);
}

.room-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.room-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.room-id {
    font-size: 0.8rem;
    color: #999;
}

.room-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
}

.room-players {
    color: var(--steam-blue-hover);
    font-weight: bold;
}

.room-meta {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
}

.badge {
    background: var(--steam-green);
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    font-size: 0.75rem;
}

.badge.full {
    background: #d32f2f;
}

.room-time {
    font-size: 0.75rem;
    color: #999;
}

/* ç©å®¶åˆ—è¡¨ */
.player-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-top: 1rem;
}

.player-card {
    background: var(--steam-dark);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    transition: all 0.3s ease;
}

.player-card:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
}

.player-avatar {
    font-size: 2.5rem;
}

.player-info {
    flex: 1;
}

.player-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.player-id {
    font-size: 0.8rem;
    color: #999;
    margin-top: 0.25rem;
}

.player-status {
    text-align: right;
    font-size: 0.9rem;
}

.player-room, .player-scene, .player-position {
    margin-bottom: 0.25rem;
}

/* åœºæ™¯åˆ—è¡¨ */
.scene-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.scene-card {
    background: var(--steam-dark);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.scene-card:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
    transform: scale(1.02);
}

.scene-header {
    margin-bottom: 0.5rem;
}

.scene-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.scene-sub {
    color: #999;
    font-size: 0.9rem;
}

.scene-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
}

/* è¯¦æƒ…é¢æ¿ */
.detail-panel {
    position: fixed;
    right: 2rem;
    top: 120px;
    width: 400px;
    max-height: calc(100vh - 140px);
    overflow-y: auto;
    background: var(--steam-card-bg);
    border: 2px solid var(--steam-blue);
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
}

.detail-panel h3 {
    color: var(--steam-blue-hover);
    margin-bottom: 1rem;
}

.detail-panel h4 {
    color: var(--steam-light-gray);
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid var(--steam-border);
    padding-bottom: 0.25rem;
}

.close-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: transparent;
    border: none;
    color: var(--steam-light-gray);
    font-size: 1.5rem;
    cursor: pointer;
}

.close-btn:hover {
    color: var(--steam-blue-hover);
}

.detail-content p {
    margin-bottom: 0.5rem;
}

.player-mini-list, .entity-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.player-mini-card, .entity-card {
    background: var(--steam-dark);
    padding: 0.5rem;
    border-radius: 3px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.entity-card.npc {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
}

.npc-main {
    display: flex;
    justify-content: space-between;
    width: 100%;
    align-items: center;
}

.entity-name {
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.npc-id {
    font-size: 0.75rem;
    color: #999;
}

.npc-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.85rem;
    width: 100%;
}

.npc-health {
    color: #ff6b6b;
}

.entity-pos {
    font-size: 0.8rem;
    color: #999;
}

.npc-meta {
    font-size: 0.75rem;
    color: #999;
    width: 100%;
}

/* ç©ºçŠ¶æ€ */
.empty-state {
    text-align: center;
    padding: 3rem;
    color: #999;
    font-size: 1.1rem;
}

/* åŠ è½½åŠ¨ç”» */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.loading-spinner {
    background: var(--steam-card-bg);
    border: 2px solid var(--steam-blue);
    padding: 2rem 3rem;
    border-radius: 8px;
    font-size: 1.2rem;
    color: var(--steam-blue-hover);
}

/* æ»šåŠ¨æ¡æ ·å¼ */
::-webkit-scrollbar {
    width: 12px;
}

::-webkit-scrollbar-track {
    background: var(--steam-darker);
}

::-webkit-scrollbar-thumb {
    background: var(--steam-gray);
    border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--steam-blue);
}


```

`Server\Web\wwwroot\index.html`:

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DuckyNet æœåŠ¡å™¨ç®¡ç†åå°</title>
    <link rel="stylesheet" href="/css/steam-style.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
    <div id="app">
        <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
        <header class="steam-header">
            <div class="header-logo">
                <h1>ğŸ¦† DuckyNet æœåŠ¡å™¨ç®¡ç†</h1>
            </div>
            <div class="header-nav">
                <button 
                    v-for="tab in tabs" 
                    :key="tab.id"
                    @click="currentTab = tab.id"
                    :class="['nav-button', { active: currentTab === tab.id }]">
                    {{ tab.name }}
                </button>
            </div>
            <div class="header-time">
                <span>{{ serverTime }}</span>
            </div>
        </header>

        <!-- ä¸»è¦å†…å®¹åŒº -->
        <main class="steam-main">
            <!-- æ€»è§ˆé¢æ¿ -->
            <div v-if="currentTab === 'overview'" class="content-panel">
                <h2 class="panel-title">æœåŠ¡å™¨æ¦‚è§ˆ</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ‘¥</div>
                        <div class="stat-content">
                            <div class="stat-value">{{ overview.onlinePlayers }}</div>
                            <div class="stat-label">åœ¨çº¿ç©å®¶</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ </div>
                        <div class="stat-content">
                            <div class="stat-value">{{ overview.totalRooms }}</div>
                            <div class="stat-label">æ´»è·ƒæˆ¿é—´</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">ğŸ¤–</div>
                        <div class="stat-content">
                            <div class="stat-value">{{ overview.totalNpcs }}</div>
                            <div class="stat-label">NPCæ•°é‡</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">â±ï¸</div>
                        <div class="stat-content">
                            <div class="stat-value">{{ overview.uptime }}</div>
                            <div class="stat-label">è¿è¡ŒçŠ¶æ€</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æˆ¿é—´åˆ—è¡¨ -->
            <div v-if="currentTab === 'rooms'" class="content-panel">
                <h2 class="panel-title">æˆ¿é—´åˆ—è¡¨</h2>
                <div class="room-list">
                    <div v-for="room in rooms" :key="room.roomId" class="room-card" @click="selectRoom(room)">
                        <div class="room-header">
                            <span class="room-name">{{ room.roomName }}</span>
                            <span class="room-id">{{ room.roomId }}</span>
                        </div>
                        <div class="room-info">
                            <span>æˆ¿ä¸»: {{ room.hostSteamId }}</span>
                            <span class="room-players">ğŸ‘¥ {{ room.currentPlayers }}/{{ room.maxPlayers }}</span>
                        </div>
                        <div class="room-meta">
                            <span v-if="room.requirePassword" class="badge">ğŸ”’ éœ€è¦å¯†ç </span>
                            <span v-if="room.isFull" class="badge full">å·²æ»¡</span>
                            <span class="room-time">åˆ›å»º: {{ formatTime(room.createTime) }}</span>
                        </div>
                    </div>
                    <div v-if="rooms.length === 0" class="empty-state">
                        æš‚æ— æ´»è·ƒæˆ¿é—´
                    </div>
                </div>

                <!-- æˆ¿é—´è¯¦æƒ…é¢æ¿ -->
                <div v-if="selectedRoom" class="detail-panel">
                    <h3>æˆ¿é—´è¯¦æƒ… - {{ selectedRoom.roomName }}</h3>
                    <button @click="selectedRoom = null" class="close-btn">âœ–</button>
                    <div class="detail-content">
                        <p><strong>æˆ¿é—´ID:</strong> {{ selectedRoom.roomId }}</p>
                        <p><strong>æè¿°:</strong> {{ selectedRoom.description || 'æ— ' }}</p>
                        <p><strong>æˆ¿ä¸»:</strong> {{ selectedRoom.hostSteamId }}</p>
                        <h4>æˆ¿é—´å†…ç©å®¶:</h4>
                        <div v-if="roomPlayers.length > 0" class="player-mini-list">
                            <div v-for="player in roomPlayers" :key="player.steamId" class="player-mini-card">
                                <span class="player-name">{{ player.steamName }}</span>
                                <span class="player-scene">{{ player.sceneName || 'æœªè¿›å…¥åœºæ™¯' }}</span>
                            </div>
                        </div>
                        <div v-else class="empty-state">æš‚æ— ç©å®¶</div>
                    </div>
                </div>
            </div>

            <!-- ç©å®¶åˆ—è¡¨ -->
            <div v-if="currentTab === 'players'" class="content-panel">
                <h2 class="panel-title">åœ¨çº¿ç©å®¶åˆ—è¡¨</h2>
                <div class="player-list">
                    <div v-for="player in players" :key="player.steamId" class="player-card">
                        <div class="player-avatar">ğŸ‘¤</div>
                        <div class="player-info">
                            <div class="player-name">{{ player.steamName }}</div>
                            <div class="player-id">{{ player.steamId }}</div>
                        </div>
                        <div class="player-status">
                            <div v-if="player.roomName" class="player-room">
                                ğŸ  {{ player.roomName }}
                            </div>
                            <div v-if="player.sceneName" class="player-scene">
                                ğŸ—ºï¸ {{ player.sceneName }}{{ player.subSceneName ? '/' + player.subSceneName : '' }}
                            </div>
                            <div v-if="player.position" class="player-position">
                                ğŸ“ ({{ player.position.x.toFixed(1) }}, {{ player.position.y.toFixed(1) }}, {{ player.position.z.toFixed(1) }})
                            </div>
                        </div>
                    </div>
                    <div v-if="players.length === 0" class="empty-state">
                        æš‚æ— åœ¨çº¿ç©å®¶
                    </div>
                </div>
            </div>

            <!-- åœºæ™¯åˆ—è¡¨ -->
            <div v-if="currentTab === 'scenes'" class="content-panel">
                <h2 class="panel-title">åœºæ™¯åˆ—è¡¨</h2>
                <div class="scene-list">
                    <div v-for="scene in scenes" :key="scene.sceneName + scene.subSceneName" 
                         class="scene-card" @click="selectScene(scene)">
                        <div class="scene-header">
                            <span class="scene-name">{{ scene.sceneName }}</span>
                            <span v-if="scene.subSceneName" class="scene-sub">/ {{ scene.subSceneName }}</span>
                        </div>
                        <div class="scene-stats">
                            <span>ğŸ‘¥ {{ scene.playerCount }} ç©å®¶</span>
                            <span>ğŸ¤– {{ scene.npcCount }} NPC</span>
                        </div>
                    </div>
                    <div v-if="scenes.length === 0" class="empty-state">
                        æš‚æ— æ´»è·ƒåœºæ™¯
                    </div>
                </div>

                <!-- åœºæ™¯è¯¦æƒ…é¢æ¿ -->
                <div v-if="selectedScene" class="detail-panel">
                    <h3>åœºæ™¯è¯¦æƒ… - {{ selectedScene.sceneName }}/{{ selectedScene.subSceneName }}</h3>
                    <button @click="selectedScene = null; sceneDetail = null" class="close-btn">âœ–</button>
                    <div class="detail-content" v-if="sceneDetail">
                        <h4>åœºæ™¯å†…ç©å®¶:</h4>
                        <div v-if="sceneDetail.players.length > 0" class="entity-list">
                            <div v-for="player in sceneDetail.players" :key="player.steamId" class="entity-card">
                                <span class="entity-name">ğŸ‘¤ {{ player.steamName }}</span>
                                <span v-if="player.position" class="entity-pos">
                                    ğŸ“ ({{ player.position.x.toFixed(1) }}, {{ player.position.y.toFixed(1) }}, {{ player.position.z.toFixed(1) }})
                                </span>
                            </div>
                        </div>
                        
                        <h4>åœºæ™¯å†…NPC:</h4>
                        <div v-if="sceneDetail.npcs.length > 0" class="entity-list">
                            <div v-for="npc in sceneDetail.npcs" :key="npc.npcId" class="entity-card npc">
                                <div class="npc-main">
                                    <span class="entity-name">ğŸ¤– {{ npc.npcType }}</span>
                                    <span class="npc-id">{{ npc.npcId }}</span>
                                </div>
                                <div class="npc-stats">
                                    <span class="npc-health">â¤ï¸ {{ npc.maxHealth }}</span>
                                    <span class="entity-pos">
                                        ğŸ“ ({{ npc.position.x.toFixed(1) }}, {{ npc.position.y.toFixed(1) }}, {{ npc.position.z.toFixed(1) }})
                                    </span>
                                </div>
                                <div class="npc-meta">
                                    <span class="npc-owner">æ‹¥æœ‰è€…: {{ npc.owner }}</span>
                                </div>
                            </div>
                        </div>
                        <div v-else class="empty-state">æš‚æ— NPC</div>
                    </div>
                </div>
            </div>
        </main>

        <!-- åŠ è½½æç¤º -->
        <div v-if="loading" class="loading-overlay">
            <div class="loading-spinner">åŠ è½½ä¸­...</div>
        </div>
    </div>

    <script src="/js/app.js"></script>
</body>
</html>


```

`Server\Web\wwwroot\js\app.js`:

```js
const { createApp } = Vue;

createApp({
    data() {
        return {
            currentTab: 'overview',
            tabs: [
                { id: 'overview', name: 'æ€»è§ˆ' },
                { id: 'rooms', name: 'æˆ¿é—´' },
                { id: 'players', name: 'ç©å®¶' },
                { id: 'scenes', name: 'åœºæ™¯' }
            ],
            loading: false,
            serverTime: '',
            overview: {
                onlinePlayers: 0,
                totalRooms: 0,
                totalNpcs: 0,
                uptime: 'è¿è¡Œä¸­'
            },
            rooms: [],
            players: [],
            scenes: [],
            selectedRoom: null,
            roomPlayers: [],
            selectedScene: null,
            sceneDetail: null,
            refreshInterval: null
        };
    },
    mounted() {
        this.updateServerTime();
        this.loadData();
        
        // æ¯5ç§’åˆ·æ–°æ•°æ®
        this.refreshInterval = setInterval(() => {
            this.loadData();
        }, 5000);
        
        // æ¯ç§’æ›´æ–°æ—¶é—´
        setInterval(() => {
            this.updateServerTime();
        }, 1000);
    },
    unmounted() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
        }
    },
    methods: {
        updateServerTime() {
            const now = new Date();
            this.serverTime = now.toLocaleString('zh-CN');
        },
        
        async loadData() {
            if (this.currentTab === 'overview') {
                await this.loadOverview();
            } else if (this.currentTab === 'rooms') {
                await this.loadRooms();
            } else if (this.currentTab === 'players') {
                await this.loadPlayers();
            } else if (this.currentTab === 'scenes') {
                await this.loadScenes();
            }
        },
        
        async loadOverview() {
            try {
                const response = await axios.get('/api/dashboard/overview');
                this.overview = response.data;
            } catch (error) {
                console.error('åŠ è½½æ¦‚è§ˆæ•°æ®å¤±è´¥:', error);
            }
        },
        
        async loadRooms() {
            try {
                const response = await axios.get('/api/rooms');
                this.rooms = response.data;
            } catch (error) {
                console.error('åŠ è½½æˆ¿é—´åˆ—è¡¨å¤±è´¥:', error);
            }
        },
        
        async loadPlayers() {
            try {
                const response = await axios.get('/api/players');
                this.players = response.data;
            } catch (error) {
                console.error('åŠ è½½ç©å®¶åˆ—è¡¨å¤±è´¥:', error);
            }
        },
        
        async loadScenes() {
            try {
                const response = await axios.get('/api/scenes');
                this.scenes = response.data;
            } catch (error) {
                console.error('åŠ è½½åœºæ™¯åˆ—è¡¨å¤±è´¥:', error);
            }
        },
        
        async selectRoom(room) {
            this.selectedRoom = room;
            try {
                const response = await axios.get(`/api/rooms/${room.roomId}`);
                this.roomPlayers = response.data.players;
            } catch (error) {
                console.error('åŠ è½½æˆ¿é—´è¯¦æƒ…å¤±è´¥:', error);
            }
        },
        
        async selectScene(scene) {
            this.selectedScene = scene;
            try {
                const response = await axios.get(`/api/scenes/${scene.sceneName}/${scene.subSceneName}`);
                this.sceneDetail = response.data;
            } catch (error) {
                console.error('åŠ è½½åœºæ™¯è¯¦æƒ…å¤±è´¥:', error);
            }
        },
        
        formatTime(timeStr) {
            const date = new Date(timeStr);
            return date.toLocaleString('zh-CN');
        }
    },
    watch: {
        currentTab(newTab) {
            this.selectedRoom = null;
            this.selectedScene = null;
            this.sceneDetail = null;
            this.loadData();
        }
    }
}).mount('#app');


```

`Server\å¯åŠ¨æœåŠ¡å™¨.bat`:

```bat
@echo off
chcp 65001 >nul
title DuckyNet æœåŠ¡å™¨

echo ========================================
echo      DuckyNet æœåŠ¡å™¨å¯åŠ¨è„šæœ¬
echo ========================================
echo.

cd /d "%~dp0"

if not exist "DuckyNetServer.csproj" (
    echo é”™è¯¯ï¼šæœªæ‰¾åˆ° DuckyNetServer.csproj
    echo è¯·ç¡®ä¿åœ¨ Server ç›®å½•ä¸‹è¿è¡Œæ­¤è„šæœ¬
    echo.
    pause
    exit /b 1
)

echo æ£€æŸ¥ .NET SDK...
dotnet --version >nul 2>&1
if errorlevel 1 (
    echo é”™è¯¯ï¼šæœªæ‰¾åˆ° .NET SDK
    echo è¯·è®¿é—® https://dotnet.microsoft.com/download ä¸‹è½½å¹¶å®‰è£… .NET 8.0 SDK
    echo.
    pause
    exit /b 1
)

echo âœ“ æ‰¾åˆ° .NET SDK
echo.

if not exist "obj" (
    echo é¦–æ¬¡è¿è¡Œï¼Œæ­£åœ¨è¿˜åŸä¾èµ–åŒ…...
    dotnet restore
    if errorlevel 1 (
        echo é”™è¯¯ï¼šä¾èµ–è¿˜åŸå¤±è´¥
        echo.
        pause
        exit /b 1
    )
    echo âœ“ ä¾èµ–è¿˜åŸå®Œæˆ
    echo.
)

echo ========================================
echo æ­£åœ¨å¯åŠ¨ DuckyNet æœåŠ¡å™¨...
echo ========================================
echo.
echo å¯åŠ¨åå¯è®¿é—®ï¼š
echo   â€¢ Web ç®¡ç†åå°: http://localhost:5000
echo   â€¢ API æ–‡æ¡£: http://localhost:5000/swagger
echo   â€¢ RPC ç«¯å£: 9050
echo.
echo æŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨
echo.
echo ========================================
echo.

dotnet run

if errorlevel 1 (
    echo.
    echo æœåŠ¡å™¨å¼‚å¸¸é€€å‡º
    echo.
    pause
)


```

`Server\å¯åŠ¨æœåŠ¡å™¨.ps1`:

```ps1
# DuckyNet æœåŠ¡å™¨å¯åŠ¨è„šæœ¬
# ä½¿ç”¨æ–¹æ³•ï¼šå³é”®ç‚¹å‡» -> ä½¿ç”¨ PowerShell è¿è¡Œ

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "     DuckyNet æœåŠ¡å™¨å¯åŠ¨è„šæœ¬" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""

# æ£€æŸ¥æ˜¯å¦åœ¨æ­£ç¡®çš„ç›®å½•
if (-not (Test-Path "DuckyNetServer.csproj")) {
    Write-Host "é”™è¯¯ï¼šæœªæ‰¾åˆ° DuckyNetServer.csproj" -ForegroundColor Red
    Write-Host "è¯·ç¡®ä¿åœ¨ Server ç›®å½•ä¸‹è¿è¡Œæ­¤è„šæœ¬" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "æŒ‰ä»»æ„é”®é€€å‡º..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit 1
}

# æ£€æŸ¥ .NET SDK
Write-Host "æ£€æŸ¥ .NET SDK..." -ForegroundColor Yellow
$dotnetVersion = dotnet --version 2>&1
if ($LASTEXITCODE -ne 0) {
    Write-Host "é”™è¯¯ï¼šæœªæ‰¾åˆ° .NET SDK" -ForegroundColor Red
    Write-Host "è¯·è®¿é—® https://dotnet.microsoft.com/download ä¸‹è½½å¹¶å®‰è£… .NET 8.0 SDK" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "æŒ‰ä»»æ„é”®é€€å‡º..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit 1
}
Write-Host "âœ“ æ‰¾åˆ° .NET SDK ç‰ˆæœ¬: $dotnetVersion" -ForegroundColor Green
Write-Host ""

# æ£€æŸ¥æ˜¯å¦éœ€è¦è¿˜åŸä¾èµ–
$objFolder = "obj"
if (-not (Test-Path $objFolder)) {
    Write-Host "é¦–æ¬¡è¿è¡Œï¼Œæ­£åœ¨è¿˜åŸä¾èµ–åŒ…..." -ForegroundColor Yellow
    dotnet restore
    if ($LASTEXITCODE -ne 0) {
        Write-Host "é”™è¯¯ï¼šä¾èµ–è¿˜åŸå¤±è´¥" -ForegroundColor Red
        Write-Host ""
        Write-Host "æŒ‰ä»»æ„é”®é€€å‡º..."
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        exit 1
    }
    Write-Host "âœ“ ä¾èµ–è¿˜åŸå®Œæˆ" -ForegroundColor Green
    Write-Host ""
}

# å¯åŠ¨æœåŠ¡å™¨
Write-Host "========================================" -ForegroundColor Cyan
Write-Host "æ­£åœ¨å¯åŠ¨ DuckyNet æœåŠ¡å™¨..." -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "å¯åŠ¨åå¯è®¿é—®ï¼š" -ForegroundColor Yellow
Write-Host "  â€¢ Web ç®¡ç†åå°: http://localhost:5000" -ForegroundColor White
Write-Host "  â€¢ API æ–‡æ¡£: http://localhost:5000/swagger" -ForegroundColor White
Write-Host "  â€¢ RPC ç«¯å£: 9050" -ForegroundColor White
Write-Host ""
Write-Host "æŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨" -ForegroundColor Yellow
Write-Host ""
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""

# è¿è¡ŒæœåŠ¡å™¨
dotnet run

# å¦‚æœæœåŠ¡å™¨å¼‚å¸¸é€€å‡º
if ($LASTEXITCODE -ne 0) {
    Write-Host ""
    Write-Host "æœåŠ¡å™¨å¼‚å¸¸é€€å‡ºï¼Œé”™è¯¯ä»£ç : $LASTEXITCODE" -ForegroundColor Red
    Write-Host ""
    Write-Host "æŒ‰ä»»æ„é”®é€€å‡º..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}


```

`Server\å¯åŠ¨è¯´æ˜.md`:

```md
# DuckyNet æœåŠ¡å™¨å¯åŠ¨è¯´æ˜

## å¿«é€Ÿå¯åŠ¨

### 1. é¦–æ¬¡å¯åŠ¨ï¼ˆéœ€è¦è¿˜åŸä¾èµ–ï¼‰

```powershell
cd E:\git\DuckyNet\Server
dotnet restore
dotnet run
```

### 2. åç»­å¯åŠ¨

```powershell
cd E:\git\DuckyNet\Server
dotnet run
```

## è®¿é—®åœ°å€

å¯åŠ¨æˆåŠŸåï¼Œä¼šçœ‹åˆ°ä»¥ä¸‹æç¤ºï¼š

```
==================================
  Server is ready!
  RPC Server: Port 9050
  Web Admin: http://localhost:5000
  Press Ctrl+C to stop server
==================================
```

### å¯è®¿é—®çš„æœåŠ¡

1. **Web ç®¡ç†åå°**: http://localhost:5000
   - æŸ¥çœ‹æœåŠ¡å™¨çŠ¶æ€
   - ç®¡ç†æˆ¿é—´å’Œç©å®¶
   - ç›‘æ§åœºæ™¯å’Œ NPC

2. **Swagger API æ–‡æ¡£**: http://localhost:5000/swagger
   - API æ¥å£æ–‡æ¡£
   - åœ¨çº¿æµ‹è¯• API

3. **RPC æœåŠ¡å™¨**: ç«¯å£ 9050
   - æ¸¸æˆå®¢æˆ·ç«¯è¿æ¥ç«¯å£

## Web åå°åŠŸèƒ½

### æ€»è§ˆé¢æ¿
- ğŸ“Š å®æ—¶ç»Ÿè®¡æ•°æ®
- ğŸ‘¥ åœ¨çº¿ç©å®¶æ•°
- ğŸ  æ´»è·ƒæˆ¿é—´æ•°
- ğŸ¤– NPC æ€»æ•°

### æˆ¿é—´ç®¡ç†
- æŸ¥çœ‹æ‰€æœ‰æˆ¿é—´
- æˆ¿é—´è¯¦ç»†ä¿¡æ¯
- æˆ¿é—´å†…ç©å®¶åˆ—è¡¨

### ç©å®¶ç®¡ç†
- åœ¨çº¿ç©å®¶åˆ—è¡¨
- ç©å®¶ä½ç½®ä¿¡æ¯
- ç©å®¶æ‰€åœ¨åœºæ™¯

### åœºæ™¯ç®¡ç†
- æ´»è·ƒåœºæ™¯åˆ—è¡¨
- åœºæ™¯å†…ç©å®¶å’Œ NPC
- NPC ä½ç½®å’Œè¡€é‡

## åœæ­¢æœåŠ¡å™¨

æŒ‰ `Ctrl+C` åœæ­¢æœåŠ¡å™¨

æœåŠ¡å™¨ä¼šè‡ªåŠ¨ï¼š
- å…³é—­æ‰€æœ‰è¿æ¥
- å¸è½½æ’ä»¶
- åœæ­¢ Web æœåŠ¡å™¨
- æ¸…ç†èµ„æº

## æ–°å¢ä¾èµ–åŒ…

æœ¬æ¬¡æ›´æ–°æ·»åŠ äº†ä»¥ä¸‹ NuGet åŒ…ï¼š
- Microsoft.AspNetCore.App
- Swashbuckle.AspNetCore (Swagger)

å¦‚æœé‡åˆ°ä¾èµ–é—®é¢˜ï¼Œè¯·è¿è¡Œï¼š
```powershell
dotnet clean
dotnet restore
```

## ç›®å½•ç»“æ„å˜åŒ–

```
Server/
â”œâ”€â”€ Web/                    # æ–°å¢ï¼šWeb åå°
â”‚   â”œâ”€â”€ Controllers/       # API æ§åˆ¶å™¨
â”‚   â”œâ”€â”€ wwwroot/           # é™æ€æ–‡ä»¶ï¼ˆHTML/CSS/JSï¼‰
â”‚   â””â”€â”€ WebServerStartup.cs
â”œâ”€â”€ Program.cs             # å·²æ›´æ–°ï¼šé›†æˆ Web æœåŠ¡å™¨
â””â”€â”€ DuckyNetServer.csproj  # å·²æ›´æ–°ï¼šæ·»åŠ ä¾èµ–
```

## å¸¸è§é—®é¢˜

### Q: ç«¯å£ 5000 è¢«å ç”¨
A: ä¿®æ”¹ `Program.cs` ç¬¬ 96 è¡Œçš„ç«¯å£å·
```csharp
var webTask = _webApp.RunAsync("http://localhost:ä½ çš„ç«¯å£");
```

### Q: æ— æ³•è®¿é—® Web ç•Œé¢
A: æ£€æŸ¥é˜²ç«å¢™è®¾ç½®ï¼Œç¡®ä¿å…è®¸ç«¯å£ 5000

### Q: API è¿”å›ç©ºæ•°æ®
A: ç¡®ä¿æœ‰å®¢æˆ·ç«¯è¿æ¥åˆ°æœåŠ¡å™¨

### Q: ç¼–è¯‘é”™è¯¯
A: è¿è¡Œ `dotnet restore` é‡æ–°è¿˜åŸä¾èµ–

## ä¸‹ä¸€æ­¥

1. å¯åŠ¨æœåŠ¡å™¨
2. æ‰“å¼€æµè§ˆå™¨è®¿é—® http://localhost:5000
3. è¿æ¥æ¸¸æˆå®¢æˆ·ç«¯æµ‹è¯•
4. åœ¨ Web åå°æŸ¥çœ‹å®æ—¶æ•°æ®

ç¥ä½¿ç”¨æ„‰å¿«ï¼ğŸ¦†


```

`Shared\Data\AnimatorSyncData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// åŠ¨ç”»çŠ¶æ€åŒæ­¥æ•°æ® - ç´§å‡‘çš„äºŒè¿›åˆ¶æ ¼å¼
    /// ç”¨äºåŒæ­¥ Animator çš„å…³é”®å‚æ•°å’ŒçŠ¶æ€
    /// </summary>
    [Serializable]
    public class AnimatorSyncData
    {
        /// <summary>
        /// å½“å‰åŠ¨ç”»çŠ¶æ€å“ˆå¸Œï¼ˆä¸»å±‚ï¼‰
        /// </summary>
        public int StateHash { get; set; }

        /// <summary>
        /// åŠ¨ç”»å½’ä¸€åŒ–æ—¶é—´ (0-1)
        /// å‹ç¼©ä¸º ushort (0-65535 æ˜ å°„åˆ° 0-1)
        /// </summary>
        public ushort NormalizedTime { get; set; }

        /// <summary>
        /// å…³é”® Float å‚æ•°ï¼ˆæœ€å¤š 8 ä¸ªï¼‰
        /// ä½¿ç”¨ short å­˜å‚¨ï¼Œç²¾åº¦ 0.01
        /// </summary>
        public short[] FloatParams { get; set; } = new short[8];

        /// <summary>
        /// Bool å‚æ•°æ‰“åŒ…ï¼ˆæœ€å¤š 32 ä¸ªï¼‰
        /// ä½¿ç”¨ä½æ ‡å¿—å‹ç¼©
        /// </summary>
        public uint BoolParams { get; set; }

        /// <summary>
        /// å‹ç¼©ä¸ºå­—èŠ‚æ•°ç»„
        /// </summary>
        public byte[] ToBytes()
        {
            using (var ms = new System.IO.MemoryStream())
            using (var writer = new System.IO.BinaryWriter(ms))
            {
                // StateHash (4 å­—èŠ‚)
                writer.Write(StateHash);

                // NormalizedTime (2 å­—èŠ‚)
                writer.Write(NormalizedTime);

                // FloatParams (16 å­—èŠ‚ = 8 * 2)
                for (int i = 0; i < 8; i++)
                {
                    writer.Write(FloatParams[i]);
                }

                // BoolParams (4 å­—èŠ‚)
                writer.Write(BoolParams);

                return ms.ToArray();
            }
        }

        /// <summary>
        /// ä»å­—èŠ‚æ•°ç»„è§£å‹
        /// </summary>
        public static AnimatorSyncData FromBytes(byte[] data)
        {
            using (var ms = new System.IO.MemoryStream(data))
            using (var reader = new System.IO.BinaryReader(ms))
            {
                return new AnimatorSyncData
                {
                    StateHash = reader.ReadInt32(),
                    NormalizedTime = reader.ReadUInt16(),
                    FloatParams = new short[]
                    {
                        reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16(),
                        reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16()
                    },
                    BoolParams = reader.ReadUInt32()
                };
            }
        }

        /// <summary>
        /// è·å–å½’ä¸€åŒ–æ—¶é—´ï¼ˆ0-1ï¼‰
        /// </summary>
        public float GetNormalizedTime()
        {
            return NormalizedTime / 65535f;
        }

        /// <summary>
        /// è®¾ç½®å½’ä¸€åŒ–æ—¶é—´ï¼ˆ0-1ï¼‰
        /// </summary>
        public void SetNormalizedTime(float value)
        {
            // ä½¿ç”¨æ ‡å‡† C# Math.Clamp (æˆ–æ‰‹åŠ¨å®ç°)
            float clamped = Math.Max(0f, Math.Min(1f, value));
            NormalizedTime = (ushort)(clamped * 65535f);
        }

        /// <summary>
        /// è·å– Float å‚æ•°å€¼
        /// </summary>
        public float GetFloatParam(int index)
        {
            if (index < 0 || index >= 8) return 0f;
            return FloatParams[index] / 100f;
        }

        /// <summary>
        /// è®¾ç½® Float å‚æ•°å€¼
        /// </summary>
        public void SetFloatParam(int index, float value)
        {
            if (index < 0 || index >= 8) return;
            FloatParams[index] = (short)(value * 100f);
        }

        /// <summary>
        /// è·å– Bool å‚æ•°å€¼
        /// </summary>
        public bool GetBoolParam(int index)
        {
            if (index < 0 || index >= 32) return false;
            return (BoolParams & (1u << index)) != 0;
        }

        /// <summary>
        /// è®¾ç½® Bool å‚æ•°å€¼
        /// </summary>
        public void SetBoolParam(int index, bool value)
        {
            if (index < 0 || index >= 32) return;
            if (value)
                BoolParams |= (1u << index);
            else
                BoolParams &= ~(1u << index);
        }
    }
}

```

`Shared\Data\CharacterAppearanceData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// è§’è‰²å¤–è§‚æ•°æ® - ç´§å‡‘çš„äºŒè¿›åˆ¶æ ¼å¼
    /// è®¾è®¡ç›®æ ‡ï¼šæœ€å°åŒ–ç½‘ç»œä¼ è¾“å¤§å°
    /// </summary>
    [Serializable]
    public class CharacterAppearanceData
    {
        /// <summary>
        /// å¤´éƒ¨è®¾ç½®æ•°æ®ï¼ˆç´§å‡‘æ ¼å¼ï¼‰
        /// </summary>
        public HeadSettingData HeadSetting { get; set; } = new HeadSettingData();

        /// <summary>
        /// éƒ¨ä½æ•°æ®æ•°ç»„ï¼ˆæœ€å¤š32ä¸ªéƒ¨ä½ï¼‰
        /// </summary>
        public PartData[] Parts { get; set; } = Array.Empty<PartData>();

        /// <summary>
        /// å‹ç¼©ä¸ºå­—èŠ‚æ•°ç»„
        /// </summary>
        public byte[] ToBytes()
        {
            using (var ms = new System.IO.MemoryStream())
            using (var writer = new System.IO.BinaryWriter(ms))
            {
                // ç‰ˆæœ¬å·ï¼ˆ1å­—èŠ‚ï¼‰
                writer.Write((byte)1);

                // å¤´éƒ¨è®¾ç½®
                HeadSetting.WriteTo(writer);

                // éƒ¨ä½æ•°é‡ï¼ˆ1å­—èŠ‚ï¼Œæœ€å¤š255ä¸ªéƒ¨ä½ï¼‰
                writer.Write((byte)Parts.Length);

                // éƒ¨ä½æ•°æ®
                foreach (var part in Parts)
                {
                    part.WriteTo(writer);
                }

                return ms.ToArray();
            }
        }

        /// <summary>
        /// ä»å­—èŠ‚æ•°ç»„è§£å‹
        /// </summary>
        public static CharacterAppearanceData FromBytes(byte[] data)
        {
            if (data == null || data.Length == 0)
                return new CharacterAppearanceData();

            using (var ms = new System.IO.MemoryStream(data))
            using (var reader = new System.IO.BinaryReader(ms))
            {
                var result = new CharacterAppearanceData();

                // ç‰ˆæœ¬å·
                byte version = reader.ReadByte();
                if (version != 1)
                    throw new Exception($"ä¸æ”¯æŒçš„å¤–è§‚æ•°æ®ç‰ˆæœ¬: {version}");

                // å¤´éƒ¨è®¾ç½®
                result.HeadSetting = HeadSettingData.ReadFrom(reader);

                // éƒ¨ä½æ•°æ®
                byte partCount = reader.ReadByte();
                result.Parts = new PartData[partCount];
                for (int i = 0; i < partCount; i++)
                {
                    result.Parts[i] = PartData.ReadFrom(reader);
                }

                return result;
            }
        }
    }

    /// <summary>
    /// å¤´éƒ¨è®¾ç½®æ•°æ®ï¼ˆ24å­—èŠ‚ï¼‰
    /// </summary>
    [Serializable]
    public class HeadSettingData
    {
        // ç¼©æ”¾ï¼ˆ6å­—èŠ‚ = 3 * Int16ï¼‰
        public short ScaleX { get; set; }
        public short ScaleY { get; set; }
        public short ScaleZ { get; set; }

        // åç§»ï¼ˆ6å­—èŠ‚ = 3 * Int16ï¼‰
        public short OffsetX { get; set; }
        public short OffsetY { get; set; }
        public short OffsetZ { get; set; }

        // æ—‹è½¬ï¼ˆ6å­—èŠ‚ = 3 * Int16ï¼Œå­˜å‚¨åº¦æ•° * 100ï¼‰
        public short RotationX { get; set; }
        public short RotationY { get; set; }
        public short RotationZ { get; set; }

        // ä¸»é¢œè‰²ï¼ˆ6å­—èŠ‚ = 3 * Int16ï¼Œå­˜å‚¨èº«ä½“/çš®è‚¤é¢œè‰²ï¼‰
        public short MainColorR { get; set; }
        public short MainColorG { get; set; }
        public short MainColorB { get; set; }

        public void WriteTo(System.IO.BinaryWriter writer)
        {
            writer.Write(ScaleX);
            writer.Write(ScaleY);
            writer.Write(ScaleZ);
            writer.Write(OffsetX);
            writer.Write(OffsetY);
            writer.Write(OffsetZ);
            writer.Write(RotationX);
            writer.Write(RotationY);
            writer.Write(RotationZ);
            writer.Write(MainColorR);
            writer.Write(MainColorG);
            writer.Write(MainColorB);
        }

        public static HeadSettingData ReadFrom(System.IO.BinaryReader reader)
        {
            return new HeadSettingData
            {
                ScaleX = reader.ReadInt16(),
                ScaleY = reader.ReadInt16(),
                ScaleZ = reader.ReadInt16(),
                OffsetX = reader.ReadInt16(),
                OffsetY = reader.ReadInt16(),
                OffsetZ = reader.ReadInt16(),
                RotationX = reader.ReadInt16(),
                RotationY = reader.ReadInt16(),
                RotationZ = reader.ReadInt16(),
                MainColorR = reader.ReadInt16(),
                MainColorG = reader.ReadInt16(),
                MainColorB = reader.ReadInt16()
            };
        }
    }

    /// <summary>
    /// éƒ¨ä½æ•°æ®ï¼ˆ27å­—èŠ‚ï¼‰
    /// </summary>
    [Serializable]
    public class PartData
    {
        // éƒ¨ä½ç±»å‹ï¼ˆ1å­—èŠ‚ï¼Œ0-255ï¼‰
        public byte PartType { get; set; }

        // éƒ¨ä½IDï¼ˆ2å­—èŠ‚ï¼Œ0-65535ï¼‰
        public ushort PartId { get; set; }

        // ç¼©æ”¾ï¼ˆ6å­—èŠ‚ï¼‰
        public short ScaleX { get; set; }
        public short ScaleY { get; set; }
        public short ScaleZ { get; set; }

        // åç§»ï¼ˆ6å­—èŠ‚ï¼‰
        public short OffsetX { get; set; }
        public short OffsetY { get; set; }
        public short OffsetZ { get; set; }

        // æ—‹è½¬ï¼ˆ6å­—èŠ‚ï¼‰
        public short RotationX { get; set; }
        public short RotationY { get; set; }
        public short RotationZ { get; set; }

        // é¢œè‰²ï¼ˆ6å­—èŠ‚ï¼‰
        public short ColorR { get; set; }
        public short ColorG { get; set; }
        public short ColorB { get; set; }

        public void WriteTo(System.IO.BinaryWriter writer)
        {
            writer.Write(PartType);
            writer.Write(PartId);
            writer.Write(ScaleX);
            writer.Write(ScaleY);
            writer.Write(ScaleZ);
            writer.Write(OffsetX);
            writer.Write(OffsetY);
            writer.Write(OffsetZ);
            writer.Write(RotationX);
            writer.Write(RotationY);
            writer.Write(RotationZ);
            writer.Write(ColorR);
            writer.Write(ColorG);
            writer.Write(ColorB);
        }

        public static PartData ReadFrom(System.IO.BinaryReader reader)
        {
            return new PartData
            {
                PartType = reader.ReadByte(),
                PartId = reader.ReadUInt16(),
                ScaleX = reader.ReadInt16(),
                ScaleY = reader.ReadInt16(),
                ScaleZ = reader.ReadInt16(),
                OffsetX = reader.ReadInt16(),
                OffsetY = reader.ReadInt16(),
                OffsetZ = reader.ReadInt16(),
                RotationX = reader.ReadInt16(),
                RotationY = reader.ReadInt16(),
                RotationZ = reader.ReadInt16(),
                ColorR = reader.ReadInt16(),
                ColorG = reader.ReadInt16(),
                ColorB = reader.ReadInt16()
            };
        }
    }

    /// <summary>
    /// è¾…åŠ©ç±»ï¼šæµ®ç‚¹æ•°å’ŒInt16ä¹‹é—´çš„è½¬æ¢
    /// èŒƒå›´ï¼š-327.68 åˆ° 327.67ï¼Œç²¾åº¦ï¼š0.01
    /// </summary>
    public static class FloatCompression
    {
        private const float SCALE = 100f;

        public static short Compress(float value)
        {
            return (short)Math.Round(value * SCALE);
        }

        public static float Decompress(short value)
        {
            return value / SCALE;
        }

        public static (short x, short y, short z) CompressVector3(float x, float y, float z)
        {
            return (Compress(x), Compress(y), Compress(z));
        }

        public static (float x, float y, float z) DecompressVector3(short x, short y, short z)
        {
            return (Decompress(x), Decompress(y), Decompress(z));
        }
    }
}


```

`Shared\Data\EquipmentData.cs`:

```cs
using System;
using System.Collections.Generic;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// è£…å¤‡æ§½ä½ç±»å‹ï¼ˆä¸å®¢æˆ·ç«¯ä¿æŒä¸€è‡´ï¼‰
    /// </summary>
    public enum EquipmentSlotType : byte
    {
        /// <summary>æŠ¤ç”²</summary>
        Armor = 0,
        /// <summary>å¤´ç›”</summary>
        Helmet = 1,
        /// <summary>é¢ç½©</summary>
        FaceMask = 2,
        /// <summary>èƒŒåŒ…</summary>
        Backpack = 3,
        /// <summary>è€³æœº</summary>
        Headset = 4
    }

    /// <summary>
    /// ç©å®¶è£…å¤‡æ•°æ®
    /// Key: EquipmentSlotType, Value: ItemTypeID (null æˆ– 0 è¡¨ç¤ºè¯¥æ§½ä½ä¸ºç©º)
    /// </summary>
    [Serializable]
    public class PlayerEquipmentData
    {
        /// <summary>
        /// è£…å¤‡æ§½ä½æ•°æ®
        /// </summary>
        public Dictionary<EquipmentSlotType, int> Equipment { get; set; } = new Dictionary<EquipmentSlotType, int>();

        /// <summary>
        /// è·å–æŒ‡å®šæ§½ä½çš„è£…å¤‡ TypeID
        /// </summary>
        public int? GetEquipment(EquipmentSlotType slotType)
        {
            if (Equipment.TryGetValue(slotType, out int typeId) && typeId > 0)
            {
                return typeId;
            }
            return null;
        }

        /// <summary>
        /// è®¾ç½®æŒ‡å®šæ§½ä½çš„è£…å¤‡
        /// </summary>
        public void SetEquipment(EquipmentSlotType slotType, int? itemTypeId)
        {
            if (itemTypeId.HasValue && itemTypeId.Value > 0)
            {
                Equipment[slotType] = itemTypeId.Value;
            }
            else
            {
                // å¸ä¸‹è£…å¤‡ - åˆ é™¤è¯¥é”®
                Equipment.Remove(slotType);
            }
        }

        /// <summary>
        /// æ¸…ç©ºæ‰€æœ‰è£…å¤‡
        /// </summary>
        public void ClearAll()
        {
            Equipment.Clear();
        }

        /// <summary>
        /// å…‹éš†è£…å¤‡æ•°æ®
        /// </summary>
        public PlayerEquipmentData Clone()
        {
            var clone = new PlayerEquipmentData();
            foreach (var kvp in Equipment)
            {
                clone.Equipment[kvp.Key] = kvp.Value;
            }
            return clone;
        }

        /// <summary>
        /// è·å–å·²è£…å¤‡çš„æ§½ä½æ•°é‡
        /// </summary>
        public int GetEquippedCount()
        {
            return Equipment.Count;
        }
    }

    /// <summary>
    /// è£…å¤‡æ§½ä½æ›´æ–°è¯·æ±‚
    /// </summary>
    [Serializable]
    public class EquipmentSlotUpdateRequest
    {
        /// <summary>æ§½ä½ç±»å‹</summary>
        public EquipmentSlotType SlotType { get; set; }

        /// <summary>ç‰©å“ TypeIDï¼ˆnull æˆ– 0 è¡¨ç¤ºå¸ä¸‹ï¼‰</summary>
        public int? ItemTypeId { get; set; }
    }

    /// <summary>
    /// è£…å¤‡æ§½ä½æ›´æ–°é€šçŸ¥ï¼ˆæœåŠ¡å™¨å¹¿æ’­ç»™å…¶ä»–ç©å®¶ï¼‰
    /// </summary>
    [Serializable]
    public class EquipmentSlotUpdateNotification
    {
        /// <summary>ç©å®¶ID</summary>
        public string PlayerId { get; set; } = "";

        /// <summary>æ§½ä½ç±»å‹</summary>
        public EquipmentSlotType SlotType { get; set; }

        /// <summary>ç‰©å“ TypeIDï¼ˆnull æˆ– 0 è¡¨ç¤ºå¸ä¸‹ï¼‰</summary>
        public int? ItemTypeId { get; set; }
    }

    /// <summary>
    /// æ‰¹é‡è£…å¤‡æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶å‘é€ï¼‰
    /// </summary>
    [Serializable]
    public class AllPlayersEquipmentData
    {
        /// <summary>
        /// æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®
        /// Key: PlayerId, Value: è¯¥ç©å®¶çš„è£…å¤‡æ•°æ®
        /// </summary>
        public Dictionary<string, PlayerEquipmentData> PlayersEquipment { get; set; } 
            = new Dictionary<string, PlayerEquipmentData>();
    }
}


```

`Shared\Data\HealthSyncData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// è¡€é‡åŒæ­¥æ•°æ®
    /// </summary>
    [Serializable]
    public class HealthSyncData
    {
        /// <summary>
        /// ç©å®¶ID (SteamId) - ç”±æœåŠ¡å™¨å¡«å……
        /// </summary>
        public string SteamId { get; set; } = string.Empty;

        /// <summary>
        /// å½“å‰è¡€é‡
        /// </summary>
        public float CurrentHealth { get; set; }

        /// <summary>
        /// æœ€å¤§è¡€é‡
        /// </summary>
        public float MaxHealth { get; set; }

        /// <summary>
        /// æ˜¯å¦æ­»äº¡
        /// </summary>
        public bool IsDead { get; set; }

        /// <summary>
        /// æ—¶é—´æˆ³ (ç”¨äºæ’åºå’Œå»é‡)
        /// </summary>
        public long Timestamp { get; set; }

        public HealthSyncData()
        {
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        }

        public override string ToString()
        {
            return $"Player:{SteamId} Health:{CurrentHealth:F0}/{MaxHealth:F0} Dead:{IsDead}";
        }
    }
}


```

`Shared\Data\ItemSyncData.cs`:

```cs
using System;
using System.Collections.Generic;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// ç‰©å“ä¸¢å¼ƒæ•°æ®
    /// </summary>
    [Serializable]
    public class ItemDropData
    {
        /// <summary>
        /// æœåŠ¡å™¨åˆ†é…çš„å…¨å±€å”¯ä¸€ç‰©å“ID
        /// </summary>
        public uint DropId { get; set; }

        /// <summary>
        /// ç‰©å“ç±»å‹ID
        /// </summary>
        public int ItemTypeId { get; set; }

        /// <summary>
        /// ç‰©å“æ˜¾ç¤ºåç§°
        /// </summary>
        public string ItemName { get; set; } = string.Empty;

        /// <summary>
        /// ä¸¢å¼ƒä½ç½®
        /// </summary>
        public SerializableVector3 Position { get; set; }

        /// <summary>
        /// ä¸¢å¼ƒæ–¹å‘
        /// </summary>
        public SerializableVector3 Direction { get; set; }

        /// <summary>
        /// æ˜¯å¦åˆ›å»ºåˆšä½“
        /// </summary>
        public bool CreateRigidbody { get; set; }

        /// <summary>
        /// éšæœºè§’åº¦
        /// </summary>
        public float RandomAngle { get; set; }

        /// <summary>
        /// ç‰©å“å®Œæ•´æ•°æ®ï¼ˆBase64ç¼–ç çš„å‹ç¼©æ•°æ®ï¼‰
        /// å¦‚æœä¸ºç©ºï¼Œè¡¨ç¤ºä½¿ç”¨é»˜è®¤ç‰©å“ï¼ˆå¢é‡åŒæ­¥ä¼˜åŒ–ï¼‰
        /// </summary>
        public string ItemDataCompressed { get; set; } = string.Empty;

        /// <summary>
        /// æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“ï¼ˆæ— è‡ªå®šä¹‰ä¿®æ”¹ï¼‰
        /// </summary>
        public bool IsDefaultItem { get; set; }

        /// <summary>
        /// ä¸¢å¼ƒè€…çš„ Steam ID
        /// </summary>
        public string DroppedByPlayerId { get; set; } = string.Empty;
    }

    /// <summary>
    /// ç‰©å“æ‹¾å–è¯·æ±‚
    /// </summary>
    [Serializable]
    public class ItemPickupRequest
    {
        /// <summary>
        /// è¦æ‹¾å–çš„ç‰©å“ DropId
        /// </summary>
        public uint DropId { get; set; }

        /// <summary>
        /// æ‹¾å–è€…çš„ Steam IDï¼ˆç”±æœåŠ¡å™¨éªŒè¯ï¼‰
        /// </summary>
        public string PickedByPlayerId { get; set; } = string.Empty;
    }

    /// <summary>
    /// å¯åºåˆ—åŒ–çš„ Vector3ï¼ˆUnity çš„ Vector3 ä¸å¯ç›´æ¥åºåˆ—åŒ–ï¼‰
    /// </summary>
    [Serializable]
    public struct SerializableVector3
    {
        public float X { get; set; }
        public float Y { get; set; }
        public float Z { get; set; }

        public SerializableVector3(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }
    }

    /// <summary>
    /// ç®€åŒ–çš„å¯åºåˆ—åŒ–ç‰©å“æ•°æ®ï¼ˆç”¨äºç½‘ç»œä¼ è¾“ï¼‰
    /// </summary>
    [Serializable]
    public class SerializableItemData
    {
        public int RootInstanceID { get; set; }
        public List<SerializableEntry> Entries { get; set; } = new List<SerializableEntry>();
    }

    [Serializable]
    public class SerializableEntry
    {
        public int InstanceID { get; set; }
        public int TypeID { get; set; }
        public List<SerializableVariable> Variables { get; set; } = new List<SerializableVariable>();
        public List<SerializableSlot> Slots { get; set; } = new List<SerializableSlot>();
        public List<SerializableInventoryItem> Inventory { get; set; } = new List<SerializableInventoryItem>();
        public List<int> InventorySortLocks { get; set; } = new List<int>();
    }

    [Serializable]
    public class SerializableVariable
    {
        public string Key { get; set; } = "";
        public int DataType { get; set; }
        public int IntValue { get; set; }
        public float FloatValue { get; set; }
        public string StringValue { get; set; } = "";
        public bool BoolValue { get; set; }
    }

    [Serializable]
    public class SerializableSlot
    {
        public string SlotName { get; set; } = "";
        public int ItemInstanceID { get; set; }
    }

    [Serializable]
    public class SerializableInventoryItem
    {
        public int Position { get; set; }
        public int ItemInstanceID { get; set; }
    }
}


```

`Shared\Data\NpcData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// NPC ç”Ÿæˆæ•°æ®
    /// </summary>
    [Serializable]
    public class NpcSpawnData
    {
        /// <summary>
        /// NPC å…¨å±€å”¯ä¸€ IDï¼ˆUUIDï¼‰
        /// </summary>
        public string NpcId { get; set; } = "";

        /// <summary>
        /// åœºæ™¯åç§°ï¼ˆä¸»åœºæ™¯ï¼‰
        /// </summary>
        public string SceneName { get; set; } = "";

        /// <summary>
        /// å­åœºæ™¯åç§°
        /// </summary>
        public string SubSceneName { get; set; } = "";

        /// <summary>
        /// NPC ç±»å‹åç§°ï¼ˆGameObject nameï¼‰
        /// </summary>
        public string NpcType { get; set; } = "";

        /// <summary>
        /// åˆå§‹ä½ç½® X
        /// </summary>
        public float PositionX { get; set; }

        /// <summary>
        /// åˆå§‹ä½ç½® Y
        /// </summary>
        public float PositionY { get; set; }

        /// <summary>
        /// åˆå§‹ä½ç½® Z
        /// </summary>
        public float PositionZ { get; set; }

        /// <summary>
        /// åˆå§‹æ—‹è½¬ Yï¼ˆç®€åŒ–ä¸ºåªåŒæ­¥æœå‘ï¼‰
        /// </summary>
        public float RotationY { get; set; }

        /// <summary>
        /// æœ€å¤§è¡€é‡
        /// </summary>
        public float MaxHealth { get; set; }

        /// <summary>
        /// ç”Ÿæˆæ—¶é—´æˆ³ï¼ˆæœåŠ¡å™¨æ—¶é—´ï¼‰
        /// </summary>
        public long SpawnTimestamp { get; set; }
    }

    /// <summary>
    /// NPC ä½ç½®æ›´æ–°æ•°æ®ï¼ˆè½»é‡çº§ï¼Œé«˜é¢‘åŒæ­¥ï¼‰
    /// </summary>
    [Serializable]
    public class NpcTransformData
    {
        /// <summary>
        /// NPC ID
        /// </summary>
        public string NpcId { get; set; } = "";

        /// <summary>
        /// ä½ç½® X
        /// </summary>
        public float PositionX { get; set; }

        /// <summary>
        /// ä½ç½® Y
        /// </summary>
        public float PositionY { get; set; }

        /// <summary>
        /// ä½ç½® Z
        /// </summary>
        public float PositionZ { get; set; }

        /// <summary>
        /// æ—‹è½¬ Yï¼ˆæœå‘è§’åº¦ï¼‰
        /// </summary>
        public float RotationY { get; set; }
    }

    /// <summary>
    /// NPC é”€æ¯æ•°æ®
    /// </summary>
    [Serializable]
    public class NpcDestroyData
    {
        /// <summary>
        /// NPC ID
        /// </summary>
        public string NpcId { get; set; } = "";

        /// <summary>
        /// é”€æ¯åŸå› ï¼ˆ0=æ­£å¸¸é”€æ¯ï¼Œ1=æ­»äº¡ï¼Œ2=åœºæ™¯å¸è½½ï¼‰
        /// </summary>
        public int Reason { get; set; }
    }

    /// <summary>
    /// NPC æ‰¹é‡ä½ç½®æ›´æ–°ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
    /// </summary>
    [Serializable]
    public class NpcBatchTransformData
    {
        /// <summary>
        /// NPC æ•°é‡
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// NPC ID åˆ—è¡¨
        /// </summary>
        public string[] NpcIds { get; set; } = Array.Empty<string>();

        /// <summary>
        /// ä½ç½® X åˆ—è¡¨
        /// </summary>
        public float[] PositionsX { get; set; } = Array.Empty<float>();

        /// <summary>
        /// ä½ç½® Y åˆ—è¡¨
        /// </summary>
        public float[] PositionsY { get; set; } = Array.Empty<float>();

        /// <summary>
        /// ä½ç½® Z åˆ—è¡¨
        /// </summary>
        public float[] PositionsZ { get; set; } = Array.Empty<float>();

        /// <summary>
        /// æ—‹è½¬ Y åˆ—è¡¨
        /// </summary>
        public float[] RotationsY { get; set; } = Array.Empty<float>();
    }
}


```

`Shared\Data\ScenelData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// è§’è‰²åŒæ­¥æ•°æ® - åŒ…å«ä½ç½®ã€æ—‹è½¬å’ŒåŠ¨ç”»çŠ¶æ€
    /// </summary>
    [Serializable]
    public class ScenelData
    {
        public string SceneName { get; set; } = "";
        public string SubSceneName { get; set; } = "";
        public ScenelData(string sceneName, string subSceneName)
        {
            SceneName = sceneName;
            SubSceneName = subSceneName;
        }

    }
}
```

`Shared\Data\UnitySyncData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// Unity ä½ç½®åŒæ­¥æ•°æ® (å‹ç¼©ç‰ˆ)
    /// ä½¿ç”¨é‡åŒ–å’Œå‹ç¼©æŠ€æœ¯å‡å°‘ç½‘ç»œä¼ è¾“é‡
    /// åŸå§‹å¤§å°: ~64 bytes -> å‹ç¼©å: ~24 bytes (å‡å°‘ 62.5%)
    /// </summary>
    [Serializable]
    public class UnitySyncData
    {
        // é‡åŒ–ç²¾åº¦å¸¸é‡
        private const float POSITION_PRECISION = 0.01f;  // 1cm ç²¾åº¦
        private const float VELOCITY_PRECISION = 0.1f;   // 0.1 m/s ç²¾åº¦
        private const float ROTATION_PRECISION = 0.0001f; // å››å…ƒæ•°ç²¾åº¦
        private const int POSITION_MULTIPLIER = 100;     // 1/0.01
        private const int VELOCITY_MULTIPLIER = 10;      // 1/0.1
        private const int ROTATION_MULTIPLIER = 10000;   // 1/0.0001

        /// <summary>
        /// ç©å®¶ID (SteamId) - ç”±æœåŠ¡å™¨å¡«å……,å®¢æˆ·ç«¯ä¸éœ€è¦å‘é€
        /// </summary>
        public string SteamId { get; set; } = string.Empty;

        /// <summary>
        /// ä½ç½® X (é‡åŒ–ä¸º int: -21474836.48m ~ 21474836.47m, ç²¾åº¦ 1cm)
        /// </summary>
        public int PosX { get; set; }

        /// <summary>
        /// ä½ç½® Y (é‡åŒ–ä¸º int: -21474836.48m ~ 21474836.47m, ç²¾åº¦ 1cm)
        /// </summary>
        public int PosY { get; set; }

        /// <summary>
        /// ä½ç½® Z (é‡åŒ–ä¸º int: -21474836.48m ~ 21474836.47m, ç²¾åº¦ 1cm)
        /// </summary>
        public int PosZ { get; set; }

        /// <summary>
        /// å‹ç¼©çš„æ—‹è½¬æ•°æ® (ä½¿ç”¨ Smallest Three ç®—æ³•)
        /// 3 ä¸ª short å­˜å‚¨æœ€å°çš„ 3 ä¸ªå››å…ƒæ•°åˆ†é‡ + 2 bit å­˜å‚¨çœç•¥çš„åˆ†é‡ç´¢å¼•
        /// </summary>
        public short RotA { get; set; }
        public short RotB { get; set; }
        public short RotC { get; set; }
        
        /// <summary>
        /// æ—‹è½¬çœç•¥ç´¢å¼• (0-3 è¡¨ç¤ºçœç•¥ x,y,z,w ä¸­çš„å“ªä¸€ä¸ª)
        /// </summary>
        public byte RotOmitIndex { get; set; }

        /// <summary>
        /// é€Ÿåº¦ X (é‡åŒ–ä¸º short: -3276.8 ~ 3276.7 m/s, ç²¾åº¦ 0.1)
        /// </summary>
        public short VelX { get; set; }

        /// <summary>
        /// é€Ÿåº¦ Y (é‡åŒ–ä¸º short: -3276.8 ~ 3276.7 m/s, ç²¾åº¦ 0.1)
        /// </summary>
        public short VelY { get; set; }

        /// <summary>
        /// é€Ÿåº¦ Z (é‡åŒ–ä¸º short: -3276.8 ~ 3276.7 m/s, ç²¾åº¦ 0.1)
        /// </summary>
        public short VelZ { get; set; }

        /// <summary>
        /// åºåˆ—å· (ç”¨äºæ’åºå’Œå»é‡ï¼Œä¸ä¼ è¾“ç»å¯¹æ—¶é—´)
        /// å®¢æˆ·ç«¯é€’å¢å‘é€ï¼ŒæœåŠ¡å™¨è½¬å‘æ—¶ä¿ç•™
        /// èŒƒå›´: 0 ~ 4,294,967,295 (çº¦49å¤©åå¾ªç¯)
        /// </summary>
        public uint SequenceNumber { get; set; }

        /// <summary>
        /// æ„é€ å‡½æ•°
        /// </summary>
        public UnitySyncData()
        {
            // ä½¿ç”¨æ¯«ç§’çº§æ—¶é—´æˆ³ä½œä¸ºåˆå§‹åºåˆ—å·ï¼ˆç¡®ä¿å”¯ä¸€æ€§ï¼‰
            SequenceNumber = (uint)(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() & 0xFFFFFFFF);
        }

        // ============ è¾…åŠ©æ–¹æ³•:ç¼–ç  ============

        /// <summary>
        /// ä»æµ®ç‚¹ä½ç½®ç¼–ç 
        /// </summary>
        public void SetPosition(float x, float y, float z)
        {
            PosX = (int)(x * POSITION_MULTIPLIER);
            PosY = (int)(y * POSITION_MULTIPLIER);
            PosZ = (int)(z * POSITION_MULTIPLIER);
        }

        /// <summary>
        /// ä»å››å…ƒæ•°ç¼–ç  (ä½¿ç”¨ Smallest Three å‹ç¼©)
        /// </summary>
        public void SetRotation(float x, float y, float z, float w)
        {
            // æ‰¾å‡ºç»å¯¹å€¼æœ€å¤§çš„åˆ†é‡å¹¶çœç•¥å®ƒ
            float[] components = { x, y, z, w };
            int omitIndex = 0;
            float maxAbs = Math.Abs(components[0]);
            
            for (int i = 1; i < 4; i++)
            {
                float abs = Math.Abs(components[i]);
                if (abs > maxAbs)
                {
                    maxAbs = abs;
                    omitIndex = i;
                }
            }

            // ç¡®ä¿çœç•¥çš„åˆ†é‡ç¬¦å·ä¸ºæ­£ (å¦‚æœä¸ºè´Ÿ,ç¿»è½¬æ‰€æœ‰åˆ†é‡)
            float sign = components[omitIndex] < 0 ? -1f : 1f;
            
            // æå–å¹¶é‡åŒ–å…¶ä»– 3 ä¸ªåˆ†é‡
            int writeIndex = 0;
            short[] compressed = new short[3];
            
            for (int i = 0; i < 4; i++)
            {
                if (i != omitIndex)
                {
                    compressed[writeIndex++] = (short)Math.Clamp(
                        (int)(components[i] * sign * ROTATION_MULTIPLIER), 
                        short.MinValue, 
                        short.MaxValue
                    );
                }
            }

            RotA = compressed[0];
            RotB = compressed[1];
            RotC = compressed[2];
            RotOmitIndex = (byte)omitIndex;
        }

        /// <summary>
        /// ä»é€Ÿåº¦å‘é‡ç¼–ç 
        /// </summary>
        public void SetVelocity(float x, float y, float z)
        {
            VelX = (short)Math.Clamp((int)(x * VELOCITY_MULTIPLIER), short.MinValue, short.MaxValue);
            VelY = (short)Math.Clamp((int)(y * VELOCITY_MULTIPLIER), short.MinValue, short.MaxValue);
            VelZ = (short)Math.Clamp((int)(z * VELOCITY_MULTIPLIER), short.MinValue, short.MaxValue);
        }

        // ============ è¾…åŠ©æ–¹æ³•:è§£ç  ============

        /// <summary>
        /// è§£ç ä½ç½®
        /// </summary>
        public (float x, float y, float z) GetPosition()
        {
            return (
                PosX * POSITION_PRECISION,
                PosY * POSITION_PRECISION,
                PosZ * POSITION_PRECISION
            );
        }

        /// <summary>
        /// è§£ç æ—‹è½¬ (ä» Smallest Three è¿˜åŸå››å…ƒæ•°)
        /// </summary>
        public (float x, float y, float z, float w) GetRotation()
        {
            float[] components = new float[4];
            float[] compressed = {
                RotA * ROTATION_PRECISION,
                RotB * ROTATION_PRECISION,
                RotC * ROTATION_PRECISION
            };

            // è¿˜åŸ 3 ä¸ªåˆ†é‡
            int readIndex = 0;
            for (int i = 0; i < 4; i++)
            {
                if (i != RotOmitIndex)
                {
                    components[i] = compressed[readIndex++];
                }
            }

            // æ ¹æ®å››å…ƒæ•°å½’ä¸€åŒ–ç‰¹æ€§,è®¡ç®—çœç•¥çš„åˆ†é‡
            float sumSquares = components[0] * components[0] + 
                              components[1] * components[1] + 
                              components[2] * components[2];
            
            components[RotOmitIndex] = (float)Math.Sqrt(Math.Max(0, 1.0f - sumSquares));

            return (components[0], components[1], components[2], components[3]);
        }

        /// <summary>
        /// è§£ç é€Ÿåº¦
        /// </summary>
        public (float x, float y, float z) GetVelocity()
        {
            return (
                VelX * VELOCITY_PRECISION,
                VelY * VELOCITY_PRECISION,
                VelZ * VELOCITY_PRECISION
            );
        }

        /// <summary>
        /// åˆ›å»ºå‰¯æœ¬
        /// </summary>
        public UnitySyncData Clone()
        {
            return new UnitySyncData
            {
                SteamId = this.SteamId,
                PosX = this.PosX,
                PosY = this.PosY,
                PosZ = this.PosZ,
                RotA = this.RotA,
                RotB = this.RotB,
                RotC = this.RotC,
                RotOmitIndex = this.RotOmitIndex,
                VelX = this.VelX,
                VelY = this.VelY,
                VelZ = this.VelZ,
                SequenceNumber = this.SequenceNumber,
            };
        }

        public override string ToString()
        {
            var pos = GetPosition();
            var vel = GetVelocity();
            return $"Player:{SteamId} Pos:({pos.x:F2},{pos.y:F2},{pos.z:F2}) " +
                   $"Vel:({vel.x:F2},{vel.y:F2},{vel.z:F2}) Seq:{SequenceNumber}";
        }
    }
}

```

`Shared\Data\WeaponFireData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// æ­¦å™¨å°„å‡»æ•°æ®ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨â†’å…¶ä»–å®¢æˆ·ç«¯ï¼‰
    /// ä»…ç”¨äºæ’­æ”¾è§†è§‰å’ŒéŸ³æ•ˆç‰¹æ•ˆï¼Œä¸å½±å“æ¸¸æˆé€»è¾‘
    /// </summary>
    [Serializable]
    public class WeaponFireData
    {
        /// <summary>å¼€æªç©å®¶çš„ID</summary>
        public string PlayerId { get; set; } = "";

        /// <summary>æªå£ä½ç½®X</summary>
        public float MuzzlePositionX { get; set; }
        
        /// <summary>æªå£ä½ç½®Y</summary>
        public float MuzzlePositionY { get; set; }
        
        /// <summary>æªå£ä½ç½®Z</summary>
        public float MuzzlePositionZ { get; set; }

        /// <summary>æªå£æ–¹å‘X</summary>
        public float MuzzleDirectionX { get; set; }
        
        /// <summary>æªå£æ–¹å‘Y</summary>
        public float MuzzleDirectionY { get; set; }
        
        /// <summary>æªå£æ–¹å‘Z</summary>
        public float MuzzleDirectionZ { get; set; }

        /// <summary>æ˜¯å¦ä½¿ç”¨æ¶ˆéŸ³å™¨</summary>
        public bool IsSilenced { get; set; }

        /// <summary>æ­¦å™¨ç±»å‹IDï¼ˆç”¨äºè·å–ç‰¹æ•ˆé…ç½®ï¼Œå¯é€‰ï¼‰</summary>
        public int WeaponTypeId { get; set; }
    }

    /// <summary>
    /// æ‰¹é‡æ­¦å™¨å°„å‡»æ•°æ®ï¼ˆéœ°å¼¹æª/è¿å‘æ­¦å™¨ä¼˜åŒ–ï¼‰
    /// ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šå°è£…å¤šå‘å­å¼¹ï¼Œé¿å… RPC æ•°ç»„åºåˆ—åŒ–é—®é¢˜
    /// </summary>
    [Serializable]
    public class WeaponFireBatchData
    {
        /// <summary>å¼€æªç©å®¶çš„ID</summary>
        public string PlayerId { get; set; } = "";

        /// <summary>æ˜¯å¦ä½¿ç”¨æ¶ˆéŸ³å™¨</summary>
        public bool IsSilenced { get; set; }

        /// <summary>æ­¦å™¨ç±»å‹ID</summary>
        public int WeaponTypeId { get; set; }

        /// <summary>å­å¼¹æ•°é‡</summary>
        public int BulletCount { get; set; }

        /// <summary>æ‰€æœ‰å­å¼¹çš„æªå£ä½ç½®Xæ•°ç»„</summary>
        public float[] MuzzlePositionsX { get; set; } = Array.Empty<float>();

        /// <summary>æ‰€æœ‰å­å¼¹çš„æªå£ä½ç½®Yæ•°ç»„</summary>
        public float[] MuzzlePositionsY { get; set; } = Array.Empty<float>();

        /// <summary>æ‰€æœ‰å­å¼¹çš„æªå£ä½ç½®Zæ•°ç»„</summary>
        public float[] MuzzlePositionsZ { get; set; } = Array.Empty<float>();

        /// <summary>æ‰€æœ‰å­å¼¹çš„æ–¹å‘Xæ•°ç»„</summary>
        public float[] DirectionsX { get; set; } = Array.Empty<float>();

        /// <summary>æ‰€æœ‰å­å¼¹çš„æ–¹å‘Yæ•°ç»„</summary>
        public float[] DirectionsY { get; set; } = Array.Empty<float>();

        /// <summary>æ‰€æœ‰å­å¼¹çš„æ–¹å‘Zæ•°ç»„</summary>
        public float[] DirectionsZ { get; set; } = Array.Empty<float>();

        /// <summary>
        /// è½¬æ¢ä¸ºå•ä¸ª WeaponFireData æ•°ç»„
        /// </summary>
        public WeaponFireData[] ToFireDataArray()
        {
            var result = new WeaponFireData[BulletCount];
            for (int i = 0; i < BulletCount; i++)
            {
                result[i] = new WeaponFireData
                {
                    PlayerId = PlayerId,
                    MuzzlePositionX = MuzzlePositionsX[i],
                    MuzzlePositionY = MuzzlePositionsY[i],
                    MuzzlePositionZ = MuzzlePositionsZ[i],
                    MuzzleDirectionX = DirectionsX[i],
                    MuzzleDirectionY = DirectionsY[i],
                    MuzzleDirectionZ = DirectionsZ[i],
                    IsSilenced = IsSilenced,
                    WeaponTypeId = WeaponTypeId
                };
            }
            return result;
        }

        /// <summary>
        /// ä» WeaponFireData æ•°ç»„åˆ›å»ºæ‰¹é‡æ•°æ®
        /// </summary>
        public static WeaponFireBatchData FromArray(WeaponFireData[] fireDataArray)
        {
            int count = fireDataArray.Length;
            var batch = new WeaponFireBatchData
            {
                BulletCount = count,
                PlayerId = count > 0 ? fireDataArray[0].PlayerId : "",
                IsSilenced = count > 0 && fireDataArray[0].IsSilenced,
                WeaponTypeId = count > 0 ? fireDataArray[0].WeaponTypeId : 0,
                MuzzlePositionsX = new float[count],
                MuzzlePositionsY = new float[count],
                MuzzlePositionsZ = new float[count],
                DirectionsX = new float[count],
                DirectionsY = new float[count],
                DirectionsZ = new float[count]
            };

            for (int i = 0; i < count; i++)
            {
                batch.MuzzlePositionsX[i] = fireDataArray[i].MuzzlePositionX;
                batch.MuzzlePositionsY[i] = fireDataArray[i].MuzzlePositionY;
                batch.MuzzlePositionsZ[i] = fireDataArray[i].MuzzlePositionZ;
                batch.DirectionsX[i] = fireDataArray[i].MuzzleDirectionX;
                batch.DirectionsY[i] = fireDataArray[i].MuzzleDirectionY;
                batch.DirectionsZ[i] = fireDataArray[i].MuzzleDirectionZ;
            }

            return batch;
        }
    }
}


```

`Shared\Data\WeaponSyncData.cs`:

```cs
using System;

namespace DuckyNet.Shared.Data
{
    /// <summary>
    /// æ­¦å™¨æ§½ä½ç±»å‹
    /// </summary>
    public enum WeaponSlotType : byte
    {
        /// <summary>ä¸»æ­¦å™¨</summary>
        PrimaryWeapon = 0,
        /// <summary>å‰¯æ­¦å™¨</summary>
        SecondaryWeapon = 1,
        /// <summary>è¿‘æˆ˜æ­¦å™¨</summary>
        MeleeWeapon = 2
    }

    /// <summary>
    /// æ­¦å™¨æ§½ä½æ›´æ–°è¯·æ±‚ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
    /// </summary>
    [Serializable]
    public class WeaponSlotUpdateRequest
    {
        /// <summary>æ§½ä½ç±»å‹</summary>
        public WeaponSlotType SlotType { get; set; }

        /// <summary>ç‰©å“ TypeID</summary>
        public int ItemTypeId { get; set; }

        /// <summary>ç‰©å“åç§°ï¼ˆç”¨äºæ—¥å¿—ï¼‰</summary>
        public string ItemName { get; set; } = "";

        /// <summary>
        /// æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“ï¼ˆå¢é‡åŒæ­¥ä¼˜åŒ–ï¼‰
        /// å¦‚æœä¸º trueï¼ŒItemDataCompressed ä¸ºç©ºï¼Œæ¥æ”¶ç«¯è‡ªåŠ¨åˆ›å»ºé»˜è®¤ç‰©å“
        /// </summary>
        public bool IsDefaultItem { get; set; }

        /// <summary>
        /// å‹ç¼©çš„ç‰©å“æ•°æ®ï¼ˆBase64ç¼–ç ï¼‰
        /// åŒ…å«å®Œæ•´çš„ç‰©å“æ ‘ï¼ˆæ§½ä½ã€èƒŒåŒ…ã€å˜é‡ç­‰ï¼‰
        /// </summary>
        public string ItemDataCompressed { get; set; } = "";
    }

    /// <summary>
    /// æ­¦å™¨æ§½ä½å¸ä¸‹è¯·æ±‚ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
    /// </summary>
    [Serializable]
    public class WeaponSlotUnequipRequest
    {
        /// <summary>æ§½ä½ç±»å‹</summary>
        public WeaponSlotType SlotType { get; set; }
    }

    /// <summary>
    /// æ­¦å™¨åˆ‡æ¢è¯·æ±‚ï¼ˆå®¢æˆ·ç«¯â†’æœåŠ¡å™¨ï¼‰
    /// å½“ç©å®¶æŒ‰1/2/3é”®åˆ‡æ¢æ­¦å™¨æ—¶å‘é€
    /// </summary>
    [Serializable]
    public class WeaponSwitchRequest
    {
        /// <summary>å½“å‰åˆ‡æ¢åˆ°çš„æ­¦å™¨æ§½ä½</summary>
        public WeaponSlotType CurrentWeaponSlot { get; set; }
    }

    /// <summary>
    /// æ­¦å™¨åˆ‡æ¢é€šçŸ¥ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
    /// </summary>
    [Serializable]
    public class WeaponSwitchNotification
    {
        /// <summary>ç©å®¶ID</summary>
        public string PlayerId { get; set; } = "";

        /// <summary>å½“å‰æ­¦å™¨æ§½ä½</summary>
        public WeaponSlotType CurrentWeaponSlot { get; set; }
    }

    /// <summary>
    /// æ­¦å™¨æ§½ä½æ›´æ–°é€šçŸ¥ï¼ˆæœåŠ¡å™¨â†’å®¢æˆ·ç«¯ï¼‰
    /// </summary>
    [Serializable]
    public class WeaponSlotUpdateNotification
    {
        /// <summary>ç©å®¶ID</summary>
        public string PlayerId { get; set; } = "";

        /// <summary>æ§½ä½ç±»å‹</summary>
        public WeaponSlotType SlotType { get; set; }

        /// <summary>ç‰©å“ TypeIDï¼ˆ0è¡¨ç¤ºå¸ä¸‹ï¼‰</summary>
        public int ItemTypeId { get; set; }

        /// <summary>ç‰©å“åç§°</summary>
        public string ItemName { get; set; } = "";

        /// <summary>æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“</summary>
        public bool IsDefaultItem { get; set; }

        /// <summary>å‹ç¼©çš„ç‰©å“æ•°æ®</summary>
        public string ItemDataCompressed { get; set; } = "";
    }

    /// <summary>
    /// ç©å®¶æ­¦å™¨æ•°æ®ï¼ˆå­˜å‚¨åœ¨ PlayerInfo ä¸­ï¼‰
    /// </summary>
    [Serializable]
    public class PlayerWeaponData
    {
        /// <summary>ä¸»æ­¦å™¨</summary>
        public WeaponItemData? PrimaryWeapon { get; set; }

        /// <summary>å‰¯æ­¦å™¨</summary>
        public WeaponItemData? SecondaryWeapon { get; set; }

        /// <summary>è¿‘æˆ˜æ­¦å™¨</summary>
        public WeaponItemData? MeleeWeapon { get; set; }

        /// <summary>å½“å‰æ‰‹æŒçš„æ­¦å™¨æ§½ä½ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰</summary>
        public WeaponSlotType? CurrentWeaponSlot { get; set; }

        /// <summary>
        /// è·å–æŒ‡å®šæ§½ä½çš„æ­¦å™¨æ•°æ®
        /// </summary>
        public WeaponItemData? GetWeapon(WeaponSlotType slotType)
        {
            return slotType switch
            {
                WeaponSlotType.PrimaryWeapon => PrimaryWeapon,
                WeaponSlotType.SecondaryWeapon => SecondaryWeapon,
                WeaponSlotType.MeleeWeapon => MeleeWeapon,
                _ => null
            };
        }

        /// <summary>
        /// è®¾ç½®æŒ‡å®šæ§½ä½çš„æ­¦å™¨æ•°æ®
        /// </summary>
        public void SetWeapon(WeaponSlotType slotType, WeaponItemData? weaponData)
        {
            switch (slotType)
            {
                case WeaponSlotType.PrimaryWeapon:
                    PrimaryWeapon = weaponData;
                    break;
                case WeaponSlotType.SecondaryWeapon:
                    SecondaryWeapon = weaponData;
                    break;
                case WeaponSlotType.MeleeWeapon:
                    MeleeWeapon = weaponData;
                    break;
            }
        }

        /// <summary>
        /// æ¸…ç©ºæ‰€æœ‰æ­¦å™¨
        /// </summary>
        public void ClearAll()
        {
            PrimaryWeapon = null;
            SecondaryWeapon = null;
            MeleeWeapon = null;
        }

        /// <summary>
        /// è·å–å·²è£…å¤‡çš„æ­¦å™¨æ•°é‡
        /// </summary>
        public int GetEquippedCount()
        {
            int count = 0;
            if (PrimaryWeapon != null) count++;
            if (SecondaryWeapon != null) count++;
            if (MeleeWeapon != null) count++;
            return count;
        }
    }

    /// <summary>
    /// å•ä¸ªæ­¦å™¨çš„æ•°æ®
    /// </summary>
    [Serializable]
    public class WeaponItemData
    {
        /// <summary>ç‰©å“ TypeID</summary>
        public int ItemTypeId { get; set; }

        /// <summary>ç‰©å“åç§°</summary>
        public string ItemName { get; set; } = "";

        /// <summary>æ˜¯å¦ä¸ºé»˜è®¤ç‰©å“</summary>
        public bool IsDefaultItem { get; set; }

        /// <summary>å‹ç¼©çš„ç‰©å“æ•°æ®ï¼ˆBase64ç¼–ç çš„åºåˆ—åŒ–æ•°æ®ï¼‰</summary>
        public string ItemDataCompressed { get; set; } = "";
    }

    /// <summary>
    /// æ‰¹é‡æ­¦å™¨æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶å‘é€ï¼‰
    /// </summary>
    [Serializable]
    public class AllPlayersWeaponData
    {
        /// <summary>
        /// æ‰€æœ‰ç©å®¶çš„æ­¦å™¨æ•°æ®
        /// Key: PlayerId, Value: è¯¥ç©å®¶çš„æ­¦å™¨æ•°æ®
        /// </summary>
        public System.Collections.Generic.Dictionary<string, PlayerWeaponData> PlayersWeapons { get; set; }
            = new System.Collections.Generic.Dictionary<string, PlayerWeaponData>();
    }
}


```

`Shared\DuckyNetShared.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <Nullable>enable</Nullable>
    <AssemblyName>DuckyNet.Shared</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="LiteNetLib" Version="1.2.0" />
    <PackageReference Include="NetSerializer" Version="4.1.1" />
  </ItemGroup>

  <ItemGroup>
    <!-- åªç¼–è¯‘Proxyæ–‡ä»¶ï¼ŒDispatcherå’ŒTypeRegisterç”¨äºæœåŠ¡å™¨ç«¯ -->
    <Compile Remove="Generated\*Dispatcher.cs" />
    <Compile Remove="Generated\TypeRegister.gen.cs" />
  </ItemGroup>

</Project>

```

`Shared\Generated\AnimatorSyncClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class AnimatorSyncClientServiceBroadcastProxy : DuckyNet.Shared.Services.IAnimatorSyncClientService
    {
        private readonly object _server;
        public AnimatorSyncClientServiceBroadcastProxy(object server) => _server = server;

        public void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IAnimatorSyncClientService));
            method.Invoke(_server, new object[] { "OnAnimatorStateUpdated", new object[] { steamId, animatorData } });
        }

    }
}

```

`Shared\Generated\AnimatorSyncClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class AnimatorSyncClientServiceClientCallProxy : DuckyNet.Shared.Services.IAnimatorSyncClientService
    {
        private readonly IClientContext _client;
        public AnimatorSyncClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData) => _client.Invoke<DuckyNet.Shared.Services.IAnimatorSyncClientService>("OnAnimatorStateUpdated", steamId, animatorData);

    }
}

```

`Shared\Generated\AnimatorSyncClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class AnimatorSyncClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public AnimatorSyncClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData) => _ctx.Invoke<DuckyNet.Shared.Services.IAnimatorSyncClientService>("OnAnimatorStateUpdated", steamId, animatorData);
    }
}

```

`Shared\Generated\AnimatorSyncClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class AnimatorSyncClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IAnimatorSyncClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public AnimatorSyncClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IAnimatorSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnAnimatorStateUpdated", new object[] { steamId, animatorData } });
        }

    }
}

```

`Shared\Generated\AnimatorSyncClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class AnimatorSyncClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IAnimatorSyncClientService _impl;
        public AnimatorSyncClientServiceServerDispatcher(DuckyNet.Shared.Services.IAnimatorSyncClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnAnimatorStateUpdated": _impl.OnAnimatorStateUpdated((string)args[0], (AnimatorSyncData)args[1]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\AnimatorSyncClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class AnimatorSyncClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IAnimatorSyncClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public AnimatorSyncClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IAnimatorSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnAnimatorStateUpdated", new object[] { steamId, animatorData } });
        }

    }
}

```

`Shared\Generated\AnimatorSyncServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class AnimatorSyncServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public AnimatorSyncServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void UpdateAnimatorState(AnimatorSyncData animatorData) => _ctx.Invoke<DuckyNet.Shared.Services.IAnimatorSyncService>("UpdateAnimatorState", animatorData);
    }
}

```

`Shared\Generated\AnimatorSyncServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class AnimatorSyncServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IAnimatorSyncService _impl;
        public AnimatorSyncServiceServerDispatcher(DuckyNet.Shared.Services.IAnimatorSyncService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "UpdateAnimatorState": _impl.UpdateAnimatorState(ctx, (AnimatorSyncData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\CharacterAppearanceClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class CharacterAppearanceClientServiceBroadcastProxy : DuckyNet.Shared.Services.ICharacterAppearanceClientService
    {
        private readonly object _server;
        public CharacterAppearanceClientServiceBroadcastProxy(object server) => _server = server;

        public void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ICharacterAppearanceClientService));
            method.Invoke(_server, new object[] { "OnAppearanceReceived", new object[] { steamId, appearanceData } });
        }

    }
}

```

`Shared\Generated\CharacterAppearanceClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class CharacterAppearanceClientServiceClientCallProxy : DuckyNet.Shared.Services.ICharacterAppearanceClientService
    {
        private readonly IClientContext _client;
        public CharacterAppearanceClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData) => _client.Invoke<DuckyNet.Shared.Services.ICharacterAppearanceClientService>("OnAppearanceReceived", steamId, appearanceData);

    }
}

```

`Shared\Generated\CharacterAppearanceClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class CharacterAppearanceClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public CharacterAppearanceClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData) => _ctx.Invoke<DuckyNet.Shared.Services.ICharacterAppearanceClientService>("OnAppearanceReceived", steamId, appearanceData);
    }
}

```

`Shared\Generated\CharacterAppearanceClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class CharacterAppearanceClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.ICharacterAppearanceClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public CharacterAppearanceClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ICharacterAppearanceClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnAppearanceReceived", new object[] { steamId, appearanceData } });
        }

    }
}

```

`Shared\Generated\CharacterAppearanceClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class CharacterAppearanceClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.ICharacterAppearanceClientService _impl;
        public CharacterAppearanceClientServiceServerDispatcher(DuckyNet.Shared.Services.ICharacterAppearanceClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnAppearanceReceived": _impl.OnAppearanceReceived((string)args[0], (CharacterAppearanceData)args[1]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\CharacterAppearanceClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class CharacterAppearanceClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.ICharacterAppearanceClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public CharacterAppearanceClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ICharacterAppearanceClientService));
            method.Invoke(_server, new object[] { _predicate, "OnAppearanceReceived", new object[] { steamId, appearanceData } });
        }

    }
}

```

`Shared\Generated\CharacterAppearanceServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class CharacterAppearanceServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public CharacterAppearanceServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void UploadAppearance(CharacterAppearanceData appearanceData) => _ctx.Invoke<DuckyNet.Shared.Services.ICharacterAppearanceService>("UploadAppearance", appearanceData);
        public void RequestAppearance(string targetSteamId) => _ctx.Invoke<DuckyNet.Shared.Services.ICharacterAppearanceService>("RequestAppearance", targetSteamId);
    }
}

```

`Shared\Generated\CharacterAppearanceServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class CharacterAppearanceServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.ICharacterAppearanceService _impl;
        public CharacterAppearanceServiceServerDispatcher(DuckyNet.Shared.Services.ICharacterAppearanceService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "UploadAppearance": _impl.UploadAppearance(ctx, (CharacterAppearanceData)args[0]); return null;
                case "RequestAppearance": _impl.RequestAppearance(ctx, (string)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\CharacterClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class CharacterClientServiceBroadcastProxy : DuckyNet.Shared.Services.ICharacterClientService
    {
        private readonly object _server;
        public CharacterClientServiceBroadcastProxy(object server) => _server = server;

        public void OnPlayerAppearanceUpdated(string steamId, Byte[] appearanceData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ICharacterClientService));
            method.Invoke(_server, new object[] { "OnPlayerAppearanceUpdated", new object[] { steamId, appearanceData } });
        }

    }
}

```

`Shared\Generated\CharacterClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class CharacterClientServiceClientCallProxy : DuckyNet.Shared.Services.ICharacterClientService
    {
        private readonly IClientContext _client;
        public CharacterClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnPlayerAppearanceUpdated(string steamId, Byte[] appearanceData) => _client.Invoke<DuckyNet.Shared.Services.ICharacterClientService>("OnPlayerAppearanceUpdated", steamId, appearanceData);

    }
}

```

`Shared\Generated\CharacterClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class CharacterClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public CharacterClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnPlayerAppearanceUpdated(string steamId, Byte[] appearanceData) => _ctx.Invoke<DuckyNet.Shared.Services.ICharacterClientService>("OnPlayerAppearanceUpdated", steamId, appearanceData);
    }
}

```

`Shared\Generated\CharacterClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class CharacterClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.ICharacterClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public CharacterClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnPlayerAppearanceUpdated(string steamId, Byte[] appearanceData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ICharacterClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerAppearanceUpdated", new object[] { steamId, appearanceData } });
        }

    }
}

```

`Shared\Generated\CharacterClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    public class CharacterClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.ICharacterClientService _impl;
        public CharacterClientServiceServerDispatcher(DuckyNet.Shared.Services.ICharacterClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnPlayerAppearanceUpdated": _impl.OnPlayerAppearanceUpdated((string)args[0], (Byte[])args[1]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\CharacterClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class CharacterClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.ICharacterClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public CharacterClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnPlayerAppearanceUpdated(string steamId, Byte[] appearanceData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ICharacterClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerAppearanceUpdated", new object[] { steamId, appearanceData } });
        }

    }
}

```

`Shared\Generated\CharacterServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class CharacterServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public CharacterServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<bool> UpdateAppearanceAsync(Byte[] appearanceData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.ICharacterService, bool>("UpdateAppearanceAsync", appearanceData);
        public Task<Byte[]> GetAppearanceAsync(string steamId) => _ctx.InvokeAsync<DuckyNet.Shared.Services.ICharacterService, Byte[]>("GetAppearanceAsync", steamId);
    }
}

```

`Shared\Generated\CharacterServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    public class CharacterServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.ICharacterService _impl;
        public CharacterServiceServerDispatcher(DuckyNet.Shared.Services.ICharacterService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "UpdateAppearanceAsync": return _impl.UpdateAppearanceAsync(ctx, (Byte[])args[0]);
                case "GetAppearanceAsync": return _impl.GetAppearanceAsync(ctx, (string)args[0]);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\EquipmentClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class EquipmentClientServiceBroadcastProxy : DuckyNet.Shared.Services.IEquipmentClientService
    {
        private readonly object _server;
        public EquipmentClientServiceBroadcastProxy(object server) => _server = server;

        public void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IEquipmentClientService));
            method.Invoke(_server, new object[] { "OnEquipmentSlotUpdated", new object[] { notification } });
        }

        public void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IEquipmentClientService));
            method.Invoke(_server, new object[] { "OnAllPlayersEquipmentReceived", new object[] { allEquipmentData } });
        }

    }
}

```

`Shared\Generated\EquipmentClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class EquipmentClientServiceClientCallProxy : DuckyNet.Shared.Services.IEquipmentClientService
    {
        private readonly IClientContext _client;
        public EquipmentClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification) => _client.Invoke<DuckyNet.Shared.Services.IEquipmentClientService>("OnEquipmentSlotUpdated", notification);

        public void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData) => _client.Invoke<DuckyNet.Shared.Services.IEquipmentClientService>("OnAllPlayersEquipmentReceived", allEquipmentData);

    }
}

```

`Shared\Generated\EquipmentClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class EquipmentClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public EquipmentClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification) => _ctx.Invoke<DuckyNet.Shared.Services.IEquipmentClientService>("OnEquipmentSlotUpdated", notification);
        public void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData) => _ctx.Invoke<DuckyNet.Shared.Services.IEquipmentClientService>("OnAllPlayersEquipmentReceived", allEquipmentData);
    }
}

```

`Shared\Generated\EquipmentClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class EquipmentClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IEquipmentClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public EquipmentClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IEquipmentClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnEquipmentSlotUpdated", new object[] { notification } });
        }

        public void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IEquipmentClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnAllPlayersEquipmentReceived", new object[] { allEquipmentData } });
        }

    }
}

```

`Shared\Generated\EquipmentClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class EquipmentClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IEquipmentClientService _impl;
        public EquipmentClientServiceServerDispatcher(DuckyNet.Shared.Services.IEquipmentClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnEquipmentSlotUpdated": _impl.OnEquipmentSlotUpdated((EquipmentSlotUpdateNotification)args[0]); return null;
                case "OnAllPlayersEquipmentReceived": _impl.OnAllPlayersEquipmentReceived((AllPlayersEquipmentData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\EquipmentClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class EquipmentClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IEquipmentClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public EquipmentClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IEquipmentClientService));
            method.Invoke(_server, new object[] { _predicate, "OnEquipmentSlotUpdated", new object[] { notification } });
        }

        public void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IEquipmentClientService));
            method.Invoke(_server, new object[] { _predicate, "OnAllPlayersEquipmentReceived", new object[] { allEquipmentData } });
        }

    }
}

```

`Shared\Generated\EquipmentServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class EquipmentServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public EquipmentServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<bool> UpdateEquipmentSlotAsync(EquipmentSlotUpdateRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IEquipmentService, bool>("UpdateEquipmentSlotAsync", request);
    }
}

```

`Shared\Generated\EquipmentServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class EquipmentServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IEquipmentService _impl;
        public EquipmentServiceServerDispatcher(DuckyNet.Shared.Services.IEquipmentService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "UpdateEquipmentSlotAsync": return _impl.UpdateEquipmentSlotAsync(ctx, (EquipmentSlotUpdateRequest)args[0]);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\HealthSyncClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class HealthSyncClientServiceBroadcastProxy : DuckyNet.Shared.Services.IHealthSyncClientService
    {
        private readonly object _server;
        public HealthSyncClientServiceBroadcastProxy(object server) => _server = server;

        public void OnHealthSyncReceived(HealthSyncData healthData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IHealthSyncClientService));
            method.Invoke(_server, new object[] { "OnHealthSyncReceived", new object[] { healthData } });
        }

    }
}

```

`Shared\Generated\HealthSyncClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class HealthSyncClientServiceClientCallProxy : DuckyNet.Shared.Services.IHealthSyncClientService
    {
        private readonly IClientContext _client;
        public HealthSyncClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnHealthSyncReceived(HealthSyncData healthData) => _client.Invoke<DuckyNet.Shared.Services.IHealthSyncClientService>("OnHealthSyncReceived", healthData);

    }
}

```

`Shared\Generated\HealthSyncClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class HealthSyncClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public HealthSyncClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnHealthSyncReceived(HealthSyncData healthData) => _ctx.Invoke<DuckyNet.Shared.Services.IHealthSyncClientService>("OnHealthSyncReceived", healthData);
    }
}

```

`Shared\Generated\HealthSyncClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class HealthSyncClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IHealthSyncClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public HealthSyncClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnHealthSyncReceived(HealthSyncData healthData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IHealthSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnHealthSyncReceived", new object[] { healthData } });
        }

    }
}

```

`Shared\Generated\HealthSyncClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class HealthSyncClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IHealthSyncClientService _impl;
        public HealthSyncClientServiceServerDispatcher(DuckyNet.Shared.Services.IHealthSyncClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnHealthSyncReceived": _impl.OnHealthSyncReceived((HealthSyncData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\HealthSyncClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class HealthSyncClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IHealthSyncClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public HealthSyncClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnHealthSyncReceived(HealthSyncData healthData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IHealthSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnHealthSyncReceived", new object[] { healthData } });
        }

    }
}

```

`Shared\Generated\HealthSyncServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class HealthSyncServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public HealthSyncServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void SendHealthSync(HealthSyncData healthData) => _ctx.Invoke<DuckyNet.Shared.Services.IHealthSyncService>("SendHealthSync", healthData);
    }
}

```

`Shared\Generated\HealthSyncServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class HealthSyncServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IHealthSyncService _impl;
        public HealthSyncServiceServerDispatcher(DuckyNet.Shared.Services.IHealthSyncService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "SendHealthSync": _impl.SendHealthSync(ctx, (HealthSyncData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\ItemSyncClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class ItemSyncClientServiceBroadcastProxy : DuckyNet.Shared.Services.IItemSyncClientService
    {
        private readonly object _server;
        public ItemSyncClientServiceBroadcastProxy(object server) => _server = server;

        public void OnRemoteItemDropped(ItemDropData dropData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IItemSyncClientService));
            method.Invoke(_server, new object[] { "OnRemoteItemDropped", new object[] { dropData } });
        }

        public void OnRemoteItemPickedUp(UInt32 dropId, string pickedByPlayerId)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IItemSyncClientService));
            method.Invoke(_server, new object[] { "OnRemoteItemPickedUp", new object[] { dropId, pickedByPlayerId } });
        }

    }
}

```

`Shared\Generated\ItemSyncClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class ItemSyncClientServiceClientCallProxy : DuckyNet.Shared.Services.IItemSyncClientService
    {
        private readonly IClientContext _client;
        public ItemSyncClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnRemoteItemDropped(ItemDropData dropData) => _client.Invoke<DuckyNet.Shared.Services.IItemSyncClientService>("OnRemoteItemDropped", dropData);

        public void OnRemoteItemPickedUp(UInt32 dropId, string pickedByPlayerId) => _client.Invoke<DuckyNet.Shared.Services.IItemSyncClientService>("OnRemoteItemPickedUp", dropId, pickedByPlayerId);

    }
}

```

`Shared\Generated\ItemSyncClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class ItemSyncClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public ItemSyncClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnRemoteItemDropped(ItemDropData dropData) => _ctx.Invoke<DuckyNet.Shared.Services.IItemSyncClientService>("OnRemoteItemDropped", dropData);
        public void OnRemoteItemPickedUp(UInt32 dropId, string pickedByPlayerId) => _ctx.Invoke<DuckyNet.Shared.Services.IItemSyncClientService>("OnRemoteItemPickedUp", dropId, pickedByPlayerId);
    }
}

```

`Shared\Generated\ItemSyncClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class ItemSyncClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IItemSyncClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public ItemSyncClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnRemoteItemDropped(ItemDropData dropData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IItemSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnRemoteItemDropped", new object[] { dropData } });
        }

        public void OnRemoteItemPickedUp(UInt32 dropId, string pickedByPlayerId)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IItemSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnRemoteItemPickedUp", new object[] { dropId, pickedByPlayerId } });
        }

    }
}

```

`Shared\Generated\ItemSyncClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class ItemSyncClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IItemSyncClientService _impl;
        public ItemSyncClientServiceServerDispatcher(DuckyNet.Shared.Services.IItemSyncClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnRemoteItemDropped": _impl.OnRemoteItemDropped((ItemDropData)args[0]); return null;
                case "OnRemoteItemPickedUp": _impl.OnRemoteItemPickedUp((UInt32)args[0], (string)args[1]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\ItemSyncClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class ItemSyncClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IItemSyncClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public ItemSyncClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnRemoteItemDropped(ItemDropData dropData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IItemSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnRemoteItemDropped", new object[] { dropData } });
        }

        public void OnRemoteItemPickedUp(UInt32 dropId, string pickedByPlayerId)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IItemSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnRemoteItemPickedUp", new object[] { dropId, pickedByPlayerId } });
        }

    }
}

```

`Shared\Generated\ItemSyncServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class ItemSyncServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public ItemSyncServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<UInt32> DropItemAsync(ItemDropData dropData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IItemSyncService, UInt32>("DropItemAsync", dropData);
        public Task<bool> PickupItemAsync(ItemPickupRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IItemSyncService, bool>("PickupItemAsync", request);
    }
}

```

`Shared\Generated\ItemSyncServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class ItemSyncServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IItemSyncService _impl;
        public ItemSyncServiceServerDispatcher(DuckyNet.Shared.Services.IItemSyncService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "DropItemAsync": return _impl.DropItemAsync(ctx, (ItemDropData)args[0]);
                case "PickupItemAsync": return _impl.PickupItemAsync(ctx, (ItemPickupRequest)args[0]);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\NpcSyncClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class NpcSyncClientServiceBroadcastProxy : DuckyNet.Shared.Services.INpcSyncClientService
    {
        private readonly object _server;
        public NpcSyncClientServiceBroadcastProxy(object server) => _server = server;

        public void OnNpcSpawned(NpcSpawnData spawnData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { "OnNpcSpawned", new object[] { spawnData } });
        }

        public void OnNpcBatchTransform(NpcBatchTransformData batchData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { "OnNpcBatchTransform", new object[] { batchData } });
        }

        public void OnNpcDestroyed(NpcDestroyData destroyData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { "OnNpcDestroyed", new object[] { destroyData } });
        }

    }
}

```

`Shared\Generated\NpcSyncClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class NpcSyncClientServiceClientCallProxy : DuckyNet.Shared.Services.INpcSyncClientService
    {
        private readonly IClientContext _client;
        public NpcSyncClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnNpcSpawned(NpcSpawnData spawnData) => _client.Invoke<DuckyNet.Shared.Services.INpcSyncClientService>("OnNpcSpawned", spawnData);

        public void OnNpcBatchTransform(NpcBatchTransformData batchData) => _client.Invoke<DuckyNet.Shared.Services.INpcSyncClientService>("OnNpcBatchTransform", batchData);

        public void OnNpcDestroyed(NpcDestroyData destroyData) => _client.Invoke<DuckyNet.Shared.Services.INpcSyncClientService>("OnNpcDestroyed", destroyData);

    }
}

```

`Shared\Generated\NpcSyncClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class NpcSyncClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public NpcSyncClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnNpcSpawned(NpcSpawnData spawnData) => _ctx.Invoke<DuckyNet.Shared.Services.INpcSyncClientService>("OnNpcSpawned", spawnData);
        public void OnNpcBatchTransform(NpcBatchTransformData batchData) => _ctx.Invoke<DuckyNet.Shared.Services.INpcSyncClientService>("OnNpcBatchTransform", batchData);
        public void OnNpcDestroyed(NpcDestroyData destroyData) => _ctx.Invoke<DuckyNet.Shared.Services.INpcSyncClientService>("OnNpcDestroyed", destroyData);
    }
}

```

`Shared\Generated\NpcSyncClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class NpcSyncClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.INpcSyncClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public NpcSyncClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnNpcSpawned(NpcSpawnData spawnData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnNpcSpawned", new object[] { spawnData } });
        }

        public void OnNpcBatchTransform(NpcBatchTransformData batchData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnNpcBatchTransform", new object[] { batchData } });
        }

        public void OnNpcDestroyed(NpcDestroyData destroyData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnNpcDestroyed", new object[] { destroyData } });
        }

    }
}

```

`Shared\Generated\NpcSyncClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class NpcSyncClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.INpcSyncClientService _impl;
        public NpcSyncClientServiceServerDispatcher(DuckyNet.Shared.Services.INpcSyncClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnNpcSpawned": _impl.OnNpcSpawned((NpcSpawnData)args[0]); return null;
                case "OnNpcBatchTransform": _impl.OnNpcBatchTransform((NpcBatchTransformData)args[0]); return null;
                case "OnNpcDestroyed": _impl.OnNpcDestroyed((NpcDestroyData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\NpcSyncClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class NpcSyncClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.INpcSyncClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public NpcSyncClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnNpcSpawned(NpcSpawnData spawnData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnNpcSpawned", new object[] { spawnData } });
        }

        public void OnNpcBatchTransform(NpcBatchTransformData batchData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnNpcBatchTransform", new object[] { batchData } });
        }

        public void OnNpcDestroyed(NpcDestroyData destroyData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.INpcSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnNpcDestroyed", new object[] { destroyData } });
        }

    }
}

```

`Shared\Generated\NpcSyncServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class NpcSyncServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public NpcSyncServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task NotifyNpcSpawned(NpcSpawnData spawnData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.INpcSyncService, object>("NotifyNpcSpawned", spawnData);
        public Task NotifyNpcTransform(NpcTransformData transformData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.INpcSyncService, object>("NotifyNpcTransform", transformData);
        public Task NotifyNpcBatchTransform(NpcBatchTransformData batchData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.INpcSyncService, object>("NotifyNpcBatchTransform", batchData);
        public Task NotifyNpcDestroyed(NpcDestroyData destroyData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.INpcSyncService, object>("NotifyNpcDestroyed", destroyData);
        public Task<NpcSpawnData[]> RequestSceneNpcs(string sceneName, string subSceneName) => _ctx.InvokeAsync<DuckyNet.Shared.Services.INpcSyncService, NpcSpawnData[]>("RequestSceneNpcs", sceneName, subSceneName);
        public Task<NpcSpawnData> RequestSingleNpc(string npcId) => _ctx.InvokeAsync<DuckyNet.Shared.Services.INpcSyncService, NpcSpawnData>("RequestSingleNpc", npcId);
    }
}

```

`Shared\Generated\NpcSyncServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class NpcSyncServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.INpcSyncService _impl;
        public NpcSyncServiceServerDispatcher(DuckyNet.Shared.Services.INpcSyncService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "NotifyNpcSpawned": return _impl.NotifyNpcSpawned(ctx, (NpcSpawnData)args[0]);
                case "NotifyNpcTransform": return _impl.NotifyNpcTransform(ctx, (NpcTransformData)args[0]);
                case "NotifyNpcBatchTransform": return _impl.NotifyNpcBatchTransform(ctx, (NpcBatchTransformData)args[0]);
                case "NotifyNpcDestroyed": return _impl.NotifyNpcDestroyed(ctx, (NpcDestroyData)args[0]);
                case "RequestSceneNpcs": return _impl.RequestSceneNpcs(ctx, (string)args[0], (string)args[1]);
                case "RequestSingleNpc": return _impl.RequestSingleNpc(ctx, (string)args[0]);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\PlayerClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class PlayerClientServiceBroadcastProxy : DuckyNet.Shared.Services.IPlayerClientService
    {
        private readonly object _server;
        public PlayerClientServiceBroadcastProxy(object server) => _server = server;

        public void OnChatMessage(PlayerInfo sender, string message)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { "OnChatMessage", new object[] { sender, message } });
        }

        public void OnPlayerJoined(PlayerInfo player)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { "OnPlayerJoined", new object[] { player } });
        }

        public void OnPlayerLeft(PlayerInfo player)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { "OnPlayerLeft", new object[] { player } });
        }

        public void OnServerMessage(string message, MessageType messageType)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { "OnServerMessage", new object[] { message, messageType } });
        }

        public void OnPlayerUnitySyncReceived(UnitySyncData syncData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { "OnPlayerUnitySyncReceived", new object[] { syncData } });
        }

    }
}

```

`Shared\Generated\PlayerClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class PlayerClientServiceClientCallProxy : DuckyNet.Shared.Services.IPlayerClientService
    {
        private readonly IClientContext _client;
        public PlayerClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnChatMessage(PlayerInfo sender, string message) => _client.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnChatMessage", sender, message);

        public void OnPlayerJoined(PlayerInfo player) => _client.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnPlayerJoined", player);

        public void OnPlayerLeft(PlayerInfo player) => _client.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnPlayerLeft", player);

        public void OnServerMessage(string message, MessageType messageType) => _client.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnServerMessage", message, messageType);

        public void OnPlayerUnitySyncReceived(UnitySyncData syncData) => _client.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnPlayerUnitySyncReceived", syncData);

    }
}

```

`Shared\Generated\PlayerClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class PlayerClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public PlayerClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnChatMessage(PlayerInfo sender, string message) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnChatMessage", sender, message);
        public void OnPlayerJoined(PlayerInfo player) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnPlayerJoined", player);
        public void OnPlayerLeft(PlayerInfo player) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnPlayerLeft", player);
        public void OnServerMessage(string message, MessageType messageType) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnServerMessage", message, messageType);
        public void OnPlayerUnitySyncReceived(UnitySyncData syncData) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerClientService>("OnPlayerUnitySyncReceived", syncData);
    }
}

```

`Shared\Generated\PlayerClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class PlayerClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IPlayerClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public PlayerClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnChatMessage(PlayerInfo sender, string message)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnChatMessage", new object[] { sender, message } });
        }

        public void OnPlayerJoined(PlayerInfo player)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerJoined", new object[] { player } });
        }

        public void OnPlayerLeft(PlayerInfo player)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerLeft", new object[] { player } });
        }

        public void OnServerMessage(string message, MessageType messageType)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnServerMessage", new object[] { message, messageType } });
        }

        public void OnPlayerUnitySyncReceived(UnitySyncData syncData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerUnitySyncReceived", new object[] { syncData } });
        }

    }
}

```

`Shared\Generated\PlayerClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class PlayerClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IPlayerClientService _impl;
        public PlayerClientServiceServerDispatcher(DuckyNet.Shared.Services.IPlayerClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnChatMessage": _impl.OnChatMessage((PlayerInfo)args[0], (string)args[1]); return null;
                case "OnPlayerJoined": _impl.OnPlayerJoined((PlayerInfo)args[0]); return null;
                case "OnPlayerLeft": _impl.OnPlayerLeft((PlayerInfo)args[0]); return null;
                case "OnServerMessage": _impl.OnServerMessage((string)args[0], (MessageType)args[1]); return null;
                case "OnPlayerUnitySyncReceived": _impl.OnPlayerUnitySyncReceived((UnitySyncData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\PlayerClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class PlayerClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IPlayerClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public PlayerClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnChatMessage(PlayerInfo sender, string message)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _predicate, "OnChatMessage", new object[] { sender, message } });
        }

        public void OnPlayerJoined(PlayerInfo player)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerJoined", new object[] { player } });
        }

        public void OnPlayerLeft(PlayerInfo player)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerLeft", new object[] { player } });
        }

        public void OnServerMessage(string message, MessageType messageType)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _predicate, "OnServerMessage", new object[] { message, messageType } });
        }

        public void OnPlayerUnitySyncReceived(UnitySyncData syncData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IPlayerClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerUnitySyncReceived", new object[] { syncData } });
        }

    }
}

```

`Shared\Generated\PlayerServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class PlayerServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public PlayerServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<LoginResult> LoginAsync(PlayerInfo playerInfo) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IPlayerService, LoginResult>("LoginAsync", playerInfo);
        public void Logout() => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerService>("Logout");
        public void SendChatMessage(string message) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerService>("SendChatMessage", message);
        public Task<PlayerInfo[]> GetAllOnlinePlayersAsync() => _ctx.InvokeAsync<DuckyNet.Shared.Services.IPlayerService, PlayerInfo[]>("GetAllOnlinePlayersAsync");
        public Task<PlayerInfo[]> GetCurrentRoomPlayersAsync() => _ctx.InvokeAsync<DuckyNet.Shared.Services.IPlayerService, PlayerInfo[]>("GetCurrentRoomPlayersAsync");
    }
}

```

`Shared\Generated\PlayerServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    public class PlayerServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IPlayerService _impl;
        public PlayerServiceServerDispatcher(DuckyNet.Shared.Services.IPlayerService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "LoginAsync": return _impl.LoginAsync(ctx, (PlayerInfo)args[0]);
                case "Logout": _impl.Logout(ctx); return null;
                case "SendChatMessage": _impl.SendChatMessage(ctx, (string)args[0]); return null;
                case "GetAllOnlinePlayersAsync": return _impl.GetAllOnlinePlayersAsync(ctx);
                case "GetCurrentRoomPlayersAsync": return _impl.GetCurrentRoomPlayersAsync(ctx);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\PlayerUnitySyncServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class PlayerUnitySyncServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public PlayerUnitySyncServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void SendPlayerUnitySync(UnitySyncData syncData) => _ctx.Invoke<DuckyNet.Shared.Services.IPlayerUnitySyncService>("SendPlayerUnitySync", syncData);
    }
}

```

`Shared\Generated\PlayerUnitySyncServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class PlayerUnitySyncServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IPlayerUnitySyncService _impl;
        public PlayerUnitySyncServiceServerDispatcher(DuckyNet.Shared.Services.IPlayerUnitySyncService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "SendPlayerUnitySync": _impl.SendPlayerUnitySync(ctx, (UnitySyncData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\RoomClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class RoomClientServiceBroadcastProxy : DuckyNet.Shared.Services.IRoomClientService
    {
        private readonly object _server;
        public RoomClientServiceBroadcastProxy(object server) => _server = server;

        public void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { "OnPlayerJoinedRoom", new object[] { player, room } });
        }

        public void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { "OnPlayerLeftRoom", new object[] { player, room } });
        }

        public void OnKickedFromRoom(string reason)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { "OnKickedFromRoom", new object[] { reason } });
        }

    }
}

```

`Shared\Generated\RoomClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class RoomClientServiceClientCallProxy : DuckyNet.Shared.Services.IRoomClientService
    {
        private readonly IClientContext _client;
        public RoomClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room) => _client.Invoke<DuckyNet.Shared.Services.IRoomClientService>("OnPlayerJoinedRoom", player, room);

        public void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room) => _client.Invoke<DuckyNet.Shared.Services.IRoomClientService>("OnPlayerLeftRoom", player, room);

        public void OnKickedFromRoom(string reason) => _client.Invoke<DuckyNet.Shared.Services.IRoomClientService>("OnKickedFromRoom", reason);

    }
}

```

`Shared\Generated\RoomClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class RoomClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public RoomClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room) => _ctx.Invoke<DuckyNet.Shared.Services.IRoomClientService>("OnPlayerJoinedRoom", player, room);
        public void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room) => _ctx.Invoke<DuckyNet.Shared.Services.IRoomClientService>("OnPlayerLeftRoom", player, room);
        public void OnKickedFromRoom(string reason) => _ctx.Invoke<DuckyNet.Shared.Services.IRoomClientService>("OnKickedFromRoom", reason);
    }
}

```

`Shared\Generated\RoomClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class RoomClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IRoomClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public RoomClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerJoinedRoom", new object[] { player, room } });
        }

        public void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerLeftRoom", new object[] { player, room } });
        }

        public void OnKickedFromRoom(string reason)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnKickedFromRoom", new object[] { reason } });
        }

    }
}

```

`Shared\Generated\RoomClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    public class RoomClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IRoomClientService _impl;
        public RoomClientServiceServerDispatcher(DuckyNet.Shared.Services.IRoomClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnPlayerJoinedRoom": _impl.OnPlayerJoinedRoom((PlayerInfo)args[0], (RoomInfo)args[1]); return null;
                case "OnPlayerLeftRoom": _impl.OnPlayerLeftRoom((PlayerInfo)args[0], (RoomInfo)args[1]); return null;
                case "OnKickedFromRoom": _impl.OnKickedFromRoom((string)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\RoomClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class RoomClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IRoomClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public RoomClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerJoinedRoom", new object[] { player, room } });
        }

        public void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerLeftRoom", new object[] { player, room } });
        }

        public void OnKickedFromRoom(string reason)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IRoomClientService));
            method.Invoke(_server, new object[] { _predicate, "OnKickedFromRoom", new object[] { reason } });
        }

    }
}

```

`Shared\Generated\RoomServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class RoomServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public RoomServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<RoomInfo[]> GetRoomListAsync() => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, RoomInfo[]>("GetRoomListAsync");
        public Task<RoomOperationResult> CreateRoomAsync(CreateRoomRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, RoomOperationResult>("CreateRoomAsync", request);
        public Task<RoomOperationResult> JoinRoomAsync(JoinRoomRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, RoomOperationResult>("JoinRoomAsync", request);
        public Task<bool> LeaveRoomAsync() => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, bool>("LeaveRoomAsync");
        public Task<RoomInfo> GetCurrentRoomAsync() => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, RoomInfo>("GetCurrentRoomAsync");
        public Task<RoomInfo> GetRoomInfoAsync(string roomId) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, RoomInfo>("GetRoomInfoAsync", roomId);
        public Task<PlayerInfo[]> GetRoomPlayersAsync(string roomId) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, PlayerInfo[]>("GetRoomPlayersAsync", roomId);
        public Task<bool> KickPlayerAsync(string SteamId) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IRoomService, bool>("KickPlayerAsync", SteamId);
    }
}

```

`Shared\Generated\RoomServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
namespace DuckyNet.Shared.Services.Generated
{
    public class RoomServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IRoomService _impl;
        public RoomServiceServerDispatcher(DuckyNet.Shared.Services.IRoomService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "GetRoomListAsync": return _impl.GetRoomListAsync(ctx);
                case "CreateRoomAsync": return _impl.CreateRoomAsync(ctx, (CreateRoomRequest)args[0]);
                case "JoinRoomAsync": return _impl.JoinRoomAsync(ctx, (JoinRoomRequest)args[0]);
                case "LeaveRoomAsync": return _impl.LeaveRoomAsync(ctx);
                case "GetCurrentRoomAsync": return _impl.GetCurrentRoomAsync(ctx);
                case "GetRoomInfoAsync": return _impl.GetRoomInfoAsync(ctx, (string)args[0]);
                case "GetRoomPlayersAsync": return _impl.GetRoomPlayersAsync(ctx, (string)args[0]);
                case "KickPlayerAsync": return _impl.KickPlayerAsync(ctx, (string)args[0]);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\RpcTypeRegistry.cs`:

```cs
// è‡ªåŠ¨ç”Ÿæˆçš„ç±»å‹æ³¨å†Œä»£ç 
// ç”± RpcCodeGen å·¥å…·è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹

using System;
using System.Collections.Generic;

namespace DuckyNet.Shared.RPC.Generated
{
    /// <summary>
    /// è‡ªåŠ¨ç”Ÿæˆçš„ RPC åºåˆ—åŒ–ç±»å‹æ³¨å†Œè¡¨
    /// </summary>
    public static class RpcTypeRegistry
    {
        /// <summary>
        /// è·å–æ‰€æœ‰éœ€è¦åºåˆ—åŒ–çš„ç±»å‹
        /// </summary>
        public static List<Type> GetSerializableTypes()
        {
            return new List<Type>
            {
                // åŸºç¡€ç±»å‹
                typeof(string),
                typeof(int),
                typeof(long),
                typeof(float),
                typeof(double),
                typeof(bool),
                typeof(byte[]),
                typeof(object[]),
                typeof(DateTime),

                // RPC æ¶ˆæ¯ç±»å‹
                typeof(DuckyNet.Shared.RPC.RpcMessage),
                typeof(DuckyNet.Shared.RPC.RpcResponse),

                // åº”ç”¨æ•°æ®ç±»å‹ (è‡ªåŠ¨å‘ç°)
                typeof(DuckyNet.Shared.Data.AllPlayersEquipmentData),
                typeof(DuckyNet.Shared.Data.AllPlayersWeaponData),
                typeof(DuckyNet.Shared.Data.AnimatorSyncData),
                typeof(DuckyNet.Shared.Data.CharacterAppearanceData),
                typeof(DuckyNet.Shared.Data.EquipmentSlotUpdateNotification),
                typeof(DuckyNet.Shared.Data.EquipmentSlotUpdateRequest),
                typeof(DuckyNet.Shared.Data.HealthSyncData),
                typeof(DuckyNet.Shared.Data.ItemDropData),
                typeof(DuckyNet.Shared.Data.ItemPickupRequest),
                typeof(DuckyNet.Shared.Data.NpcBatchTransformData),
                typeof(DuckyNet.Shared.Data.NpcDestroyData),
                typeof(DuckyNet.Shared.Data.NpcSpawnData),
                typeof(DuckyNet.Shared.Data.NpcSpawnData[]),
                typeof(DuckyNet.Shared.Data.NpcTransformData),
                typeof(DuckyNet.Shared.Data.ScenelData),
                typeof(DuckyNet.Shared.Data.UnitySyncData),
                typeof(DuckyNet.Shared.Data.WeaponFireBatchData),
                typeof(DuckyNet.Shared.Data.WeaponFireData),
                typeof(DuckyNet.Shared.Data.WeaponSlotUnequipRequest),
                typeof(DuckyNet.Shared.Data.WeaponSlotUpdateNotification),
                typeof(DuckyNet.Shared.Data.WeaponSlotUpdateRequest),
                typeof(DuckyNet.Shared.Data.WeaponSwitchNotification),
                typeof(DuckyNet.Shared.Data.WeaponSwitchRequest),
                typeof(DuckyNet.Shared.Services.CreateRoomRequest),
                typeof(DuckyNet.Shared.Services.JoinRoomRequest),
                typeof(DuckyNet.Shared.Services.LoginResult),
                typeof(DuckyNet.Shared.Services.MessageType),
                typeof(DuckyNet.Shared.Services.PlayerInfo),
                typeof(DuckyNet.Shared.Services.PlayerInfo[]),
                typeof(DuckyNet.Shared.Services.RoomInfo),
                typeof(DuckyNet.Shared.Services.RoomInfo[]),
                typeof(DuckyNet.Shared.Services.RoomOperationResult),
                typeof(System.Byte[]),
            };
        }
    }
}

```

`Shared\Generated\SceneClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class SceneClientServiceBroadcastProxy : DuckyNet.Shared.Services.ISceneClientService
    {
        private readonly object _server;
        public SceneClientServiceBroadcastProxy(object server) => _server = server;

        public void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ISceneClientService));
            method.Invoke(_server, new object[] { "OnPlayerEnteredScene", new object[] { playerInfo, scenelData } });
        }

        public void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ISceneClientService));
            method.Invoke(_server, new object[] { "OnPlayerLeftScene", new object[] { playerInfo, scenelData } });
        }

    }
}

```

`Shared\Generated\SceneClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class SceneClientServiceClientCallProxy : DuckyNet.Shared.Services.ISceneClientService
    {
        private readonly IClientContext _client;
        public SceneClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData) => _client.Invoke<DuckyNet.Shared.Services.ISceneClientService>("OnPlayerEnteredScene", playerInfo, scenelData);

        public void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData) => _client.Invoke<DuckyNet.Shared.Services.ISceneClientService>("OnPlayerLeftScene", playerInfo, scenelData);

    }
}

```

`Shared\Generated\SceneClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class SceneClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public SceneClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData) => _ctx.Invoke<DuckyNet.Shared.Services.ISceneClientService>("OnPlayerEnteredScene", playerInfo, scenelData);
        public void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData) => _ctx.Invoke<DuckyNet.Shared.Services.ISceneClientService>("OnPlayerLeftScene", playerInfo, scenelData);
    }
}

```

`Shared\Generated\SceneClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class SceneClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.ISceneClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public SceneClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ISceneClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerEnteredScene", new object[] { playerInfo, scenelData } });
        }

        public void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ISceneClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnPlayerLeftScene", new object[] { playerInfo, scenelData } });
        }

    }
}

```

`Shared\Generated\SceneClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class SceneClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.ISceneClientService _impl;
        public SceneClientServiceServerDispatcher(DuckyNet.Shared.Services.ISceneClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnPlayerEnteredScene": _impl.OnPlayerEnteredScene((PlayerInfo)args[0], (ScenelData)args[1]); return null;
                case "OnPlayerLeftScene": _impl.OnPlayerLeftScene((PlayerInfo)args[0], (ScenelData)args[1]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\SceneClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class SceneClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.ISceneClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public SceneClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ISceneClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerEnteredScene", new object[] { playerInfo, scenelData } });
        }

        public void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.ISceneClientService));
            method.Invoke(_server, new object[] { _predicate, "OnPlayerLeftScene", new object[] { playerInfo, scenelData } });
        }

    }
}

```

`Shared\Generated\SceneServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class SceneServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public SceneServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<bool> EnterSceneAsync(ScenelData scenelData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.ISceneService, bool>("EnterSceneAsync", scenelData);
        public Task<bool> LeaveSceneAsync(ScenelData scenelData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.ISceneService, bool>("LeaveSceneAsync", scenelData);
        public Task<PlayerInfo[]> GetScenePlayersAsync(ScenelData scenelData) => _ctx.InvokeAsync<DuckyNet.Shared.Services.ISceneService, PlayerInfo[]>("GetScenePlayersAsync", scenelData);
    }
}

```

`Shared\Generated\SceneServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class SceneServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.ISceneService _impl;
        public SceneServiceServerDispatcher(DuckyNet.Shared.Services.ISceneService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "EnterSceneAsync": return _impl.EnterSceneAsync(ctx, (ScenelData)args[0]);
                case "LeaveSceneAsync": return _impl.LeaveSceneAsync(ctx, (ScenelData)args[0]);
                case "GetScenePlayersAsync": return _impl.GetScenePlayersAsync(ctx, (ScenelData)args[0]);
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\WeaponSyncClientServiceBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class WeaponSyncClientServiceBroadcastProxy : DuckyNet.Shared.Services.IWeaponSyncClientService
    {
        private readonly object _server;
        public WeaponSyncClientServiceBroadcastProxy(object server) => _server = server;

        public void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { "OnWeaponSlotUpdated", new object[] { notification } });
        }

        public void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { "OnAllPlayersWeaponReceived", new object[] { allWeaponData } });
        }

        public void OnWeaponSwitched(WeaponSwitchNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { "OnWeaponSwitched", new object[] { notification } });
        }

        public void OnWeaponFired(WeaponFireData fireData)
        {
            var method = _server.GetType().GetMethod("BroadcastToAll").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { "OnWeaponFired", new object[] { fireData } });
        }

    }
}

```

`Shared\Generated\WeaponSyncClientServiceClientCallProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯
    /// </summary>
    public class WeaponSyncClientServiceClientCallProxy : DuckyNet.Shared.Services.IWeaponSyncClientService
    {
        private readonly IClientContext _client;
        public WeaponSyncClientServiceClientCallProxy(IClientContext client) => _client = client;

        public void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification) => _client.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnWeaponSlotUpdated", notification);

        public void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData) => _client.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnAllPlayersWeaponReceived", allWeaponData);

        public void OnWeaponSwitched(WeaponSwitchNotification notification) => _client.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnWeaponSwitched", notification);

        public void OnWeaponFired(WeaponFireData fireData) => _client.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnWeaponFired", fireData);

    }
}

```

`Shared\Generated\WeaponSyncClientServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class WeaponSyncClientServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public WeaponSyncClientServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification) => _ctx.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnWeaponSlotUpdated", notification);
        public void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData) => _ctx.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnAllPlayersWeaponReceived", allWeaponData);
        public void OnWeaponSwitched(WeaponSwitchNotification notification) => _ctx.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnWeaponSwitched", notification);
        public void OnWeaponFired(WeaponFireData fireData) => _ctx.Invoke<DuckyNet.Shared.Services.IWeaponSyncClientService>("OnWeaponFired", fireData);
    }
}

```

`Shared\Generated\WeaponSyncClientServiceClientsBroadcastProxy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯
    /// </summary>
    public class WeaponSyncClientServiceClientsBroadcastProxy : DuckyNet.Shared.Services.IWeaponSyncClientService
    {
        private readonly object _server;
        private readonly IEnumerable<string> _clientIds;
        public WeaponSyncClientServiceClientsBroadcastProxy(object server, IEnumerable<string> clientIds)
        {
            _server = server;
            _clientIds = clientIds;
        }

        public void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnWeaponSlotUpdated", new object[] { notification } });
        }

        public void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnAllPlayersWeaponReceived", new object[] { allWeaponData } });
        }

        public void OnWeaponSwitched(WeaponSwitchNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnWeaponSwitched", new object[] { notification } });
        }

        public void OnWeaponFired(WeaponFireData fireData)
        {
            var method = _server.GetType().GetMethod("BroadcastToClients").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _clientIds, "OnWeaponFired", new object[] { fireData } });
        }

    }
}

```

`Shared\Generated\WeaponSyncClientServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class WeaponSyncClientServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IWeaponSyncClientService _impl;
        public WeaponSyncClientServiceServerDispatcher(DuckyNet.Shared.Services.IWeaponSyncClientService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "OnWeaponSlotUpdated": _impl.OnWeaponSlotUpdated((WeaponSlotUpdateNotification)args[0]); return null;
                case "OnAllPlayersWeaponReceived": _impl.OnAllPlayersWeaponReceived((AllPlayersWeaponData)args[0]); return null;
                case "OnWeaponSwitched": _impl.OnWeaponSwitched((WeaponSwitchNotification)args[0]); return null;
                case "OnWeaponFired": _impl.OnWeaponFired((WeaponFireData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\Generated\WeaponSyncClientServiceWhereBroadcastProxy.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰
    /// </summary>
    public class WeaponSyncClientServiceWhereBroadcastProxy : DuckyNet.Shared.Services.IWeaponSyncClientService
    {
        private readonly object _server;
        private readonly Func<string, bool> _predicate;
        public WeaponSyncClientServiceWhereBroadcastProxy(object server, Func<string, bool> predicate)
        {
            _server = server;
            _predicate = predicate;
        }

        public void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnWeaponSlotUpdated", new object[] { notification } });
        }

        public void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnAllPlayersWeaponReceived", new object[] { allWeaponData } });
        }

        public void OnWeaponSwitched(WeaponSwitchNotification notification)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnWeaponSwitched", new object[] { notification } });
        }

        public void OnWeaponFired(WeaponFireData fireData)
        {
            var method = _server.GetType().GetMethod("BroadcastWhere").MakeGenericMethod(typeof(DuckyNet.Shared.Services.IWeaponSyncClientService));
            method.Invoke(_server, new object[] { _predicate, "OnWeaponFired", new object[] { fireData } });
        }

    }
}

```

`Shared\Generated\WeaponSyncServiceClientProxy.cs`:

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    public class WeaponSyncServiceClientProxy
    {
        private readonly IClientContext _ctx;
        public WeaponSyncServiceClientProxy(IClientContext ctx) => _ctx = ctx;

        public Task<bool> EquipWeaponAsync(WeaponSlotUpdateRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IWeaponSyncService, bool>("EquipWeaponAsync", request);
        public Task<bool> UnequipWeaponAsync(WeaponSlotUnequipRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IWeaponSyncService, bool>("UnequipWeaponAsync", request);
        public Task<bool> SwitchWeaponSlotAsync(WeaponSwitchRequest request) => _ctx.InvokeAsync<DuckyNet.Shared.Services.IWeaponSyncService, bool>("SwitchWeaponSlotAsync", request);
        public void NotifyWeaponFire(WeaponFireData fireData) => _ctx.Invoke<DuckyNet.Shared.Services.IWeaponSyncService>("NotifyWeaponFire", fireData);
        public void NotifyWeaponFireBatch(WeaponFireBatchData batchData) => _ctx.Invoke<DuckyNet.Shared.Services.IWeaponSyncService>("NotifyWeaponFireBatch", batchData);
    }
}

```

`Shared\Generated\WeaponSyncServiceServerDispatcher.cs`:

```cs
using System;
using System.Threading.Tasks;
using DuckyNet.Shared.RPC;
using DuckyNet.Shared.Data;
namespace DuckyNet.Shared.Services.Generated
{
    public class WeaponSyncServiceServerDispatcher
    {
        private readonly DuckyNet.Shared.Services.IWeaponSyncService _impl;
        public WeaponSyncServiceServerDispatcher(DuckyNet.Shared.Services.IWeaponSyncService impl) => _impl = impl;

        public object Dispatch(string method, object[] args, IClientContext ctx)
        {
            switch (method)
            {
                case "EquipWeaponAsync": return _impl.EquipWeaponAsync(ctx, (WeaponSlotUpdateRequest)args[0]);
                case "UnequipWeaponAsync": return _impl.UnequipWeaponAsync(ctx, (WeaponSlotUnequipRequest)args[0]);
                case "SwitchWeaponSlotAsync": return _impl.SwitchWeaponSlotAsync(ctx, (WeaponSwitchRequest)args[0]);
                case "NotifyWeaponFire": _impl.NotifyWeaponFire(ctx, (WeaponFireData)args[0]); return null;
                case "NotifyWeaponFireBatch": _impl.NotifyWeaponFireBatch(ctx, (WeaponFireBatchData)args[0]); return null;
                default: throw new Exception("Unknown method");
            }
        }
    }
}

```

`Shared\RPC\ClientLoginState.cs`:

```cs
using System;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// å®¢æˆ·ç«¯ç™»å½•çŠ¶æ€
    /// </summary>
    public enum ClientLoginState
    {
        /// <summary>
        /// æœªç™»å½•ï¼ˆåˆšè¿æ¥ï¼Œç­‰å¾…ç™»å½•ï¼‰
        /// </summary>
        NotLoggedIn,

        /// <summary>
        /// ç™»å½•ä¸­ï¼ˆå·²å‘é€ç™»å½•è¯·æ±‚ï¼Œç­‰å¾…å“åº”ï¼‰
        /// </summary>
        LoggingIn,

        /// <summary>
        /// å·²ç™»å½•ï¼ˆç™»å½•æˆåŠŸï¼Œå¯ä»¥ä½¿ç”¨æ‰€æœ‰åŠŸèƒ½ï¼‰
        /// </summary>
        LoggedIn,

        /// <summary>
        /// ç™»å½•å¤±è´¥
        /// </summary>
        LoginFailed
    }

    /// <summary>
    /// ç™»å½•çŠ¶æ€ç®¡ç†å™¨
    /// </summary>
    public class LoginStateManager
    {
        private ClientLoginState _state = ClientLoginState.NotLoggedIn;
        private readonly object _lock = new object();
        private DateTime _connectionTime;
        private DateTime? _loginRequestTime;

        public ClientLoginState State
        {
            get
            {
                lock (_lock)
                {
                    return _state;
                }
            }
        }

        /// <summary>
        /// æ˜¯å¦å·²ç™»å½•ï¼ˆå¯ä»¥å‘é€å…¶ä»–RPCè¯·æ±‚ï¼‰
        /// </summary>
        public bool IsLoggedIn => State == ClientLoginState.LoggedIn;

        /// <summary>
        /// æ˜¯å¦æ­£åœ¨ç™»å½•
        /// </summary>
        public bool IsLoggingIn => State == ClientLoginState.LoggingIn;

        /// <summary>
        /// æ˜¯å¦éœ€è¦ç™»å½•ï¼ˆè¿æ¥åå°šæœªç™»å½•ï¼‰
        /// </summary>
        public bool NeedsLogin => State == ClientLoginState.NotLoggedIn;

        /// <summary>
        /// è¿æ¥åç»è¿‡çš„æ—¶é—´ï¼ˆç§’ï¼‰
        /// </summary>
        public double SecondsSinceConnection
        {
            get
            {
                lock (_lock)
                {
                    return (DateTime.UtcNow - _connectionTime).TotalSeconds;
                }
            }
        }

        /// <summary>
        /// ç™»å½•çŠ¶æ€å˜åŒ–äº‹ä»¶
        /// </summary>
        public event EventHandler<ClientLoginState>? StateChanged;

        /// <summary>
        /// å½“è¿æ¥å»ºç«‹æ—¶è°ƒç”¨
        /// </summary>
        public void OnConnected()
        {
            lock (_lock)
            {
                _state = ClientLoginState.NotLoggedIn;
                _connectionTime = DateTime.UtcNow;
                _loginRequestTime = null;
            }
            Console.WriteLine("[LoginState] Connected, waiting for login");
        }

        /// <summary>
        /// å½“å¼€å§‹ç™»å½•æ—¶è°ƒç”¨
        /// </summary>
        public void OnLoginStarted()
        {
            lock (_lock)
            {
                if (_state != ClientLoginState.NotLoggedIn)
                {
                    Console.WriteLine($"[LoginState] Login started in wrong state: {_state}");
                }
                _state = ClientLoginState.LoggingIn;
                _loginRequestTime = DateTime.UtcNow;
            }
            Console.WriteLine("[LoginState] Login request sent");
            StateChanged?.Invoke(this, ClientLoginState.LoggingIn);
        }

        /// <summary>
        /// å½“ç™»å½•æˆåŠŸæ—¶è°ƒç”¨
        /// </summary>
        public void OnLoginSucceeded()
        {
            lock (_lock)
            {
                _state = ClientLoginState.LoggedIn;
                if (_loginRequestTime.HasValue)
                {
                    var duration = (DateTime.UtcNow - _loginRequestTime.Value).TotalMilliseconds;
                    Console.WriteLine($"[LoginState] Login succeeded in {duration:F0}ms");
                }
            }
            StateChanged?.Invoke(this, ClientLoginState.LoggedIn);
        }

        /// <summary>
        /// å½“ç™»å½•å¤±è´¥æ—¶è°ƒç”¨
        /// </summary>
        public void OnLoginFailed(string reason)
        {
            lock (_lock)
            {
                _state = ClientLoginState.LoginFailed;
            }
            Console.WriteLine($"[LoginState] Login failed: {reason}");
            StateChanged?.Invoke(this, ClientLoginState.LoginFailed);
        }

        /// <summary>
        /// å½“æ–­å¼€è¿æ¥æ—¶è°ƒç”¨
        /// </summary>
        public void OnDisconnected()
        {
            lock (_lock)
            {
                _state = ClientLoginState.NotLoggedIn;
            }
        }

        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘é€RPCè¯·æ±‚
        /// </summary>
        public bool CanSendRpc()
        {
            return IsLoggedIn;
        }

        /// <summary>
        /// å¦‚æœæœªç™»å½•åˆ™æŠ›å‡ºå¼‚å¸¸
        /// </summary>
        public void EnsureLoggedIn()
        {
            if (!IsLoggedIn)
            {
                throw new InvalidOperationException(
                    $"Cannot send RPC request: not logged in (current state: {State})");
            }
        }
    }
}


```

`Shared\RPC\ConnectionState.cs`:

```cs
using System;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPCè¿æ¥çŠ¶æ€æšä¸¾
    /// </summary>
    public enum RpcConnectionState
    {
        Disconnected,
        Connecting,
        Connected,
        Reconnecting,
        Disconnecting
    }

    /// <summary>
    /// è¿æ¥çŠ¶æ€å˜åŒ–äº‹ä»¶
    /// </summary>
    public class ConnectionStateChangedEventArgs : EventArgs
    {
        public RpcConnectionState OldState { get; }
        public RpcConnectionState NewState { get; }
        public string? Reason { get; }

        public ConnectionStateChangedEventArgs(RpcConnectionState oldState, RpcConnectionState newState, string? reason = null)
        {
            OldState = oldState;
            NewState = newState;
            Reason = reason;
        }
    }

    /// <summary>
    /// è¿æ¥ç®¡ç†å™¨
    /// </summary>
    public class ConnectionManager
    {
        private RpcConnectionState _state = RpcConnectionState.Disconnected;
        private readonly object _lock = new object();

        public RpcConnectionState State
        {
            get
            {
                lock (_lock)
                {
                    return _state;
                }
            }
            private set
            {
                lock (_lock)
                {
                    if (_state != value)
                    {
                        var oldState = _state;
                        _state = value;
                        OnStateChanged(oldState, value);
                    }
                }
            }
        }

        public bool IsConnected => State == RpcConnectionState.Connected;
        public bool CanConnect => State == RpcConnectionState.Disconnected;

        public event EventHandler<ConnectionStateChangedEventArgs>? StateChanged;

        public void SetState(RpcConnectionState newState, string? reason = null)
        {
            var oldState = State;
            State = newState;
            
            if (oldState != newState)
            {
                Console.WriteLine($"Connection state changed: {oldState} -> {newState}" + 
                    (reason != null ? $" ({reason})" : ""));
            }
        }

        private void OnStateChanged(RpcConnectionState oldState, RpcConnectionState newState)
        {
            StateChanged?.Invoke(this, new ConnectionStateChangedEventArgs(oldState, newState));
        }
    }
}


```

`Shared\RPC\IClientContext.cs`:

```cs
using System;
using System.Threading.Tasks;
namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡æ¥å£
    /// åœ¨æœåŠ¡å™¨ç«¯æ–¹æ³•ä¸­ä¼ é€’ï¼Œæ ‡è¯†æ˜¯å“ªä¸ªå®¢æˆ·ç«¯å‘èµ·çš„è¯·æ±‚
    /// </summary>
    public interface IClientContext
    {
        /// <summary>
        /// å®¢æˆ·ç«¯å”¯ä¸€æ ‡è¯†
        /// </summary>
        string ClientId { get; }

        /// <summary>
        /// å®¢æˆ·ç«¯ç½‘ç»œç«¯ç‚¹ä¿¡æ¯
        /// </summary>
        object NetPeer { get; }

        /// <summary>
        /// ä¼šè¯çŠ¶æ€ï¼ˆå¦‚å·²è®¤è¯ã€å·²æ–­å¼€ã€æ´»è·ƒç­‰ï¼‰
        /// </summary>
        ClientSessionState SessionState { get; }

        /// <summary>
        /// æœ€åå¿ƒè·³æ—¶é—´
        /// </summary>
        DateTime LastHeartbeat { get; }

        /// <summary>
        /// æ˜¯å¦å·²æ–­çº¿
        /// </summary>
        bool IsDisconnected { get; }

        /// <summary>
        /// æ–­çº¿é‡è¿æ¬¡æ•°
        /// </summary>
        int ReconnectCount { get; }

        /// <summary>
        /// å‘è¯¥å®¢æˆ·ç«¯å‘é€RPCè°ƒç”¨
        /// </summary>
        void Invoke<TService>(string methodName, params object[] parameters) where TService : class;

        /// <summary>
        /// å‘è¯¥å®¢æˆ·ç«¯å‘é€RPCè°ƒç”¨ï¼ˆå¼‚æ­¥ï¼‰
        /// </summary>
        Task<TResult> InvokeAsync<TService, TResult>(string methodName, params object[] parameters) where TService : class;
    }

    /// <summary>
    /// å®¢æˆ·ç«¯ä¼šè¯çŠ¶æ€
    /// </summary>
    public enum ClientSessionState
    {
        Unknown,
        Connected,
        Authenticated,
        Disconnected,
        Reconnecting
    }
}

```

`Shared\RPC\IClientContextExtensions.cs`:

```cs
using System;
using System.Collections.Concurrent;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// IClientContext æ‰©å±•æ–¹æ³• - æä¾›å¼ºç±»å‹çš„å®¢æˆ·ç«¯è°ƒç”¨
    /// </summary>
    public static class IClientContextExtensions
    {
        private static readonly ConcurrentDictionary<string, object> _clientProxyCache = new ConcurrentDictionary<string, object>();

        /// <summary>
        /// è·å–å¼ºç±»å‹çš„å®¢æˆ·ç«¯è°ƒç”¨ä»£ç†
        /// </summary>
        /// <typeparam name="TService">æœåŠ¡æ¥å£ç±»å‹</typeparam>
        /// <param name="context">å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡</param>
        /// <returns>å®¢æˆ·ç«¯è°ƒç”¨ä»£ç†å®ä¾‹</returns>
        public static TService Call<TService>(this IClientContext context) where TService : class
        {
            var serviceType = typeof(TService);
            var cacheKey = $"{context.ClientId}_{serviceType.FullName}";
            
            return (TService)_clientProxyCache.GetOrAdd(cacheKey, key =>
            {
                // æ ¹æ®æ¥å£ç±»å‹åˆ›å»ºå¯¹åº”çš„å®¢æˆ·ç«¯è°ƒç”¨ä»£ç†
                // ç§»é™¤æ¥å£åå¼€å¤´çš„ 'I' (åªç§»é™¤ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œé¿å… IItemSync å˜æˆ temSync)
                string serviceName = serviceType.Name.StartsWith("I") && serviceType.Name.Length > 1
                    ? serviceType.Name.Substring(1)  // IItemSyncClientService -> ItemSyncClientService âœ…
                    : serviceType.Name;
                
                var proxyTypeName = $"{serviceType.Namespace}.Generated.{serviceName}ClientCallProxy";
                var proxyType = serviceType.Assembly.GetType(proxyTypeName);
                
                if (proxyType == null)
                {
                    throw new InvalidOperationException(
                        $"æ‰¾ä¸åˆ°å®¢æˆ·ç«¯è°ƒç”¨ä»£ç†ç±»å‹: {proxyTypeName}ã€‚è¯·ç¡®ä¿è¿è¡Œäº†ä»£ç ç”Ÿæˆå™¨ã€‚");
                }
                
                return Activator.CreateInstance(proxyType, context)!;
            });
        }
    }
}


```

`Shared\RPC\RpcAttributes.cs`:

```cs
using System;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// æ ‡è®°RPCæœåŠ¡æ¥å£
    /// </summary>
    [AttributeUsage(AttributeTargets.Interface)]
    public class RpcServiceAttribute : Attribute
    {
        public string ServiceName { get; }

        public RpcServiceAttribute(string serviceName)
        {
            ServiceName = serviceName;
        }
    }

    /// <summary>
    /// æ ‡è®°RPCæ–¹æ³•
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class RpcMethodAttribute : Attribute
    {
        public string? MethodName { get; set; }
    }

    /// <summary>
    /// æ ‡è®°å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨çš„RPCæ–¹æ³•
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class ClientToServerAttribute : RpcMethodAttribute
    {
    }

    /// <summary>
    /// æ ‡è®°æœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯çš„RPCæ–¹æ³•
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class ServerToClientAttribute : RpcMethodAttribute
    {
    }
}

```

`Shared\RPC\RpcConfig.cs`:

```cs
namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC é…ç½®
    /// </summary>
    public class RpcConfig
    {
        /// <summary>
        /// é»˜è®¤RPCè°ƒç”¨è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        /// </summary>
        public int DefaultTimeoutMs { get; set; } = 30000;

        /// <summary>
        /// å¿ƒè·³é—´éš”ï¼ˆæ¯«ç§’ï¼‰
        /// </summary>
        public int HeartbeatIntervalMs { get; set; } = 5000;

        /// <summary>
        /// æœ€å¤§é‡è¿æ¬¡æ•°
        /// </summary>
        public int MaxReconnectAttempts { get; set; } = 5;

        /// <summary>
        /// é‡è¿å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
        /// </summary>
        public int ReconnectDelayMs { get; set; } = 2000;

        /// <summary>
        /// æœ€å¤§å¹¶å‘RPCè°ƒç”¨æ•°
        /// </summary>
        public int MaxConcurrentCalls { get; set; } = 100;

        /// <summary>
        /// æ˜¯å¦å¯ç”¨è¯¦ç»†æ—¥å¿—
        /// </summary>
        public bool EnableVerboseLogging { get; set; } = false;

        /// <summary>
        /// æœ€å¤§å®¢æˆ·ç«¯è¿æ¥æ•°ï¼ˆæœåŠ¡å™¨ï¼‰
        /// </summary>
        public int MaxClients { get; set; } = 100;

        /// <summary>
        /// é»˜è®¤é…ç½®
        /// </summary>
        public static RpcConfig Default => new RpcConfig();

        /// <summary>
        /// å¼€å‘æ¨¡å¼é…ç½®ï¼ˆæ›´å¤šæ—¥å¿—ï¼‰
        /// </summary>
        public static RpcConfig Development => new RpcConfig
        {
            EnableVerboseLogging = true,
            DefaultTimeoutMs = 60000
        };

        /// <summary>
        /// ç”Ÿäº§æ¨¡å¼é…ç½®ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼‰
        /// </summary>
        public static RpcConfig Production => new RpcConfig
        {
            EnableVerboseLogging = false,
            DefaultTimeoutMs = 15000
        };
    }
}


```

`Shared\RPC\RpcInvoker.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC æ–¹æ³•è°ƒç”¨å™¨
    /// è´Ÿè´£é€šè¿‡å¼ºç±»å‹å§”æ‰˜è°ƒç”¨æ³¨å†Œçš„æœåŠ¡æ–¹æ³•
    /// </summary>
    public class RpcInvoker
    {
        private readonly Dictionary<string, ServiceInfo> _services = new Dictionary<string, ServiceInfo>();

        // å®šä¹‰ç»Ÿä¸€çš„å§”æ‰˜ç±»å‹
        private delegate object? RpcMethodDelegate(object instance, object?[]? parameters, IClientContext? clientContext);

        private class ServiceInfo
        {
            public object Instance { get; set; } = null!;
            public Dictionary<string, RpcMethodDelegate> Methods { get; set; } = new Dictionary<string, RpcMethodDelegate>();
        }

        /// <summary>
        /// æ³¨å†ŒæœåŠ¡
        /// </summary>
        public void RegisterService<TService>(object serviceInstance) where TService : class
        {
            var serviceType = typeof(TService);
            var serviceName = GetServiceName(serviceType);

            var serviceInfo = new ServiceInfo
            {
                Instance = serviceInstance
            };

            // æŸ¥æ‰¾æ‰€æœ‰æ ‡è®°äº† RpcMethod çš„æ–¹æ³•ï¼ˆåŒ…æ‹¬æ´¾ç”Ÿç‰¹æ€§ï¼‰
            var methods = serviceType.GetMethods();
            foreach (var method in methods)
            {
                // inherit: true ç¡®ä¿èƒ½æ‰¾åˆ° ClientToServerAttribute å’Œ ServerToClientAttribute
                var rpcAttr = method.GetCustomAttribute<RpcMethodAttribute>(inherit: true);
                if (rpcAttr != null)
                {
                    var methodName = string.IsNullOrEmpty(rpcAttr.MethodName) ? method.Name : rpcAttr.MethodName;
                    serviceInfo.Methods[methodName] = CreateDelegate(method);
                }
            }

            _services[serviceName] = serviceInfo;
        }

        /// <summary>
        /// åˆ›å»ºå¼ºç±»å‹å§”æ‰˜
        /// </summary>
        private RpcMethodDelegate CreateDelegate(MethodInfo method)
        {
            var parameters = method.GetParameters();
            bool hasClientContext = parameters.Length > 0 && parameters[0].ParameterType == typeof(IClientContext);

            return (instance, args, clientContext) =>
            {
                object?[] invokeParams;

                if (hasClientContext)
                {
                    invokeParams = new object?[parameters.Length];
                    invokeParams[0] = clientContext;
                    if (args != null)
                    {
                        // è½¬æ¢å‚æ•°ç±»å‹ä»¥åŒ¹é…æ–¹æ³•ç­¾å
                        for (int i = 0; i < Math.Min(args.Length, parameters.Length - 1); i++)
                        {
                            var paramIndex = i + 1; // +1 å› ä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ clientContext
                            var paramType = parameters[paramIndex].ParameterType;
                            invokeParams[paramIndex] = ConvertParameter(args[i], paramType);
                        }
                    }
                }
                else
                {
                    invokeParams = new object?[parameters.Length];
                    if (args != null)
                    {
                        // è½¬æ¢å‚æ•°ç±»å‹ä»¥åŒ¹é…æ–¹æ³•ç­¾å
                        for (int i = 0; i < Math.Min(args.Length, parameters.Length); i++)
                        {
                            var paramType = parameters[i].ParameterType;
                            invokeParams[i] = ConvertParameter(args[i], paramType);
                        }
                    }
                }

                return method.Invoke(instance, invokeParams);
            };
        }

        /// <summary>
        /// è½¬æ¢å‚æ•°ç±»å‹
        /// </summary>
        private object? ConvertParameter(object? value, Type targetType)
        {
            if (value == null)
                return null;

            var sourceType = value.GetType();

            // å¦‚æœå·²ç»æ˜¯æ­£ç¡®ç±»å‹ï¼Œç›´æ¥è¿”å›
            if (targetType.IsInstanceOfType(value))
                return value;

            // å¯¹äºæ•°ç»„ç±»å‹ï¼Œæ£€æŸ¥å…ƒç´ ç±»å‹æ˜¯å¦åŒ¹é…
            if (targetType.IsArray && sourceType.IsArray)
            {
                var targetElementType = targetType.GetElementType();
                var sourceElementType = sourceType.GetElementType();
                
                if (targetElementType != null)
                {
                    // æƒ…å†µ1: å¦‚æœæºæ•°ç»„å…ƒç´ ç±»å‹å°±æ˜¯ç›®æ ‡å…ƒç´ ç±»å‹ï¼Œç›´æ¥è¿”å›
                    if (sourceElementType != null && 
                        (targetElementType.IsAssignableFrom(sourceElementType) || 
                         targetElementType.FullName == sourceElementType.FullName))
                    {
                        return value; // å¯ä»¥å®‰å…¨è½¬æ¢
                    }
                    
                    // æƒ…å†µ2: å¦‚æœæºæ•°ç»„æ˜¯ object[]ï¼ˆååºåˆ—åŒ–åçš„å¸¸è§æƒ…å†µï¼‰ï¼Œéœ€è¦æ‰‹åŠ¨è½¬æ¢
                    if (sourceType == typeof(object[]))
                    {
                        try
                        {
                            var sourceArray = (Array)value;
                            var targetArray = Array.CreateInstance(targetElementType, sourceArray.Length);
                            
                            for (int i = 0; i < sourceArray.Length; i++)
                            {
                                var element = sourceArray.GetValue(i);
                                if (element != null)
                                {
                                    // å¦‚æœå…ƒç´ å·²ç»æ˜¯ç›®æ ‡ç±»å‹ï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦åˆ™å°è¯•è½¬æ¢
                                    if (targetElementType.IsInstanceOfType(element))
                                    {
                                        targetArray.SetValue(element, i);
                                    }
                                    else
                                    {
                                        // å°è¯•ç±»å‹è½¬æ¢ï¼ˆé€’å½’è°ƒç”¨ï¼Œä½†é¿å…æ•°ç»„ç±»å‹çš„æ— é™é€’å½’ï¼‰
                                        // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬åªè½¬æ¢å•ä¸ªå…ƒç´ ï¼Œä¸ä¼šå†æ¬¡è¿›å…¥æ•°ç»„è½¬æ¢åˆ†æ”¯
                                        object? convertedElement = element;
                                        var elementType = element.GetType();
                                        
                                        // å¦‚æœæ˜¯å¯ä»¥ç›´æ¥èµ‹å€¼çš„æƒ…å†µ
                                        if (targetElementType.IsAssignableFrom(elementType))
                                        {
                                            convertedElement = element;
                                        }
                                        // å¦‚æœæ˜¯å®Œå…¨é™å®šååŒ¹é…ï¼ˆä¸åŒç¨‹åºé›†ä¸­çš„ç›¸åŒç±»å‹ï¼‰
                                        else if (targetElementType.FullName == elementType.FullName)
                                        {
                                            convertedElement = element;
                                        }
                                        // å°è¯•å¼ºåˆ¶è½¬æ¢ï¼ˆç”¨äºåŒ…è£…ç±»å‹ç­‰æƒ…å†µï¼‰
                                        else
                                        {
                                            try
                                            {
                                                convertedElement = System.Convert.ChangeType(element, targetElementType);
                                            }
                                            catch
                                            {
                                                // è½¬æ¢å¤±è´¥ï¼Œæœ€åå°è¯•ç›´æ¥èµ‹å€¼ï¼ˆå¯èƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ï¼‰
                                                convertedElement = element;
                                            }
                                        }
                                        
                                        // å°è¯•è®¾ç½®å€¼ï¼Œå¦‚æœç±»å‹ä¸åŒ¹é…ä¼šæŠ›å‡ºå¼‚å¸¸
                                        try
                                        {
                                            targetArray.SetValue(convertedElement, i);
                                        }
                                        catch (Exception setEx)
                                        {
                                            throw new InvalidCastException(
                                                $"Cannot set element at index {i}. Source type: {element?.GetType().FullName ?? "null"}, " +
                                                $"Target type: {targetElementType.FullName}, Converted type: {convertedElement?.GetType().FullName ?? "null"}. " +
                                                $"Error: {setEx.Message}", setEx);
                                        }
                                    }
                                }
                                else
                                {
                                    targetArray.SetValue(null, i);
                                }
                            }
                            
                            return targetArray;
                        }
                        catch (Exception ex)
                        {
                            throw new InvalidCastException(
                                $"Failed to convert object[] to {targetType.FullName}. Error: {ex.Message}");
                        }
                    }
                }
            }

            // å°è¯•ä½¿ç”¨ Convert.ChangeTypeï¼ˆä¸»è¦ç”¨äºå€¼ç±»å‹ï¼‰
            if (targetType.IsValueType || targetType == typeof(string))
            {
                try
                {
                    return System.Convert.ChangeType(value, targetType);
                }
                catch
                {
                    // è½¬æ¢å¤±è´¥ï¼Œç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
                }
            }

            // å¯¹äºå¼•ç”¨ç±»å‹ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ç›´æ¥èµ‹å€¼ï¼ˆç»§æ‰¿å…³ç³»ï¼‰
            if (!targetType.IsValueType && value != null)
            {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç»§æ‰¿å…³ç³»
                if (targetType.IsAssignableFrom(sourceType))
                {
                    return value;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯æ¥å£å®ç°
                if (targetType.IsInterface)
                {
                    var interfaces = sourceType.GetInterfaces();
                    if (interfaces.Any(i => i == targetType || i.IsAssignableFrom(targetType)))
                    {
                        return value;
                    }
                }

                // æ£€æŸ¥å®Œå…¨é™å®šåæ˜¯å¦åŒ¹é…ï¼ˆå¯èƒ½æ˜¯ä¸åŒç¨‹åºé›†ä¸­çš„ç›¸åŒç±»å‹ï¼‰
                if (targetType.FullName == sourceType.FullName)
                {
                    return value;
                }

                // æœ€åå°è¯•ç›´æ¥è¿”å›å¹¶æ•è·å¼‚å¸¸
                try
                {
                    return value;
                }
                catch (Exception ex)
                {
                    throw new InvalidCastException($"Cannot convert {sourceType.FullName} ({sourceType.Assembly.FullName}) to {targetType.FullName} ({targetType.Assembly.FullName}). Error: {ex.Message}");
                }
            }

            throw new InvalidCastException($"Cannot convert {sourceType.FullName ?? "null"} to {targetType.FullName}");
        }

        /// <summary>
        /// è°ƒç”¨æœåŠ¡æ–¹æ³•
        /// </summary>
        public object? Invoke(string serviceName, string methodName, object?[]? parameters, IClientContext? clientContext = null)
        {
            if (!_services.TryGetValue(serviceName, out var serviceInfo))
            {
                throw new Exception($"Service '{serviceName}' not found");
            }

            if (!serviceInfo.Methods.TryGetValue(methodName, out var methodDelegate))
            {
                throw new Exception($"Method '{methodName}' not found in service '{serviceName}'");
            }

            try
            {
                return methodDelegate(serviceInfo.Instance, parameters, clientContext);
            }
            catch (TargetInvocationException ex)
            {
                // é‡æ–°æŠ›å‡ºå†…éƒ¨å¼‚å¸¸ï¼Œä¿ç•™åŸå§‹å †æ ˆè·Ÿè¸ª
                throw ex.InnerException ?? ex;
            }
        }

        /// <summary>
        /// å¼‚æ­¥è°ƒç”¨æœåŠ¡æ–¹æ³•
        /// </summary>
        public async Task<object?> InvokeAsync(string serviceName, string methodName, object?[]? parameters, IClientContext? clientContext = null)
        {
            var result = Invoke(serviceName, methodName, parameters, clientContext);
            
            if (result is Task task)
            {
                await task.ConfigureAwait(false);
                
                // å¦‚æœæ˜¯ Task<T>ï¼Œæå–ç»“æœ
                var taskType = task.GetType();
                if (taskType.IsGenericType)
                {
                    var genericArgs = taskType.GetGenericArguments();
                    if (genericArgs.Length > 0)
                    {
                        var resultProperty = taskType.GetProperty("Result");
                        if (resultProperty != null)
                        {
                            var taskResult = resultProperty.GetValue(task);
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ VoidTaskResultï¼ˆTask çš„å†…éƒ¨ç±»å‹ï¼‰
                            var resultType = taskResult?.GetType();
                            if (resultType != null && resultType.Name == "VoidTaskResult")
                            {
                                // VoidTaskResult ä¸åº”è¯¥è¢«åºåˆ—åŒ–ï¼Œè¿”å› null
                                return null;
                            }
                            
                            // æå– Task<T> çš„ç»“æœ
                            return taskResult;
                        }
                    }
                }
                
                // Task (éæ³›å‹) æˆ– void æ–¹æ³•
                return null;
            }
            
            // éå¼‚æ­¥æ–¹æ³•ï¼Œç›´æ¥è¿”å›ç»“æœ
            return result;
        }

        /// <summary>
        /// è·å–æœåŠ¡åç§°
        /// </summary>
        private string GetServiceName(Type serviceType)
        {
            var attr = serviceType.GetCustomAttribute<RpcServiceAttribute>();
            return attr?.ServiceName ?? serviceType.Name;
        }

        /// <summary>
        /// æ£€æŸ¥æœåŠ¡æ˜¯å¦å·²æ³¨å†Œ
        /// </summary>
        public bool IsServiceRegistered(string serviceName)
        {
            return _services.ContainsKey(serviceName);
        }

        /// <summary>
        /// è·å–å·²æ³¨å†Œçš„æœåŠ¡åˆ—è¡¨
        /// </summary>
        public IEnumerable<string> GetRegisteredServices()
        {
            return _services.Keys;
        }
    }
}

```

`Shared\RPC\RpcLogger.cs`:

```cs
using System;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC æ—¥å¿—æ¥å£
    /// </summary>
    public interface IRpcLogger
    {
        void Log(string message);
        void LogWarning(string message);
        void LogError(string message);
    }

    /// <summary>
    /// æ§åˆ¶å°æ—¥å¿—å®ç°
    /// </summary>
    public class ConsoleRpcLogger : IRpcLogger
    {
        public void Log(string message)
        {
            Console.WriteLine($"[RPC] {message}");
        }

        public void LogWarning(string message)
        {
            Console.WriteLine($"[RPC WARNING] {message}");
        }

        public void LogError(string message)
        {
            Console.WriteLine($"[RPC ERROR] {message}");
        }
    }

    /// <summary>
    /// é™æ€æ—¥å¿—ç®¡ç†å™¨
    /// </summary>
    public static class RpcLog
    {
        private static IRpcLogger _logger = new ConsoleRpcLogger();

        public static void SetLogger(IRpcLogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public static void Info(string message) => _logger.Log(message);
        public static void Warning(string message) => _logger.LogWarning(message);
        public static void Error(string message) => _logger.LogError(message);
    }
}


```

`Shared\RPC\RpcMessage.cs`:

```cs
using System;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC æ¶ˆæ¯ç±»å‹æ ‡è¯†
    /// </summary>
    public enum RpcMessageType : byte
    {
        Request = 0x01,   // è¯·æ±‚æ¶ˆæ¯ (RpcMessage)
        Response = 0x02   // å“åº”æ¶ˆæ¯ (RpcResponse)
    }

    /// <summary>
    /// RPC æ¶ˆæ¯åŸºç±»
    /// </summary>
    [Serializable]
    public class RpcMessage
    {
        /// <summary>
        /// æ¶ˆæ¯IDï¼Œç”¨äºè¯·æ±‚-å“åº”åŒ¹é…
        /// </summary>
        public int MessageId { get; set; }

        /// <summary>
        /// æœåŠ¡åç§°
        /// </summary>
        public string ServiceName { get; set; } = string.Empty;

        /// <summary>
        /// æ–¹æ³•åç§°
        /// </summary>
        public string MethodName { get; set; } = string.Empty;

        /// <summary>
        /// æ–¹æ³•å‚æ•°ï¼ˆåºåˆ—åŒ–åçš„å­—èŠ‚æ•°ç»„ï¼‰
        /// </summary>
        public byte[]? Parameters { get; set; }
    }

    /// <summary>
    /// RPC å“åº”æ¶ˆæ¯
    /// </summary>
    [Serializable]
    public class RpcResponse
    {
        /// <summary>
        /// å¯¹åº”çš„è¯·æ±‚æ¶ˆæ¯ID
        /// </summary>
        public int MessageId { get; set; }

        /// <summary>
        /// æ˜¯å¦æˆåŠŸ
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// è¿”å›å€¼ï¼ˆåºåˆ—åŒ–åçš„å­—èŠ‚æ•°ç»„ï¼‰
        /// </summary>
        public byte[]? Result { get; set; }

        /// <summary>
        /// é”™è¯¯ä¿¡æ¯
        /// </summary>
        public string? ErrorMessage { get; set; }
    }
}

```

`Shared\RPC\RpcPerformanceStats.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC æ€§èƒ½ç»Ÿè®¡
    /// </summary>
    public class RpcPerformanceStats
    {
        private readonly Dictionary<string, ServiceStats> _serviceStats = new Dictionary<string, ServiceStats>();
        private readonly object _lock = new object();

        /// <summary>
        /// è®°å½•æ–¹æ³•è°ƒç”¨
        /// </summary>
        public void RecordCall(string serviceName, string methodName, TimeSpan duration, bool success)
        {
            lock (_lock)
            {
                if (!_serviceStats.TryGetValue(serviceName, out var serviceStats))
                {
                    serviceStats = new ServiceStats(serviceName);
                    _serviceStats[serviceName] = serviceStats;
                }

                serviceStats.RecordCall(methodName, duration, success);
            }
        }

        /// <summary>
        /// è·å–æœåŠ¡ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public ServiceStats? GetServiceStats(string serviceName)
        {
            lock (_lock)
            {
                return _serviceStats.TryGetValue(serviceName, out var stats) ? stats : null;
            }
        }

        /// <summary>
        /// è·å–æ‰€æœ‰æœåŠ¡ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public Dictionary<string, ServiceStats> GetAllStats()
        {
            lock (_lock)
            {
                return new Dictionary<string, ServiceStats>(_serviceStats);
            }
        }

        /// <summary>
        /// æ¸…é™¤ç»Ÿè®¡ä¿¡æ¯
        /// </summary>
        public void ClearStats()
        {
            lock (_lock)
            {
                _serviceStats.Clear();
            }
        }
    }

    /// <summary>
    /// æœåŠ¡ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    public class ServiceStats
    {
        public string ServiceName { get; }
        private readonly Dictionary<string, MethodStats> _methodStats = new Dictionary<string, MethodStats>();

        public ServiceStats(string serviceName)
        {
            ServiceName = serviceName;
        }

        public void RecordCall(string methodName, TimeSpan duration, bool success)
        {
            if (!_methodStats.TryGetValue(methodName, out var methodStats))
            {
                methodStats = new MethodStats(methodName);
                _methodStats[methodName] = methodStats;
            }

            methodStats.RecordCall(duration, success);
        }

        public MethodStats? GetMethodStats(string methodName)
        {
            return _methodStats.TryGetValue(methodName, out var stats) ? stats : null;
        }

        public Dictionary<string, MethodStats> GetAllMethodStats()
        {
            return new Dictionary<string, MethodStats>(_methodStats);
        }
    }

    /// <summary>
    /// æ–¹æ³•ç»Ÿè®¡ä¿¡æ¯
    /// </summary>
    public class MethodStats
    {
        public string MethodName { get; }
        public long TotalCalls { get; private set; }
        public long SuccessfulCalls { get; private set; }
        public long FailedCalls { get; private set; }
        public TimeSpan TotalDuration { get; private set; }
        public TimeSpan MinDuration { get; private set; } = TimeSpan.MaxValue;
        public TimeSpan MaxDuration { get; private set; } = TimeSpan.MinValue;

        public MethodStats(string methodName)
        {
            MethodName = methodName;
        }

        public void RecordCall(TimeSpan duration, bool success)
        {
            TotalCalls++;
            TotalDuration = TotalDuration.Add(duration);

            if (duration < MinDuration)
                MinDuration = duration;
            if (duration > MaxDuration)
                MaxDuration = duration;

            if (success)
                SuccessfulCalls++;
            else
                FailedCalls++;
        }

        public TimeSpan AverageDuration => TotalCalls > 0 ? 
            TimeSpan.FromTicks(TotalDuration.Ticks / TotalCalls) : TimeSpan.Zero;

        public double SuccessRate => TotalCalls > 0 ? 
            (double)SuccessfulCalls / TotalCalls : 0.0;
    }

    /// <summary>
    /// æ€§èƒ½ç›‘æ§è¾…åŠ©ç±»
    /// </summary>
    public class RpcPerformanceMonitor : IDisposable
    {
        private readonly Stopwatch _stopwatch;
        private readonly RpcPerformanceStats _stats;
        private readonly string _serviceName;
        private readonly string _methodName;

        public RpcPerformanceMonitor(RpcPerformanceStats stats, string serviceName, string methodName)
        {
            _stats = stats;
            _serviceName = serviceName;
            _methodName = methodName;
            _stopwatch = Stopwatch.StartNew();
        }

        public void Dispose()
        {
            _stopwatch.Stop();
            _stats.RecordCall(_serviceName, _methodName, _stopwatch.Elapsed, true);
        }

        public void RecordFailure()
        {
            _stopwatch.Stop();
            _stats.RecordCall(_serviceName, _methodName, _stopwatch.Elapsed, false);
        }
    }
}
```

`Shared\RPC\RpcSerializer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using NetSerializer;
using DuckyNet.Shared.Services;
using DuckyNet.Shared.RPC;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC åºåˆ—åŒ–å·¥å…·
    /// å°è£… NetSerializer ç”¨äºå‚æ•°å’Œè¿”å›å€¼çš„åºåˆ—åŒ–
    /// </summary>
    public class RpcSerializer
    {
        private readonly Serializer _serializer;
        private static RpcSerializer? _instance;
        private static readonly object _lock = new object();

        /// <summary>
        /// è·å–å•ä¾‹å®ä¾‹
        /// </summary>
        public static RpcSerializer Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                        {
                            _instance = new RpcSerializer();
                        }
                    }
                }
                return _instance;
            }
        }

        private RpcSerializer()
        {
            // ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„ç±»å‹æ³¨å†Œè¡¨
            // ç”± RpcCodeGen å·¥å…·è‡ªåŠ¨ç”Ÿæˆï¼Œæ— éœ€æ‰‹åŠ¨ç»´æŠ¤
            List<Type> types;
            
            try
            {
                // å°è¯•ä½¿ç”¨ç”Ÿæˆçš„ç±»å‹æ³¨å†Œè¡¨
                var registryType = Type.GetType("DuckyNet.Shared.RPC.Generated.RpcTypeRegistry, DuckyNet.Shared");
                if (registryType != null)
                {
                    var method = registryType.GetMethod("GetSerializableTypes");
                    types = (List<Type>)method!.Invoke(null, null)!;
                    Console.WriteLine($"[RpcSerializer] Loaded {types.Count} types from auto-generated registry");
                }
                else
                {
                    // å¦‚æœä»£ç è¿˜æ²¡ç”Ÿæˆï¼Œä½¿ç”¨åå¤‡ç±»å‹åˆ—è¡¨
                    Console.WriteLine("[RpcSerializer] Auto-generated type registry not found, using fallback types");
                    types = GetFallbackTypes();
                }
            }
            catch (Exception ex)
            {
                // å‡ºé”™æ—¶ä½¿ç”¨åå¤‡åˆ—è¡¨
                Console.WriteLine($"[RpcSerializer] Error loading type registry: {ex.Message}, using fallback");
                types = GetFallbackTypes();
            }

            _serializer = new Serializer(types);
        }
        
        /// <summary>
        /// åå¤‡ç±»å‹åˆ—è¡¨ï¼ˆç”¨äºä»£ç ç”Ÿæˆå‰æˆ–å‡ºé”™æ—¶ï¼‰
        /// </summary>
        private static List<Type> GetFallbackTypes()
        {
            return new List<Type>
            {
                typeof(RpcMessage),
                typeof(RpcResponse),
                typeof(string),
                typeof(int),
                typeof(long),
                typeof(float),
                typeof(double),
                typeof(bool),
                typeof(byte[]),
                typeof(object[]),
                typeof(DateTime),
                // åº”ç”¨ç±»å‹ï¼ˆéœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼Œå»ºè®®è¿è¡Œä»£ç ç”Ÿæˆå™¨ï¼‰
                typeof(PlayerInfo),
                typeof(LoginResult),
                typeof(MessageType),
                typeof(PlayerInfo[])
            };
        }

        /// <summary>
        /// åºåˆ—åŒ–å¯¹è±¡ï¼ˆå¸¦ç±»å‹æ ‡è®°ï¼‰
        /// </summary>
        public byte[] Serialize(object obj)
        {
            using (var ms = new MemoryStream())
            {
                // ç¡®å®šæ¶ˆæ¯ç±»å‹
                RpcMessageType messageType;
                if (obj is RpcMessage)
                {
                    messageType = RpcMessageType.Request;
                }
                else if (obj is RpcResponse)
                {
                    messageType = RpcMessageType.Response;
                }
                else
                {
                    // ä¸æ˜¯RPCæ¶ˆæ¯ç±»å‹ï¼Œç›´æ¥åºåˆ—åŒ–ï¼ˆä¸æ·»åŠ æ ‡è®°ï¼‰
                    _serializer.Serialize(ms, obj);
                    return ms.ToArray();
                }

                // å†™å…¥ç±»å‹æ ‡è®°
                ms.WriteByte((byte)messageType);

                // åºåˆ—åŒ–å®é™…å¯¹è±¡
                _serializer.Serialize(ms, obj);
                return ms.ToArray();
            }
        }

        /// <summary>
        /// åºåˆ—åŒ–å¯¹è±¡ï¼ˆä¸å¸¦ç±»å‹æ ‡è®°ï¼Œç”¨äºå†…éƒ¨ä½¿ç”¨ï¼‰
        /// </summary>
        private byte[] SerializeRaw(object obj)
        {
            using (var ms = new MemoryStream())
            {
                _serializer.Serialize(ms, obj);
                return ms.ToArray();
            }
        }

        /// <summary>
        /// ååºåˆ—åŒ–å¯¹è±¡ï¼ˆæ”¯æŒç±»å‹æ ‡è®°ï¼‰
        /// </summary>
        public T Deserialize<T>(byte[] data)
        {
            try
            {
                using (var ms = new MemoryStream(data))
                {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¸¦æ ‡è®°çš„RPCæ¶ˆæ¯
                    if (typeof(T) == typeof(RpcMessage) || typeof(T) == typeof(RpcResponse))
                    {
                        // è¯»å–ç±»å‹æ ‡è®°ï¼ˆéœ€è¦è‡³å°‘1å­—èŠ‚ï¼‰
                        if (ms.Length >= 1)
                        {
                            var typeByte = (byte)ms.ReadByte();
                            
                            // éªŒè¯æ˜¯å¦æ˜¯æœ‰æ•ˆçš„æ¶ˆæ¯ç±»å‹æ ‡è®°
                            if (!Enum.IsDefined(typeof(RpcMessageType), typeByte))
                            {
                                // ä¸æ˜¯æœ‰æ•ˆçš„ç±»å‹æ ‡è®°ï¼Œå¯èƒ½æ˜¯æ—§æ ¼å¼æ•°æ®ï¼Œé‡ç½®æµä½ç½®
                                ms.Position = 0;
                            }
                            else
                            {
                                var messageType = (RpcMessageType)typeByte;

                                // éªŒè¯ç±»å‹åŒ¹é…
                                if (messageType == RpcMessageType.Request && typeof(T) != typeof(RpcMessage))
                                {
                                    throw new InvalidCastException(
                                        $"Message type mismatch: data is Request (RpcMessage), but expecting {typeof(T).FullName}");
                                }
                                if (messageType == RpcMessageType.Response && typeof(T) != typeof(RpcResponse))
                                {
                                    throw new InvalidCastException(
                                        $"Message type mismatch: data is Response (RpcResponse), but expecting {typeof(T).FullName}");
                                }
                            }
                        }
                        else
                        {
                            // æ•°æ®å¤ªçŸ­ï¼Œå¯èƒ½æ˜¯æŸåçš„æ•°æ®æˆ–æ—§æ ¼å¼
                            throw new InvalidOperationException(
                                $"Data too short to contain message type marker. Data length: {data?.Length ?? 0} bytes");
                        }
                    }

                    var obj = _serializer.Deserialize(ms);
                    if (obj == null)
                    {
                        throw new InvalidOperationException($"Deserialized object is null, expected type: {typeof(T).FullName}");
                    }
                    
                    // å¦‚æœç±»å‹å®Œå…¨åŒ¹é…ï¼Œç›´æ¥è½¬æ¢
                    if (obj is T directMatch)
                    {
                        return directMatch;
                    }
                    
                    // å°è¯•å¼ºåˆ¶è½¬æ¢
                    try
                    {
                        return (T)obj;
                    }
                    catch (InvalidCastException ex)
                    {
                        throw new InvalidCastException(
                            $"Cannot cast deserialized object from {obj.GetType().FullName} to {typeof(T).FullName}. " +
                            $"Object type assembly: {obj.GetType().Assembly.FullName}, " +
                            $"Target type assembly: {typeof(T).Assembly.FullName}. " +
                            $"Original error: {ex.Message}", ex);
                    }
                }
            }
            catch (Exception ex)
            {
                if (ex is InvalidCastException ice && (ice.Message.Contains("Cannot cast") || ice.Message.Contains("Message type mismatch")))
                {
                    // å·²ç»æ˜¯æˆ‘ä»¬æ”¹è¿›çš„é”™è¯¯ä¿¡æ¯ï¼Œç›´æ¥æŠ›å‡º
                    throw;
                }
                
                // åŒ…è£…å…¶ä»–å¼‚å¸¸ä»¥æä¾›æ›´å¤šä¸Šä¸‹æ–‡
                throw new InvalidOperationException(
                    $"Failed to deserialize to {typeof(T).FullName}. Data length: {data?.Length ?? 0} bytes. " +
                    $"Error: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// æ£€æµ‹æ¶ˆæ¯ç±»å‹ï¼ˆä¸è¿›è¡Œå®Œæ•´ååºåˆ—åŒ–ï¼‰
        /// </summary>
        public RpcMessageType? DetectMessageType(byte[] data)
        {
            if (data == null || data.Length < 1)
                return null;

            try
            {
                using (var ms = new MemoryStream(data))
                {
                    if (ms.Length < 1)
                        return null;
                        
                    var typeByte = (byte)ms.ReadByte();
                    if (Enum.IsDefined(typeof(RpcMessageType), typeByte))
                    {
                        return (RpcMessageType)typeByte;
                    }
                }
            }
            catch
            {
                // å¿½ç•¥é”™è¯¯ï¼Œè¿”å› null è¡¨ç¤ºæ— æ³•æ£€æµ‹ï¼ˆå¯èƒ½æ˜¯æ—§æ ¼å¼æ•°æ®ï¼‰
            }

            return null;
        }

        /// <summary>
        /// åºåˆ—åŒ–å‚æ•°æ•°ç»„ï¼ˆå‚æ•°ä¸éœ€è¦ç±»å‹æ ‡è®°ï¼‰
        /// </summary>
        public byte[]? SerializeParameters(object?[]? parameters)
        {
            if (parameters == null || parameters.Length == 0)
                return null;

            return SerializeRaw(parameters);
        }

        /// <summary>
        /// ååºåˆ—åŒ–å‚æ•°æ•°ç»„
        /// </summary>
        public object?[]? DeserializeParameters(byte[]? data)
        {
            if (data == null || data.Length == 0)
                return null;

            return Deserialize<object[]>(data);
        }

    }
}

```

`Shared\RPC\RpcTimeoutManager.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;

namespace DuckyNet.Shared.RPC
{
    /// <summary>
    /// RPC è°ƒç”¨è¶…æ—¶ç®¡ç†å™¨
    /// </summary>
    public class RpcTimeoutManager
    {
        private readonly ConcurrentDictionary<int, CancellationTokenSource> _timeouts = new ConcurrentDictionary<int, CancellationTokenSource>();
        private readonly int _defaultTimeoutMs;

        public RpcTimeoutManager(int defaultTimeoutMs = 30000)
        {
            _defaultTimeoutMs = defaultTimeoutMs;
        }

        /// <summary>
        /// ä¸ºæ¶ˆæ¯IDè®¾ç½®è¶…æ—¶
        /// </summary>
        public CancellationToken SetTimeout(int messageId, int timeoutMs = -1)
        {
            if (timeoutMs <= 0)
                timeoutMs = _defaultTimeoutMs;

            var cts = new CancellationTokenSource(timeoutMs);
            _timeouts[messageId] = cts;

            // è¶…æ—¶æ—¶è‡ªåŠ¨æ¸…ç†
            cts.Token.Register(() => ClearTimeout(messageId));

            return cts.Token;
        }

        /// <summary>
        /// æ¸…é™¤è¶…æ—¶è®¾ç½®
        /// </summary>
        public void ClearTimeout(int messageId)
        {
            if (_timeouts.TryRemove(messageId, out var cts))
            {
                cts.Dispose();
            }
        }

        /// <summary>
        /// æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦å·²è¶…æ—¶
        /// </summary>
        public bool IsTimedOut(int messageId)
        {
            if (_timeouts.TryGetValue(messageId, out var cts))
            {
                return cts.Token.IsCancellationRequested;
            }
            return false;
        }

        /// <summary>
        /// æ¸…ç†æ‰€æœ‰è¶…æ—¶è®¾ç½®
        /// </summary>
        public void ClearAll()
        {
            foreach (var kvp in _timeouts)
            {
                kvp.Value.Dispose();
            }
            _timeouts.Clear();
        }
    }
}
```

`Shared\Services\IAnimatorSyncService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// åŠ¨ç”»åŒæ­¥æœåŠ¡æ¥å£
    /// </summary>
    [RpcService("AnimatorSync")]
    public interface IAnimatorSyncService
    {
        /// <summary>
        /// ä¸Šä¼ åŠ¨ç”»çŠ¶æ€åˆ°æœåŠ¡å™¨ï¼ˆå®¢æˆ·ç«¯ -> æœåŠ¡å™¨ï¼‰
        /// </summary>
        [ClientToServer]
        void UpdateAnimatorState(IClientContext client, AnimatorSyncData animatorData);
    }

    /// <summary>
    /// åŠ¨ç”»åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡ï¼ˆæœåŠ¡å™¨å¹¿æ’­ç»™å®¢æˆ·ç«¯ï¼‰
    /// </summary>
    [RpcService("AnimatorSyncClient")]
    public interface IAnimatorSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„åŠ¨ç”»çŠ¶æ€ï¼ˆæœåŠ¡å™¨ -> å®¢æˆ·ç«¯ï¼‰
        /// </summary>
        [ServerToClient]
        void OnAnimatorStateUpdated(string steamId, AnimatorSyncData animatorData);
    }
}

```

`Shared\Services\ICharacterAppearanceService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// è§’è‰²å¤–è§‚åŒæ­¥æœåŠ¡æ¥å£ (æœåŠ¡ç«¯æ¥æ”¶)
    /// å¤„ç†ç©å®¶å¤–è§‚æ•°æ®çš„ä¸Šä¼ ã€å­˜å‚¨å’Œåˆ†å‘
    /// </summary>
    [RpcService("CharacterAppearanceService")]
    public interface ICharacterAppearanceService
    {
        /// <summary>
        /// å®¢æˆ·ç«¯ä¸Šä¼ è‡ªå·±çš„å¤–è§‚æ•°æ®ï¼ˆé¦–æ¬¡åŠ å…¥æˆ–æ›´æ–°æ—¶è°ƒç”¨ï¼‰
        /// æœåŠ¡å™¨ä¼šå­˜å‚¨å¹¶è½¬å‘ç»™æˆ¿é—´å†…æ‰€æœ‰ç©å®¶
        /// </summary>
        [ClientToServer]
        void UploadAppearance(IClientContext client, CharacterAppearanceData appearanceData);

        /// <summary>
        /// å®¢æˆ·ç«¯è¯·æ±‚è·å–æŒ‡å®šç©å®¶çš„å¤–è§‚æ•°æ®
        /// ç”¨äºä¸­é€”åŠ å…¥æˆ¿é—´æ—¶è·å–å…¶ä»–ç©å®¶çš„å¤–è§‚
        /// </summary>
        [ClientToServer]
        void RequestAppearance(IClientContext client, string targetSteamId);
    }

    /// <summary>
    /// è§’è‰²å¤–è§‚åŒæ­¥æœåŠ¡æ¥å£ (å®¢æˆ·ç«¯æ¥æ”¶)
    /// æ¥æ”¶æœåŠ¡å™¨æ¨é€çš„å¤–è§‚æ•°æ®
    /// </summary>
    [RpcService("CharacterAppearanceClientService")]
    public interface ICharacterAppearanceClientService
    {
        /// <summary>
        /// æ¥æ”¶ç©å®¶çš„å¤–è§‚æ•°æ®
        /// ç”±æœåŠ¡å™¨è°ƒç”¨ï¼Œé€šçŸ¥å®¢æˆ·ç«¯æŸä¸ªç©å®¶çš„å¤–è§‚æ•°æ®
        /// </summary>
        [ServerToClient]
        void OnAppearanceReceived(string steamId, CharacterAppearanceData appearanceData);
    }
}


```

`Shared\Services\ICharacterService.cs`:

```cs
using DuckyNet.Shared.RPC;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// è§’è‰²æœåŠ¡æ¥å£ - ç®¡ç†è§’è‰²å¤–è§‚å’Œæ•°æ®
    /// </summary>
    [RpcService("CharacterService")]
    public interface ICharacterService
    {
        /// <summary>
        /// æ›´æ–°ç©å®¶è§’è‰²å¤–è§‚
        /// </summary>
        [ClientToServer]
        Task<bool> UpdateAppearanceAsync(IClientContext client, byte[] appearanceData);

        /// <summary>
        /// è·å–ç©å®¶è§’è‰²å¤–è§‚
        /// </summary>
        [ClientToServer]
        Task<byte[]?> GetAppearanceAsync(IClientContext client, string steamId);

    }

    /// <summary>
    /// è§’è‰²å®¢æˆ·ç«¯æœåŠ¡æ¥å£
    /// </summary>
    [RpcService("CharacterClientService")]
    public interface ICharacterClientService
    {
        /// <summary>
        /// ç©å®¶å¤–è§‚æ›´æ–°é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerAppearanceUpdated(string steamId, byte[] appearanceData);
    }
}


```

`Shared\Services\IEquipmentService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// è£…å¤‡åŒæ­¥æœåŠ¡æ¥å£
    /// å®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨ï¼šæ›´æ–°è£…å¤‡æ§½ä½
    /// æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯ï¼šå¹¿æ’­è£…å¤‡å˜æ›´ã€æ‰¹é‡å‘é€è£…å¤‡æ•°æ®
    /// </summary>
    [RpcService("EquipmentService")]
    public interface IEquipmentService
    {
        // ==================== å®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨ ====================

        /// <summary>
        /// æ›´æ–°å•ä¸ªè£…å¤‡æ§½ä½
        /// å®¢æˆ·ç«¯è°ƒç”¨ï¼Œé€šçŸ¥æœåŠ¡å™¨è£…å¤‡å˜æ›´
        /// </summary>
        /// <param name="client">å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡</param>
        /// <param name="request">è£…å¤‡æ›´æ–°è¯·æ±‚</param>
        /// <returns>æ˜¯å¦æˆåŠŸ</returns>
        [ClientToServer]
        Task<bool> UpdateEquipmentSlotAsync(IClientContext client, EquipmentSlotUpdateRequest request);
    }

    /// <summary>
    /// è£…å¤‡åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡æ¥å£
    /// æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯çš„å•å‘é€šçŸ¥
    /// </summary>
    [RpcService("EquipmentClientService")]
    public interface IEquipmentClientService
    {
        // ==================== æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯ ====================

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„è£…å¤‡æ§½ä½æ›´æ–°é€šçŸ¥
        /// </summary>
        /// <param name="notification">è£…å¤‡æ›´æ–°é€šçŸ¥</param>
        [ServerToClient]
        void OnEquipmentSlotUpdated(EquipmentSlotUpdateNotification notification);

        /// <summary>
        /// æ¥æ”¶æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶ï¼‰
        /// </summary>
        /// <param name="allEquipmentData">æ‰€æœ‰ç©å®¶çš„è£…å¤‡æ•°æ®</param>
        [ServerToClient]
        void OnAllPlayersEquipmentReceived(AllPlayersEquipmentData allEquipmentData);
    }
}


```

`Shared\Services\IHealthSyncService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// è¡€é‡åŒæ­¥æœåŠ¡æ¥å£ï¼ˆå®¢æˆ·ç«¯è°ƒç”¨æœåŠ¡ç«¯ï¼‰
    /// </summary>
    [RpcService("HealthSyncService")]
    public interface IHealthSyncService
    {
        /// <summary>
        /// å®¢æˆ·ç«¯å‘é€è¡€é‡æ•°æ®åˆ°æœåŠ¡å™¨
        /// </summary>
        [ClientToServer]
        void SendHealthSync(IClientContext client, HealthSyncData healthData);
    }

    /// <summary>
    /// è¡€é‡åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡æ¥å£ï¼ˆæœåŠ¡ç«¯è°ƒç”¨å®¢æˆ·ç«¯ï¼‰
    /// </summary>
    [RpcService("HealthSyncClientService")]
    public interface IHealthSyncClientService
    {
        /// <summary>
        /// æœåŠ¡å™¨å¹¿æ’­è¡€é‡æ•°æ®åˆ°å®¢æˆ·ç«¯
        /// </summary>
        [ServerToClient]
        void OnHealthSyncReceived(HealthSyncData healthData);
    }
}


```

`Shared\Services\IItemSyncService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// ç‰©å“åŒæ­¥æœåŠ¡æ¥å£ï¼ˆå®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨ï¼‰
    /// </summary>
    [RpcService("ItemSyncService")]
    public interface IItemSyncService
    {
        /// <summary>
        /// ä¸¢å¼ƒç‰©å“
        /// å®¢æˆ·ç«¯é€šçŸ¥æœåŠ¡å™¨ç©å®¶ä¸¢å¼ƒäº†ç‰©å“ï¼ŒæœåŠ¡å™¨åˆ†é…å…¨å±€ DropId å¹¶å¹¿æ’­ç»™å…¶ä»–ç©å®¶
        /// </summary>
        /// <param name="client">å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡</param>
        /// <param name="dropData">ä¸¢å¼ƒæ•°æ®ï¼ˆä¸å« DropIdï¼Œç”±æœåŠ¡å™¨åˆ†é…ï¼‰</param>
        /// <returns>æœåŠ¡å™¨åˆ†é…çš„ DropId</returns>
        [ClientToServer]
        Task<uint> DropItemAsync(IClientContext client, ItemDropData dropData);

        /// <summary>
        /// æ‹¾å–ç‰©å“
        /// å®¢æˆ·ç«¯é€šçŸ¥æœåŠ¡å™¨ç©å®¶æ‹¾å–äº†ç‰©å“ï¼ŒæœåŠ¡å™¨éªŒè¯å¹¶å¹¿æ’­ç»™å…¶ä»–ç©å®¶é”€æ¯è¯¥ç‰©å“
        /// </summary>
        /// <param name="client">å®¢æˆ·ç«¯ä¸Šä¸‹æ–‡</param>
        /// <param name="request">æ‹¾å–è¯·æ±‚</param>
        [ClientToServer]
        Task<bool> PickupItemAsync(IClientContext client, ItemPickupRequest request);
    }

    /// <summary>
    /// ç‰©å“åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡æ¥å£ï¼ˆæœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯ï¼‰
    /// </summary>
    [RpcService("ItemSyncClientService")]
    public interface IItemSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶è¿œç¨‹ç©å®¶ä¸¢å¼ƒç‰©å“çš„é€šçŸ¥
        /// æœåŠ¡å™¨å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶ï¼Œè®©ä»–ä»¬åœ¨æœ¬åœ°åˆ›å»ºè¯¥ç‰©å“
        /// </summary>
        /// <param name="dropData">å®Œæ•´çš„ä¸¢å¼ƒæ•°æ®ï¼ˆå« DropIdï¼‰</param>
        [ServerToClient]
        void OnRemoteItemDropped(ItemDropData dropData);

        /// <summary>
        /// æ¥æ”¶è¿œç¨‹ç©å®¶æ‹¾å–ç‰©å“çš„é€šçŸ¥
        /// æœåŠ¡å™¨å¹¿æ’­ç»™æˆ¿é—´å†…çš„å…¶ä»–ç©å®¶ï¼Œè®©ä»–ä»¬é”€æ¯æœ¬åœ°çš„è¯¥ç‰©å“
        /// </summary>
        /// <param name="dropId">è¢«æ‹¾å–çš„ç‰©å“ DropId</param>
        /// <param name="pickedByPlayerId">æ‹¾å–è€…çš„ SteamId</param>
        [ServerToClient]
        void OnRemoteItemPickedUp(uint dropId, string pickedByPlayerId);
    }
}


```

`Shared\Services\INpcSyncService.cs`:

```cs
using System.Threading.Tasks;
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// NPC åŒæ­¥æœåŠ¡ï¼ˆæœåŠ¡å™¨ç«¯ï¼‰
    /// </summary>
    [RpcService("NpcSyncService")]
    public interface INpcSyncService
    {
        /// <summary>
        /// é€šçŸ¥æœåŠ¡å™¨ NPC ç”Ÿæˆ
        /// </summary>
        [ClientToServer]
        Task NotifyNpcSpawned(IClientContext client, NpcSpawnData spawnData);

        /// <summary>
        /// é€šçŸ¥æœåŠ¡å™¨ NPC ä½ç½®æ›´æ–°ï¼ˆå•ä¸ªï¼‰
        /// </summary>
        [ClientToServer]
        Task NotifyNpcTransform(IClientContext client, NpcTransformData transformData);

        /// <summary>
        /// é€šçŸ¥æœåŠ¡å™¨ NPC ä½ç½®æ›´æ–°ï¼ˆæ‰¹é‡ï¼‰
        /// </summary>
        [ClientToServer]
        Task NotifyNpcBatchTransform(IClientContext client, NpcBatchTransformData batchData);

        /// <summary>
        /// é€šçŸ¥æœåŠ¡å™¨ NPC é”€æ¯
        /// </summary>
        [ClientToServer]
        Task NotifyNpcDestroyed(IClientContext client, NpcDestroyData destroyData);

        /// <summary>
        /// è¯·æ±‚åœºæ™¯å†…æ‰€æœ‰ NPCï¼ˆè¿›å…¥åœºæ™¯æ—¶ï¼‰
        /// </summary>
        [ClientToServer]
        Task<NpcSpawnData[]> RequestSceneNpcs(IClientContext client, string sceneName, string subSceneName);

        /// <summary>
        /// è¯·æ±‚å•ä¸ª NPC ä¿¡æ¯ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
        /// </summary>
        [ClientToServer]
        Task<NpcSpawnData?> RequestSingleNpc(IClientContext client, string npcId);
    }

    /// <summary>
    /// NPC åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡ï¼ˆæ¥æ”¶å¹¿æ’­ï¼‰
    /// </summary>
    [RpcService("NpcSyncClientService")]
    public interface INpcSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–å®¢æˆ·ç«¯çš„ NPC ç”Ÿæˆ
        /// </summary>
        [ServerToClient]
        void OnNpcSpawned(NpcSpawnData spawnData);

        /// <summary>
        /// æ¥æ”¶ NPC ä½ç½®æ›´æ–°ï¼ˆæ‰¹é‡ï¼‰
        /// </summary>
        [ServerToClient]
        void OnNpcBatchTransform(NpcBatchTransformData batchData);

        /// <summary>
        /// æ¥æ”¶ NPC é”€æ¯
        /// </summary>
        [ServerToClient]
        void OnNpcDestroyed(NpcDestroyData destroyData);
    }
}


```

`Shared\Services\IPlayerService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// ç©å®¶æœåŠ¡æ¥å£
    /// å®šä¹‰å®¢æˆ·ç«¯å¯ä»¥è°ƒç”¨çš„æœåŠ¡å™¨æ–¹æ³•
    /// </summary>
    [RpcService("PlayerService")]
    public interface IPlayerService
    {
        /// <summary>
        /// ç©å®¶ç™»å½•ï¼ˆè¿æ¥å3ç§’å†…å¿…é¡»è°ƒç”¨ï¼Œå¦åˆ™æ–­å¼€è¿æ¥ï¼‰
        /// </summary>
        [ClientToServer]
        Task<LoginResult> LoginAsync(IClientContext client, PlayerInfo playerInfo);

        /// <summary>
        /// ç©å®¶ç™»å‡º
        /// </summary>
        [ClientToServer]
        void Logout(IClientContext client);

        /// <summary>
        /// å‘é€èŠå¤©æ¶ˆæ¯ï¼ˆå‘é€åˆ°å½“å‰æˆ¿é—´ï¼Œå¦‚æœä¸åœ¨æˆ¿é—´åˆ™å‘é€åˆ°å…¨å±€ï¼‰
        /// </summary>
        [ClientToServer]
        void SendChatMessage(IClientContext client, string message);

        /// <summary>
        /// è·å–å…¨å±€åœ¨çº¿ç©å®¶åˆ—è¡¨ï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
        /// </summary>
        [ClientToServer]
        Task<PlayerInfo[]> GetAllOnlinePlayersAsync(IClientContext client);

        /// <summary>
        /// è·å–å½“å‰æˆ¿é—´ç©å®¶åˆ—è¡¨
        /// </summary>
        [ClientToServer]
        Task<PlayerInfo[]> GetCurrentRoomPlayersAsync(IClientContext client);
    }

    /// <summary>
    /// ç©å®¶å®¢æˆ·ç«¯æœåŠ¡æ¥å£
    /// å®šä¹‰æœåŠ¡å™¨å¯ä»¥è°ƒç”¨çš„å®¢æˆ·ç«¯æ–¹æ³•
    /// </summary>
    [RpcService("PlayerClientService")]
    public interface IPlayerClientService
    {
        /// <summary>
        /// æ¥æ”¶èŠå¤©æ¶ˆæ¯
        /// </summary>
        [ServerToClient]
        void OnChatMessage(PlayerInfo sender, string message);

        /// <summary>
        /// ç©å®¶åŠ å…¥é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerJoined(PlayerInfo player);

        /// <summary>
        /// ç©å®¶ç¦»å¼€é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerLeft(PlayerInfo player);

        /// <summary>
        /// æœåŠ¡å™¨æ¶ˆæ¯é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnServerMessage(string message, MessageType messageType = MessageType.Info);

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„ä½ç½®åŒæ­¥æ•°æ®
        /// æœåŠ¡å™¨å¹¿æ’­ç»™æˆ¿é—´/åœºæ™¯å†…çš„å…¶ä»–ç©å®¶
        /// </summary>
        [ServerToClient]
        void OnPlayerUnitySyncReceived(UnitySyncData syncData);
    }

    /// <summary>
    /// ç™»å½•ç»“æœ
    /// </summary>
    [Serializable]
    public class LoginResult
    {
        public bool Success { get; set; }
        public string? ErrorMessage { get; set; }
        public PlayerInfo? PlayerInfo { get; set; }
        public string? SessionToken { get; set; }
    }


    /// <summary>
    /// æ¶ˆæ¯ç±»å‹æšä¸¾
    /// </summary>
    [Serializable]
    public enum MessageType
    {
        Info,
        Warning,
        Error,
        Success
    }

    /// <summary>
    /// ç©å®¶ä¿¡æ¯æ•°æ®ç±»
    /// </summary>
    [Serializable]
    public class PlayerInfo
    {
        public string SteamId { get; set; } = string.Empty;
        public string SteamName { get; set; } = string.Empty;

        /// <summary>
        /// Steam å¤´åƒ URLï¼ˆä¸­ç­‰å°ºå¯¸ï¼‰
        /// </summary>
        public string AvatarUrl { get; set; } = string.Empty;
        public ScenelData CurrentScenelData { get; set; } = new ScenelData("", "");
        /// <summary>
        /// è§’è‰²æ˜¯å¦å·²åŠ è½½
        /// </summary>
        public bool HasCharacter { get; set; }

        /// <summary>
        /// è§’è‰²å¤–è§‚æ•°æ®ï¼ˆå‹ç¼©çš„äºŒè¿›åˆ¶æ ¼å¼ï¼‰
        /// </summary>
        public byte[]? AppearanceData { get; set; }

        /// <summary>
        /// ç©å®¶è£…å¤‡æ•°æ®ï¼ˆ5ä¸ªè£…å¤‡æ§½ä½çš„ç‰©å“TypeIDï¼‰
        /// </summary>
        public PlayerEquipmentData EquipmentData { get; set; } = new PlayerEquipmentData();

        /// <summary>
        /// ç©å®¶æ­¦å™¨æ•°æ®ï¼ˆ3ä¸ªæ­¦å™¨æ§½ä½çš„å®Œæ•´ç‰©å“æ•°æ®ï¼‰
        /// </summary>
        public PlayerWeaponData? WeaponData { get; set; }

        /// <summary>
        /// éªŒè¯ç©å®¶ä¿¡æ¯æ˜¯å¦æœ‰æ•ˆ
        /// </summary>
        public bool IsValid()
        {
            return !string.IsNullOrWhiteSpace(SteamId) && !string.IsNullOrWhiteSpace(SteamName);
        }

    }



}


```

`Shared\Services\IPlayerUnitySyncService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// ç©å®¶æœåŠ¡æ¥å£
    /// å®šä¹‰å®¢æˆ·ç«¯å¯ä»¥è°ƒç”¨çš„æœåŠ¡å™¨æ–¹æ³•ï¼ˆä¸Šè¡Œï¼‰
    /// </summary>
    [RpcService("PlayerUnitySyncService")]
    public interface IPlayerUnitySyncService
    {
        /// <summary>
        /// å‘é€è‡ªèº«åæ ‡åˆ°æœåŠ¡å™¨/æœåŠ¡å™¨æ ¹æ®å½“å‰æˆ¿é—´å’Œåœºæ™¯è¿›è¡Œåˆ†å‘
        /// </summary>
        [ClientToServer]
        void SendPlayerUnitySync(IClientContext client, UnitySyncData syncData);
    }
}
```

`Shared\Services\IRoomService.cs`:

```cs
using DuckyNet.Shared.RPC;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// æˆ¿é—´æ•°æ®
    /// </summary>
    [Serializable]
    public class RoomInfo
    {
        /// <summary>
        /// æˆ¿é—´å”¯ä¸€ID
        /// </summary>
        public string RoomId { get; set; } = string.Empty;

        /// <summary>
        /// æˆ¿é—´åç§°
        /// </summary>
        public string RoomName { get; set; } = string.Empty;

        /// <summary>
        /// æˆ¿é—´æè¿°
        /// </summary>
        public string Description { get; set; } = string.Empty;

        /// <summary>
        /// æˆ¿é—´å¯†ç ï¼ˆå¯é€‰ï¼‰
        /// </summary>
        public string? Password { get; set; }

        /// <summary>
        /// æ˜¯å¦éœ€è¦å¯†ç 
        /// </summary>
        public bool RequirePassword => !string.IsNullOrEmpty(Password);

        /// <summary>
        /// æˆ¿ä¸»ç©å®¶SteamId
        /// </summary>
        public string HostSteamId { get; set; } = string.Empty;

        /// <summary>
        /// å½“å‰ç©å®¶æ•°
        /// </summary>
        public int CurrentPlayers { get; set; }

        /// <summary>
        /// æœ€å¤§ç©å®¶æ•°
        /// </summary>
        public int MaxPlayers { get; set; } = 8;

        /// <summary>
        /// æˆ¿é—´åˆ›å»ºæ—¶é—´
        /// </summary>
        public DateTime CreateTime { get; set; }

        /// <summary>
        /// æ˜¯å¦å·²æ»¡
        /// </summary>
        public bool IsFull => CurrentPlayers >= MaxPlayers;

        /// <summary>
        /// æ˜¯å¦å¯åŠ å…¥
        /// </summary>
        public bool CanJoin => !IsFull;
    }


    /// <summary>
    /// åˆ›å»ºæˆ¿é—´è¯·æ±‚
    /// </summary>
    [Serializable]
    public class CreateRoomRequest
    {
        public string RoomName { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string? Password { get; set; }
        public int MaxPlayers { get; set; } = 8;
    }

    /// <summary>
    /// åŠ å…¥æˆ¿é—´è¯·æ±‚
    /// </summary>
    [Serializable]
    public class JoinRoomRequest
    {
        public string RoomId { get; set; } = string.Empty;
        public string? Password { get; set; }
    }

    /// <summary>
    /// æˆ¿é—´æ“ä½œç»“æœ
    /// </summary>
    [Serializable]
    public class RoomOperationResult
    {
        public bool Success { get; set; }
        public string? ErrorMessage { get; set; }
        public RoomInfo? Room { get; set; }
    }

    /// <summary>
    /// æˆ¿é—´æœåŠ¡æ¥å£
    /// </summary>
    [RpcService("RoomService")]
    public interface IRoomService
    {
        /// <summary>
        /// è·å–æ‰€æœ‰æˆ¿é—´åˆ—è¡¨
        /// </summary>
        [ClientToServer]
        Task<RoomInfo[]> GetRoomListAsync(IClientContext client);

        /// <summary>
        /// åˆ›å»ºæˆ¿é—´
        /// </summary>
        [ClientToServer]
        Task<RoomOperationResult> CreateRoomAsync(IClientContext client, CreateRoomRequest request);

        /// <summary>
        /// åŠ å…¥æˆ¿é—´
        /// </summary>
        [ClientToServer]
        Task<RoomOperationResult> JoinRoomAsync(IClientContext client, JoinRoomRequest request);

        /// <summary>
        /// ç¦»å¼€æˆ¿é—´
        /// </summary>
        [ClientToServer]
        Task<bool> LeaveRoomAsync(IClientContext client);

        /// <summary>
        /// è·å–å½“å‰æˆ¿é—´ä¿¡æ¯
        /// </summary>
        [ClientToServer]
        Task<RoomInfo?> GetCurrentRoomAsync(IClientContext client);

        /// <summary>
        /// è·å–æŒ‡å®šæˆ¿é—´ä¿¡æ¯
        /// </summary>
        [ClientToServer]
        Task<RoomInfo?> GetRoomInfoAsync(IClientContext client, string roomId);

        /// <summary>
        /// è·å–æˆ¿é—´å†…çš„ç©å®¶åˆ—è¡¨
        /// </summary>
        [ClientToServer]
        Task<PlayerInfo[]> GetRoomPlayersAsync(IClientContext client, string roomId);

        /// <summary>
        /// è¸¢å‡ºç©å®¶ï¼ˆä»…æˆ¿ä¸»ï¼‰
        /// </summary>
        [ClientToServer]
        Task<bool> KickPlayerAsync(IClientContext client, string SteamId);
    }

    /// <summary>
    /// æˆ¿é—´å®¢æˆ·ç«¯æœåŠ¡æ¥å£
    /// </summary>
    [RpcService("RoomClientService")]
    public interface IRoomClientService
    {
        /// <summary>
        /// ç©å®¶åŠ å…¥æˆ¿é—´é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerJoinedRoom(PlayerInfo player, RoomInfo room);

        /// <summary>
        /// ç©å®¶ç¦»å¼€æˆ¿é—´é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerLeftRoom(PlayerInfo player, RoomInfo room);

        /// <summary>
        /// è¢«è¸¢å‡ºæˆ¿é—´é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnKickedFromRoom(string reason);
    }
}


```

`Shared\Services\ISceneService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{

    /// <summary>
    /// åœºæ™¯æœåŠ¡æ¥å£
    /// </summary>
    [RpcService("SceneService")]
    public interface ISceneService
    {
        /// <summary>
        /// è¿›å…¥åœºæ™¯
        /// </summary>
        [ClientToServer]
        Task<bool> EnterSceneAsync(IClientContext client, ScenelData scenelData);

        /// <summary>
        /// ç¦»å¼€å½“å‰åœºæ™¯
        /// </summary>
        [ClientToServer]
        Task<bool> LeaveSceneAsync(IClientContext client, ScenelData scenelData);

        /// <summary>
        /// è·å–åœºæ™¯å†…çš„ç©å®¶åˆ—è¡¨
        /// </summary>
        [ClientToServer]
        Task<PlayerInfo[]> GetScenePlayersAsync(IClientContext client, ScenelData scenelData);

    }

    /// <summary>
    /// åœºæ™¯å®¢æˆ·ç«¯æœåŠ¡æ¥å£
    /// </summary>
    [RpcService("SceneClientService")]
    public interface ISceneClientService
    {
        /// <summary>
        /// ç©å®¶è¿›å…¥åœºæ™¯é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerEnteredScene(PlayerInfo playerInfo, ScenelData scenelData);

        /// <summary>
        /// ç©å®¶ç¦»å¼€åœºæ™¯é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnPlayerLeftScene(PlayerInfo playerInfo, ScenelData scenelData);
    }
}


```

`Shared\Services\IWeaponSyncService.cs`:

```cs
using DuckyNet.Shared.Data;
using DuckyNet.Shared.RPC;
using System.Threading.Tasks;

namespace DuckyNet.Shared.Services
{
    /// <summary>
    /// æ­¦å™¨åŒæ­¥æœåŠ¡æ¥å£
    /// å®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨ï¼šæ›´æ–°æ­¦å™¨æ§½ä½
    /// æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯ï¼šå¹¿æ’­æ­¦å™¨å˜æ›´ã€æ‰¹é‡å‘é€æ­¦å™¨æ•°æ®
    /// </summary>
    [RpcService("WeaponSyncService")]
    public interface IWeaponSyncService
    {
        /// <summary>
        /// è£…å¤‡æ­¦å™¨åˆ°æ§½ä½
        /// </summary>
        [ClientToServer]
        Task<bool> EquipWeaponAsync(IClientContext client, WeaponSlotUpdateRequest request);

        /// <summary>
        /// å¸ä¸‹æ­¦å™¨æ§½ä½
        /// </summary>
        [ClientToServer]
        Task<bool> UnequipWeaponAsync(IClientContext client, WeaponSlotUnequipRequest request);

        /// <summary>
        /// åˆ‡æ¢å½“å‰æ­¦å™¨æ§½ä½
        /// </summary>
        [ClientToServer]
        Task<bool> SwitchWeaponSlotAsync(IClientContext client, WeaponSwitchRequest request);

        /// <summary>
        /// é€šçŸ¥æ­¦å™¨å¼€ç«ï¼ˆæ’­æ”¾ç‰¹æ•ˆï¼‰- å•å‘
        /// </summary>
        [ClientToServer]
        void NotifyWeaponFire(IClientContext client, WeaponFireData fireData);

        /// <summary>
        /// æ‰¹é‡é€šçŸ¥æ­¦å™¨å¼€ç«ï¼ˆæ’­æ”¾ç‰¹æ•ˆï¼‰- å¤šå‘ï¼ˆéœ°å¼¹æª/è¿å‘æ­¦å™¨ä¼˜åŒ–ï¼‰
        /// ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šéœ°å¼¹æª 8 å‘å¼¹ä¸¸åªéœ€ 1 æ¬¡ RPC è°ƒç”¨
        /// </summary>
        [ClientToServer]
        void NotifyWeaponFireBatch(IClientContext client, WeaponFireBatchData batchData);
    }

    /// <summary>
    /// æ­¦å™¨åŒæ­¥å®¢æˆ·ç«¯æœåŠ¡æ¥å£
    /// æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯çš„å•å‘é€šçŸ¥
    /// </summary>
    [RpcService("WeaponSyncClientService")]
    public interface IWeaponSyncClientService
    {
        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„æ­¦å™¨æ§½ä½æ›´æ–°é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnWeaponSlotUpdated(WeaponSlotUpdateNotification notification);

        /// <summary>
        /// æ¥æ”¶æ‰€æœ‰ç©å®¶çš„æ­¦å™¨æ•°æ®ï¼ˆåŠ å…¥æˆ¿é—´æ—¶ï¼‰
        /// </summary>
        [ServerToClient]
        void OnAllPlayersWeaponReceived(AllPlayersWeaponData allWeaponData);

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„æ­¦å™¨åˆ‡æ¢é€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnWeaponSwitched(WeaponSwitchNotification notification);

        /// <summary>
        /// æ¥æ”¶å…¶ä»–ç©å®¶çš„å¼€æªç‰¹æ•ˆé€šçŸ¥
        /// </summary>
        [ServerToClient]
        void OnWeaponFired(WeaponFireData fireData);
    }
}



```

`Tools\RpcCodeGen\Program.cs`:

```cs
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Collections.Generic;
using DuckyNet.Shared.RPC;

namespace RpcCodeGen
{
    class Program
    {
        static void Main(string[] args)
        {
            // 0. æ¸…ç†æ—§çš„ç”Ÿæˆæ–‡ä»¶
            var currentDir = AppDomain.CurrentDomain.BaseDirectory;
            var solutionDir = FindSolutionDirectory(currentDir);
            CleanGeneratedFiles(solutionDir);
            
            // 1. åŠ è½½ç›®æ ‡ç¨‹åºé›†
            var sharedDll = Path.Combine(solutionDir, "Shared", "bin", "Debug", "netstandard2.1", "DuckyNet.Shared.dll");
            if (!File.Exists(sharedDll))
            {
                Console.WriteLine($"æœªæ‰¾åˆ°ç¨‹åºé›†: {sharedDll}");
                return;
            }
            var asm = Assembly.LoadFrom(sharedDll);

            // 2. æ‰«æå¸¦æœ‰ RpcServiceAttribute çš„æ¥å£
            var rpcServiceAttr = asm.GetType("DuckyNet.Shared.RPC.RpcServiceAttribute");
            var interfaces = asm.GetTypes().Where(t => t.IsInterface && t.GetCustomAttributes(rpcServiceAttr, false).Any()).ToList();

            // 3. ç”Ÿæˆå®¢æˆ·ç«¯ä»£ç†å’ŒæœåŠ¡ç«¯åˆ†å‘å™¨
            var serverToClientAttr = asm.GetType("DuckyNet.Shared.RPC.ServerToClientAttribute");
            foreach (var iface in interfaces)
            {
                var attr = iface.GetCustomAttributes(rpcServiceAttr, false).FirstOrDefault();
                var serviceName = (string)rpcServiceAttr.GetProperty("ServiceName").GetValue(attr);
                GenerateClientProxy(iface, serviceName);
                GenerateServerDispatcher(iface, serviceName);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ServerToClientæ–¹æ³•ï¼Œç”Ÿæˆå¹¿æ’­ä»£ç†
                var hasServerToClient = iface.GetMethods().Any(m => m.GetCustomAttributes(serverToClientAttr, false).Any());
                if (hasServerToClient)
                {
                    GenerateBroadcastProxy(iface, serviceName);
                    GenerateClientsBroadcastProxy(iface, serviceName);
                    GenerateWhereBroadcastProxy(iface, serviceName);
                    GenerateClientCallProxy(iface, serviceName);
                }
            }

            // 4. æ”¶é›†æ‰€æœ‰å‚æ•°/è¿”å›ç±»å‹ï¼Œç”Ÿæˆç±»å‹æ³¨å†Œä»£ç 
            GenerateTypeRegister(interfaces);
        }

        static void GenerateClientProxy(Type iface, string serviceName)
        {
            var sb = new StringBuilder();
            var ns = iface.Namespace + ".Generated";
            // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦ï¼Œé¿å… "IItemSync" å˜æˆ "temSync"
            var className = (iface.Name.StartsWith("I") && iface.Name.Length > 1 && char.IsUpper(iface.Name[1])) 
                ? iface.Name.Substring(1) + "ClientProxy"
                : iface.Name + "ClientProxy";
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦çš„å‘½åç©ºé—´
            var namespaces = CollectNamespaces(iface);
            
            sb.AppendLine($"using System;");
            sb.AppendLine($"using System.Linq;");
            sb.AppendLine($"using System.Threading.Tasks;");
            sb.AppendLine($"using DuckyNet.Shared.RPC;");
            foreach (var n in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {n};");
            }
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine($"{{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// å®¢æˆ·ç«¯ä»£ç† - ç”¨äºè°ƒç”¨æœåŠ¡å™¨æ–¹æ³•");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {className}");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        private readonly IClientContext _ctx;");
            sb.AppendLine($"        public {className}(IClientContext ctx) => _ctx = ctx;");
            sb.AppendLine();
            
            foreach (var m in iface.GetMethods())
            {
                var retType = SimplifyTypeName(m.ReturnType);
                var parameters = m.GetParameters();
                
                // è¿‡æ»¤æ‰ IClientContext å‚æ•°ï¼ˆå®¢æˆ·ç«¯è°ƒç”¨æœåŠ¡å™¨æ—¶ä¸éœ€è¦ä¼ é€’ï¼‰
                var clientParams = parameters.Where(p => p.ParameterType != typeof(IClientContext)).ToArray();
                var paramList = string.Join(", ", clientParams.Select(p => SimplifyTypeName(p.ParameterType) + " " + p.Name));
                var argNames = string.Join(", ", clientParams.Select(p => p.Name));
                
                if (m.ReturnType.FullName.StartsWith("System.Threading.Tasks.Task"))
                {
                    var genericArg = m.ReturnType.GenericTypeArguments.Length > 0 ? SimplifyTypeName(m.ReturnType.GenericTypeArguments[0]) : "object";
                    sb.AppendLine($"        public {retType} {m.Name}({paramList}) => _ctx.InvokeAsync<{iface.FullName}, {genericArg}>(\"{m.Name}\"{(argNames.Length > 0 ? ", " + argNames : "")});");
                }
                else
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList}) => _ctx.Invoke<{iface.FullName}>(\"{m.Name}\"{(argNames.Length > 0 ? ", " + argNames : "")});");
                }
            }
            sb.AppendLine($"    }}");
            sb.AppendLine($"}}");
            
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, $"{className}.cs"), sb.ToString());
        }

        static void GenerateServerDispatcher(Type iface, string serviceName)
        {
            var sb = new StringBuilder();
            var ns = iface.Namespace + ".Generated";
            // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
            var className = (iface.Name.StartsWith("I") && iface.Name.Length > 1 && char.IsUpper(iface.Name[1])) 
                ? iface.Name.Substring(1) + "ServerDispatcher"
                : iface.Name + "ServerDispatcher";
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦çš„å‘½åç©ºé—´
            var namespaces = CollectNamespaces(iface);
            
            sb.AppendLine($"using System;");
            sb.AppendLine($"using System.Threading.Tasks;");
            sb.AppendLine($"using DuckyNet.Shared.RPC;");
            foreach (var n in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {n};");
            }
            sb.AppendLine($"namespace {ns}\n{{");
            sb.AppendLine($"    public class {className}\n    {{");
            sb.AppendLine($"        private readonly {iface.FullName} _impl;\n        public {className}({iface.FullName} impl) => _impl = impl;\n");
            sb.AppendLine($"        public object Dispatch(string method, object[] args, IClientContext ctx)\n        {{");
            sb.AppendLine($"            switch (method)\n            {{");
            foreach (var m in iface.GetMethods())
            {
                var parameters = m.GetParameters();
                var hasClientContext = parameters.Length > 0 && parameters[0].ParameterType == typeof(IClientContext);
                
                var argList = new List<string>();
                int argIndex = 0;
                for (int i = 0; i < parameters.Length; i++)
                {
                    if (parameters[i].ParameterType == typeof(IClientContext))
                    {
                        argList.Add("ctx");
                    }
                    else
                    {
                        argList.Add($"({SimplifyTypeName(parameters[i].ParameterType)})args[{argIndex}]");
                        argIndex++;
                    }
                }
                
                // å¤„ç† void è¿”å›ç±»å‹
                if (m.ReturnType == typeof(void))
                {
                    sb.AppendLine($"                case \"{m.Name}\": _impl.{m.Name}({string.Join(", ", argList)}); return null;");
                }
                else
                {
                    sb.AppendLine($"                case \"{m.Name}\": return _impl.{m.Name}({string.Join(", ", argList)});");
                }
            }
            sb.AppendLine($"                default: throw new Exception(\"Unknown method\");\n            }}\n        }}");
            sb.AppendLine("    }\n}");
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, $"{className}.cs"), sb.ToString());
        }

        static void GenerateBroadcastProxy(Type iface, string serviceName)
        {
            var sb = new StringBuilder();
            var ns = iface.Namespace + ".Generated";
            // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
            var className = (iface.Name.StartsWith("I") && iface.Name.Length > 1 && char.IsUpper(iface.Name[1])) 
                ? iface.Name.Substring(1) + "BroadcastProxy"
                : iface.Name + "BroadcastProxy";
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦çš„å‘½åç©ºé—´
            var namespaces = CollectNamespaces(iface);
            
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            foreach (var n in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {n};");
            }
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ‰€æœ‰å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {className} : {iface.FullName}");
            sb.AppendLine("    {");
            sb.AppendLine("        private readonly object _server;");
            sb.AppendLine($"        public {className}(object server) => _server = server;");
            sb.AppendLine();
            
            foreach (var m in iface.GetMethods())
            {
                var retType = SimplifyTypeName(m.ReturnType);
                var parameters = m.GetParameters();
                var paramList = string.Join(", ", parameters.Select(p => SimplifyTypeName(p.ParameterType) + " " + p.Name));
                var argNames = string.Join(", ", parameters.Select(p => p.Name));
                var argArray = parameters.Length > 0 ? $", {argNames}" : "";
                
                if (m.ReturnType == typeof(void))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList})");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            var method = _server.GetType().GetMethod(\"BroadcastToAll\").MakeGenericMethod(typeof({iface.FullName}));");
                    sb.AppendLine($"            method.Invoke(_server, new object[] {{ \"{m.Name}\", new object[] {{ {argNames} }} }});");
                    sb.AppendLine("        }");
                }
                else if (m.ReturnType.FullName.StartsWith("System.Threading.Tasks.Task"))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList})");
                    sb.AppendLine("        {");
                    sb.AppendLine("            // æ³¨æ„: å¹¿æ’­æ–¹æ³•ä¸æ”¯æŒè¿”å›å€¼");
                    sb.AppendLine($"            var method = _server.GetType().GetMethod(\"BroadcastToAll\").MakeGenericMethod(typeof({iface.FullName}));");
                    sb.AppendLine($"            method.Invoke(_server, new object[] {{ \"{m.Name}\", new object[] {{ {argNames} }} }});");
                    if (m.ReturnType.GenericTypeArguments.Length > 0)
                    {
                        sb.AppendLine($"            return Task.FromResult(default({SimplifyTypeName(m.ReturnType.GenericTypeArguments[0])}));");
                    }
                    else
                    {
                        sb.AppendLine("            return Task.CompletedTask;");
                    }
                    sb.AppendLine("        }");
                }
                sb.AppendLine();
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, $"{className}.cs"), sb.ToString());
        }

        static void GenerateClientsBroadcastProxy(Type iface, string serviceName)
        {
            var sb = new StringBuilder();
            var ns = iface.Namespace + ".Generated";
            // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
            var className = (iface.Name.StartsWith("I") && iface.Name.Length > 1 && char.IsUpper(iface.Name[1])) 
                ? iface.Name.Substring(1) + "ClientsBroadcastProxy"
                : iface.Name + "ClientsBroadcastProxy";
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦çš„å‘½åç©ºé—´
            var namespaces = CollectNamespaces(iface);
            
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Threading.Tasks;");
            foreach (var n in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {n};");
            }
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æŒ‡å®šå®¢æˆ·ç«¯åˆ—è¡¨å‘é€æ¶ˆæ¯");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {className} : {iface.FullName}");
            sb.AppendLine("    {");
            sb.AppendLine("        private readonly object _server;");
            sb.AppendLine("        private readonly IEnumerable<string> _clientIds;");
            sb.AppendLine($"        public {className}(object server, IEnumerable<string> clientIds)");
            sb.AppendLine("        {");
            sb.AppendLine("            _server = server;");
            sb.AppendLine("            _clientIds = clientIds;");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            foreach (var m in iface.GetMethods())
            {
                var retType = SimplifyTypeName(m.ReturnType);
                var parameters = m.GetParameters();
                var paramList = string.Join(", ", parameters.Select(p => SimplifyTypeName(p.ParameterType) + " " + p.Name));
                var argNames = string.Join(", ", parameters.Select(p => p.Name));
                
                if (m.ReturnType == typeof(void))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList})");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            var method = _server.GetType().GetMethod(\"BroadcastToClients\").MakeGenericMethod(typeof({iface.FullName}));");
                    sb.AppendLine($"            method.Invoke(_server, new object[] {{ _clientIds, \"{m.Name}\", new object[] {{ {argNames} }} }});");
                    sb.AppendLine("        }");
                }
                else if (m.ReturnType.FullName.StartsWith("System.Threading.Tasks.Task"))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList})");
                    sb.AppendLine("        {");
                    sb.AppendLine("            // æ³¨æ„: å¹¿æ’­æ–¹æ³•ä¸æ”¯æŒè¿”å›å€¼");
                    sb.AppendLine($"            var method = _server.GetType().GetMethod(\"BroadcastToClients\").MakeGenericMethod(typeof({iface.FullName}));");
                    sb.AppendLine($"            method.Invoke(_server, new object[] {{ _clientIds, \"{m.Name}\", new object[] {{ {argNames} }} }});");
                    if (m.ReturnType.GenericTypeArguments.Length > 0)
                    {
                        sb.AppendLine($"            return Task.FromResult(default({SimplifyTypeName(m.ReturnType.GenericTypeArguments[0])}));");
                    }
                    else
                    {
                        sb.AppendLine("            return Task.CompletedTask;");
                    }
                    sb.AppendLine("        }");
                }
                sb.AppendLine();
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, $"{className}.cs"), sb.ToString());
        }

        static void GenerateWhereBroadcastProxy(Type iface, string serviceName)
        {
            var sb = new StringBuilder();
            var ns = iface.Namespace + ".Generated";
            // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
            var className = (iface.Name.StartsWith("I") && iface.Name.Length > 1 && char.IsUpper(iface.Name[1])) 
                ? iface.Name.Substring(1) + "WhereBroadcastProxy"
                : iface.Name + "WhereBroadcastProxy";
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦çš„å‘½åç©ºé—´
            var namespaces = CollectNamespaces(iface);
            
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            foreach (var n in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {n};");
            }
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// å¹¿æ’­ä»£ç† - ç”¨äºå‘æ»¡è¶³æ¡ä»¶çš„å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {className} : {iface.FullName}");
            sb.AppendLine("    {");
            sb.AppendLine("        private readonly object _server;");
            sb.AppendLine("        private readonly Func<string, bool> _predicate;");
            sb.AppendLine($"        public {className}(object server, Func<string, bool> predicate)");
            sb.AppendLine("        {");
            sb.AppendLine("            _server = server;");
            sb.AppendLine("            _predicate = predicate;");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            foreach (var m in iface.GetMethods())
            {
                var retType = SimplifyTypeName(m.ReturnType);
                var parameters = m.GetParameters();
                var paramList = string.Join(", ", parameters.Select(p => SimplifyTypeName(p.ParameterType) + " " + p.Name));
                var argNames = string.Join(", ", parameters.Select(p => p.Name));
                
                if (m.ReturnType == typeof(void))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList})");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            var method = _server.GetType().GetMethod(\"BroadcastWhere\").MakeGenericMethod(typeof({iface.FullName}));");
                    sb.AppendLine($"            method.Invoke(_server, new object[] {{ _predicate, \"{m.Name}\", new object[] {{ {argNames} }} }});");
                    sb.AppendLine("        }");
                }
                else if (m.ReturnType.FullName.StartsWith("System.Threading.Tasks.Task"))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList})");
                    sb.AppendLine("        {");
                    sb.AppendLine("            // æ³¨æ„: å¹¿æ’­æ–¹æ³•ä¸æ”¯æŒè¿”å›å€¼");
                    sb.AppendLine($"            var method = _server.GetType().GetMethod(\"BroadcastWhere\").MakeGenericMethod(typeof({iface.FullName}));");
                    sb.AppendLine($"            method.Invoke(_server, new object[] {{ _predicate, \"{m.Name}\", new object[] {{ {argNames} }} }});");
                    if (m.ReturnType.GenericTypeArguments.Length > 0)
                    {
                        sb.AppendLine($"            return Task.FromResult(default({SimplifyTypeName(m.ReturnType.GenericTypeArguments[0])}));");
                    }
                    else
                    {
                        sb.AppendLine("            return Task.CompletedTask;");
                    }
                    sb.AppendLine("        }");
                }
                sb.AppendLine();
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, $"{className}.cs"), sb.ToString());
        }

        static void GenerateClientCallProxy(Type iface, string serviceName)
        {
            var sb = new StringBuilder();
            var ns = iface.Namespace + ".Generated";
            // ä¿®å¤ï¼šåªç§»é™¤ç¬¬ä¸€ä¸ª 'I' å­—ç¬¦
            var className = (iface.Name.StartsWith("I") && iface.Name.Length > 1 && char.IsUpper(iface.Name[1])) 
                ? iface.Name.Substring(1) + "ClientCallProxy"
                : iface.Name + "ClientCallProxy";
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦çš„å‘½åç©ºé—´
            var namespaces = CollectNamespaces(iface);
            
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using DuckyNet.Shared.RPC;");
            foreach (var n in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {n};");
            }
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// å•å®¢æˆ·ç«¯è°ƒç”¨ä»£ç† - ç”¨äºå‘ç‰¹å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public class {className} : {iface.FullName}");
            sb.AppendLine("    {");
            sb.AppendLine("        private readonly IClientContext _client;");
            sb.AppendLine($"        public {className}(IClientContext client) => _client = client;");
            sb.AppendLine();
            
            foreach (var m in iface.GetMethods())
            {
                var retType = SimplifyTypeName(m.ReturnType);
                var parameters = m.GetParameters();
                var paramList = string.Join(", ", parameters.Select(p => SimplifyTypeName(p.ParameterType) + " " + p.Name));
                var argNames = string.Join(", ", parameters.Select(p => p.Name));
                
                if (m.ReturnType == typeof(void))
                {
                    sb.AppendLine($"        public {retType} {m.Name}({paramList}) => _client.Invoke<{iface.FullName}>(\"{m.Name}\"{(argNames.Length > 0 ? ", " + argNames : "")});");
                }
                else if (m.ReturnType.FullName.StartsWith("System.Threading.Tasks.Task"))
                {
                    var genericArg = m.ReturnType.GenericTypeArguments.Length > 0 ? SimplifyTypeName(m.ReturnType.GenericTypeArguments[0]) : "object";
                    sb.AppendLine($"        public {retType} {m.Name}({paramList}) => _client.InvokeAsync<{iface.FullName}, {genericArg}>(\"{m.Name}\"{(argNames.Length > 0 ? ", " + argNames : "")});");
                }
                sb.AppendLine();
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, $"{className}.cs"), sb.ToString());
        }

        static void GenerateTypeRegister(List<Type> interfaces)
        {
            // æ”¶é›†æ‰€æœ‰éœ€è¦åºåˆ—åŒ–çš„ç±»å‹
            var allTypes = new HashSet<Type>();
            
            foreach (var iface in interfaces)
            {
                foreach (var method in iface.GetMethods())
                {
                    // æ·»åŠ å‚æ•°ç±»å‹
                    foreach (var param in method.GetParameters())
                    {
                        AddSerializableType(allTypes, param.ParameterType);
                    }
                    
                    // æ·»åŠ è¿”å›å€¼ç±»å‹
                    AddSerializableType(allTypes, method.ReturnType);
                }
            }
            
            // ç”Ÿæˆç±»å‹æ³¨å†Œä»£ç 
            var sb = new StringBuilder();
            sb.AppendLine("// è‡ªåŠ¨ç”Ÿæˆçš„ç±»å‹æ³¨å†Œä»£ç ");
            sb.AppendLine("// ç”± RpcCodeGen å·¥å…·è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine("namespace DuckyNet.Shared.RPC.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// è‡ªåŠ¨ç”Ÿæˆçš„ RPC åºåˆ—åŒ–ç±»å‹æ³¨å†Œè¡¨");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class RpcTypeRegistry");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// è·å–æ‰€æœ‰éœ€è¦åºåˆ—åŒ–çš„ç±»å‹");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static List<Type> GetSerializableTypes()");
            sb.AppendLine("        {");
            sb.AppendLine("            return new List<Type>");
            sb.AppendLine("            {");
            sb.AppendLine("                // åŸºç¡€ç±»å‹");
            sb.AppendLine("                typeof(string),");
            sb.AppendLine("                typeof(int),");
            sb.AppendLine("                typeof(long),");
            sb.AppendLine("                typeof(float),");
            sb.AppendLine("                typeof(double),");
            sb.AppendLine("                typeof(bool),");
            sb.AppendLine("                typeof(byte[]),");
            sb.AppendLine("                typeof(object[]),");
            sb.AppendLine("                typeof(DateTime),");
            sb.AppendLine();
            sb.AppendLine("                // RPC æ¶ˆæ¯ç±»å‹");
            sb.AppendLine("                typeof(DuckyNet.Shared.RPC.RpcMessage),");
            sb.AppendLine("                typeof(DuckyNet.Shared.RPC.RpcResponse),");
            sb.AppendLine();
            sb.AppendLine("                // åº”ç”¨æ•°æ®ç±»å‹ (è‡ªåŠ¨å‘ç°)");
            
            foreach (var type in allTypes.OrderBy(t => t.FullName))
            {
                sb.AppendLine($"                typeof({GetTypeofString(type)}),");
            }
            
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            var solutionDir = FindSolutionDirectory(AppDomain.CurrentDomain.BaseDirectory);
            var outputDir = Path.Combine(solutionDir, "Shared", "Generated");
            Directory.CreateDirectory(outputDir);
            File.WriteAllText(Path.Combine(outputDir, "RpcTypeRegistry.cs"), sb.ToString());
            
            Console.WriteLine($"[CodeGen] Generated type registry with {allTypes.Count} types");
        }
        
        static void AddSerializableType(HashSet<Type> types, Type type)
        {
            // è·³è¿‡ä¸éœ€è¦åºåˆ—åŒ–çš„ç±»å‹
            if (type == null || 
                type == typeof(void) || 
                type == typeof(IClientContext) ||
                type.IsInterface ||
                type.IsPrimitive ||
                type == typeof(string) ||
                type == typeof(DateTime) ||
                type.IsGenericTypeDefinition)
            {
                return;
            }
            
            // è·³è¿‡æ‰€æœ‰ Task ç±»å‹ï¼ˆåŒ…æ‹¬ Task å’Œ Task<T>ï¼‰
            if (type == typeof(Task) || 
                (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Task<>)))
            {
                // Task æœ¬èº«ä¸èƒ½è¢«åºåˆ—åŒ–
                // å¯¹äº Task<T>ï¼Œåªåºåˆ—åŒ–å…¶ç»“æœç±»å‹ T
                if (type.IsGenericType)
                {
                    var genericArg = type.GetGenericArguments()[0];
                    AddSerializableType(types, genericArg);
                }
                return;
            }
            
            // å¤„ç†æ•°ç»„ç±»å‹
            if (type.IsArray)
            {
                types.Add(type);
                AddSerializableType(types, type.GetElementType());
                return;
            }
            
            // æ·»åŠ è‡ªå®šä¹‰ç±»å‹
            if (!types.Contains(type))
            {
                types.Add(type);
            }
        }

        /// <summary>
        /// æ¸…ç†æ—§çš„ç”Ÿæˆæ–‡ä»¶
        /// </summary>
        static void CleanGeneratedFiles(string solutionDir)
        {
            var generatedDir = Path.Combine(solutionDir, "Shared", "Generated");
            if (!Directory.Exists(generatedDir))
            {
                Console.WriteLine("[CodeGen] Generated ç›®å½•ä¸å­˜åœ¨ï¼Œå°†åˆ›å»º");
                Directory.CreateDirectory(generatedDir);
                return;
            }
            
            // åˆ é™¤æ‰€æœ‰ .cs æ–‡ä»¶ï¼ˆæ‰€æœ‰ç”Ÿæˆçš„æ–‡ä»¶éƒ½æ˜¯ .cs æ–‡ä»¶ï¼‰
            var files = Directory.GetFiles(generatedDir, "*.cs");
            var deletedCount = 0;
            foreach (var file in files)
            {
                try
                {
                    File.Delete(file);
                    deletedCount++;
                    Console.WriteLine($"[CodeGen] å·²åˆ é™¤æ—§æ–‡ä»¶: {Path.GetFileName(file)}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[CodeGen] åˆ é™¤æ–‡ä»¶å¤±è´¥ {Path.GetFileName(file)}: {ex.Message}");
                }
            }
            
            if (deletedCount > 0)
            {
                Console.WriteLine($"[CodeGen] å·²æ¸…ç† {deletedCount} ä¸ªæ—§ç”Ÿæˆæ–‡ä»¶");
            }
            else
            {
                Console.WriteLine("[CodeGen] æ²¡æœ‰æ‰¾åˆ°éœ€è¦æ¸…ç†çš„æ—§æ–‡ä»¶");
            }
        }

        static string FindSolutionDirectory(string startDir)
        {
            var dir = new DirectoryInfo(startDir);
            while (dir != null)
            {
                if (File.Exists(Path.Combine(dir.FullName, "DuckyNet.sln")))
                {
                    return dir.FullName;
                }
                dir = dir.Parent;
            }
            throw new DirectoryNotFoundException("Could not find solution directory containing DuckyNet.sln");
        }

        static string SimplifyTypeName(Type type)
        {
            if (type == typeof(void)) return "void";
            if (type == typeof(int)) return "int";
            if (type == typeof(string)) return "string";
            if (type == typeof(bool)) return "bool";
            if (type == typeof(long)) return "long";
            if (type == typeof(float)) return "float";
            if (type == typeof(double)) return "double";
            if (type == typeof(DateTime)) return "DateTime";

            // å¤„ç†æ•°ç»„ç±»å‹
            if (type.IsArray)
            {
                return SimplifyTypeName(type.GetElementType()) + "[]";
            }

            // å¤„ç†æ³›å‹ç±»å‹
            if (type.IsGenericType)
            {
                var genericType = type.GetGenericTypeDefinition();
                if (genericType == typeof(Task<>))
                {
                    var argType = SimplifyTypeName(type.GenericTypeArguments[0]);
                    return $"Task<{argType}>";
                }
                // å¯ä»¥æ‰©å±•å…¶ä»–æ³›å‹ç±»å‹
            }

            // å¯¹äºè‡ªå®šä¹‰ç±»å‹ï¼Œè¿”å›ç®€åŒ–çš„åç§°ï¼ˆå»æ‰å‘½åç©ºé—´å‰ç¼€ï¼Œå¦‚æœåœ¨å½“å‰ä¸Šä¸‹æ–‡ä¸­ï¼‰
            return type.Name;
        }
        
        /// <summary>
        /// ç”Ÿæˆç”¨äº typeof() çš„ç±»å‹å­—ç¬¦ä¸²
        /// </summary>
        static string GetTypeofString(Type type)
        {
            // å¤„ç†æ•°ç»„ç±»å‹
            if (type.IsArray)
            {
                return GetTypeofString(type.GetElementType()) + "[]";
            }
            
            // å¤„ç†æ³›å‹ç±»å‹
            if (type.IsGenericType)
            {
                var genericTypeDef = type.GetGenericTypeDefinition();
                var genericArgs = type.GetGenericArguments();
                
                // è·å–æ³›å‹ç±»å‹çš„å®Œæ•´åç§°ï¼ˆä¸åŒ…å«æ³›å‹å‚æ•°ï¼‰
                var genericTypeName = genericTypeDef.FullName;
                if (genericTypeName == null)
                {
                    return type.FullName;
                }
                
                // ç§»é™¤æ³›å‹å‚æ•°å ä½ç¬¦ `1, `2 ç­‰
                var tickIndex = genericTypeName.IndexOf('`');
                if (tickIndex > 0)
                {
                    genericTypeName = genericTypeName.Substring(0, tickIndex);
                }
                
                // æ„å»ºæ³›å‹å‚æ•°å­—ç¬¦ä¸²
                var argStrings = genericArgs.Select(GetTypeofString);
                return $"{genericTypeName}<{string.Join(", ", argStrings)}>";
            }
            
            // å¯¹äºéæ³›å‹ç±»å‹ï¼Œç›´æ¥è¿”å›å®Œæ•´åç§°
            return type.FullName ?? type.Name;
        }
        
        /// <summary>
        /// æ”¶é›†æ¥å£ä¸­æ‰€æœ‰å‚æ•°å’Œè¿”å›å€¼ç±»å‹æ‰€éœ€çš„å‘½åç©ºé—´
        /// </summary>
        static HashSet<string> CollectNamespaces(Type iface)
        {
            var namespaces = new HashSet<string>();
            
            foreach (var method in iface.GetMethods())
            {
                // æ”¶é›†å‚æ•°ç±»å‹çš„å‘½åç©ºé—´
                foreach (var param in method.GetParameters())
                {
                    AddNamespace(namespaces, param.ParameterType);
                }
                
                // æ”¶é›†è¿”å›å€¼ç±»å‹çš„å‘½åç©ºé—´
                AddNamespace(namespaces, method.ReturnType);
            }
            
            // ç§»é™¤Systemå‘½åç©ºé—´ï¼ˆå·²ç»é»˜è®¤åŒ…å«ï¼‰å’Œå½“å‰å‘½åç©ºé—´
            namespaces.Remove("System");
            namespaces.Remove("System.Threading.Tasks");
            namespaces.Remove("DuckyNet.Shared.RPC");
            namespaces.Remove(iface.Namespace);
            namespaces.Remove(iface.Namespace + ".Generated");
            
            return namespaces;
        }
        
        /// <summary>
        /// æ·»åŠ ç±»å‹æ‰€å±çš„å‘½åç©ºé—´
        /// </summary>
        static void AddNamespace(HashSet<string> namespaces, Type type)
        {
            if (type == null || type == typeof(void) || type.IsPrimitive || type == typeof(string))
            {
                return;
            }
            
            // å¤„ç†æ•°ç»„ç±»å‹
            if (type.IsArray)
            {
                AddNamespace(namespaces, type.GetElementType());
                return;
            }
            
            // å¤„ç†æ³›å‹ç±»å‹ï¼ˆå¦‚ Task<T>ï¼‰
            if (type.IsGenericType)
            {
                // æ·»åŠ æ³›å‹å®šä¹‰çš„å‘½åç©ºé—´
                var genericTypeDef = type.GetGenericTypeDefinition();
                if (!string.IsNullOrEmpty(genericTypeDef.Namespace))
                {
                    namespaces.Add(genericTypeDef.Namespace);
                }
                
                // é€’å½’å¤„ç†æ³›å‹å‚æ•°
                foreach (var arg in type.GetGenericArguments())
                {
                    AddNamespace(namespaces, arg);
                }
                return;
            }
            
            // æ·»åŠ ç±»å‹çš„å‘½åç©ºé—´
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                namespaces.Add(type.Namespace);
            }
        }
    }
}

```

`Tools\RpcCodeGen\RpcCodeGen.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\Shared\DuckyNetShared.csproj" />
  </ItemGroup>

</Project>

```

`WebAdmin\README.md`:

```md
# DuckyNet Web Admin - å‰ç«¯é¡¹ç›®

åŸºäº **Vue 3** + **Vite** çš„ DuckyNet æœåŠ¡å™¨ç®¡ç†åå°ç•Œé¢ï¼ˆSteamé£æ ¼ï¼‰

## ç‰¹æ€§

- ğŸ¨ Steam é£æ ¼UIè®¾è®¡
- âš¡ï¸ Vite å¿«é€Ÿå¼€å‘ä½“éªŒ
- ğŸ”„ WebSocket å®æ—¶æ•°æ®æ¨é€
- ğŸ“Š å®æ—¶æœåŠ¡å™¨çŠ¶æ€ç›‘æ§
- ğŸ  æˆ¿é—´ç®¡ç†
- ğŸ‘¥ ç©å®¶ç®¡ç†
- ğŸ—ºï¸ åœºæ™¯ç®¡ç†
- ğŸ¤– NPC ç›‘æ§

## æŠ€æœ¯æ ˆ

- Vue 3 (Composition API)
- Vite
- Axios (HTTPè¯·æ±‚)
- WebSocket (å®æ—¶é€šä¿¡)

## å¿«é€Ÿå¼€å§‹

### 1. å®‰è£…ä¾èµ–

```bash
npm install
```

### 2. å¯åŠ¨å¼€å‘æœåŠ¡å™¨

```bash
npm run dev
```

æµè§ˆå™¨è®¿é—®ï¼šhttp://localhost:3000

### 3. æ„å»ºç”Ÿäº§ç‰ˆæœ¬

```bash
npm run build
```

æ„å»ºäº§ç‰©åœ¨ `dist/` ç›®å½•

### 4. é¢„è§ˆç”Ÿäº§æ„å»º

```bash
npm run preview
```

## é…ç½®

### ç¯å¢ƒå˜é‡

åœ¨ `.env` æ–‡ä»¶ä¸­é…ç½® API åœ°å€ï¼š

```env
VITE_API_BASE_URL=http://localhost:5000
VITE_WS_BASE_URL=ws://localhost:5000
```

ç”Ÿäº§ç¯å¢ƒåœ¨ `.env.production` ä¸­é…ç½®

## ç›®å½•ç»“æ„

```
WebAdmin/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ App.vue              # ä¸»åº”ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ main.js              # å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ assets/              # é™æ€èµ„æº
â”‚   â”‚   â””â”€â”€ steam-style.css  # Steamæ ·å¼
â”‚   â””â”€â”€ services/            # æœåŠ¡å±‚
â”‚       â””â”€â”€ api.js           # APIå’ŒWebSocket
â”œâ”€â”€ index.html               # HTMLæ¨¡æ¿
â”œâ”€â”€ vite.config.js           # Viteé…ç½®
â”œâ”€â”€ package.json             # ä¾èµ–é…ç½®
â””â”€â”€ README.md                # æœ¬æ–‡æ¡£
```

## APIç«¯ç‚¹

### REST API
- `GET /api/dashboard/overview` - æœåŠ¡å™¨æ¦‚è§ˆ
- `GET /api/rooms` - æˆ¿é—´åˆ—è¡¨
- `GET /api/rooms/{roomId}` - æˆ¿é—´è¯¦æƒ…
- `GET /api/players` - ç©å®¶åˆ—è¡¨
- `GET /api/scenes` - åœºæ™¯åˆ—è¡¨
- `GET /api/scenes/{sceneName}/{subSceneName}` - åœºæ™¯è¯¦æƒ…

### WebSocket
- `ws://localhost:5000/ws` - å®æ—¶æ•°æ®æ¨é€

## å¼€å‘è¯´æ˜

### ä¿®æ”¹ç«¯å£

åœ¨ `vite.config.js` ä¸­ä¿®æ”¹ï¼š

```javascript
server: {
  port: 3000  // ä¿®æ”¹ä¸ºä½ éœ€è¦çš„ç«¯å£
}
```

### ä¿®æ”¹APIåœ°å€

åœ¨ `.env` æ–‡ä»¶ä¸­ä¿®æ”¹

### æ·»åŠ æ–°åŠŸèƒ½

1. åœ¨ `src/App.vue` çš„ `data()` ä¸­æ·»åŠ å“åº”å¼æ•°æ®
2. åœ¨ `methods` ä¸­æ·»åŠ æ–¹æ³•
3. åœ¨ `template` ä¸­æ·»åŠ UI

## éƒ¨ç½²

### éƒ¨ç½²åˆ°é™æ€æœåŠ¡å™¨

```bash
npm run build
# å°† dist/ ç›®å½•éƒ¨ç½²åˆ° Nginx/Apache ç­‰
```

### Nginx é…ç½®ç¤ºä¾‹

```nginx
server {
    listen 80;
    server_name your-domain.com;
    
    location / {
        root /path/to/dist;
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://localhost:5000;
    }
    
    location /ws {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

## æ³¨æ„äº‹é¡¹

1. ç¡®ä¿åç«¯Serveræ­£åœ¨è¿è¡Œï¼ˆç«¯å£5000ï¼‰
2. WebSocketéœ€è¦åç«¯æ”¯æŒ
3. å¼€å‘æ¨¡å¼ä¸‹Viteä¼šè‡ªåŠ¨ä»£ç†APIè¯·æ±‚

## è®¸å¯è¯

ä¸ DuckyNet é¡¹ç›®ä¿æŒä¸€è‡´


```

`WebAdmin\index.html`:

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DuckyNet æœåŠ¡å™¨ç®¡ç†åå°</title>
</head>
<body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
</body>
</html>


```

`WebAdmin\package-lock.json`:

```json
{
  "name": "duckynet-web-admin",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "duckynet-web-admin",
      "version": "1.0.0",
      "dependencies": {
        "@mdi/font": "^7.4.0",
        "axios": "^1.6.0",
        "pinia": "^2.1.0",
        "vue": "^3.4.0",
        "vue-router": "^4.2.0",
        "vuetify": "^3.5.0"
      },
      "devDependencies": {
        "@vitejs/plugin-vue": "^5.0.0",
        "vite": "^5.0.0",
        "vite-plugin-vuetify": "^2.0.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.5.tgz",
      "integrity": "sha512-KKBU1VGYR7ORr3At5HAtUQ+TV3SzRCXmA/8OdDZiLDBIZxVyzXuztPjfLd3BV1PRAQGCMWWSHYhL0F8d5uHBDQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.5"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.5.tgz",
      "integrity": "sha512-qQ5m48eI/MFLQ5PxQj4PFaprjyCTLI37ElWMmNs0K8Lk3dVeOdNpB3ks8jc7yM5CDmVC73eMVk/trk3fgmrUpA==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "license": "MIT"
    },
    "node_modules/@mdi/font": {
      "version": "7.4.47",
      "resolved": "https://registry.npmjs.org/@mdi/font/-/font-7.4.47.tgz",
      "integrity": "sha512-43MtGpd585SNzHZPcYowu/84Vz2a2g31TvPMTm9uTiCSWzaheQySUcSyUH/46fPnuPQWof2yd0pGBtzee/IQWw==",
      "license": "Apache-2.0"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.53.2.tgz",
      "integrity": "sha512-yDPzwsgiFO26RJA4nZo8I+xqzh7sJTZIWQOxn+/XOdPE31lAvLIYCKqjV+lNH/vxE2L2iH3plKxDCRK6i+CwhA==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.53.2.tgz",
      "integrity": "sha512-k8FontTxIE7b0/OGKeSN5B6j25EuppBcWM33Z19JoVT7UTXFSo3D9CdU39wGTeb29NO3XxpMNauh09B+Ibw+9g==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.53.2.tgz",
      "integrity": "sha512-A6s4gJpomNBtJ2yioj8bflM2oogDwzUiMl2yNJ2v9E7++sHrSrsQ29fOfn5DM/iCzpWcebNYEdXpaK4tr2RhfQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.53.2.tgz",
      "integrity": "sha512-e6XqVmXlHrBlG56obu9gDRPW3O3hLxpwHpLsBJvuI8qqnsrtSZ9ERoWUXtPOkY8c78WghyPHZdmPhHLWNdAGEw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.53.2.tgz",
      "integrity": "sha512-v0E9lJW8VsrwPux5Qe5CwmH/CF/2mQs6xU1MF3nmUxmZUCHazCjLgYvToOk+YuuUqLQBio1qkkREhxhc656ViA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.53.2.tgz",
      "integrity": "sha512-ClAmAPx3ZCHtp6ysl4XEhWU69GUB1D+s7G9YjHGhIGCSrsg00nEGRRZHmINYxkdoJehde8VIsDC5t9C0gb6yqA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.53.2.tgz",
      "integrity": "sha512-EPlb95nUsz6Dd9Qy13fI5kUPXNSljaG9FiJ4YUGU1O/Q77i5DYFW5KR8g1OzTcdZUqQQ1KdDqsTohdFVwCwjqg==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.53.2.tgz",
      "integrity": "sha512-BOmnVW+khAUX+YZvNfa0tGTEMVVEerOxN0pDk2E6N6DsEIa2Ctj48FOMfNDdrwinocKaC7YXUZ1pHlKpnkja/Q==",
      "cpu": [
        "arm"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.53.2.tgz",
      "integrity": "sha512-Xt2byDZ+6OVNuREgBXr4+CZDJtrVso5woFtpKdGPhpTPHcNG7D8YXeQzpNbFRxzTVqJf7kvPMCub/pcGUWgBjA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.53.2.tgz",
      "integrity": "sha512-+LdZSldy/I9N8+klim/Y1HsKbJ3BbInHav5qE9Iy77dtHC/pibw1SR/fXlWyAk0ThnpRKoODwnAuSjqxFRDHUQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.53.2.tgz",
      "integrity": "sha512-8ms8sjmyc1jWJS6WdNSA23rEfdjWB30LH8Wqj0Cqvv7qSHnvw6kgMMXRdop6hkmGPlyYBdRPkjJnj3KCUHV/uQ==",
      "cpu": [
        "loong64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.53.2.tgz",
      "integrity": "sha512-3HRQLUQbpBDMmzoxPJYd3W6vrVHOo2cVW8RUo87Xz0JPJcBLBr5kZ1pGcQAhdZgX9VV7NbGNipah1omKKe23/g==",
      "cpu": [
        "ppc64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.53.2.tgz",
      "integrity": "sha512-fMjKi+ojnmIvhk34gZP94vjogXNNUKMEYs+EDaB/5TG/wUkoeua7p7VCHnE6T2Tx+iaghAqQX8teQzcvrYpaQA==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.53.2.tgz",
      "integrity": "sha512-XuGFGU+VwUUV5kLvoAdi0Wz5Xbh2SrjIxCtZj6Wq8MDp4bflb/+ThZsVxokM7n0pcbkEr2h5/pzqzDYI7cCgLQ==",
      "cpu": [
        "riscv64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.53.2.tgz",
      "integrity": "sha512-w6yjZF0P+NGzWR3AXWX9zc0DNEGdtvykB03uhonSHMRa+oWA6novflo2WaJr6JZakG2ucsyb+rvhrKac6NIy+w==",
      "cpu": [
        "s390x"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.53.2.tgz",
      "integrity": "sha512-yo8d6tdfdeBArzC7T/PnHd7OypfI9cbuZzPnzLJIyKYFhAQ8SvlkKtKBMbXDxe1h03Rcr7u++nFS7tqXz87Gtw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.53.2.tgz",
      "integrity": "sha512-ah59c1YkCxKExPP8O9PwOvs+XRLKwh/mV+3YdKqQ5AMQ0r4M4ZDuOrpWkUaqO7fzAHdINzV9tEVu8vNw48z0lA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.53.2.tgz",
      "integrity": "sha512-4VEd19Wmhr+Zy7hbUsFZ6YXEiP48hE//KPLCSVNY5RMGX2/7HZ+QkN55a3atM1C/BZCGIgqN+xrVgtdak2S9+A==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.53.2.tgz",
      "integrity": "sha512-IlbHFYc/pQCgew/d5fslcy1KEaYVCJ44G8pajugd8VoOEI8ODhtb/j8XMhLpwHCMB3yk2J07ctup10gpw2nyMA==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.53.2.tgz",
      "integrity": "sha512-lNlPEGgdUfSzdCWU176ku/dQRnA7W+Gp8d+cWv73jYrb8uT7HTVVxq62DUYxjbaByuf1Yk0RIIAbDzp+CnOTFg==",
      "cpu": [
        "ia32"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.53.2.tgz",
      "integrity": "sha512-S6YojNVrHybQis2lYov1sd+uj7K0Q05NxHcGktuMMdIQ2VixGwAfbJ23NnlvvVV1bdpR2m5MsNBViHJKcA4ADw==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.53.2.tgz",
      "integrity": "sha512-k+/Rkcyx//P6fetPoLMb8pBeqJBNGx81uuf7iljX9++yNBVRDQgD04L+SVXmXmh5ZP4/WOp4mWF0kmi06PW2tA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/@vitejs/plugin-vue": {
      "version": "5.2.4",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-vue/-/plugin-vue-5.2.4.tgz",
      "integrity": "sha512-7Yx/SXSOcQq5HiiV3orevHUFn+pmMB4cgbEkDYgnkUWb0WfeQ/wa2yFv6D5ICiCQOVpjA7vYDXrC7AGO8yjDHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "peerDependencies": {
        "vite": "^5.0.0 || ^6.0.0",
        "vue": "^3.2.25"
      }
    },
    "node_modules/@vue/compiler-core": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/compiler-core/-/compiler-core-3.5.24.tgz",
      "integrity": "sha512-eDl5H57AOpNakGNAkFDH+y7kTqrQpJkZFXhWZQGyx/5Wh7B1uQYvcWkvZi11BDhscPgj8N7XV3oRwiPnx1Vrig==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.5",
        "@vue/shared": "3.5.24",
        "entities": "^4.5.0",
        "estree-walker": "^2.0.2",
        "source-map-js": "^1.2.1"
      }
    },
    "node_modules/@vue/compiler-dom": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/compiler-dom/-/compiler-dom-3.5.24.tgz",
      "integrity": "sha512-1QHGAvs53gXkWdd3ZMGYuvQFXHW4ksKWPG8HP8/2BscrbZ0brw183q2oNWjMrSWImYLHxHrx1ItBQr50I/q2zw==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-core": "3.5.24",
        "@vue/shared": "3.5.24"
      }
    },
    "node_modules/@vue/compiler-sfc": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/compiler-sfc/-/compiler-sfc-3.5.24.tgz",
      "integrity": "sha512-8EG5YPRgmTB+YxYBM3VXy8zHD9SWHUJLIGPhDovo3Z8VOgvP+O7UP5vl0J4BBPWYD9vxtBabzW1EuEZ+Cqs14g==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.5",
        "@vue/compiler-core": "3.5.24",
        "@vue/compiler-dom": "3.5.24",
        "@vue/compiler-ssr": "3.5.24",
        "@vue/shared": "3.5.24",
        "estree-walker": "^2.0.2",
        "magic-string": "^0.30.21",
        "postcss": "^8.5.6",
        "source-map-js": "^1.2.1"
      }
    },
    "node_modules/@vue/compiler-ssr": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/compiler-ssr/-/compiler-ssr-3.5.24.tgz",
      "integrity": "sha512-trOvMWNBMQ/odMRHW7Ae1CdfYx+7MuiQu62Jtu36gMLXcaoqKvAyh+P73sYG9ll+6jLB6QPovqoKGGZROzkFFg==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-dom": "3.5.24",
        "@vue/shared": "3.5.24"
      }
    },
    "node_modules/@vue/devtools-api": {
      "version": "6.6.4",
      "resolved": "https://registry.npmjs.org/@vue/devtools-api/-/devtools-api-6.6.4.tgz",
      "integrity": "sha512-sGhTPMuXqZ1rVOk32RylztWkfXTRhuS7vgAKv0zjqk8gbsHkJ7xfFf+jbySxt7tWObEJwyKaHMikV/WGDiQm8g==",
      "license": "MIT"
    },
    "node_modules/@vue/reactivity": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/reactivity/-/reactivity-3.5.24.tgz",
      "integrity": "sha512-BM8kBhtlkkbnyl4q+HiF5R5BL0ycDPfihowulm02q3WYp2vxgPcJuZO866qa/0u3idbMntKEtVNuAUp5bw4teg==",
      "license": "MIT",
      "dependencies": {
        "@vue/shared": "3.5.24"
      }
    },
    "node_modules/@vue/runtime-core": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/runtime-core/-/runtime-core-3.5.24.tgz",
      "integrity": "sha512-RYP/byyKDgNIqfX/gNb2PB55dJmM97jc9wyF3jK7QUInYKypK2exmZMNwnjueWwGceEkP6NChd3D2ZVEp9undQ==",
      "license": "MIT",
      "dependencies": {
        "@vue/reactivity": "3.5.24",
        "@vue/shared": "3.5.24"
      }
    },
    "node_modules/@vue/runtime-dom": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/runtime-dom/-/runtime-dom-3.5.24.tgz",
      "integrity": "sha512-Z8ANhr/i0XIluonHVjbUkjvn+CyrxbXRIxR7wn7+X7xlcb7dJsfITZbkVOeJZdP8VZwfrWRsWdShH6pngMxRjw==",
      "license": "MIT",
      "dependencies": {
        "@vue/reactivity": "3.5.24",
        "@vue/runtime-core": "3.5.24",
        "@vue/shared": "3.5.24",
        "csstype": "^3.1.3"
      }
    },
    "node_modules/@vue/server-renderer": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/server-renderer/-/server-renderer-3.5.24.tgz",
      "integrity": "sha512-Yh2j2Y4G/0/4z/xJ1Bad4mxaAk++C2v4kaa8oSYTMJBJ00/ndPuxCnWeot0/7/qafQFLh5pr6xeV6SdMcE/G1w==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-ssr": "3.5.24",
        "@vue/shared": "3.5.24"
      },
      "peerDependencies": {
        "vue": "3.5.24"
      }
    },
    "node_modules/@vue/shared": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/@vue/shared/-/shared-3.5.24.tgz",
      "integrity": "sha512-9cwHL2EsJBdi8NY22pngYYWzkTDhld6fAD6jlaeloNGciNSJL6bLpbxVgXl96X00Jtc6YWQv96YA/0sxex/k1A==",
      "license": "MIT"
    },
    "node_modules/@vuetify/loader-shared": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/@vuetify/loader-shared/-/loader-shared-2.1.1.tgz",
      "integrity": "sha512-jSZTzTYaoiv8iwonFCVZQ0YYX/M+Uyl4ng+C4egMJT0Hcmh9gIxJL89qfZICDeo3g0IhqrvipW2FFKKRDMtVcA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "upath": "^2.0.1"
      },
      "peerDependencies": {
        "vue": "^3.0.0",
        "vuetify": "^3.0.0"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/axios": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.2.tgz",
      "integrity": "sha512-VPk9ebNqPcy5lRGuSlKx752IlDatOjT9paPlm8A7yOuW2Fbvp4X3JznJtT4f0GzGLLiWE9W8onz51SqLYwzGaA==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.4",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/entities": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/entities/-/entities-4.5.0.tgz",
      "integrity": "sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/estree-walker": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-2.0.2.tgz",
      "integrity": "sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==",
      "license": "MIT"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz",
      "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.21",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.21.tgz",
      "integrity": "sha512-vd2F4YUyEXKGcLHoq+TEyCjxueSeHnFxyyjNp80yg0XV4vUhnDer/lvvlqM/arB5bXQN5K2/3oinyCRyx8T2CQ==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/pinia": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/pinia/-/pinia-2.3.1.tgz",
      "integrity": "sha512-khUlZSwt9xXCaTbbxFYBKDc/bWAGWJjOgvxETwkTN7KRm66EeT1ZdZj6i2ceh9sP2Pzqsbc704r2yngBrxBVug==",
      "license": "MIT",
      "dependencies": {
        "@vue/devtools-api": "^6.6.3",
        "vue-demi": "^0.14.10"
      },
      "funding": {
        "url": "https://github.com/sponsors/posva"
      },
      "peerDependencies": {
        "typescript": ">=4.4.4",
        "vue": "^2.7.0 || ^3.5.11"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/rollup": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.53.2.tgz",
      "integrity": "sha512-MHngMYwGJVi6Fmnk6ISmnk7JAHRNF0UkuucA0CUW3N3a4KnONPEZz+vUanQP/ZC/iY1Qkf3bwPWzyY84wEks1g==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.53.2",
        "@rollup/rollup-android-arm64": "4.53.2",
        "@rollup/rollup-darwin-arm64": "4.53.2",
        "@rollup/rollup-darwin-x64": "4.53.2",
        "@rollup/rollup-freebsd-arm64": "4.53.2",
        "@rollup/rollup-freebsd-x64": "4.53.2",
        "@rollup/rollup-linux-arm-gnueabihf": "4.53.2",
        "@rollup/rollup-linux-arm-musleabihf": "4.53.2",
        "@rollup/rollup-linux-arm64-gnu": "4.53.2",
        "@rollup/rollup-linux-arm64-musl": "4.53.2",
        "@rollup/rollup-linux-loong64-gnu": "4.53.2",
        "@rollup/rollup-linux-ppc64-gnu": "4.53.2",
        "@rollup/rollup-linux-riscv64-gnu": "4.53.2",
        "@rollup/rollup-linux-riscv64-musl": "4.53.2",
        "@rollup/rollup-linux-s390x-gnu": "4.53.2",
        "@rollup/rollup-linux-x64-gnu": "4.53.2",
        "@rollup/rollup-linux-x64-musl": "4.53.2",
        "@rollup/rollup-openharmony-arm64": "4.53.2",
        "@rollup/rollup-win32-arm64-msvc": "4.53.2",
        "@rollup/rollup-win32-ia32-msvc": "4.53.2",
        "@rollup/rollup-win32-x64-gnu": "4.53.2",
        "@rollup/rollup-win32-x64-msvc": "4.53.2",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/upath": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/upath/-/upath-2.0.1.tgz",
      "integrity": "sha512-1uEe95xksV1O0CYKXo8vQvN1JEbtJp7lb7C5U9HMsIp6IVwntkH/oNUzyVNQSd4S1sYk2FpSSW44FqMc8qee5w==",
      "devOptional": true,
      "license": "MIT",
      "engines": {
        "node": ">=4",
        "yarn": "*"
      }
    },
    "node_modules/vite": {
      "version": "5.4.21",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.21.tgz",
      "integrity": "sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite-plugin-vuetify": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/vite-plugin-vuetify/-/vite-plugin-vuetify-2.1.2.tgz",
      "integrity": "sha512-I/wd6QS+DO6lHmuGoi1UTyvvBTQ2KDzQZ9oowJQEJ6OcjWfJnscYXx2ptm6S7fJSASuZT8jGRBL3LV4oS3LpaA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "@vuetify/loader-shared": "^2.1.1",
        "debug": "^4.3.3",
        "upath": "^2.0.1"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "peerDependencies": {
        "vite": ">=5",
        "vue": "^3.0.0",
        "vuetify": "^3.0.0"
      }
    },
    "node_modules/vue": {
      "version": "3.5.24",
      "resolved": "https://registry.npmjs.org/vue/-/vue-3.5.24.tgz",
      "integrity": "sha512-uTHDOpVQTMjcGgrqFPSb8iO2m1DUvo+WbGqoXQz8Y1CeBYQ0FXf2z1gLRaBtHjlRz7zZUBHxjVB5VTLzYkvftg==",
      "license": "MIT",
      "dependencies": {
        "@vue/compiler-dom": "3.5.24",
        "@vue/compiler-sfc": "3.5.24",
        "@vue/runtime-dom": "3.5.24",
        "@vue/server-renderer": "3.5.24",
        "@vue/shared": "3.5.24"
      },
      "peerDependencies": {
        "typescript": "*"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/vue-demi": {
      "version": "0.14.10",
      "resolved": "https://registry.npmjs.org/vue-demi/-/vue-demi-0.14.10.tgz",
      "integrity": "sha512-nMZBOwuzabUO0nLgIcc6rycZEebF6eeUfaiQx9+WSk8e29IbLvPU9feI6tqW4kTo3hvoYAJkMh8n8D0fuISphg==",
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "vue-demi-fix": "bin/vue-demi-fix.js",
        "vue-demi-switch": "bin/vue-demi-switch.js"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/antfu"
      },
      "peerDependencies": {
        "@vue/composition-api": "^1.0.0-rc.1",
        "vue": "^3.0.0-0 || ^2.6.0"
      },
      "peerDependenciesMeta": {
        "@vue/composition-api": {
          "optional": true
        }
      }
    },
    "node_modules/vue-router": {
      "version": "4.6.3",
      "resolved": "https://registry.npmjs.org/vue-router/-/vue-router-4.6.3.tgz",
      "integrity": "sha512-ARBedLm9YlbvQomnmq91Os7ck6efydTSpRP3nuOKCvgJOHNrhRoJDSKtee8kcL1Vf7nz6U+PMBL+hTvR3bTVQg==",
      "license": "MIT",
      "dependencies": {
        "@vue/devtools-api": "^6.6.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/posva"
      },
      "peerDependencies": {
        "vue": "^3.5.0"
      }
    },
    "node_modules/vuetify": {
      "version": "3.10.10",
      "resolved": "https://registry.npmjs.org/vuetify/-/vuetify-3.10.10.tgz",
      "integrity": "sha512-4RRQrJCaiWRalciBVpIKuZmPlfGUGwJalXuca8nHVNTDKJq4LHYNLcIKEbfdyP/6VBiWG4jZPJDTmC0dpXu+sA==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/johnleider"
      },
      "peerDependencies": {
        "typescript": ">=4.7",
        "vite-plugin-vuetify": ">=2.1.0",
        "vue": "^3.5.0",
        "webpack-plugin-vuetify": ">=3.1.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        },
        "vite-plugin-vuetify": {
          "optional": true
        },
        "webpack-plugin-vuetify": {
          "optional": true
        }
      }
    }
  }
}

```

`WebAdmin\package.json`:

```json
{
  "name": "duckynet-web-admin",
  "version": "1.0.0",
  "description": "DuckyNet æœåŠ¡å™¨ç®¡ç†åå°",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.4.0",
    "vuetify": "^3.5.0",
    "axios": "^1.6.0",
    "@mdi/font": "^7.4.0",
    "pinia": "^2.1.0",
    "vue-router": "^4.2.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "vite": "^5.0.0",
    "vite-plugin-vuetify": "^2.0.0"
  }
}


```

`WebAdmin\src\App.vue`:

```vue
<template>
  <v-app>
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <v-app-bar color="primary" dark prominent>
      <v-app-bar-nav-icon @click="drawer = !drawer"></v-app-bar-nav-icon>
      <v-toolbar-title>
        <v-icon left>mdi-duck</v-icon>
        DuckyNet æœåŠ¡å™¨ç®¡ç†
      </v-toolbar-title>
      
      <v-spacer></v-spacer>
      
      <!-- è‡ªåŠ¨åˆ·æ–°çŠ¶æ€ -->
      <v-chip color="success" label>
        <v-icon left>mdi-refresh</v-icon>
        å®æ—¶åˆ·æ–° (0.1ç§’)
      </v-chip>
      
      <v-btn icon @click="refreshData">
        <v-icon>mdi-refresh</v-icon>
      </v-btn>
      
      <span class="text-caption ml-4">{{ serverTime }}</span>
    </v-app-bar>

    <!-- ä¾§è¾¹å¯¼èˆªæŠ½å±‰ -->
    <v-navigation-drawer v-model="drawer" app>
      <v-list>
        <v-list-item prepend-icon="mdi-view-dashboard" title="æ€»è§ˆ" value="overview" @click="currentView = 'overview'"></v-list-item>
        <v-list-item prepend-icon="mdi-door" title="æˆ¿é—´ç®¡ç†" value="rooms" @click="currentView = 'rooms'"></v-list-item>
        <v-list-item prepend-icon="mdi-account-multiple" title="ç©å®¶åˆ—è¡¨" value="players" @click="currentView = 'players'"></v-list-item>
        <v-list-item prepend-icon="mdi-map" title="åœºæ™¯ç›‘æ§" value="scenes" @click="currentView = 'scenes'"></v-list-item>
        <v-list-item prepend-icon="mdi-robot" title="NPCç®¡ç†" value="npcs" @click="currentView = 'npcs'"></v-list-item>
        <v-list-item prepend-icon="mdi-chart-line" title="æ€§èƒ½ç›‘æ§" value="performance" @click="currentView = 'performance'"></v-list-item>
      </v-list>
    </v-navigation-drawer>

    <!-- ä¸»å†…å®¹åŒº -->
    <v-main>
      <v-container fluid>
        <!-- æ€»è§ˆè§†å›¾ -->
        <div v-if="currentView === 'overview'">
          <v-row>
            <v-col cols="12" md="3">
              <v-card>
                <v-card-text>
                  <div class="text-h4 text-primary">{{ overview.onlinePlayers }}</div>
                  <div class="text-subtitle-1">åœ¨çº¿ç©å®¶</div>
                  <v-icon size="48" color="primary">mdi-account-multiple</v-icon>
                </v-card-text>
              </v-card>
            </v-col>
            <v-col cols="12" md="3">
              <v-card>
                <v-card-text>
                  <div class="text-h4 text-success">{{ overview.totalRooms }}</div>
                  <div class="text-subtitle-1">æ´»è·ƒæˆ¿é—´</div>
                  <v-icon size="48" color="success">mdi-door</v-icon>
                </v-card-text>
              </v-card>
            </v-col>
            <v-col cols="12" md="3">
              <v-card>
                <v-card-text>
                  <div class="text-h4 text-warning">{{ overview.totalNpcs }}</div>
                  <div class="text-subtitle-1">NPCæ•°é‡</div>
                  <v-icon size="48" color="warning">mdi-robot</v-icon>
                </v-card-text>
              </v-card>
            </v-col>
            <v-col cols="12" md="3">
              <v-card>
                <v-card-text>
                  <div class="text-h4 text-info">{{ overview.uptime }}</div>
                  <div class="text-subtitle-1">è¿è¡ŒçŠ¶æ€</div>
                  <v-icon size="48" color="info">mdi-check-circle</v-icon>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>
        </div>

        <!-- æˆ¿é—´ç®¡ç†è§†å›¾ -->
        <div v-if="currentView === 'rooms'">
          <v-row>
            <v-col cols="12" md="8">
              <v-card>
                <v-card-title>æˆ¿é—´åˆ—è¡¨</v-card-title>
                <v-card-text>
                  <v-data-table
                    :headers="roomHeaders"
                    :items="rooms"
                    :items-per-page="10"
                    @click:row="selectRoom">
                    <template v-slot:item.requirePassword="{ item }">
                      <v-icon v-if="item.requirePassword" color="warning">mdi-lock</v-icon>
                      <v-icon v-else color="success">mdi-lock-open</v-icon>
                    </template>
                    <template v-slot:item.isFull="{ item }">
                      <v-chip :color="item.isFull ? 'error' : 'success'" small>
                        {{ item.isFull ? 'å·²æ»¡' : 'å¯åŠ å…¥' }}
                      </v-chip>
                    </template>
                    <template v-slot:item.currentPlayers="{ item }">
                      {{ item.currentPlayers }}/{{ item.maxPlayers }}
                    </template>
                  </v-data-table>
                </v-card-text>
              </v-card>
            </v-col>
            
            <v-col cols="12" md="4" v-if="selectedRoom">
              <v-card>
                <v-card-title>æˆ¿é—´è¯¦æƒ…</v-card-title>
                <v-card-text>
                  <v-list>
                    <v-list-item>
                      <v-list-item-title>æˆ¿é—´åç§°</v-list-item-title>
                      <v-list-item-subtitle>{{ selectedRoom.roomName }}</v-list-item-subtitle>
                    </v-list-item>
                    <v-list-item>
                      <v-list-item-title>æˆ¿ä¸»</v-list-item-title>
                      <v-list-item-subtitle>{{ selectedRoom.hostSteamId }}</v-list-item-subtitle>
                    </v-list-item>
                    <v-list-item>
                      <v-list-item-title>åˆ›å»ºæ—¶é—´</v-list-item-title>
                      <v-list-item-subtitle>{{ formatTime(selectedRoom.createTime) }}</v-list-item-subtitle>
                    </v-list-item>
                  </v-list>
                  
                  <v-divider class="my-3"></v-divider>
                  
                  <div class="text-subtitle-1 mb-2">æˆ¿é—´å†…ç©å®¶</div>
                  <v-chip v-for="player in roomPlayers" :key="player.steamId" class="ma-1">
                    {{ player.steamName }}
                  </v-chip>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>
        </div>

        <!-- ç©å®¶åˆ—è¡¨è§†å›¾ -->
        <div v-if="currentView === 'players'">
          <v-card>
            <v-card-title>åœ¨çº¿ç©å®¶åˆ—è¡¨</v-card-title>
            <v-card-text>
              <v-data-table
                :headers="playerHeaders"
                :items="players"
                :items-per-page="15">
                <template v-slot:item.position="{ item }">
                  <span v-if="item.position">
                    ({{ item.position.x.toFixed(1) }}, {{ item.position.y.toFixed(1) }}, {{ item.position.z.toFixed(1) }})
                  </span>
                  <span v-else class="text-grey">-</span>
                </template>
                <template v-slot:item.sceneName="{ item }">
                  {{ item.sceneName || '-' }}
                  <span v-if="item.subSceneName" class="text-grey">/ {{ item.subSceneName }}</span>
                </template>
              </v-data-table>
            </v-card-text>
          </v-card>
        </div>

        <!-- åœºæ™¯ç›‘æ§è§†å›¾ -->
        <div v-if="currentView === 'scenes'">
          <v-row>
            <v-col cols="12" md="4">
              <v-card>
                <v-card-title>åœºæ™¯åˆ—è¡¨</v-card-title>
                <v-card-text>
                  <v-list>
                    <v-list-item
                      v-for="scene in scenes"
                      :key="scene.sceneName + scene.subSceneName"
                      @click="selectScene(scene)"
                      :active="selectedScene?.sceneName === scene.sceneName">
                      <v-list-item-title>{{ scene.sceneName }}</v-list-item-title>
                      <v-list-item-subtitle>
                        {{ scene.subSceneName || 'ä¸»åœºæ™¯' }} - 
                        ğŸ‘¥ {{ scene.playerCount }} ç©å®¶ | 
                        ğŸ¤– {{ scene.npcCount }} NPC
                      </v-list-item-subtitle>
                    </v-list-item>
                  </v-list>
                </v-card-text>
              </v-card>
            </v-col>
            
            <v-col cols="12" md="8" v-if="selectedScene && sceneDetail">
              <v-card>
                <v-card-title>
                  {{ selectedScene.sceneName }} / {{ selectedScene.subSceneName }}
                </v-card-title>
                <v-card-text>
                  <SceneMap 
                    :players="sceneDetail.players" 
                    :npcs="sceneDetail.npcs" />
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>
        </div>

        <!-- NPCç®¡ç†è§†å›¾ -->
        <div v-if="currentView === 'npcs'">
          <v-card>
            <v-card-title>NPCåˆ—è¡¨</v-card-title>
            <v-card-text>
              <v-data-table
                :headers="npcHeaders"
                :items="allNpcs"
                :items-per-page="20">
                <template v-slot:item.position="{ item }">
                  ({{ item.position.x.toFixed(1) }}, {{ item.position.y.toFixed(1) }}, {{ item.position.z.toFixed(1) }})
                </template>
                <template v-slot:item.maxHealth="{ item }">
                  <v-progress-linear
                    :model-value="100"
                    color="success"
                    height="20">
                    {{ item.maxHealth }}
                  </v-progress-linear>
                </template>
              </v-data-table>
            </v-card-text>
          </v-card>
        </div>

        <!-- æ€§èƒ½ç›‘æ§è§†å›¾ -->
        <div v-if="currentView === 'performance'">
          <v-row>
            <v-col cols="12">
              <v-card>
                <v-card-title>å®æ—¶æ€§èƒ½ç›‘æ§</v-card-title>
                <v-card-text>
                  <div class="text-h6">æœåŠ¡å™¨ç»Ÿè®¡</div>
                  <v-table>
                    <tbody>
                      <tr>
                        <td>åˆ·æ–°æ–¹å¼</td>
                        <td>HTTP å®æ—¶è½®è¯¢</td>
                      </tr>
                      <tr>
                        <td>æ›´æ–°é¢‘ç‡</td>
                        <td>æ¯0.1ç§’ (10æ¬¡/ç§’)</td>
                      </tr>
                      <tr>
                        <td>æœåŠ¡å™¨æ—¶é—´</td>
                        <td>{{ serverTime }}</td>
                      </tr>
                      <tr>
                        <td>åœ¨çº¿ç©å®¶</td>
                        <td>{{ overview.onlinePlayers }}</td>
                      </tr>
                    </tbody>
                  </v-table>
                </v-card-text>
              </v-card>
            </v-col>
          </v-row>
        </div>
      </v-container>
    </v-main>
  </v-app>
</template>

<script>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import { api } from './services/api'
import SceneMap from './components/SceneMap.vue'

export default {
  name: 'App',
  components: {
    SceneMap
  },
  setup() {
    const drawer = ref(true)
    const currentView = ref('overview')
    const wsConnected = ref(true) // HTTPè½®è¯¢æ¨¡å¼ï¼Œå§‹ç»ˆæ˜¾ç¤ºä¸ºå·²è¿æ¥
    const serverTime = ref('')
    
    const overview = ref({
      onlinePlayers: 0,
      totalRooms: 0,
      totalNpcs: 0,
      uptime: 'è¿è¡Œä¸­'
    })
    
    const rooms = ref([])
    const players = ref([])
    const scenes = ref([])
    const allNpcs = ref([])
    
    const selectedRoom = ref(null)
    const roomPlayers = ref([])
    const selectedScene = ref(null)
    const sceneDetail = ref(null)
    
    const roomHeaders = [
      { title: 'æˆ¿é—´åç§°', key: 'roomName' },
      { title: 'æˆ¿é—´ID', key: 'roomId' },
      { title: 'æˆ¿ä¸»', key: 'hostSteamId' },
      { title: 'ç©å®¶', key: 'currentPlayers' },
      { title: 'å¯†ç ', key: 'requirePassword' },
      { title: 'çŠ¶æ€', key: 'isFull' }
    ]
    
    const playerHeaders = [
      { title: 'ç©å®¶åç§°', key: 'steamName' },
      { title: 'Steam ID', key: 'steamId' },
      { title: 'æ‰€åœ¨æˆ¿é—´', key: 'roomName' },
      { title: 'åœºæ™¯', key: 'sceneName' },
      { title: 'ä½ç½®', key: 'position' }
    ]
    
    const npcHeaders = [
      { title: 'NPC ID', key: 'npcId' },
      { title: 'NPCç±»å‹', key: 'npcType' },
      { title: 'åœºæ™¯', key: 'sceneName' },
      { title: 'ä½ç½®', key: 'position' },
      { title: 'è¡€é‡', key: 'maxHealth' },
      { title: 'æ‹¥æœ‰è€…', key: 'owner' }
    ]
    
    let refreshInterval = null
    let timeInterval = null
    
    const updateServerTime = () => {
      serverTime.value = new Date().toLocaleString('zh-CN')
    }
    
    const refreshData = async () => {
      if (currentView.value === 'overview') {
        await loadOverview()
      } else if (currentView.value === 'rooms') {
        await loadRooms()
        // å¦‚æœæœ‰é€‰ä¸­çš„æˆ¿é—´ï¼Œåˆ·æ–°æˆ¿é—´è¯¦æƒ…
        if (selectedRoom.value) {
          try {
            const data = await api.getRoomDetail(selectedRoom.value.roomId)
            roomPlayers.value = data.players
          } catch (error) {
            // é™é»˜å¤±è´¥
          }
        }
      } else if (currentView.value === 'players') {
        await loadPlayers()
      } else if (currentView.value === 'scenes') {
        await loadScenes()
      }
    }
    
    const loadOverview = async () => {
      try {
        overview.value = await api.getOverview()
      } catch (error) {
        console.error('åŠ è½½æ¦‚è§ˆå¤±è´¥:', error)
      }
    }
    
    const loadRooms = async () => {
      try {
        rooms.value = await api.getRooms()
      } catch (error) {
        console.error('åŠ è½½æˆ¿é—´å¤±è´¥:', error)
      }
    }
    
    const loadPlayers = async () => {
      try {
        players.value = await api.getPlayers()
      } catch (error) {
        console.error('åŠ è½½ç©å®¶å¤±è´¥:', error)
      }
    }
    
    const loadScenes = async () => {
      try {
        scenes.value = await api.getScenes()
        
        // å¦‚æœæœ‰é€‰ä¸­çš„åœºæ™¯ï¼Œå®æ—¶åˆ·æ–°å®ƒçš„è¯¦æƒ…
        if (selectedScene.value) {
          try {
            sceneDetail.value = await api.getSceneDetail(
              selectedScene.value.sceneName, 
              selectedScene.value.subSceneName
            )
          } catch (error) {
            console.error('åˆ·æ–°åœºæ™¯è¯¦æƒ…å¤±è´¥:', error)
          }
        }
        
        // åŠ è½½æ‰€æœ‰åœºæ™¯çš„NPC
        const allNpcList = []
        for (const scene of scenes.value) {
          const detail = await api.getSceneDetail(scene.sceneName, scene.subSceneName)
          allNpcList.push(...detail.npcs)
        }
        allNpcs.value = allNpcList
      } catch (error) {
        console.error('åŠ è½½åœºæ™¯å¤±è´¥:', error)
      }
    }
    
    const selectRoom = async (event, { item }) => {
      selectedRoom.value = item
      try {
        const data = await api.getRoomDetail(item.roomId)
        roomPlayers.value = data.players
      } catch (error) {
        console.error('åŠ è½½æˆ¿é—´è¯¦æƒ…å¤±è´¥:', error)
      }
    }
    
    const selectScene = async (scene) => {
      selectedScene.value = scene
      try {
        sceneDetail.value = await api.getSceneDetail(scene.sceneName, scene.subSceneName)
      } catch (error) {
        console.error('åŠ è½½åœºæ™¯è¯¦æƒ…å¤±è´¥:', error)
      }
    }
    
    const formatTime = (timeStr) => {
      return new Date(timeStr).toLocaleString('zh-CN')
    }
    
    onMounted(() => {
      updateServerTime()
      refreshData()
      
      // æ¯0.1ç§’è‡ªåŠ¨åˆ·æ–°ï¼ˆå®æ—¶è½®è¯¢ï¼‰
      refreshInterval = setInterval(() => {
        refreshData()
      }, 100)
      
      // æ¯ç§’æ›´æ–°æ—¶é—´
      timeInterval = setInterval(updateServerTime, 1000)
      
    })
    
    onUnmounted(() => {
      if (refreshInterval) clearInterval(refreshInterval)
      if (timeInterval) clearInterval(timeInterval)
    })
    
    return {
      drawer,
      currentView,
      wsConnected,
      serverTime,
      overview,
      rooms,
      players,
      scenes,
      allNpcs,
      selectedRoom,
      roomPlayers,
      selectedScene,
      sceneDetail,
      roomHeaders,
      playerHeaders,
      npcHeaders,
      refreshData,
      selectRoom,
      selectScene,
      formatTime
    }
  }
}
</script>

```

`WebAdmin\src\assets\steam-style.css`:

```css
/* Steam é£æ ¼é…è‰² */
:root {
    --steam-dark: #1b2838;
    --steam-darker: #171a21;
    --steam-blue: #1a9fff;
    --steam-blue-hover: #66c0f4;
    --steam-gray: #2a475e;
    --steam-light-gray: #c7d5e0;
    --steam-green: #5c7e10;
    --steam-card-bg: #16202d;
    --steam-border: #3c4f5e;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: "Motiva Sans", Arial, sans-serif;
    background: linear-gradient(135deg, var(--steam-darker) 0%, var(--steam-dark) 100%);
    color: var(--steam-light-gray);
    min-height: 100vh;
}

/* é¡¶éƒ¨å¯¼èˆªæ  */
.steam-header {
    background: var(--steam-darker);
    border-bottom: 2px solid var(--steam-blue);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    gap: 2rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.header-logo h1 {
    font-size: 1.5rem;
    color: var(--steam-blue-hover);
    font-weight: bold;
}

.header-nav {
    display: flex;
    gap: 0.5rem;
    flex: 1;
}

.nav-button {
    background: transparent;
    border: 2px solid var(--steam-gray);
    color: var(--steam-light-gray);
    padding: 0.5rem 1.5rem;
    cursor: pointer;
    font-size: 1rem;
    border-radius: 3px;
    transition: all 0.3s ease;
}

.nav-button:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
}

.nav-button.active {
    background: linear-gradient(to bottom, var(--steam-blue) 0%, #1a7dc4 100%);
    border-color: var(--steam-blue);
    color: white;
    box-shadow: 0 0 10px rgba(26, 159, 255, 0.5);
}

.header-time {
    color: var(--steam-light-gray);
    font-size: 0.9rem;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.25rem;
}

/* WebSocket çŠ¶æ€ */
.ws-status {
    font-size: 0.75rem;
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
}

.ws-status.connected {
    background: rgba(92, 126, 16, 0.3);
    color: #9cdb3c;
}

.ws-status.disconnected {
    background: rgba(211, 47, 47, 0.3);
    color: #ff6b6b;
}

/* ä¸»å†…å®¹åŒº */
.steam-main {
    padding: 2rem;
    max-width: 1600px;
    margin: 0 auto;
}

.content-panel {
    background: var(--steam-card-bg);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 2rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
}

.panel-title {
    color: var(--steam-blue-hover);
    font-size: 1.8rem;
    margin-bottom: 1.5rem;
    border-bottom: 2px solid var(--steam-blue);
    padding-bottom: 0.5rem;
}

/* ç»Ÿè®¡å¡ç‰‡ç½‘æ ¼ */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
}

.stat-card {
    background: linear-gradient(135deg, var(--steam-gray) 0%, var(--steam-dark) 100%);
    border: 1px solid var(--steam-border);
    border-radius: 8px;
    padding: 1.5rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(26, 159, 255, 0.3);
}

.stat-icon {
    font-size: 3rem;
}

.stat-content {
    flex: 1;
}

.stat-value {
    font-size: 2.5rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.stat-label {
    color: var(--steam-light-gray);
    font-size: 0.9rem;
    margin-top: 0.25rem;
}

/* æˆ¿é—´åˆ—è¡¨ */
.room-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.room-card {
    background: var(--steam-dark);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.room-card:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
    transform: translateX(5px);
}

.room-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.room-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.room-id {
    font-size: 0.8rem;
    color: #999;
}

.room-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
}

.room-players {
    color: var(--steam-blue-hover);
    font-weight: bold;
}

.room-meta {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
}

.badge {
    background: var(--steam-green);
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    font-size: 0.75rem;
}

.badge.full {
    background: #d32f2f;
}

.room-time {
    font-size: 0.75rem;
    color: #999;
}

/* ç©å®¶åˆ—è¡¨ */
.player-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-top: 1rem;
}

.player-card {
    background: var(--steam-dark);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    transition: all 0.3s ease;
}

.player-card:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
}

.player-avatar {
    font-size: 2.5rem;
}

.player-info {
    flex: 1;
}

.player-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.player-id {
    font-size: 0.8rem;
    color: #999;
    margin-top: 0.25rem;
}

.player-status {
    text-align: right;
    font-size: 0.9rem;
}

.player-room, .player-scene, .player-position {
    margin-bottom: 0.25rem;
}

/* åœºæ™¯åˆ—è¡¨ */
.scene-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.scene-card {
    background: var(--steam-dark);
    border: 1px solid var(--steam-border);
    border-radius: 5px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.scene-card:hover {
    background: var(--steam-gray);
    border-color: var(--steam-blue);
    transform: scale(1.02);
}

.scene-header {
    margin-bottom: 0.5rem;
}

.scene-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.scene-sub {
    color: #999;
    font-size: 0.9rem;
}

.scene-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
}

/* è¯¦æƒ…é¢æ¿ */
.detail-panel {
    position: fixed;
    right: 2rem;
    top: 120px;
    width: 400px;
    max-height: calc(100vh - 140px);
    overflow-y: auto;
    background: var(--steam-card-bg);
    border: 2px solid var(--steam-blue);
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
}

.detail-panel h3 {
    color: var(--steam-blue-hover);
    margin-bottom: 1rem;
}

.detail-panel h4 {
    color: var(--steam-light-gray);
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid var(--steam-border);
    padding-bottom: 0.25rem;
}

.close-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: transparent;
    border: none;
    color: var(--steam-light-gray);
    font-size: 1.5rem;
    cursor: pointer;
}

.close-btn:hover {
    color: var(--steam-blue-hover);
}

.detail-content p {
    margin-bottom: 0.5rem;
}

.player-mini-list, .entity-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.player-mini-card, .entity-card {
    background: var(--steam-dark);
    padding: 0.5rem;
    border-radius: 3px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.entity-card.npc {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
}

.npc-main {
    display: flex;
    justify-content: space-between;
    width: 100%;
    align-items: center;
}

.entity-name {
    font-weight: bold;
    color: var(--steam-blue-hover);
}

.npc-id {
    font-size: 0.75rem;
    color: #999;
}

.npc-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.85rem;
    width: 100%;
}

.npc-health {
    color: #ff6b6b;
}

.entity-pos {
    font-size: 0.8rem;
    color: #999;
}

.npc-meta {
    font-size: 0.75rem;
    color: #999;
    width: 100%;
}

/* ç©ºçŠ¶æ€ */
.empty-state {
    text-align: center;
    padding: 3rem;
    color: #999;
    font-size: 1.1rem;
}

/* åŠ è½½åŠ¨ç”» */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.loading-spinner {
    background: var(--steam-card-bg);
    border: 2px solid var(--steam-blue);
    padding: 2rem 3rem;
    border-radius: 8px;
    font-size: 1.2rem;
    color: var(--steam-blue-hover);
}

/* æ»šåŠ¨æ¡æ ·å¼ */
::-webkit-scrollbar {
    width: 12px;
}

::-webkit-scrollbar-track {
    background: var(--steam-darker);
}

::-webkit-scrollbar-thumb {
    background: var(--steam-gray);
    border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--steam-blue);
}


```

`WebAdmin\src\components\SceneMap.vue`:

```vue
<template>
  <div>
    <v-card>
      <v-card-title class="d-flex justify-space-between">
        <span>åœºæ™¯åœ°å›¾ (2Dä¿¯è§†å›¾)</span>
        <v-btn-group density="compact">
          <v-btn @click="zoomIn" icon="mdi-plus"></v-btn>
          <v-btn @click="zoomOut" icon="mdi-minus"></v-btn>
          <v-btn @click="resetView" icon="mdi-refresh"></v-btn>
        </v-btn-group>
      </v-card-title>
      <v-card-text>
        <canvas 
          ref="canvas" 
          :width="canvasWidth" 
          :height="canvasHeight"
          @mousedown="onMouseDown"
          @mousemove="onMouseMove"
          @mouseup="onMouseUp"
          @wheel="onWheel"
          style="border: 1px solid #666; cursor: grab;">
        </canvas>
        
        <v-row class="mt-2">
          <v-col cols="12" md="6">
            <div class="d-flex align-center">
              <v-icon color="primary" class="mr-2">mdi-account</v-icon>
              <span>ç©å®¶ ({{ players.length }})</span>
            </div>
          </v-col>
          <v-col cols="12" md="6">
            <div class="d-flex align-center">
              <v-icon color="warning" class="mr-2">mdi-robot</v-icon>
              <span>NPC ({{ npcs.length }})</span>
            </div>
          </v-col>
        </v-row>
        
        <!-- å®ä½“åˆ—è¡¨ -->
        <v-expansion-panels class="mt-3">
          <v-expansion-panel>
            <v-expansion-panel-title>
              <v-icon left>mdi-format-list-bulleted</v-icon>
              å®ä½“è¯¦æƒ…åˆ—è¡¨
            </v-expansion-panel-title>
            <v-expansion-panel-text>
              <v-tabs v-model="tab">
                <v-tab value="players">ç©å®¶</v-tab>
                <v-tab value="npcs">NPC</v-tab>
              </v-tabs>
              
              <v-window v-model="tab">
                <v-window-item value="players">
                  <v-list>
                    <v-list-item 
                      v-for="player in players" 
                      :key="player.steamId"
                      @click="focusEntity(player, 'player')">
                      <template v-slot:prepend>
                        <v-icon color="primary">mdi-account</v-icon>
                      </template>
                      <v-list-item-title>{{ player.steamName }}</v-list-item-title>
                      <v-list-item-subtitle v-if="player.position">
                        X: {{ player.position.x.toFixed(1) }}, 
                        Y: {{ player.position.y.toFixed(1) }}, 
                        Z: {{ player.position.z.toFixed(1) }}
                      </v-list-item-subtitle>
                    </v-list-item>
                  </v-list>
                </v-window-item>
                
                <v-window-item value="npcs">
                  <v-list>
                    <v-list-item 
                      v-for="npc in npcs" 
                      :key="npc.npcId"
                      @click="focusEntity(npc, 'npc')">
                      <template v-slot:prepend>
                        <v-icon color="warning">mdi-robot</v-icon>
                      </template>
                      <v-list-item-title>{{ npc.npcType }}</v-list-item-title>
                      <v-list-item-subtitle>
                        è¡€é‡: {{ npc.maxHealth }} | 
                        ä½ç½®: ({{ npc.position.x.toFixed(1) }}, {{ npc.position.y.toFixed(1) }}, {{ npc.position.z.toFixed(1) }})
                      </v-list-item-subtitle>
                    </v-list-item>
                  </v-list>
                </v-window-item>
              </v-window>
            </v-expansion-panel-text>
          </v-expansion-panel>
        </v-expansion-panels>
      </v-card-text>
    </v-card>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted, watch, nextTick } from 'vue'

export default {
  name: 'SceneMap',
  props: {
    players: {
      type: Array,
      default: () => []
    },
    npcs: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const canvas = ref(null)
    const canvasWidth = 800
    const canvasHeight = 600
    const tab = ref('players')
    let autoRefreshTimer = null
    
    // è§†å›¾æ§åˆ¶
    const offsetX = ref(0)
    const offsetY = ref(0)
    const scale = ref(1)
    const isDragging = ref(false)
    const lastMouseX = ref(0)
    const lastMouseY = ref(0)
    
    // åœ°å›¾èŒƒå›´è‡ªåŠ¨è®¡ç®—
    const bounds = ref({
      minX: -100,
      maxX: 100,
      minZ: -100,
      maxZ: 100
    })
    
    const calculateBounds = () => {
      const allEntities = [
        ...props.players.filter(p => p.position).map(p => p.position),
        ...props.npcs.map(n => n.position)
      ]
      
      if (allEntities.length === 0) return
      
      const xs = allEntities.map(e => e.x)
      const zs = allEntities.map(e => e.z)
      
      bounds.value = {
        minX: Math.min(...xs, -100),
        maxX: Math.max(...xs, 100),
        minZ: Math.min(...zs, -100),
        maxZ: Math.max(...zs, 100)
      }
      
      // æ·»åŠ è¾¹è·
      const marginX = (bounds.value.maxX - bounds.value.minX) * 0.1
      const marginZ = (bounds.value.maxZ - bounds.value.minZ) * 0.1
      bounds.value.minX -= marginX
      bounds.value.maxX += marginX
      bounds.value.minZ -= marginZ
      bounds.value.maxZ += marginZ
    }
    
    const worldToScreen = (x, z) => {
      const rangeX = bounds.value.maxX - bounds.value.minX
      const rangeZ = bounds.value.maxZ - bounds.value.minZ
      
      const screenX = ((x - bounds.value.minX) / rangeX) * canvasWidth * scale.value + offsetX.value
      const screenY = ((z - bounds.value.minZ) / rangeZ) * canvasHeight * scale.value + offsetY.value
      
      return { x: screenX, y: screenY }
    }
    
    const drawMap = () => {
      if (!canvas.value) return
      
      const ctx = canvas.value.getContext('2d')
      if (!ctx) return
      
      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, canvasWidth, canvasHeight)
      
      // èƒŒæ™¯
      ctx.fillStyle = '#1E1E1E'
      ctx.fillRect(0, 0, canvasWidth, canvasHeight)
      
      // ç½‘æ ¼
      ctx.strokeStyle = '#333'
      ctx.lineWidth = 1
      const gridSize = 50
      for (let i = bounds.value.minX; i <= bounds.value.maxX; i += gridSize) {
        const pos = worldToScreen(i, bounds.value.minZ)
        const pos2 = worldToScreen(i, bounds.value.maxZ)
        ctx.beginPath()
        ctx.moveTo(pos.x, pos.y)
        ctx.lineTo(pos2.x, pos2.y)
        ctx.stroke()
      }
      for (let i = bounds.value.minZ; i <= bounds.value.maxZ; i += gridSize) {
        const pos = worldToScreen(bounds.value.minX, i)
        const pos2 = worldToScreen(bounds.value.maxX, i)
        ctx.beginPath()
        ctx.moveTo(pos.x, pos.y)
        ctx.lineTo(pos2.x, pos2.y)
        ctx.stroke()
      }
      
      // åŸç‚¹æ ‡è®°
      const origin = worldToScreen(0, 0)
      ctx.strokeStyle = '#666'
      ctx.lineWidth = 2
      ctx.beginPath()
      ctx.moveTo(origin.x - 10, origin.y)
      ctx.lineTo(origin.x + 10, origin.y)
      ctx.moveTo(origin.x, origin.y - 10)
      ctx.lineTo(origin.x, origin.y + 10)
      ctx.stroke()
      
      // ç»˜åˆ¶NPCï¼ˆå›ºå®šå›¾æ ‡å¤§å°ï¼‰
      props.npcs.forEach(npc => {
        const pos = worldToScreen(npc.position.x, npc.position.z)
        
        // NPCåœ†å½¢ï¼ˆå›ºå®šå¤§å°8pxï¼‰
        ctx.fillStyle = '#FF9800'
        ctx.beginPath()
        ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2)
        ctx.fill()
        
        ctx.strokeStyle = '#FFC107'
        ctx.lineWidth = 2
        ctx.stroke()
        
        // NPCåç§°ï¼ˆå›ºå®šå¤§å°12pxï¼‰
        ctx.fillStyle = '#FFF'
        ctx.font = '12px Arial'
        ctx.fillText(npc.npcType, pos.x + 12, pos.y + 4)
        
        // è¡€é‡æ¡ï¼ˆå›ºå®šå¤§å°ï¼‰
        const barWidth = 40
        const barHeight = 4
        ctx.fillStyle = '#333'
        ctx.fillRect(pos.x - barWidth/2, pos.y - 15, barWidth, barHeight)
        ctx.fillStyle = '#4CAF50'
        ctx.fillRect(pos.x - barWidth/2, pos.y - 15, barWidth, barHeight)
      })
      
      // ç»˜åˆ¶ç©å®¶ï¼ˆå›ºå®šå›¾æ ‡å¤§å°ï¼‰
      props.players.forEach(player => {
        if (!player.position) return
        
        const pos = worldToScreen(player.position.x, player.position.z)
        
        // ç©å®¶ä¸‰è§’å½¢ï¼ˆå›ºå®šå¤§å°ï¼‰
        ctx.fillStyle = '#2196F3'
        ctx.beginPath()
        ctx.moveTo(pos.x, pos.y - 10)
        ctx.lineTo(pos.x - 8, pos.y + 6)
        ctx.lineTo(pos.x + 8, pos.y + 6)
        ctx.closePath()
        ctx.fill()
        
        ctx.strokeStyle = '#64B5F6'
        ctx.lineWidth = 2
        ctx.stroke()
        
        // ç©å®¶åç§°ï¼ˆå›ºå®šå¤§å°12pxï¼‰
        ctx.fillStyle = '#FFF'
        ctx.font = '12px Arial'
        ctx.fillText(player.steamName, pos.x + 12, pos.y + 4)
      })
    }
    
    const zoomIn = () => {
      scale.value = Math.min(scale.value * 1.2, 5)
      drawMap()
    }
    
    const zoomOut = () => {
      scale.value = Math.max(scale.value / 1.2, 0.1)
      drawMap()
    }
    
    const resetView = () => {
      offsetX.value = 0
      offsetY.value = 0
      scale.value = 1
      calculateBounds()
      drawMap()
    }
    
    const focusEntity = (entity, type) => {
      const pos = type === 'player' && entity.position 
        ? entity.position 
        : type === 'npc' 
        ? entity.position 
        : null
      
      if (!pos) return
      
      // å°†å®ä½“ç§»åˆ°ç”»å¸ƒä¸­å¿ƒ
      const screenPos = worldToScreen(pos.x, pos.z)
      offsetX.value += canvasWidth / 2 - screenPos.x
      offsetY.value += canvasHeight / 2 - screenPos.y
      
      drawMap()
    }
    
    const onMouseDown = (e) => {
      isDragging.value = true
      lastMouseX.value = e.clientX
      lastMouseY.value = e.clientY
      canvas.value.style.cursor = 'grabbing'
    }
    
    const onMouseMove = (e) => {
      if (!isDragging.value) return
      
      const dx = e.clientX - lastMouseX.value
      const dy = e.clientY - lastMouseY.value
      
      offsetX.value += dx
      offsetY.value += dy
      
      lastMouseX.value = e.clientX
      lastMouseY.value = e.clientY
      
      drawMap()
    }
    
    const onMouseUp = () => {
      isDragging.value = false
      canvas.value.style.cursor = 'grab'
    }
    
    const onWheel = (e) => {
      e.preventDefault()
      
      const delta = e.deltaY > 0 ? 0.9 : 1.1
      const newScale = scale.value * delta
      
      if (newScale < 0.1 || newScale > 5) return
      
      // ä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒç¼©æ”¾
      const rect = canvas.value.getBoundingClientRect()
      const mouseX = e.clientX - rect.left
      const mouseY = e.clientY - rect.top
      
      offsetX.value = mouseX - (mouseX - offsetX.value) * delta
      offsetY.value = mouseY - (mouseY - offsetY.value) * delta
      scale.value = newScale
      
      drawMap()
    }
    
    onMounted(() => {
      calculateBounds()
      nextTick(() => {
        drawMap()
      })
      
      // è‡ªåŠ¨åˆ·æ–°åœ°å›¾ï¼ˆæ¯0.1ç§’ï¼‰
      autoRefreshTimer = setInterval(() => {
        drawMap()
      }, 100)
    })
    
    onUnmounted(() => {
      if (autoRefreshTimer) {
        clearInterval(autoRefreshTimer)
      }
    })
    
    watch(() => [props.players, props.npcs], () => {
      calculateBounds()
      drawMap()
    }, { deep: true, immediate: false })
    
    return {
      canvas,
      canvasWidth,
      canvasHeight,
      tab,
      zoomIn,
      zoomOut,
      resetView,
      focusEntity,
      onMouseDown,
      onMouseMove,
      onMouseUp,
      onWheel
    }
  }
}
</script>

<style scoped>
canvas {
  display: block;
  max-width: 100%;
}
</style>


```

`WebAdmin\src\main.js`:

```js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

// Vuetify
import 'vuetify/styles'
import { createVuetify } from 'vuetify'
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'
import '@mdi/font/css/materialdesignicons.css'

const vuetify = createVuetify({
  components,
  directives,
  theme: {
    defaultTheme: 'dark',
    themes: {
      dark: {
        colors: {
          primary: '#1E88E5',
          secondary: '#26C6DA',
          accent: '#9C27B0',
          error: '#F44336',
          warning: '#FF9800',
          info: '#2196F3',
          success: '#4CAF50',
          background: '#121212',
          surface: '#1E1E1E'
        }
      }
    }
  }
})

const pinia = createPinia()
const app = createApp(App)

app.use(vuetify)
app.use(pinia)
app.mount('#app')


```

`WebAdmin\src\services\api.js`:

```js
import axios from 'axios'

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000'
const WS_BASE_URL = import.meta.env.VITE_WS_BASE_URL || 'ws://localhost:5000'

// åˆ›å»ºaxioså®ä¾‹
const http = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000
})

// è¯·æ±‚æ‹¦æˆªå™¨
http.interceptors.request.use(
  config => {
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// å“åº”æ‹¦æˆªå™¨
http.interceptors.response.use(
  response => {
    return response.data
  },
  error => {
    console.error('API Error:', error)
    return Promise.reject(error)
  }
)

// APIæ–¹æ³•
export const api = {
  // æ€»è§ˆ
  getOverview: () => http.get('/api/dashboard/overview'),
  
  // æˆ¿é—´
  getRooms: () => http.get('/api/rooms'),
  getRoomDetail: (roomId) => http.get(`/api/rooms/${roomId}`),
  
  // ç©å®¶
  getPlayers: () => http.get('/api/players'),
  getPlayerDetail: (steamId) => http.get(`/api/players/${steamId}`),
  
  // åœºæ™¯
  getScenes: () => http.get('/api/scenes'),
  getSceneDetail: (sceneName, subSceneName) => http.get(`/api/scenes/${sceneName}/${subSceneName}`),
  
  // NPC
  getNpcs: () => http.get('/api/npcs'),
  getNpcDetail: (npcId) => http.get(`/api/npcs/${npcId}`),
  
  // ç›‘æ§
  getPerformance: () => http.get('/api/monitor/performance'),
  getPlayerDistribution: () => http.get('/api/monitor/player-distribution'),
  getNpcStats: () => http.get('/api/monitor/npc-stats'),
  getHotScenes: () => http.get('/api/monitor/hot-scenes'),
  getHealth: () => http.get('/api/monitor/health')
}


```

`WebAdmin\vite.config.js`:

```js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vuetify from 'vite-plugin-vuetify'

export default defineConfig({
  plugins: [
    vue(),
    vuetify({ autoImport: true })
  ],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true
      },
      '/ws': {
        target: 'ws://localhost:5000',
        ws: true
      }
    }
  }
})


```

`WebAdmin\å¯åŠ¨å‰ç«¯.bat`:

```bat
@echo off
chcp 65001 >nul
title DuckyNet Web Admin - å‰ç«¯

echo ========================================
echo   DuckyNet Web Admin - å‰ç«¯å¯åŠ¨è„šæœ¬
echo ========================================
echo.

cd /d "%~dp0"

if not exist "package.json" (
    echo é”™è¯¯ï¼šæœªæ‰¾åˆ° package.json
    echo è¯·ç¡®ä¿åœ¨ WebAdmin ç›®å½•ä¸‹è¿è¡Œæ­¤è„šæœ¬
    echo.
    pause
    exit /b 1
)

echo æ£€æŸ¥ Node.js...
node --version >nul 2>&1
if errorlevel 1 (
    echo é”™è¯¯ï¼šæœªæ‰¾åˆ° Node.js
    echo è¯·è®¿é—® https://nodejs.org ä¸‹è½½å¹¶å®‰è£… Node.js
    echo.
    pause
    exit /b 1
)

echo âœ“ æ‰¾åˆ° Node.js
echo.

if not exist "node_modules" (
    echo é¦–æ¬¡è¿è¡Œï¼Œæ­£åœ¨å®‰è£…ä¾èµ–...
    call npm install
    if errorlevel 1 (
        echo é”™è¯¯ï¼šä¾èµ–å®‰è£…å¤±è´¥
        echo.
        pause
        exit /b 1
    )
    echo âœ“ ä¾èµ–å®‰è£…å®Œæˆ
    echo.
)

echo ========================================
echo æ­£åœ¨å¯åŠ¨å‰ç«¯å¼€å‘æœåŠ¡å™¨...
echo ========================================
echo.
echo å¯åŠ¨åå¯è®¿é—®ï¼š
echo   â€¢ å‰ç«¯ç•Œé¢: http://localhost:3000
echo.
echo æŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨
echo.
echo ========================================
echo.

call npm run dev

if errorlevel 1 (
    echo.
    echo æœåŠ¡å™¨å¼‚å¸¸é€€å‡º
    echo.
    pause
)


```

`WebAdmin\å¿«é€Ÿå¼€å§‹.md`:

```md
# DuckyNet Web Admin - å¿«é€Ÿå¼€å§‹

## ğŸš€ ç¬¬ä¸€æ¬¡å¯åŠ¨

### 1. å®‰è£… Node.js
å¦‚æœè¿˜æ²¡å®‰è£…Node.jsï¼Œè¯·è®¿é—®ï¼šhttps://nodejs.org/

### 2. å®‰è£…ä¾èµ–
```bash
cd WebAdmin
npm install
```

### 3. å¯åŠ¨å¼€å‘æœåŠ¡å™¨
```bash
npm run dev
```

### 4. è®¿é—®ç•Œé¢
æ‰“å¼€æµè§ˆå™¨è®¿é—®ï¼šhttp://localhost:3000

## âš¡ åç»­å¯åŠ¨

### æ–¹å¼1ï¼šä½¿ç”¨å¯åŠ¨è„šæœ¬ï¼ˆæ¨èï¼‰
åŒå‡» `å¯åŠ¨å‰ç«¯.bat`

### æ–¹å¼2ï¼šå‘½ä»¤è¡Œ
```bash
cd WebAdmin
npm run dev
```

## ğŸ”Œ è¿æ¥åç«¯

ç¡®ä¿åç«¯ Server æ­£åœ¨è¿è¡Œï¼š
- API åœ°å€: http://localhost:5000
- WebSocket: ws://localhost:5000/ws

å¦‚æœåç«¯ç«¯å£ä¸æ˜¯5000ï¼Œè¯·ä¿®æ”¹ `.env` æ–‡ä»¶

## ğŸ“ å¼€å‘æ¨¡å¼

- è‡ªåŠ¨çƒ­é‡è½½ï¼ˆä¿®æ”¹ä»£ç ç«‹å³ç”Ÿæ•ˆï¼‰
- Vite ä»£ç†ï¼ˆè‡ªåŠ¨è½¬å‘APIè¯·æ±‚ï¼‰
- DevTools æ”¯æŒ

## ğŸ—ï¸ ç”Ÿäº§æ„å»º

```bash
npm run build
```

ç”Ÿæˆçš„æ–‡ä»¶åœ¨ `dist/` ç›®å½•

## â“ é‡åˆ°é—®é¢˜ï¼Ÿ

### ç«¯å£è¢«å ç”¨
ä¿®æ”¹ `vite.config.js` ä¸­çš„ç«¯å£

### ä¾èµ–å®‰è£…å¤±è´¥
```bash
rm -rf node_modules
npm install
```

### æ— æ³•è¿æ¥åç«¯
æ£€æŸ¥åç«¯æ˜¯å¦è¿è¡Œåœ¨ http://localhost:5000

## ğŸ¯ ä¸‹ä¸€æ­¥

æŸ¥çœ‹ `README.md` äº†è§£æ›´å¤šåŠŸèƒ½å’Œé…ç½®


```

`build.bat`:

```bat
@echo off
echo ================================
echo DuckyNet RPC Framework Build
echo ================================

echo.
echo [1/5] Building Shared...
dotnet build Shared/DuckyNetShared.csproj -c Debug

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Shared build failed!
    pause
    exit /b 1
)

echo.
echo [2/5] Running Code Generator...
dotnet run --project Tools/RpcCodeGen/RpcCodeGen.csproj

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Code generation failed!
    pause
    exit /b 1
)

echo.
echo [3/5] Rebuilding Shared (with generated code)...
dotnet build Shared/DuckyNetShared.csproj -c Debug

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Shared rebuild failed!
    pause
    exit /b 1
)

echo.
echo [4/5] Building Server...
dotnet build Server/DuckyNetServer.csproj -c Debug

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Server build failed!
    pause
    exit /b 1
)

echo.
echo [5/5] Building Client...
dotnet build Client/DuckyNetClient.csproj -c Debug

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Client build failed!
    pause
    exit /b 1
)

echo.
echo ================================
echo Build Complete! 
echo ================================
echo.
echo Output Files:
echo   Server: Server\bin\Debug\net8.0\DuckyNetServer.exe
echo   Client: Client\bin\Debug\netstandard2.1\DuckyNetClient.dll
echo.
echo To run server:
echo   cd Server\bin\Debug\net8.0
echo   DuckyNetServer.exe
echo.
echo To test:
echo   run_test.bat
echo.
pause


```

`build_linux_release.ps1`:

```ps1
# DuckyNet Linux Release Build Script
# PowerShell 5.1 compatible

Write-Host "================================" -ForegroundColor Cyan
Write-Host "DuckyNet Linux Release Build" -ForegroundColor Cyan
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""

$ErrorActionPreference = "Stop"

# Clean old dist
$LinuxDistDir = "dist/linux"
if (Test-Path $LinuxDistDir) {
    Write-Host "Cleaning old dist..." -ForegroundColor Yellow
    Remove-Item -Path $LinuxDistDir -Recurse -Force
}

Write-Host ""
Write-Host "[1/6] Building Shared (Release)..." -ForegroundColor Green
dotnet build Shared/DuckyNetShared.csproj -c Release
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Shared build failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[2/6] Running Code Generator..." -ForegroundColor Green
dotnet run --project Tools/RpcCodeGen/RpcCodeGen.csproj
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Code generation failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[3/6] Rebuilding Shared..." -ForegroundColor Green
dotnet build Shared/DuckyNetShared.csproj -c Release
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Shared rebuild failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[4/6] Publishing Server (Linux x64)..." -ForegroundColor Green
dotnet publish Server/DuckyNetServer.csproj -c Release -r linux-x64 --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=false -p:IncludeNativeLibrariesForSelfExtract=true -o "$LinuxDistDir/Server"

if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Server publish failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[5/6] Building Client..." -ForegroundColor Green
dotnet build Client/DuckyNetClient.csproj -c Release
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Client build failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[6/6] Packaging..." -ForegroundColor Green

$ClientDistDir = "$LinuxDistDir/Client"
New-Item -ItemType Directory -Path $ClientDistDir -Force | Out-Null
Copy-Item -Path "Client/res/*" -Destination $ClientDistDir -Recurse -Force

# Create start script
$StartScript = "#!/bin/bash`ncd `"`$(dirname `"`$0`")`"`nchmod +x ./DuckyNet.Server`n./DuckyNet.Server"
$StartScript | Out-File -FilePath "$LinuxDistDir/Server/start_server.sh" -Encoding ASCII -NoNewline

# Create README
$Readme = "# DuckyNet Linux Release`n`n## Server`n`n"
$Readme += "Start: cd Server && chmod +x start_server.sh && ./start_server.sh`n`n"
$Readme += "Port: 9050`n`n"
$Readme += "## Client (Unity Mod)`n`n"
$Readme += "Copy Client/*.dll to game Mods folder`n`n"
$Readme += "Build: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')`n"
$Readme | Out-File -FilePath "$LinuxDistDir/README.txt" -Encoding UTF8

Write-Host ""
Write-Host "================================" -ForegroundColor Cyan
Write-Host "Build Complete!" -ForegroundColor Green
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Output Directory: $LinuxDistDir" -ForegroundColor Yellow
Write-Host ""
Write-Host "Files:" -ForegroundColor White
Write-Host "  Server: dist/linux/Server/DuckyNet.Server (67 MB)" -ForegroundColor Gray
Write-Host "  Client: dist/linux/Client/*.dll (3 MB)" -ForegroundColor Gray
Write-Host "  README: dist/linux/README.txt" -ForegroundColor Gray
Write-Host ""
Write-Host "Ready to deploy!" -ForegroundColor Green
Write-Host ""

```

`build_macos_release.ps1`:

```ps1
# DuckyNet macOS Release Build Script
# PowerShell 5.1 compatible
# Supports both Intel (x64) and Apple Silicon (arm64)

Write-Host "================================" -ForegroundColor Cyan
Write-Host "DuckyNet macOS Release Build" -ForegroundColor Cyan
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""

$ErrorActionPreference = "Stop"

# Ask for architecture
Write-Host "Select target architecture:" -ForegroundColor Yellow
Write-Host "  1) Intel (x64)" -ForegroundColor White
Write-Host "  2) Apple Silicon (arm64)" -ForegroundColor White
Write-Host "  3) Both (Universal)" -ForegroundColor White
$choice = Read-Host "Enter choice (1-3)"

$BuildIntel = $false
$BuildArm = $false

switch ($choice) {
    "1" { $BuildIntel = $true; $ArchName = "x64" }
    "2" { $BuildArm = $true; $ArchName = "arm64" }
    "3" { $BuildIntel = $true; $BuildArm = $true; $ArchName = "universal" }
    default { 
        Write-Host "Invalid choice, defaulting to Intel (x64)" -ForegroundColor Yellow
        $BuildIntel = $true
        $ArchName = "x64"
    }
}

# Clean old dist
$MacOSDistDir = "dist/macos-$ArchName"
if (Test-Path $MacOSDistDir) {
    Write-Host "Cleaning old dist..." -ForegroundColor Yellow
    Remove-Item -Path $MacOSDistDir -Recurse -Force
}

Write-Host ""
Write-Host "[1/6] Building Shared (Release)..." -ForegroundColor Green
dotnet build Shared/DuckyNetShared.csproj -c Release
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Shared build failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[2/6] Running Code Generator..." -ForegroundColor Green
dotnet run --project Tools/RpcCodeGen/RpcCodeGen.csproj
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Code generation failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[3/6] Rebuilding Shared..." -ForegroundColor Green
dotnet build Shared/DuckyNetShared.csproj -c Release
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Shared rebuild failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[4/6] Publishing Server (macOS)..." -ForegroundColor Green

# Build Intel version
if ($BuildIntel) {
    Write-Host "  Building for Intel (x64)..." -ForegroundColor Cyan
    $IntelDir = if ($BuildArm) { "$MacOSDistDir/Server-Intel" } else { "$MacOSDistDir/Server" }
    dotnet publish Server/DuckyNetServer.csproj -c Release -r osx-x64 --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=false -p:IncludeNativeLibrariesForSelfExtract=true -o $IntelDir
    
    if ($LASTEXITCODE -ne 0) {
        Write-Host "ERROR: Intel server publish failed!" -ForegroundColor Red
        exit 1
    }
}

# Build ARM version (Apple Silicon)
if ($BuildArm) {
    Write-Host "  Building for Apple Silicon (arm64)..." -ForegroundColor Cyan
    $ArmDir = if ($BuildIntel) { "$MacOSDistDir/Server-ARM" } else { "$MacOSDistDir/Server" }
    dotnet publish Server/DuckyNetServer.csproj -c Release -r osx-arm64 --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=false -p:IncludeNativeLibrariesForSelfExtract=true -o $ArmDir
    
    if ($LASTEXITCODE -ne 0) {
        Write-Host "ERROR: ARM server publish failed!" -ForegroundColor Red
        exit 1
    }
}

Write-Host ""
Write-Host "[5/6] Building Client..." -ForegroundColor Green
dotnet build Client/DuckyNetClient.csproj -c Release
if ($LASTEXITCODE -ne 0) {
    Write-Host "ERROR: Client build failed!" -ForegroundColor Red
    exit 1
}

Write-Host ""
Write-Host "[6/6] Packaging..." -ForegroundColor Green

$ClientDistDir = "$MacOSDistDir/Client"
New-Item -ItemType Directory -Path $ClientDistDir -Force | Out-Null
Copy-Item -Path "Client/res/*" -Destination $ClientDistDir -Recurse -Force

# Create start scripts
if ($BuildIntel -and -not $BuildArm) {
    # Single Intel version
    $StartScript = "#!/bin/bash`ncd `"`$(dirname `"`$0`")`"`nchmod +x ./DuckyNet.Server`n./DuckyNet.Server"
    $StartScript | Out-File -FilePath "$MacOSDistDir/Server/start_server.sh" -Encoding ASCII -NoNewline
}
elseif ($BuildArm -and -not $BuildIntel) {
    # Single ARM version
    $StartScript = "#!/bin/bash`ncd `"`$(dirname `"`$0`")`"`nchmod +x ./DuckyNet.Server`n./DuckyNet.Server"
    $StartScript | Out-File -FilePath "$MacOSDistDir/Server/start_server.sh" -Encoding ASCII -NoNewline
}
else {
    # Universal - create scripts for both
    $StartScriptIntel = "#!/bin/bash`ncd `"`$(dirname `"`$0`")`"/Server-Intel`nchmod +x ./DuckyNet.Server`n./DuckyNet.Server"
    $StartScriptIntel | Out-File -FilePath "$MacOSDistDir/start_server_intel.sh" -Encoding ASCII -NoNewline
    
    $StartScriptArm = "#!/bin/bash`ncd `"`$(dirname `"`$0`")`"/Server-ARM`nchmod +x ./DuckyNet.Server`n./DuckyNet.Server"
    $StartScriptArm | Out-File -FilePath "$MacOSDistDir/start_server_arm.sh" -Encoding ASCII -NoNewline
    
    # Auto-detect script
    $AutoScript = @"
#!/bin/bash
cd "`$(dirname "`$0`")"

# Detect architecture
ARCH=`$(uname -m)

if [ "`$ARCH" = "arm64" ]; then
    echo "Detected Apple Silicon (ARM64)"
    chmod +x ./start_server_arm.sh
    ./start_server_arm.sh
elif [ "`$ARCH" = "x86_64" ]; then
    echo "Detected Intel (x64)"
    chmod +x ./start_server_intel.sh
    ./start_server_intel.sh
else
    echo "Unknown architecture: `$ARCH"
    exit 1
fi
"@
    $AutoScript | Out-File -FilePath "$MacOSDistDir/start_server.sh" -Encoding ASCII -NoNewline
}

# Create README
$Readme = "# DuckyNet macOS Release`n`n"

if ($BuildIntel -and $BuildArm) {
    $Readme += "## Server (Universal Binary)`n`n"
    $Readme += "Auto-start (detects your Mac type):`n"
    $Readme += "  chmod +x start_server.sh && ./start_server.sh`n`n"
    $Readme += "Or manually:`n"
    $Readme += "  Intel Mac: chmod +x start_server_intel.sh && ./start_server_intel.sh`n"
    $Readme += "  Apple Silicon: chmod +x start_server_arm.sh && ./start_server_arm.sh`n`n"
}
elseif ($BuildIntel) {
    $Readme += "## Server (Intel x64)`n`n"
    $Readme += "Start: cd Server && chmod +x start_server.sh && ./start_server.sh`n`n"
}
else {
    $Readme += "## Server (Apple Silicon ARM64)`n`n"
    $Readme += "Start: cd Server && chmod +x start_server.sh && ./start_server.sh`n`n"
}

$Readme += "Port: 9050`n`n"
$Readme += "## Client (Unity Mod)`n`n"
$Readme += "Copy Client/*.dll to game Mods folder`n`n"
$Readme += "## System Requirements`n`n"

if ($BuildIntel -and $BuildArm) {
    $Readme += "- macOS 10.15+ (Catalina or later)`n"
    $Readme += "- Works on both Intel and Apple Silicon Macs`n`n"
}
elseif ($BuildIntel) {
    $Readme += "- macOS 10.15+ (Catalina or later)`n"
    $Readme += "- Intel-based Mac only`n`n"
}
else {
    $Readme += "- macOS 11.0+ (Big Sur or later)`n"
    $Readme += "- Apple Silicon Mac only`n`n"
}

$Readme += "Build: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')`n"
$Readme += "Architecture: $ArchName`n"
$Readme | Out-File -FilePath "$MacOSDistDir/README.txt" -Encoding UTF8

Write-Host ""
Write-Host "================================" -ForegroundColor Cyan
Write-Host "Build Complete!" -ForegroundColor Green
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Output Directory: $MacOSDistDir" -ForegroundColor Yellow
Write-Host ""
Write-Host "Files:" -ForegroundColor White

if ($BuildIntel -and $BuildArm) {
    Write-Host "  Server (Intel): dist/macos-universal/Server-Intel/DuckyNet.Server (~67 MB)" -ForegroundColor Gray
    Write-Host "  Server (ARM): dist/macos-universal/Server-ARM/DuckyNet.Server (~67 MB)" -ForegroundColor Gray
    Write-Host "  Auto-start: dist/macos-universal/start_server.sh" -ForegroundColor Gray
}
elseif ($BuildIntel) {
    Write-Host "  Server: dist/macos-x64/Server/DuckyNet.Server (~67 MB)" -ForegroundColor Gray
}
else {
    Write-Host "  Server: dist/macos-arm64/Server/DuckyNet.Server (~67 MB)" -ForegroundColor Gray
}

Write-Host "  Client: dist/macos-$ArchName/Client/*.dll (3 MB)" -ForegroundColor Gray
Write-Host "  README: dist/macos-$ArchName/README.txt" -ForegroundColor Gray
Write-Host ""
Write-Host "Ready to deploy!" -ForegroundColor Green
Write-Host ""


```

`build_release.bat`:

```bat
@echo off
echo ================================
echo DuckyNet RPC Framework Build (Release)
echo ================================

echo.
echo [1/5] Building Shared (Release)...
dotnet build Shared/DuckyNetShared.csproj -c Release

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Shared build failed!
    pause
    exit /b 1
)

echo.
echo [2/5] Running Code Generator...
dotnet run --project Tools/RpcCodeGen/RpcCodeGen.csproj

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Code generation failed!
    pause
    exit /b 1
)

echo.
echo [3/5] Rebuilding Shared (with generated code, Release)...
dotnet build Shared/DuckyNetShared.csproj -c Release

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Shared rebuild failed!
    pause
    exit /b 1
)

echo.
echo [4/5] Building Server (Release)...
dotnet build Server/DuckyNetServer.csproj -c Release

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Server build failed!
    pause
    exit /b 1
)

echo.
echo [5/5] Building Client (Release, no console)...
dotnet build Client/DuckyNetClient.csproj -c Release

if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] Client build failed!
    pause
    exit /b 1
)

echo.
echo ================================
echo Build Complete (Release)! 
echo ================================
echo.
echo Output Files:
echo   Server: Server\bin\Release\net8.0\DuckyNetServer.exe
echo   Client: Client\bin\Release\netstandard2.1\DuckyNetClient.dll
echo.
echo Release features:
echo   - Optimized performance
echo   - No debug console window
echo   - Smaller file size
echo.
echo To run server:
echo   cd Server\bin\Release\net8.0
echo   DuckyNetServer.exe
echo.
pause


```

`dist\linux\Client\info.ini`:

```ini
name = DuckyNet.Client
displayName = DuckyNet
description = DuckyNet

publishedFileId = 3595610321

```

`dist\linux\README.txt`:

```txt
# DuckyNet Linux Release

## Server

Start: cd Server && chmod +x start_server.sh && ./start_server.sh

Port: 9050

## Client (Unity Mod)

Copy Client/*.dll to game Mods folder

Build: 2025-11-12 12:59:47


```

`dist\linux\Server\start_server.sh`:

```sh
#!/bin/bash
cd "$(dirname "$0")"
chmod +x ./DuckyNet.Server
./DuckyNet.Server
```

`dist\macos-x64\Client\info.ini`:

```ini
name = DuckyNet.Client
displayName = DuckyNet
description = DuckyNet

publishedFileId = 3595610321

```

`dist\macos-x64\README.txt`:

```txt
# DuckyNet macOS Release

## Server (Intel x64)

Start: cd Server && chmod +x start_server.sh && ./start_server.sh

Port: 9050

## Client (Unity Mod)

Copy Client/*.dll to game Mods folder

## System Requirements

- macOS 10.15+ (Catalina or later)
- Intel-based Mac only

Build: 2025-11-12 13:04:46
Architecture: x64


```

`dist\macos-x64\Server\start_server.sh`:

```sh
#!/bin/bash
cd "$(dirname "$0")"
chmod +x ./DuckyNet.Server
./DuckyNet.Server
```

`start_server.bat`:

```bat
@echo off
chcp 65001 >nul
echo â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo           ğŸ¦† DuckyNet Server v2.2
echo â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo.
echo [å¯åŠ¨ä¸­] æ­£åœ¨å¯åŠ¨æœåŠ¡å™¨...
echo.

cd Server\bin\Debug\net8.0
DuckyNet.Server.exe

pause


```

`å¯åŠ¨å®Œæ•´ç³»ç»Ÿ.bat`:

```bat
@echo off
chcp 65001 >nul
title DuckyNet å®Œæ•´ç³»ç»Ÿå¯åŠ¨

echo ========================================
echo   DuckyNet å®Œæ•´ç³»ç»Ÿå¯åŠ¨è„šæœ¬
echo ========================================
echo.
echo å°†å¯åŠ¨ï¼š
echo   1. åç«¯ Server (RPC + Web API)
echo   2. å‰ç«¯ Web Admin (Vue3)
echo.
echo æŒ‰ä»»æ„é”®ç»§ç»­...
pause >nul

echo.
echo [1/2] å¯åŠ¨åç«¯ Server...
start "DuckyNet Server" cmd /c "cd /d E:\git\DuckyNet\Server && dotnet run"

echo.
echo ç­‰å¾…åç«¯å¯åŠ¨ï¼ˆ5ç§’ï¼‰...
timeout /t 5 >nul

echo.
echo [2/2] å¯åŠ¨å‰ç«¯ Web Admin...
start "DuckyNet WebAdmin" cmd /c "cd /d E:\git\DuckyNet\WebAdmin && npm run dev"

echo.
echo ========================================
echo å®Œæ•´ç³»ç»Ÿå·²å¯åŠ¨ï¼
echo ========================================
echo.
echo è®¿é—®åœ°å€ï¼š
echo   â€¢ å‰ç«¯ç•Œé¢: http://localhost:3000
echo   â€¢ åç«¯API: http://localhost:5000/swagger
echo   â€¢ WebSocket: ws://localhost:5000/ws
echo.
echo å…³é—­æ­¤çª—å£ä¸ä¼šåœæ­¢æœåŠ¡ï¼Œ
echo è¯·åœ¨å„è‡ªçš„çª—å£ä¸­æŒ‰ Ctrl+C åœæ­¢ã€‚
echo.
pause


```